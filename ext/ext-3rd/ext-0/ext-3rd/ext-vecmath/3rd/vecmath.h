/*
------------------------------------------------------------------------------
         Licensing information can be found at the end of the file.
------------------------------------------------------------------------------

vecmath.h - v1.0 - vector/matrix math library for C/C++.
*/

/**

vecmath.h
=========

vecmath.h is a vector/matrix math library for C/C++, with some additional 
helpers specifically for 3D math.

It's designed to support most of the functionality you would expect from
shader languages like GLSL and, primarily, HLSL, with matching behavior.
Other parts of the library have been modelled after the D3DX parts of the
DirectX SDK.

The goal of vecmath.h is to be a complete and comprehensive vector math
library. It makes no use of SIMD intrinsics or similar, but instead just
implements each function in the most straightforward way. It uses no complex
macro acrobatics to shorten the implementations, and no templates or the 
like. Many compilers do a decent job optimizing the functions, but if you 
need maximum speed, you are probably best off doing a custom SIMD intrinsics
implementation for your specific use case - but this also involves structuring
your data to allow for maximum parallelization.

Care has been taken to keep the API consistent and predictable, and most of
the functions should be easy to guess the name of, and it should be obvious
what they do in most cases, as standard terminology is used.

> vecmath.h is primarily designed to be a C library, but some care have been
> taken to make sure it works well when used from C++ too. It makes no claim
> to be using idiomatic "Modern C++" practices, but is instead taking a 
> pragmatic approach, to leverage some C++ features when using the library
> from C++ code. This documentation points out all C++ specific behavior in
> blocks like this one.

> [!NOTE]  
> In C++ all functions and types are wrapped in `namespace vecmath`.


Examples
--------

Here is a sample of how code using the vecmath.h library can look (this is
taken from a software renderer doing per-pixel lighting, as you would 
typically see in a GPU shader written in HLSL or GLSL):

    vec3_t lighting( vec3_t albedo, vec3_t l, vec3_t n, vec3_t view, float spec, float gloss, float ambocc, vec3_t env ) {
        vec3_t sky = vec3( 0.95f, 0.95f, 0.99f );
        vec3_t ground= vec3( 0.3f, 0.2f, 0.1f );
        vec3_t lightcol= vec3( 0.9f, 0.85f, 0.8f );

        vec3_t r = normalize( 2.0f *  dot(n, l) * n - l); 
        float sn = pow( 2.0f, 8.0f * gloss );
        float s = pow( saturate( dot( r, view ) ), sn ) * ( ( sn + 2.0f ) / ( 2 * VECMATH_PI ) );

        float diffuse = saturate( dot( n, l ) );
        float diffuse_wrapped = saturate( dot( n, l ) * 0.5f + 0.5f );
        vec3_t hemisphere = lerp( ground, sky, n.y * 0.5f + 0.5f ) * 0.5f * ambocc;
        vec3_t directional = lightcol * ( diffuse * 0.75f + diffuse_wrapped * 0.5f );
        vec3_t specular = s * albedo * ambocc;

        vec3_t color = albedo * ( directional + hemisphere ) + specular * 2.0f; 
        color += env * spec;
        return color;
    }

The example above is in C, but it is also using the vecmath.h option to use the
clang extension for vector types, allowing operators `+`, `-`, `*`, `/` to be 
used in C. It is also using the option to define aliases without prefixes for 
nicer vecmath function names.

Without the clang vector type extension, and without stripping prefixes, the same
code would look like this:

    vec3_t lighting( vec3_t albedo, vec3_t l, vec3_t n, vec3_t view, float spec, float gloss, float ambocc, vec3_t env ) {
        vec3_t sky = vec3( 0.95f, 0.95f, 0.99f );
        vec3_t ground= vec3( 0.3f, 0.2f, 0.1f );
        vec3_t lightcol= vec3( 0.9f, 0.85f, 0.8f );

        vec3_t r = vec3_normalize( vec3_fmul( 2.0f, vec3_sub( vec3_fmul( vec3_dot(n, l), n ), l ) ) ); 
        float sn = vecmath_pow( 2.0f, 8.0f * gloss );
        float s = vecmath_pow( vecmath_saturate( vec3_dot( r, view ) ), sn ) * ( ( sn + 2.0f ) / ( 2 * VECMATH_PI ) );

        float diffuse = vecmath_saturate( vec3_dot( n, l ) );
        float diffuse_wrapped = vecmath_saturate( vec3_dot( n, l ) * 0.5f + 0.5f );
        vec3_t hemisphere = vec3_mulf( vec3_lerp( ground, sky, n.y * 0.5f + 0.5f ), 0.5f * ambocc );
        vec3_t directional = vec3_mulf( lightcol, diffuse * 0.75f + diffuse_wrapped * 0.5f );
        vec3_t specular = vec3_fmul( s, vec3_mulf( albedo, ambocc ) );

        vec3_t color = vec3_add( vec3_mul( albedo, vec3_add( directional, hemisphere ) ), vec3_mulf( specular, 2.0f ) ); 
        color = vec3_add( color, vec3_mulf( env, spec ) );
        return color;
    }

Which is admittedly not quite as nice, but still reasonable. Note that both
versions can be compiled with C++ as well.


Customization
-------------

There are a couple of aspects of vecmath.h that can be customized through 
compile-time defines.

### Standard math functions

By default, vecmath.h will include the standard C <math.h> header, and use the
standard math functions defined there. However, you can override this to use
your own equivalents by defining one or more of the following macros:

`VECMATH_ABS`, `VECMATH_ACOS`, `VECMATH_ASIN`, `VECMATH_ATAN`, `VECMATH_ATAN2`, 
`VECMATH_CEIL`, `VECMATH_COS`, `VECMATH_COSH`, `VECMATH_EXP`, `VECMATH_EXP2`, 
`VECMATH_FLOOR`, `VECMATH_FMOD`, `VECMATH_FRAC`, `VECMATH_LOG`, `VECMATH_LOG10`, 
`VECMATH_POW`, `VECMATH_SIN`, `VECMATH_SINH`, `VECMATH_SQRT`, `VECMATH_LOG2`, 
`VECMATH_ROUND`, `VECMATH_TAN`, `VECMATH_TANH`, `VECMATH_TRUNC` 

If you redefine every single one of these, vecmath.h will no longer include
the <math.h> header at all.


### Clang vector type extensions

The clang compiler has an extension named `ext_vector_type`, which allows for
defining a vector type of a specific size, and then be able to use operators
(+, -, *, /) to perform element-wise arithmetic.

You can enable this by defining `VECMATH_EXT_VECTOR_TYPE` before including
vecmath.h. It will only be enabled for compilers supporting it. If the compiler
does not support it, the `VECMATH_EXT_VECTOR_TYPE` define will be ignored.

Note that any usage code leveraging this feature, will of course only compile
in clang.

> In C++, operator overloading is used to achieve the same functionality, and
> there is no need to toggle it with any define.


Types
-----

There are three vector types:

* `vec2_t` two component vector, x/y
* `vec3_t` three component vector, x/y/z
* `vec4_t` four component vector, x/y/z/w

There are nine matrix types. A matrix is made up of a number of rows, where 
each row is a vector type representing the columns of the matrix.

* `mat22_t` matrix with two rows (x/y) of vec2_t
* `mat23_t` matrix with two rows (x/y) of vec3_t
* `mat24_t` matrix with two rows (x/y) of vec4_t

- `mat32_t` matrix with three rows (x/y/z) of vec2_t
- `mat33_t` matrix with three rows (x/y/z) of vec3_t
- `mat34_t` matrix with three rows (x/y/z) of vec4_t

* `mat42_t` matrix with four rows (x/y/z/w) of vec2_t
* `mat43_t` matrix with four rows (x/y/z/w) of vec3_t
* `mat44_t` matrix with four rows (x/y/z/w) of vec4_t

Matrices are *row-major*, which means if you need to pass them on to an API
expecting column-major matrices (such as OpenGL) you need to transpose them
first.

> In C++, there are also class-equivalents of the types, without the `_t` suffix,
> which supports overloaded constructors and operators for a more idiomatic C++
> feel. These are named vec2, vec3, vec4, mat22, mat23, mat24, mat32, mat33, 
> mat34, mat42, mat43 and mat44.

Note that all of these are simple structs of floats, with no padding, meaning
arrays are also just made up of tightly packed floats. Be aware though, that if
you define `VECMATH_EXT_VECTOR_TYPE`, the clang extension to get operator 
overloading, padding of vector types might be introduced. No part of vecmath.h
itself relies on elements being tightly packed, but if your code does and you
enable `VECMATH_EXT_VECTOR_TYPE`, be aware that tight packing of elements is no
longer guaranteed (typically, vec2_t/vec3_t/vec4_t will all be 16 bytes in size).

For all of the types, both vector and matrices, there are a large number of 
functions, operators and constructors defined, following a unified naming 
convention and behavior.


Constructors
------------

All types can be constructed from their elements:

    vec2_t vec2( float x, float y ) 
    vec3_t vec3( float x, float y, float z )
    vec4_t vec4( float x, float y, float z, float w )

    mat22_t mat22( vec2_t x, vec2_t y )
    mat23_t mat23( vec3_t x, vec3_t y )
    mat24_t mat24( vec4_t x, vec4_t y )

    mat32_t mat32( vec2_t x, vec2_t y, vec2_t z ) 
    mat33_t mat33( vec3_t x, vec3_t y, vec3_t z )
    mat34_t mat34( vec4_t x, vec4_t y, vec4_t z )

    mat42_t mat42( vec2_t x, vec2_t y, vec2_t z, vec2_t w )
    mat43_t mat43( vec3_t x, vec3_t y, vec3_t z, vec3_t w )
    mat44_t mat44( vec4_t x, vec4_t y, vec4_t z, vec4_t w )

Note that for vectors, each element is a float, while for matrices, each
element is a vector.

> In C++, this is implemented as a constructor on the vec2, vec3, vec4, mat22, 
> mat23, mat24, mat32, mat33, mat34, mat42, mat43 and mat44 classes, but the
> syntax for constructing is the same.

Both vectors and matrices can also be initialized with a single float value, which
will be propagated to every element of the vector or the matrices, and in the case
of matrices, to every column of every row.

    vec2_t vec2f( float v )
    vec3_t vec3f( float v )
    vec4_t vec4f( float v )

    mat22_t mat22f( float v )
    mat23_t mat23f( float v )
    mat24_t mat24f( float v )
            
    mat32_t mat32f( float v )
    mat33_t mat33f( float v )
    mat34_t mat34f( float v )
            
    mat42_t mat42f( float v )
    mat43_t mat43f( float v )
    mat44_t mat44f( float v )

All of these have the suffix `f` for float.

> In C++, there are also constructor overloads for all classes, allowing for 
> passing a single float, without needing the suffix `f`. Do note that using
> those will of course make it so your code no longer compiles in C. Using 
> the constructor functions with the `f` suffix works in both C and C++.

Additionally, for vec3_t and vec4_t, it is possible to construct them from a
vector with one less component plus a single float, or (in the case of vec4_t)
from two vec2_t.

    vec3_t vec3v2f( vec2_t v, float f )
    vec3_t vec3fv2( float f, vec2_t v )

    vec4_t vec4v3f( vec3_t v, float f )
    vec4_t vec4fv3( float f, vec3_t v ) 
    vec4_t vec4v2( vec2_t a, vec2_t b )

These have various suffixes to indicate which parameters are used - `v2f` for
a two-element vector followed by a single float, or `fv3` for a single float
followed by a three-element vector, etc.

> In C++, there are also constructor overloads for all of these, so you can use
> them without needing the suffixes. Do note that using them will of course make
> it so your code no longer compiles in C. Using the constructor functions with
> the suffixes works in both C and C++.


Accessing elements
------------------

Each element can of course be accessed using `.x`, `.y`, `.z` and `.w`. For 
matrices, individual cells can be accessed using `.x.x`, `.x.y` etc, as would be
expected.

It is also possible to access elements by index. To get the value by index,
the functions are type name with suffix `_get`:

    float vec2_get( vec2_t vec, int index ) 
    float vec3_get( vec3_t vec, int index ) 
    float vec4_get( vec4_t vec, int index ) 

    vec2_t mat22_get( mat22_t m, int row )
    vec3_t mat23_get( mat23_t m, int row )
    vec4_t mat24_get( mat24_t m, int row )

    vec2_t mat32_get( mat32_t m, int row )
    vec3_t mat33_get( mat33_t m, int row )
    vec4_t mat34_get( mat34_t m, int row )

    vec2_t mat42_get( mat42_t m, int row )
    vec3_t mat43_get( mat43_t m, int row )
    vec4_t mat44_get( mat44_t m, int row )

To set a value by index, the functions are type name with suffix `_set`:

    void vec2_set( vec2_t* vec, int index, float f )
    void vec3_set( vec3_t* vec, int index, float f )
    void vec4_set( vec4_t* vec, int index, float f )

    void mat22_set( mat22_t* m, int row, vec2_t v )
    void mat23_set( mat23_t* m, int row, vec3_t v )
    void mat24_set( mat24_t* m, int row, vec4_t v )

    void mat32_set( mat32_t* m, int row, vec2_t v )
    void mat33_set( mat33_t* m, int row, vec3_t v )
    void mat34_set( mat34_t* m, int row, vec4_t v )

    void mat42_set( mat42_t* m, int row, vec2_t v )
    void mat43_set( mat43_t* m, int row, vec3_t v )
    void mat44_set( mat44_t* m, int row, vec4_t v )

> [!CAUTION]
> Do note that accessing elements by index, either using `*_get` or `*_set`,
> do NOT do any range checking on the `index` or `row` parameter. Passing
> an index outside of the valid range for the type you are accessing, will not
> return a valid result, and is likely to cause an access violation.

> In C++, there are also subscript operators, `operator[]` defined for all of
> the classes, allowing you to access elements, for setting or getting, using
> a syntax like `v[0]=2` or `m[3][2]=v[2]` ( the `3` indicates row 3, the `2`
> indicates column 2) etc. These are also NOT bounds checked, so use with care.


Operators
---------

A number of operators are defined, as functions, for all of the types, 
performing element-wise negation, equality-test, addition, multiplication and 
division, with variants supporting element-wise add/sub/mul/div between two of 
the same type as well as any type with a single float.

The operator functions are defined in this general form, where `###` is the 
type name (vec2, vec3, vec4, mat22, mat23, mat24, mat32, mat33, mat34, mat42, 
mat43 or mat44):

    ###_t ###_neg( ###_t v )
    int ###_eq( ###_t a, ###_t b )
    ###_t ###_add( ###_t a, ###_t b ) 
    ###_t ###_sub( ###_t a, ###_t b ) 
    ###_t ###_mul( ###_t a, ###_t b ) 
    ###_t ###_div( ###_t a, ###_t b ) 
    ###_t ###_addf( ###_t a, float s ) 
    ###_t ###_subf( ###_t a, float s ) 
    ###_t ###_mulf( ###_t a, float s ) 
    ###_t ###_divf( ###_t a, float s ) 

For example, for vec2_t the following operators are defined:

    vec2_t vec2_neg( vec2_t v )
    int vec2_eq( vec2_t a, vec2_t b )
    vec2_t vec2_add( vec2_t a, vec2_t b )
    vec2_t vec2_sub( vec2_t a, vec2_t b )
    vec2_t vec2_mul( vec2_t a, vec2_t b )
    vec2_t vec2_div( vec2_t a, vec2_t b )
    vec2_t vec2_addf( vec2_t a, float s )
    vec2_t vec2_subf( vec2_t a, float s )
    vec2_t vec2_mulf( vec2_t a, float s )
    vec2_t vec2_divf( vec2_t a, float s )

Note that for matrix types, the `###_mul` operator is named `###_mul_elem`,
so as to not cause confusion with matrix multiplication functions like
`mat44_mul_mat44` etc (which does full row-by-column multiplication). 

> [!WARNING]  
> The `###_mul_elem` functions (`mat22_mul_elem`, `mat44_mul_elem` etc) does
> NOT perform standard matrix multiplication - they perform element-wise
> multiplication, also known as Hadamard product. A separate set of functions,
> named on the form `###_mul_###`, for example `mat44_mul_mat44`, is provided
> for performing standard matrix multiplication between matrices of compatible
> dimensions (see the section on "Matrix Multiplication").

> For C++, all of these, except for the `###_mul_elem` functions, are also 
> provided as C++ operator overloads. The multiplication operator `operator*`
> is mapped to the matrix multiplication functions, like `mat44_mul_mat44`
> rather than to the element-wise `###_mul_elem` functions. For vectors, 
> multiplication operator maps to the element-wise `###_mul` functions.
>
> For multiplication of vector with matrix, or matrix with vector, the vector
> is treated as a 1xN or Nx1 matrix, and full matrix multiplication is performed.


Element-wise functions
----------------------

There is a large number of functions defined for every type, that perform 
element-wise calculations. Here are their declarations for the vect2_t
type, but the naming is consistent for all other types (both vector and 
matrix types):

    vec2_t vec2_abs( vec2_t m ) 
    vec2_t vec2_acos( vec2_t m ) 
    int vec2_all( vec2_t m ) 
    int vec2_any( vec2_t m ) 
    vec2_t vec2_asin( vec2_t m ) 
    vec2_t vec2_atan( vec2_t m ) 
    vec2_t vec2_atan2( vec2_t y, vec2_t x ) 
    vec2_t vec2_ceil( vec2_t m ) 
    vec2_t vec2_clamp( vec2_t m, vec2_t min_v, vec2_t max_v ) 
    vec2_t vec2_cos( vec2_t m ) 
    vec2_t vec2_cosh( vec2_t m ) 
    vec2_t vec2_degrees( vec2_t m ) 
    vec2_t vec2_exp( vec2_t m ) 
    vec2_t vec2_exp2( vec2_t m ) 
    vec2_t vec2_floor( vec2_t m ) 
    vec2_t vec2_fmod( vec2_t a, vec2_t b ) 
    vec2_t vec2_frac( vec2_t m ) 
    vec2_t vec2_lerp( vec2_t a, vec2_t b, float s ) 
    vec2_t vec2_log( vec2_t m ) 
    vec2_t vec2_log2( vec2_t m ) 
    vec2_t vec2_log10( vec2_t m ) 
    vec2_t vec2_max( vec2_t a, vec2_t b ) 
    vec2_t vec2_min( vec2_t a, vec2_t b ) 
    vec2_t vec2_pow( vec2_t a, vec2_t b ) 
    vec2_t vec2_radians( vec2_t m ) 
    vec2_t vec2_rcp( vec2_t m ) 
    vec2_t vec2_round( vec2_t m ) 
    vec2_t vec2_rsqrt( vec2_t m ) 
    vec2_t vec2_saturate( vec2_t m ) 
    vec2_t vec2_sign( vec2_t m ) 
    vec2_t vec2_sin( vec2_t m ) 
    vec2_t vec2_sinh( vec2_t m ) 
    vec2_t vec2_smoothstep( vec2_t min_v, vec2_t max_v, vec2_t m ) 
    vec2_t vec2_smootherstep( vec2_t min_v, vec2_t max_v, vec2_t m ) 
    vec2_t vec2_sqrt( vec2_t m ) 
    vec2_t vec2_step( vec2_t a, vec2_t b ) 
    vec2_t vec2_tan( vec2_t m ) 
    vec2_t vec2_tanh( vec2_t m ) 
    vec2_t vec2_trunc( vec2_t m ) 

These all perform, per element, the standard mathematical calculation suggested
by each function's name. The behavior is consistent with that of HLSL (or GLSL,
but is primarily modeled after HLSL).

In addition, the following are only defined for vector types (and are defined for
vector types of all three sizes), but not for matrix types:

    float vec2_distancesq( vec2_t a, vec2_t b ) 
    float vec2_distance( vec2_t a, vec2_t b ) 
    float vec2_dot( vec2_t a, vec2_t b ) 
    float vec2_lengthsq( vec2_t v ) 
    float vec2_length( vec2_t v ) 
    vec2_t vec2_normalize( vec2_t v ) 
    vec2_t vec2_reflect( vec2_t i, vec2_t n ) 
    vec2_t vec2_refract( vec2_t i, vec2_t n, float r ) 

and again, they work the same as in HLSL.

Finally, a cross-product function is only defined for vec3_t:

    vec3_t vec3_cross( vec3_t a, vec3_t b )


For completeness, all of these functions are also implemented in a version for
single floats, using a `vecmath_` prefix:

    float vecmath_abs( float v ) 
    float vecmath_acos( float v ) 
    int vecmath_all( float v ) 
    int vecmath_any( float v ) 
    float vecmath_asin( float v ) 
    float vecmath_atan( float v ) 
    float vecmath_atan2( float y, float x ) 
    float vecmath_ceil( float v ) 
    float vecmath_clamp( float v, float min_v, float max_v ) 
    float vecmath_cos( float v ) 
    float vecmath_cosh( float v ) 
    float vecmath_degrees( float v ) 
    float vecmath_distancesq( float a, float b ) 
    float vecmath_distance( float a, float b ) 
    float vecmath_dot( float a, float b ) 
    float vecmath_exp( float v ) 
    float vecmath_exp2( float v ) 
    float vecmath_floor( float v ) 
    float vecmath_fmod( float a, float b ) 
    float vecmath_frac( float v ) 
    float vecmath_lengthsq( float v ) 
    float vecmath_length( float v ) 
    float vecmath_lerp( float a, float b, float s ) 
    float vecmath_log( float v ) 
    float vecmath_log2( float v ) 
    float vecmath_log10( float v ) 
    float vecmath_max( float a, float b ) 
    float vecmath_min( float a, float b ) 
    float vecmath_normalize( float v ) 
    float vecmath_pow( float a, float b ) 
    float vecmath_radians( float v ) 
    float vecmath_rcp( float v ) 
    float vecmath_reflect( float i, float n ) 
    float vecmath_refract( float i, float n, float r ) 
    float vecmath_round( float v ) 
    float vecmath_rsqrt( float v ) 
    float vecmath_saturate( float v ) 
    float vecmath_sign( float v ) 
    float vecmath_sin( float v ) 
    float vecmath_sinh( float v ) 
    float vecmath_smoothstep( float min_v, float max_v, float v ) 
    float vecmath_smootherstep( float min_v, float max_v, float v ) 
    float vecmath_sqrt( float v ) 
    float vecmath_step( float edge, float x ) 
    float vecmath_tan( float v ) 
    float vecmath_tanh( float v ) 
    float vecmath_trunc( float v ) 


Transpose, determinant, inverse and identity matrices
-----------------------------------------------------

Transposing matrices are supported for all matrix types:

    mat22_t mat22_transpose( mat22_t m )
    mat32_t mat23_transpose( mat23_t m )
    mat23_t mat32_transpose( mat32_t m )
    mat33_t mat33_transpose( mat33_t m )
    mat42_t mat24_transpose( mat24_t m )
    mat43_t mat34_transpose( mat34_t m )
    mat24_t mat42_transpose( mat42_t m )
    mat34_t mat43_transpose( mat43_t m )
    mat44_t mat44_transpose( mat44_t m )

Calculating the determinant is supported for square matrices only:

    float mat22_determinant( mat22_t m)
    float mat33_determinant( mat33_t m)
    float mat44_determinant( mat44_t m)

As is computing the inverse:

    int mat22_inverse( mat22_t* out_matrix, float* out_determinant, mat22_t m ) 
    int mat33_inverse( mat33_t* out_matrix, float* out_determinant, mat33_t m ) 
    int mat44_inverse( mat44_t* out_matrix, float* out_determinant, mat44_t m ) 

Note that the inverse functions return 0 if the matrix cannot be inverted, and 
non-zero if inversion was successful. Both the `out_matrix` and the 
`out_determinant` parameters are optional and may be NULL. If non-NULL, 
`out_determinant` will be set, and if non-NULL and inversion is successful, 
`out_matrix` will be set.

There are helper functions to construct the identity matrix for each of the 
square matrix sizes:

    mat22_t mat22_identity( void ) 
    mat33_t mat33_identity( void ) 
    mat44_t mat44_identity( void ) 

and also functions to test if a matrix is exactly identity:

    int mat22_is_identity( mat22_t m ) 
    int mat33_is_identity( mat33_t m ) 
    int mat44_is_identity( mat44_t m ) 

returning non-zero if the matrix is identity, as compared exactly (no 
floating point epsilon is used).


Matrix multiplications
----------------------

Matrix multiplication is supported between all vectors and matrices, in any
valid combination of dimensions, all named on the form `###_mul_###` where 
`###` is the type name of the first and second argument. The return type
depends on the dimensions of the types involved.

All valid combinations, along with their return types, are as follows:

    float vec2_mul_vec2( vec2_t a, vec2_t b )
    float vec3_mul_vec3( vec3_t a, vec3_t b )
    float vec4_mul_vec4( vec4_t a, vec4_t b )

    vec2_t vec2_mul_mat22( vec2_t a, mat22_t b ) 
    vec3_t vec2_mul_mat23( vec2_t a, mat23_t b ) 
    vec4_t vec2_mul_mat24( vec2_t a, mat24_t b ) 
    vec2_t vec3_mul_mat32( vec3_t a, mat32_t b ) 
    vec3_t vec3_mul_mat33( vec3_t a, mat33_t b ) 
    vec4_t vec3_mul_mat34( vec3_t a, mat34_t b ) 
    vec2_t vec4_mul_mat42( vec4_t a, mat42_t b ) 
    vec3_t vec4_mul_mat43( vec4_t a, mat43_t b ) 
    vec4_t vec4_mul_mat44( vec4_t a, mat44_t b ) 

    vec2_t mat22_mul_vec2( mat22_t a, vec2_t b ) 
    vec3_t mat32_mul_vec2( mat32_t a, vec2_t b ) 
    vec4_t mat42_mul_vec2( mat42_t a, vec2_t b ) 
    vec2_t mat23_mul_vec3( mat23_t a, vec3_t b ) 
    vec3_t mat33_mul_vec3( mat33_t a, vec3_t b ) 
    vec4_t mat43_mul_vec3( mat43_t a, vec3_t b ) 
    vec2_t mat24_mul_vec4( mat24_t a, vec4_t b ) 
    vec3_t mat34_mul_vec4( mat34_t a, vec4_t b ) 
    vec4_t mat44_mul_vec4( mat44_t a, vec4_t b )
 
    mat22_t mat22_mul_mat22( mat22_t a, mat22_t b )
    mat23_t mat22_mul_mat23( mat22_t a, mat23_t b )
    mat24_t mat22_mul_mat24( mat22_t a, mat24_t b )
    mat22_t mat23_mul_mat32( mat23_t a, mat32_t b )
    mat23_t mat23_mul_mat33( mat23_t a, mat33_t b )
    mat24_t mat23_mul_mat34( mat23_t a, mat34_t b )
    mat22_t mat24_mul_mat42( mat24_t a, mat42_t b )
    mat23_t mat24_mul_mat43( mat24_t a, mat43_t b )
    mat24_t mat24_mul_mat44( mat24_t a, mat44_t b )

    mat32_t mat32_mul_mat22( mat32_t a, mat22_t b )
    mat33_t mat32_mul_mat23( mat32_t a, mat23_t b )
    mat34_t mat32_mul_mat24( mat32_t a, mat24_t b )
    mat32_t mat33_mul_mat32( mat33_t a, mat32_t b )
    mat33_t mat33_mul_mat33( mat33_t a, mat33_t b )
    mat34_t mat33_mul_mat34( mat33_t a, mat34_t b )
    mat32_t mat34_mul_mat42( mat34_t a, mat42_t b )
    mat33_t mat34_mul_mat43( mat34_t a, mat43_t b )
    mat34_t mat34_mul_mat44( mat34_t a, mat44_t b )

    mat42_t mat42_mul_mat22( mat42_t a, mat22_t b )
    mat43_t mat42_mul_mat23( mat42_t a, mat23_t b )
    mat44_t mat42_mul_mat24( mat42_t a, mat24_t b )
    mat42_t mat43_mul_mat32( mat43_t a, mat32_t b )
    mat43_t mat43_mul_mat33( mat43_t a, mat33_t b )
    mat44_t mat43_mul_mat34( mat43_t a, mat34_t b )
    mat42_t mat44_mul_mat42( mat44_t a, mat42_t b )
    mat43_t mat44_mul_mat43( mat44_t a, mat43_t b )
    mat44_t mat44_mul_mat44( mat44_t a, mat44_t b )

When a vector is multiplied by another vector, this is equivalent to the dot
product. When a vector is multiplied by a matrix, the vector is treated like a
1xN matrix, or row vector. When a matrix is multiplied by a vector, the 
vector is treated like a Nx1 matrix, or a column vector.


Quaternions
-----------

Quaternions are supported, and as they also have four elements, they are 
represented by the `vec4_t` type.

The following functions operate on quaternions:

    vec4_t quat_normalize( vec4_t q ) 
    vec4_t quat_slerp( vec4_t a, vec4_t b, float t ) 
    vec4_t quat_barycentric( vec4_t q1, vec4_t q2, vec4_t q3, float f, float g ) 
    vec4_t quat_conjugate( vec4_t q ) 
    vec4_t quat_exp( vec4_t q ) 
    vec4_t quat_identity( void ) 
    vec4_t quat_inverse( vec4_t q ) 
    int quat_is_identity( vec4_t q ) 
    vec4_t quat_ln( vec4_t q ) 
    vec4_t quat_mul( vec4_t a, vec4_t b ) 
    vec4_t quat_rotation_axis( vec3_t axis, float angle ) 
    vec4_t quat_rotation_matrix( mat44_t m ) 
    vec4_t quat_rotation_yaw_pitch_roll(float yaw, float pitch, float roll) 
    void quat_squad_setup( vec4_t* out_a, vec4_t* out_b, vec4_t* out_c, vec4_t q0, vec4_t q1, vec4_t q2, vec4_t q3 ) 
    vec4_t quat_squad(vec4_t q1, vec4_t a, vec4_t b, vec4_t c, float t ) 
    void quat_to_axis_angle( vec4_t q, vec3_t* out_axis, float* out_angle ) 
    vec3_t quat_rotate_vector( vec3_t v, vec4_t q ) 
    vec4_t quat_shortest_arc( vec3_t from, vec3_t to ) 
    vec4_t quat_from_mat33( mat33_t m ) 
    vec4_t quat_from_mat44( mat44_t m ) 
    float quat_angle( vec4_t a, vec4_t b ) 
    mat33_t mat33_from_quat( vec4_t q ) 
    mat44_t mat44_from_quat( vec4_t q ) 

The functionality and behavior of all of these are consistent with D3DX, 
XNAMath or DirectXMath, and the support they have for quaternions.

> [!NOTE]  
> As there is nothing in the API preventing you from using four-element 
> vectors and quaternions interchangeably, care should be taken to use
> them in the correct way. For example, using `vec4_mul` to multiply two 
> quaternions will give the wrong result - make sure to use `quat_mul` 
> instead.


Matrix 3D utility functions
---------------------------

There are a number of utility functions for creating various matrices used in 3d
rendering (transformation and projection):

    mat44_t mat44_look_at_lh( vec3_t eye, vec3_t at, vec3_t up ) 
    mat44_t mat44_look_at_rh( vec3_t eye, vec3_t at, vec3_t up ) 
    mat44_t mat44_ortho_lh( float w, float h, float zn, float zf ) 
    mat44_t mat44_ortho_rh( float w, float h, float zn, float zf ) 
    mat44_t mat44_ortho_off_center_lh( float l, float r, float b, float t, float zn, float zf ) 
    mat44_t mat44_ortho_off_center_rh( float l, float r, float b, float t, float zn, float zf ) 
    mat44_t mat44_perspective_lh( float w, float h, float zn, float zf ) 
    mat44_t mat44_perspective_rh( float w, float h, float zn, float zf ) 
    mat44_t mat44_perspective_off_center_lh( float l, float r, float b, float t, float zn, float zf ) 
    mat44_t mat44_perspective_off_center_rh( float l, float r, float b, float t, float zn, float zf ) 
    mat44_t mat44_perspective_fov_lh( float fovy, float aspect, float zn, float zf ) 
    mat44_t mat44_perspective_fov_rh( float fovy, float aspect, float zn, float zf ) 
    mat44_t mat44_rotation_axis( vec3_t axis, float angle ) 
    mat44_t mat44_rotation_x( float angle ) 
    mat44_t mat44_rotation_y( float angle ) 
    mat44_t mat44_rotation_z( float angle ) 
    mat44_t mat44_rotation_yaw_pitch_roll( float yaw, float pitch, float roll ) 
    mat44_t mat44_scaling( float sx, float sy, float sz ) 
    mat44_t mat44_translation( float tx, float ty, float tz ) 

These all work the same as in DirectX (and most 3d math libraries).

There's also a function to decompose a transformation matrix into separate scale,
rotation and translation components:
    
    int mat44_decompose( vec3_t* out_scale, vec4_t* out_rotation, vec3_t* out_translation, mat44_t m ) 

Again, this works just like in D3DX, and returns a non-zero value if the matrix
could be successfully decomposed, and returns 0 if decomposition failed. If it
failed, `out_scale`, `out_rotation` and `out_translation` are not modified. It
is valid to pass NULL for any of the out parameters if you do not need that 
result value.

Finally, there are transform helpers mirroring the ones in D3DX:

    vec4_t vec2_transform( vec2_t v, mat44_t m ) 
    vec2_t vec2_transform_coord( vec2_t v, mat44_t m ) 
    vec2_t vec2_transform_normal( vec2_t v, mat44_t m ) 
    vec4_t vec3_transform( vec3_t v, mat44_t m ) 
    vec3_t vec3_transform_coord( vec3_t v, mat44_t m ) 
    vec3_t vec3_transform_normal( vec3_t v, mat44_t m ) 
    vec4_t vec4_transform( vec4_t v, mat44_t m ) 


Vector swizzling
----------------

vecmath.h supports swizzling in the form swizzle-on-read, but does not support
swizzle-on-right, meaning you cannot assign to a swizzled target.

Swizzling is supported by defining separate swizzle functions for every single
combination of swizzling, on vec2/vec3 and vec4 types. That's hundreds of 
functions, and we won't list them here, but let's at least look at the ones 
returning vec2_t (the rest follows the same pattern, but with many more 
variations):

    vec2_t vec2_xx( vec2_t v )
    vec2_t vec2_xy( vec2_t v )
    vec2_t vec2_yx( vec2_t v )
    vec2_t vec2_yy( vec2_t v )
    
    vec2_t vec3_xx( vec3_t v )
    vec2_t vec3_xy( vec3_t v )
    vec2_t vec3_xz( vec3_t v )
    vec2_t vec3_yx( vec3_t v )
    vec2_t vec3_yy( vec3_t v )
    vec2_t vec3_yz( vec3_t v )
    vec2_t vec3_zx( vec3_t v )
    vec2_t vec3_zy( vec3_t v )
    vec2_t vec3_zz( vec3_t v )
    
    vec2_t vec4_xx( vec4_t v )
    vec2_t vec4_xy( vec4_t v )
    vec2_t vec4_xz( vec4_t v )
    vec2_t vec4_xw( vec4_t v )
    vec2_t vec4_yx( vec4_t v )
    vec2_t vec4_yy( vec4_t v )
    vec2_t vec4_yz( vec4_t v )
    vec2_t vec4_yw( vec4_t v )
    vec2_t vec4_zx( vec4_t v )
    vec2_t vec4_zy( vec4_t v )
    vec2_t vec4_zz( vec4_t v )
    vec2_t vec4_zw( vec4_t v )
    vec2_t vec4_wx( vec4_t v )
    vec2_t vec4_wy( vec4_t v )
    vec2_t vec4_wz( vec4_t v )
    vec2_t vec4_ww( vec4_t v )

As we can see, the return type is decided by how many elements we have in the
function suffix (`_xx`, `_yx` etc) - all of the two elements in this example,
but variants exist with more elements as well, for other swizzling combinations.

The function prefix (`vec2_`, `vec3_`, `vec4_`) indicates the parameter type
as would be expected. 

> For C++, swizzling is also supported in the form of member functions on the
> `vec2`, `vec3` and `vec4` classes, allowing swizzling in the form `v.xxx()`,
> `v.yyxx()`, `v.xy` etc. Note that the C swizzling functions are also available
> from C++.


C Generics and C++ overloads
----------------------------

All functions in vecmath.h are prefixed with the name of the type it operates
on (`vec2_`, `vec3_`, `vec4_`, `mat22_` etc ). From C11, there is the new
keyword `_Generic`, allowing for defining a macro dispatcher that allows the
use of the same name to invoke different functions depending on the type of
the arguments. 

In vecmath.h you can define the preprocessor symbol `VECMATH_GENERICS`, and if
you are compiling with C11 or later, a full set of `vm_` macros will be defined
for calling functions without specifying a prefix. It allows you to do things
like `vm_add( a, b )` regardless of which vecmath.h types `a` and `b` are, as
long as they are the same type. 

Unlike most other vm_ functions, which perform element-wise operations, the 
`vm_mul` macro does not wrap the `*_mul_elem` element-wise multiply functions, 
but instead the full matrix multiply `*_mul_*` functions, allowing for 
expressions like `vm_mul( v4, m44 )`, `vm_mul( m44, v44 )`, `vm_mul( m44, m44 )` 
etc.

The full set of generic function names are:

    vm_neg
    vm_eq
    vm_mul
    vm_add
    vm_sub
    vm_div
    vm_abs
    vm_acos
    vm_all
    vm_any
    vm_asin
    vm_atan
    vm_atan2
    vm_ceil
    vm_clamp
    vm_cos
    vm_cosh
    vm_cross
    vm_degrees
    vm_distancesq
    vm_distance
    vm_dot
    vm_exp
    vm_exp2
    vm_floor
    vm_fmod
    vm_frac
    vm_lengthsq
    vm_length
    vm_lerp
    vm_log
    vm_log2
    vm_log10
    vm_max
    vm_min
    vm_normalize
    vm_pow
    vm_radians
    vm_rcp
    vm_reflect
    vm_refract
    vm_round
    vm_rsqrt
    vm_saturate
    vm_sign
    vm_sin
    vm_sinh
    vm_smoothstep
    vm_smootherstep
    vm_sqrt
    vm_step
    vm_tan
    vm_tanh
    vm_trunc
    vm_transpose
    vm_determinant

> In C++, if `VECMATH_GENERICS` is defined, all these `vm_` functions will be
> defined as overloaded functions instead of using the `_Generic` macro for C,
> providing the same functionality as long as `VECMATH_GENERICS` is defined.

### Generics without the prefix

In addition to the `VECMATH_GENERICS` preprocessor symbol, it is also possible
to define the symbol `VECMATH_GENERICS_NO_PREFIX`, to create a set of aliases
for all the `vm_*` macros, that omits the `vm_` prefix, providing more natural
names like `add( a, b )`, `mul( v, m )` etc. 

> [!CAUTION]
> Do note that defining `VECMATH_GENERICS_NO_PREFIX` will redefine names like
> `abs`, `sin`, `cos` etc, which will very much be in direct conflict with
> names from the C standard math library. Use this feature with care, as it can
> very easily lead to some pretty weird compilation errors.

> In C++, when `VECMATH_GENERICS_NO_PREFIX` is defined, all the function 
> overloads are just defined without the prefix in the first place, and instead
> macros are defined to provide the `vm_` prefixed names as aliases. This avoids
> the global redefining of common math.h names, and also places the overloaded
> functions within the `vecmath` namespace, which further avoids collisions. 


Unit tests
----------

vecmath.h contains an extensive test suite, consisting of over 1300 tests, 
checking over 6000 assertions. These tests are implemented at the end of the 
vecmath.h file, guarded by a conditional compile flag so they are ignored when
using the library normally.

To enable the tests, compile vecmath.h as a C or C++ file, and define the 
preprocessor symbol VECMATH_RUN_TESTS.

Using MSVCs cl.exe it would look like this:

    cl -Tc vecmath.h -DVECMATH_RUN_TESTS

and using clang (gcc and tcc use similar syntax):

    clang -xc vecmath.h -DVECMATH_RUN_TESTS

The executable produced can then be run, and it will perform all tests and
print the result.

### DirectX D3D conformance tests

To ensure the correctness of the library, it seemed appropriate to test some
parts of it against a known correct implementation. So vecmath.h implements
a set of tests that compare its computations with those of Microsofts DirectX
library, specifically the D3DX part of DirectX 9. This is a very widely used
and well proven math library implementation, and testing vecmath.h against this
gives a high level of confidence.

To enable the running of D3DX tests, define the preprocessor symbol 
`VECMATH_RUN_D3DX_TESTS` (in addition to `VECMATH_RUN_TESTS`), and make sure to
build with the correct include and library paths set for your installation of
d3d9.


### Using external testfw.h

By default, the tests are written using a handful of simple macros that check
for errors and print results. These macros are defined in the test code portion
of vecmath.h.

However, to get better test coverage (catching things like access violations and
other system exceptions, or memory leaks) and nicer printout of the result (for
example, using multi-colored output), it's possible to use the testfw.h single-
header lib, which can be found at:
https://github.com/mattiasgustavsson/libs/blob/main/testfw.h

To enable the use of testfw.h, the file must be placed in the same directory
as vecmath.h, and the preprocessor symbol VECMATH_USE_EXTERNAL_TESTFW must be
defined at compilation, like so:

    cl -Tc vecmath.h -DVECMATH_RUN_TESTS -DVECMATH_USE_EXTERNAL_TESTFW

if using msvc, or:

    clang -xc vecmath.h -DVECMATH_RUN_TESTS -DVECMATH_USE_EXTERNAL_TESTFW

if using clang (gcc and tcc use similar syntax).


*/

#ifndef vecmath_h
#define vecmath_h

#if defined( __GNUC__ ) || defined( __clang__ )
    #define VECMATH_INLINE static inline __attribute__((always_inline))
#elif defined( _MSC_VER )
    #define VECMATH_INLINE static inline __forceinline
#else
    #define VECMATH_INLINE static inline
#endif

#ifdef __cplusplus
    namespace vecmath {
#endif

// types
#if defined( VECMATH_EXT_VECTOR_TYPE ) && !defined( __cplusplus ) && defined(__clang__) && __clang_major__ >= 3
    typedef float vec2_t __attribute__((ext_vector_type(2)));
    typedef float vec3_t __attribute__((ext_vector_type(3)));
    typedef float vec4_t __attribute__((ext_vector_type(4)));
#else 
    typedef struct vec2_t { float x, y; } vec2_t ;
    typedef struct vec3_t { float x, y, z; } vec3_t;
    typedef struct vec4_t { float x, y, z, w; } vec4_t;
#endif
typedef struct mat22_t { /* rows */ vec2_t x, y; } mat22_t;
typedef struct mat23_t { /* rows */ vec3_t x, y; } mat23_t;
typedef struct mat24_t { /* rows */ vec4_t x, y; } mat24_t;

typedef struct mat32_t { /* rows */ vec2_t x, y, z; } mat32_t;
typedef struct mat33_t { /* rows */ vec3_t x, y, z; } mat33_t;
typedef struct mat34_t { /* rows */ vec4_t x, y, z; } mat34_t;

typedef struct mat42_t { /* rows */ vec2_t x, y, z, w; } mat42_t;
typedef struct mat43_t { /* rows */ vec3_t x, y, z, w; } mat43_t;
typedef struct mat44_t { /* rows */ vec4_t x, y, z, w; } mat44_t;


// math defines

#define VECMATH_PI 3.141592654f

#if !defined( VECMATH_ABS ) || !defined( VECMATH_ACOS ) || !defined( VECMATH_ASIN ) || !defined( VECMATH_ATAN ) || \
    !defined( VECMATH_ATAN2 ) || !defined( VECMATH_CEIL ) || !defined( VECMATH_COS ) || !defined( VECMATH_COSH ) || \
    !defined( VECMATH_EXP ) || !defined( VECMATH_EXP2 ) || !defined( VECMATH_FLOOR ) || !defined( VECMATH_FMOD ) || \
    !defined( VECMATH_FRAC ) || !defined( VECMATH_LOG ) || !defined( VECMATH_LOG10 ) || !defined( VECMATH_POW ) || \
    !defined( VECMATH_SIN ) || !defined( VECMATH_SINH ) || !defined( VECMATH_SQRT ) || !defined( VECMATH_LOG2 ) || \
    !defined( VECMATH_ROUND ) || !defined( VECMATH_TAN ) || !defined( VECMATH_TANH ) || !defined( VECMATH_TRUNC )

    #ifdef __cplusplus
        } // namespace vecmath
    #endif

    #define _CRT_NONSTDC_NO_DEPRECATE 
    #define _CRT_SECURE_NO_WARNINGS

    // If we are running tests on windows
    #if defined( VECMATH_RUN_TESTS ) && defined( VECMATH_USE_EXTERNAL_TESTFW ) && defined( _MSC_VER ) && !defined( __clang__ ) && !defined( __GNUC__ ) && !defined( __TINYC__ )
        #define _CRTDBG_MAP_ALLOC
        #include <crtdbg.h>
    #endif

    #include <math.h>
    
    #ifdef __cplusplus
        namespace vecmath {
    #endif
#endif

#if !defined( VECMATH_ABS ) 
    #ifndef __TINYC__
        #define VECMATH_ABS( v ) ( (float)( fabsf( v ) ) )
    #else
        #define VECMATH_ABS( v ) ( (float)( fabs( v ) ) )
    #endif
#endif
#if !defined( VECMATH_ACOS ) 
    #ifndef __TINYC__
        #define VECMATH_ACOS( v ) ( (float)( acosf( v ) ) )
    #else
        #define VECMATH_ACOS( v ) ( (float)( acos( v ) ) )
    #endif
#endif
#if !defined( VECMATH_ASIN ) 
    #ifndef __TINYC__
        #define VECMATH_ASIN( v ) ( (float)( asinf( v ) ) )
    #else
        #define VECMATH_ASIN( v ) ( (float)( asin( v ) ) )
    #endif
#endif
#if !defined( VECMATH_ATAN ) 
    #ifndef __TINYC__
        #define VECMATH_ATAN( v ) ( (float)( atanf( v ) ) )
    #else
        #define VECMATH_ATAN( v ) ( (float)( atan( v ) ) )
    #endif
#endif
#if !defined( VECMATH_ATAN2 ) 
    #ifndef __TINYC__
        #define VECMATH_ATAN2( y, x ) ( (float)( atan2f( ( y ), ( x ) ) ) )
    #else
        #define VECMATH_ATAN2( y, x ) ( (float)( atan2( ( y ), ( x ) ) ) )
    #endif
#endif
#if !defined( VECMATH_CEIL ) 
    #ifndef __TINYC__
        #define VECMATH_CEIL( v ) ( (float)( ceilf( v ) ) )
    #else
        #define VECMATH_CEIL( v ) ( (float)( ceil( v ) ) )
    #endif
#endif
#if !defined( VECMATH_COS ) 
    #ifndef __TINYC__
        #define VECMATH_COS( v ) ( (float)( cosf( v ) ) )
    #else
        #define VECMATH_COS( v ) ( (float)( cos( v ) ) )
    #endif
#endif
#if !defined( VECMATH_COSH ) 
    #ifndef __TINYC__
        #define VECMATH_COSH( v ) ( (float)( coshf( v ) ) )
    #else
        #define VECMATH_COSH( v ) ( (float)( cosh( v ) ) )
    #endif
#endif
#if !defined( VECMATH_EXP ) 
    #ifndef __TINYC__
        #define VECMATH_EXP( v ) ( (float)( expf( v ) ) )
    #else
        #define VECMATH_EXP( v ) ( (float)( exp( v ) ) )
    #endif
#endif
#if !defined( VECMATH_EXP2 ) 
    #if defined( _MSC_VER ) && !defined( __clang__ ) && !defined( __GNUC__ ) && _MSC_VER < 1800 
        #define VECMATH_EXP2( v ) ( (float)( powf( 2.0f, ( v ) ) ) )
    #elif defined(__TINYC__)
        #define VECMATH_EXP2( v ) ( (float)( pow( 2.0f, ( v ) ) ) )
    #else
        #define VECMATH_EXP2( v ) ( (float)( exp2f( v ) ) )
    #endif
#endif
#if !defined( VECMATH_FLOOR ) 
    #ifndef __TINYC__
        #define VECMATH_FLOOR( v ) ( (float)( floorf( v ) ) )
    #else
        #define VECMATH_FLOOR( v ) ( (float)( floor( v ) ) )
    #endif
#endif
#if !defined( VECMATH_FMOD ) 
    #ifndef __TINYC__
        #define VECMATH_FMOD( a, b ) ( (float)( fmodf( ( a ), ( b ) ) ) )
    #else
        #define VECMATH_FMOD( a, b ) ( (float)( fmod( ( a ), ( b ) ) ) )
    #endif
#endif
#if !defined( VECMATH_FRAC ) 
    #ifndef __TINYC__
        VECMATH_INLINE float internal_vecmath_frac( float v ) { float t; return (float)( fabsf( modff( v, &t ) ) ); }
    #else
        VECMATH_INLINE float internal_vecmath_frac( float v ) { double t; return (float)( fabs( modf( v, &t ) ) ); }
    #endif
    #define VECMATH_FRAC( v ) internal_vecmath_frac( v )
#endif
#if !defined( VECMATH_LOG ) 
    #ifndef __TINYC__
        #define VECMATH_LOG( v ) ( (float)( logf( v ) ) )
    #else
        #define VECMATH_LOG( v ) ( (float)( log( v ) ) )
    #endif
#endif
#if !defined( VECMATH_LOG2 ) 
    #if defined( _MSC_VER ) && !defined( __clang__ ) && !defined( __GNUC__ ) && _MSC_VER < 1800
        #define VECMATH_LOG2( v ) ( (float)( VECMATH_LOG10( ( v ) ) / VECMATH_LOG10( 2.0 ) ) )
    #elif defined( __TINYC__ )
        #define VECMATH_LOG2( v ) ( (float)( VECMATH_LOG10( ( v ) ) / VECMATH_LOG10( 2.0 ) ) )
    #else
        #define VECMATH_LOG2( v ) ( (float)( log2f( v ) ) )
    #endif
#endif
#if !defined( VECMATH_LOG10 ) 
    #ifndef __TINYC__
        #define VECMATH_LOG10( v ) ( (float)( log10f( v ) ) )
    #else
        #define VECMATH_LOG10( v ) ( (float)( log10( v ) ) )
    #endif
#endif
#if !defined( VECMATH_MAX ) 
    #ifndef __TINYC__
        #define VECMATH_MAX( a, b ) ( (float)( fmaxf( a, b ) ) )
    #else
        #define VECMATH_MAX( a, b ) ( (float)( fmax( a, b ) ) )
    #endif
#endif
#if !defined( VECMATH_MIN ) 
    #ifndef __TINYC__
        #define VECMATH_MIN( a, b ) ( (float)( fminf( a, b ) ) )
    #else
        #define VECMATH_MIN( a, b ) ( (float)( fmin( a, b ) ) )
    #endif
#endif
#if !defined( VECMATH_POW ) 
    #ifndef __TINYC__
        #define VECMATH_POW( a, b ) ( (float)( powf( ( a ), ( b ) ) ) )
    #else
        #define VECMATH_POW( a, b ) ( (float)( pow( ( a ), ( b ) ) ) )
    #endif
#endif
#if !defined( VECMATH_ROUND ) 
    #if defined( _MSC_VER ) && !defined( __clang__ ) && !defined( __GNUC__ ) && _MSC_VER < 1800
        VECMATH_INLINE float internal_vecmath_round( float x ) { float i, r; float fraction = modff( (float) x, &i ); modff( 2.0f * fraction, &r ); return i + r; }
        #define VECMATH_ROUND( v ) internal_vecmath_round( v )
    #elif defined( __TINYC__ )
        #define VECMATH_ROUND( v ) ( (float)( round( v ) ) )
    #else
        #define VECMATH_ROUND( v ) ( (float)( roundf( v ) ) )
    #endif
#endif
#if !defined( VECMATH_SIN ) 
    #ifndef __TINYC__
        #define VECMATH_SIN( v ) ( (float)( sinf( v ) ) )
    #else
        #define VECMATH_SIN( v ) ( (float)( sin( v ) ) )
    #endif
#endif
#if !defined( VECMATH_SINH ) 
    #ifndef __TINYC__
        #define VECMATH_SINH( v ) ( (float)( sinhf( v ) ) )
    #else
        #define VECMATH_SINH( v ) ( (float)( sinh( v ) ) )
    #endif
#endif
#if !defined( VECMATH_SQRT ) 
    #ifndef __TINYC__
        #define VECMATH_SQRT( v ) ( (float)( sqrtf( v ) ) )
    #else
        #define VECMATH_SQRT( v ) ( (float)( sqrt( v ) ) )
    #endif
#endif
#if !defined( VECMATH_TAN ) 
    #ifndef __TINYC__
        #define VECMATH_TAN( v ) ( (float)( tanf( v ) ) )
    #else
        #define VECMATH_TAN( v ) ( (float)( tan( v ) ) )
    #endif
#endif
#if !defined( VECMATH_TANH ) 
    #ifndef __TINYC__
        #define VECMATH_TANH( v ) ( (float)( tanhf( v ) ) )
    #else
        #define VECMATH_TANH( v ) ( (float)( tanh( v ) ) )
    #endif
#endif
#if !defined( VECMATH_TRUNC ) 
    #if defined( _MSC_VER ) && !defined( __clang__ ) && !defined( __GNUC__ ) && _MSC_VER < 1800
        #define VECMATH_TRUNC( v ) ( (float)( v > 0.0f ? ( VECMATH_FLOOR( v ) ) : ( VECMATH_CEIL( v ) ) ) )
    #elif defined( __TINYC__ )
        #define VECMATH_TRUNC( v ) ( (float)( v > 0.0f ? ( VECMATH_FLOOR( v ) ) : ( VECMATH_CEIL( v ) ) ) )
    #else
        #define VECMATH_TRUNC( v ) ( (float)( truncf( v ) ) )
    #endif
#endif

// functions
VECMATH_INLINE float vecmath_abs( float v ) { return VECMATH_ABS( v ); }
VECMATH_INLINE float vecmath_acos( float v ) { return VECMATH_ACOS( v ); }
VECMATH_INLINE int vecmath_all( float v ) { return v != 0.0f; }
VECMATH_INLINE int vecmath_any( float v ) { return v != 0.0f; }
VECMATH_INLINE float vecmath_asin( float v ) { return VECMATH_ASIN( v ); }
VECMATH_INLINE float vecmath_atan( float v ) { return VECMATH_ATAN( v ); }
VECMATH_INLINE float vecmath_atan2( float y, float x ) { return VECMATH_ATAN2( y, x ); }
VECMATH_INLINE float vecmath_ceil( float v ) { return VECMATH_CEIL( v ); }
VECMATH_INLINE float vecmath_clamp( float v, float min_v, float max_v ) { return v < min_v ? min_v : v > max_v ? max_v : v; }
VECMATH_INLINE float vecmath_cos( float v ) { return VECMATH_COS( v ); }
VECMATH_INLINE float vecmath_cosh( float v ) { return VECMATH_COSH( v ); }
VECMATH_INLINE float vecmath_degrees( float v ) { float const f = 57.295779513082320876846364344191f; return v * f; } 
VECMATH_INLINE float vecmath_distancesq( float a, float b ) { float x = b - a; return x * x; }
VECMATH_INLINE float vecmath_distance( float a, float b ) { return VECMATH_ABS( b - a ); }
VECMATH_INLINE float vecmath_dot( float a, float b ) { return a * b; } 
VECMATH_INLINE float vecmath_exp( float v ) { return VECMATH_EXP( v ); }
VECMATH_INLINE float vecmath_exp2( float v ) { return VECMATH_EXP2( v ); }
VECMATH_INLINE float vecmath_floor( float v ) { return VECMATH_FLOOR( v ); }
VECMATH_INLINE float vecmath_fmod( float a, float b ) { return VECMATH_FMOD( a, b ); }
VECMATH_INLINE float vecmath_frac( float v ) { return VECMATH_FRAC( v ); }
VECMATH_INLINE float vecmath_lengthsq( float v ) { return v * v; }
VECMATH_INLINE float vecmath_length( float v ) { return VECMATH_SQRT( v * v ); }
VECMATH_INLINE float vecmath_lerp( float a, float b, float s ) { return a + ( b - a ) * s; }
VECMATH_INLINE float vecmath_log( float v ) { return VECMATH_LOG( v ); }
VECMATH_INLINE float vecmath_log2( float v ) { return VECMATH_LOG2( v );}
VECMATH_INLINE float vecmath_log10( float v ) { return VECMATH_LOG10( v ); }
VECMATH_INLINE float vecmath_max( float a, float b ) { return VECMATH_MAX( a , b ); }
VECMATH_INLINE float vecmath_min( float a, float b ) { return VECMATH_MIN( a, b ); }
VECMATH_INLINE float vecmath_normalize( float v ) { float l = VECMATH_SQRT( v * v ); return l == 0.0f ? v : (float)( v / l ); }
VECMATH_INLINE float vecmath_pow( float a, float b ) { return VECMATH_POW( a, b );}
VECMATH_INLINE float vecmath_radians( float v ) { float const f = 0.01745329251994329576922222222222f; return v * f; } 
VECMATH_INLINE float vecmath_rcp( float v ) { return 1.0f / v; }
VECMATH_INLINE float vecmath_reflect( float i, float n ) { return i - 2.0f * n * vecmath_dot( i, n ); }
VECMATH_INLINE float vecmath_refract( float i, float n, float r ) { float n_i = vecmath_dot( n, i ); float k = 1.0f - r * r * ( 1.0f - n_i * n_i ); return ( k < 0.0f ) ? (float)( 0.0f ) : ( r * i - ( r * n_i + VECMATH_SQRT( k ) ) * n ); }
VECMATH_INLINE float vecmath_round( float v ) { return VECMATH_ROUND( v ); }
VECMATH_INLINE float vecmath_rsqrt( float v ) { return 1.0f / VECMATH_SQRT( v ); }
VECMATH_INLINE float vecmath_saturate( float v ) { return v < 0.0f ? 0.0f : v > 1.0f ? 1.0f : v; }
VECMATH_INLINE float vecmath_sign( float v ) { return v < 0.0f ? -1.0f : v > 0.0f ? 1.0f : 0.0f; }
VECMATH_INLINE float vecmath_sin( float v ) { return VECMATH_SIN( v );}
VECMATH_INLINE float vecmath_sinh( float v ) { return VECMATH_SINH( v ); }
VECMATH_INLINE float vecmath_smoothstep( float min_v, float max_v, float v ) { float range = max_v - min_v; if( range == 0.0f ) return v < min_v ? 0.0f : 1.0f; v = ( v - min_v ) / range; v = v < 0.0f ? 0.0f : v > 1.0f ? 1.0f : v; return v * v * ( 3.0f - 2.0f * v ); }
VECMATH_INLINE float vecmath_smootherstep( float min_v, float max_v, float v ) { float range = max_v - min_v; if( range == 0.0f ) return v < min_v ? 0.0f : 1.0f; v = ( v - min_v ) / range; v = v < 0.0f ? 0.0f : v > 1.0f ? 1.0f : v; return v * v * v * ( v * ( v * 6.0f - 15.0f ) + 10.0f ); }
VECMATH_INLINE float vecmath_sqrt( float v ) { return VECMATH_SQRT( v ); }
VECMATH_INLINE float vecmath_step( float edge, float x ) { return x >= edge ? 1.0f : 0.0f; }
VECMATH_INLINE float vecmath_tan( float v ) { return VECMATH_TAN( v ); }
VECMATH_INLINE float vecmath_tanh( float v ) { return VECMATH_TANH( v ); }
VECMATH_INLINE float vecmath_trunc( float v ) { return VECMATH_TRUNC( v ); }

// helpers for making `vm_*` generics easier to implement
VECMATH_INLINE float vecmath_fneg( float a ) { return -a; }
VECMATH_INLINE int vecmath_feq( float a, float b ) { return a == b; }
VECMATH_INLINE float vecmath_fadd( float a, float b ) { return a + b; }
VECMATH_INLINE float vecmath_fsub( float a, float b ) { return a - b; }
VECMATH_INLINE float vecmath_fmul( float a, float b ) { return a * b; }
VECMATH_INLINE float vecmath_fdiv( float a, float b ) { return a / b; }

// vec2
#ifdef __cplusplus
    struct vec2 : vec2_t { 
        inline vec2() {}
        inline vec2( float x_, float y_ ) { x = x_; y = y_; }
        inline vec2( vec2_t v ) { x = v.x; y = v.y; }
        inline vec2( float v ) { x = v; y = v; }
        inline float operator[]( int index ) const { return ( (float*) this)[ index ]; }
        inline float& operator[]( int index ) { return ( (float*) this )[ index ]; }

        inline vec2_t xx() { vec2_t r = { x, x }; return r; }
        inline vec2_t xy() { vec2_t r = { x, y }; return r; }
        inline vec2_t yx() { vec2_t r = { y, x }; return r; }
        inline vec2_t yy() { vec2_t r = { y, y }; return r; }

        inline vec3_t xxx() { vec3_t r = { x, x, x }; return r; }
        inline vec3_t xxy() { vec3_t r = { x, x, y }; return r; }
        inline vec3_t xyx() { vec3_t r = { x, y, x }; return r; }
        inline vec3_t xyy() { vec3_t r = { x, y, y }; return r; }
        inline vec3_t yxx() { vec3_t r = { y, x, x }; return r; }
        inline vec3_t yxy() { vec3_t r = { y, x, y }; return r; }
        inline vec3_t yyx() { vec3_t r = { y, y, x }; return r; }
        inline vec3_t yyy() { vec3_t r = { y, y, y }; return r; }

        inline vec4_t xxxx() { vec4_t r = { x, x, x, x }; return r; }
        inline vec4_t xxxy() { vec4_t r = { x, x, x, y }; return r; }
        inline vec4_t xxyx() { vec4_t r = { x, x, y, x }; return r; }
        inline vec4_t xxyy() { vec4_t r = { x, x, y, y }; return r; }
        inline vec4_t xyxx() { vec4_t r = { x, y, x, x }; return r; }
        inline vec4_t xyxy() { vec4_t r = { x, y, x, y }; return r; }
        inline vec4_t xyyx() { vec4_t r = { x, y, y, x }; return r; }
        inline vec4_t xyyy() { vec4_t r = { x, y, y, y }; return r; }
        inline vec4_t yxxx() { vec4_t r = { y, x, x, x }; return r; }
        inline vec4_t yxxy() { vec4_t r = { y, x, x, y }; return r; }
        inline vec4_t yxyx() { vec4_t r = { y, x, y, x }; return r; }
        inline vec4_t yxyy() { vec4_t r = { y, x, y, y }; return r; }
        inline vec4_t yyxx() { vec4_t r = { y, y, x, x }; return r; }
        inline vec4_t yyxy() { vec4_t r = { y, y, x, y }; return r; }
        inline vec4_t yyyx() { vec4_t r = { y, y, y, x }; return r; }
        inline vec4_t yyyy() { vec4_t r = { y, y, y, y }; return r; }
    };
#else
    VECMATH_INLINE vec2_t vec2( float x, float y ) { vec2_t vec; vec.x = x; vec.y = y; return vec; }
#endif
VECMATH_INLINE vec2_t vec2f( float v ) { vec2_t vec; vec.x = v; vec.y = v; return vec; }
    
VECMATH_INLINE float vec2_get( vec2_t vec, int index ) { return ( (float*) &vec )[ index ]; }
VECMATH_INLINE void vec2_set( vec2_t* vec, int index, float f ) { ( (float*) vec )[ index ] = f; }
    
// operators
VECMATH_INLINE vec2_t vec2_neg( vec2_t v ) { return vec2( -v.x, -v.y ); }
VECMATH_INLINE int vec2_eq( vec2_t a, vec2_t b ) { return a.x == b.x && a.y == b.y; }
VECMATH_INLINE vec2_t vec2_add( vec2_t a, vec2_t b ) { return vec2( a.x + b.x, a.y + b.y ); }
VECMATH_INLINE vec2_t vec2_sub( vec2_t a, vec2_t b ) { return vec2( a.x - b.x, a.y - b.y ); }
VECMATH_INLINE vec2_t vec2_mul( vec2_t a, vec2_t b ) { return vec2( a.x * b.x, a.y * b.y ); }
VECMATH_INLINE vec2_t vec2_div( vec2_t a, vec2_t b ) { return vec2( a.x / b.x, a.y / b.y ); }
VECMATH_INLINE vec2_t vec2_addf( vec2_t a, float s ) { return vec2( a.x + s, a.y + s ); }
VECMATH_INLINE vec2_t vec2_subf( vec2_t a, float s ) { return vec2( a.x - s, a.y - s ); }
VECMATH_INLINE vec2_t vec2_mulf( vec2_t a, float s ) { return vec2( a.x * s, a.y * s ); }
VECMATH_INLINE vec2_t vec2_divf( vec2_t a, float s ) { return vec2( a.x / s, a.y / s ); }
VECMATH_INLINE vec2_t vec2_fadd( float s, vec2_t a ) { return vec2_addf( a, s ); }
VECMATH_INLINE vec2_t vec2_fsub( float s, vec2_t a ) { return vec2_sub( vec2f( s ), a ); }
VECMATH_INLINE vec2_t vec2_fmul( float s, vec2_t a ) { return vec2_mulf( a, s ); }
VECMATH_INLINE vec2_t vec2_fdiv( float s, vec2_t a ) { return vec2_div( vec2f( s ), a ); }

// functions
VECMATH_INLINE vec2_t vec2_abs( vec2_t v ) { return vec2( vecmath_abs( v.x ), vecmath_abs( v.y ) ); }
VECMATH_INLINE vec2_t vec2_acos( vec2_t v ) { return vec2( vecmath_acos( v.x ), vecmath_acos( v.y ) ); }
VECMATH_INLINE int vec2_all( vec2_t v ) { return v.x != 0.0f && v.y != 0.0f; }
VECMATH_INLINE int vec2_any( vec2_t v ) { return v.x != 0.0f || v.y != 0.0f; }
VECMATH_INLINE vec2_t vec2_asin( vec2_t v ) { return vec2( vecmath_asin( v.x ), vecmath_asin( v.y ) ); }
VECMATH_INLINE vec2_t vec2_atan( vec2_t v ) { return vec2( vecmath_atan( v.x ), vecmath_atan( v.y ) ); }
VECMATH_INLINE vec2_t vec2_atan2( vec2_t y, vec2_t x ) { return vec2( vecmath_atan2( y.x, x.x ), vecmath_atan2( y.y, x.y ) ); }
VECMATH_INLINE vec2_t vec2_ceil( vec2_t v ) { return vec2( vecmath_ceil( v.x ), vecmath_ceil( v.y ) ); }
VECMATH_INLINE vec2_t vec2_clamp( vec2_t v, vec2_t min_v, vec2_t max_v ) { return vec2( vecmath_clamp( v.x, min_v.x, max_v.x ), vecmath_clamp( v.y, min_v.y, max_v.y ) ); }
VECMATH_INLINE vec2_t vec2_cos( vec2_t v ) { return vec2( vecmath_cos( v.x ), vecmath_cos( v.y ) ); }
VECMATH_INLINE vec2_t vec2_cosh( vec2_t v ) { return vec2( vecmath_cosh( v.x ), vecmath_cosh( v.y ) ); }
VECMATH_INLINE float vec2_cross( vec2_t a, vec2_t b ) { return a.x * b.y - a.y * b.x; }
VECMATH_INLINE vec2_t vec2_degrees( vec2_t v ) { return vec2( vecmath_degrees( v.x ), vecmath_degrees( v.y ) ); } 
VECMATH_INLINE float vec2_distancesq( vec2_t a, vec2_t b ) { float x = b.x - a.x; float y = b.y - a.y; return x * x + y * y; }
VECMATH_INLINE float vec2_distance( vec2_t a, vec2_t b ) { float x = b.x - a.x; float y = b.y - a.y; return vecmath_sqrt( x * x + y * y ); }
VECMATH_INLINE float vec2_dot( vec2_t a, vec2_t b ) { return a.x * b.x + a.y * b.y; }
VECMATH_INLINE vec2_t vec2_exp( vec2_t v ) { return vec2( vecmath_exp( v.x ), vecmath_exp( v.y ) ); }
VECMATH_INLINE vec2_t vec2_exp2( vec2_t v ) { return vec2( vecmath_exp2( v.x ), vecmath_exp2( v.y ) ); }
VECMATH_INLINE vec2_t vec2_floor( vec2_t v ) { return vec2( vecmath_floor( v.x ), vecmath_floor( v.y ) ); }
VECMATH_INLINE vec2_t vec2_fmod( vec2_t a, vec2_t b ) { return vec2( vecmath_fmod( a.x, b.x ), vecmath_fmod( a.y, b.y ) ); }
VECMATH_INLINE vec2_t vec2_frac( vec2_t v ) { return vec2( vecmath_frac( v.x ), vecmath_frac( v.y ) ); }
VECMATH_INLINE float vec2_lengthsq( vec2_t v ) { return v.x * v.x + v.y * v.y; }
VECMATH_INLINE float vec2_length( vec2_t v ) { return vecmath_sqrt( v.x * v.x + v.y * v.y ); }
VECMATH_INLINE vec2_t vec2_lerp( vec2_t a, vec2_t b, float s ) { return vec2( vecmath_lerp( a.x, b.x, s ), vecmath_lerp( a.y, b.y, s ) ); }
VECMATH_INLINE vec2_t vec2_log( vec2_t v ) { return vec2( vecmath_log( v.x ), vecmath_log( v.y ) ); }
VECMATH_INLINE vec2_t vec2_log2( vec2_t v ) { return vec2( vecmath_log2( v.x ), vecmath_log2( v.y ) ); }
VECMATH_INLINE vec2_t vec2_log10( vec2_t v ) { return vec2( vecmath_log10( v.x ), vecmath_log10( v.y ) ); }
VECMATH_INLINE vec2_t vec2_max( vec2_t a, vec2_t b ) { return vec2( vecmath_max( a.x, b.x ), vecmath_max( a.y, b.y ) ); }
VECMATH_INLINE vec2_t vec2_min( vec2_t a, vec2_t b ) { return vec2( vecmath_min( a.x, b.x ), vecmath_min( a.y, b.y ) ); }
VECMATH_INLINE vec2_t vec2_normalize( vec2_t v ) { float l = vecmath_sqrt( v.x * v.x + v.y * v.y ); return l == 0.0f ? v : vec2( v.x / l, v.y / l ); }
VECMATH_INLINE vec2_t vec2_pow( vec2_t a, vec2_t b ) { return vec2( vecmath_pow( a.x, b.x ), vecmath_pow( a.y, b.y ) ); }
VECMATH_INLINE vec2_t vec2_radians( vec2_t v ) { return vec2( vecmath_radians( v.x ), vecmath_radians( v.y ) ); } 
VECMATH_INLINE vec2_t vec2_rcp( vec2_t v ) { return vec2( vecmath_rcp( v.x ), vecmath_rcp( v.y ) ); }
VECMATH_INLINE vec2_t vec2_reflect( vec2_t i, vec2_t n ) { return vec2_sub( i, vec2_mulf( n, 2.0f * vec2_dot( i, n ) ) ); }
VECMATH_INLINE vec2_t vec2_refract( vec2_t i, vec2_t n, float r ) { float d = vec2_dot( n, i ); float k = 1.0f - r * r * ( 1.0f - d * d ); return k < 0.0f ? vec2f( 0.0f ) : vec2_sub( vec2_mulf( i, r ), vec2_mulf( n, r * d + vecmath_sqrt( k ) ) ); }
VECMATH_INLINE vec2_t vec2_round( vec2_t v ) { return vec2( vecmath_round( v.x ), vecmath_round( v.y ) ); }
VECMATH_INLINE vec2_t vec2_rsqrt( vec2_t v ) { return vec2( vecmath_rcp( vecmath_sqrt( v.x ) ), vecmath_rcp( vecmath_sqrt( v.y ) ) ); }
VECMATH_INLINE vec2_t vec2_saturate( vec2_t v ) { return vec2( vecmath_saturate( v.x ), vecmath_saturate( v.y ) ); }
VECMATH_INLINE vec2_t vec2_sign( vec2_t v ) { return vec2( vecmath_sign( v.x ), vecmath_sign( v.y ) ); }
VECMATH_INLINE vec2_t vec2_sin( vec2_t v ) { return vec2( vecmath_sin( v.x ), vecmath_sin( v.y ) ); }
VECMATH_INLINE vec2_t vec2_sinh( vec2_t v ) { return vec2( vecmath_sinh( v.x ), vecmath_sinh( v.y ) ); }
VECMATH_INLINE vec2_t vec2_smoothstep( vec2_t min_v, vec2_t max_v, vec2_t v ) { return vec2( vecmath_smoothstep( min_v.x, max_v.x, v.x ), vecmath_smoothstep( min_v.y, max_v.y, v.y ) ); }
VECMATH_INLINE vec2_t vec2_smootherstep( vec2_t min_v, vec2_t max_v, vec2_t v ) { return vec2( vecmath_smootherstep( min_v.x, max_v.x, v.x ), vecmath_smootherstep( min_v.y, max_v.y, v.y ) ); }
VECMATH_INLINE vec2_t vec2_sqrt( vec2_t v ) { return vec2( vecmath_sqrt( v.x ), vecmath_sqrt( v.y ) ); }
VECMATH_INLINE vec2_t vec2_step( vec2_t a, vec2_t b ) { return vec2( vecmath_step( a.x, b.x ), vecmath_step( a.y, b.y ) ); }
VECMATH_INLINE vec2_t vec2_tan( vec2_t v ) { return vec2( vecmath_tan( v.x ), vecmath_tan( v.y ) ); }
VECMATH_INLINE vec2_t vec2_tanh( vec2_t v ) { return vec2( vecmath_tanh( v.x ), vecmath_tanh( v.y ) ); }
VECMATH_INLINE vec2_t vec2_trunc( vec2_t v ) { return vec2( vecmath_trunc( v.x ), vecmath_trunc( v.y ) ); }


// vec3
#ifdef __cplusplus
    struct vec3 : vec3_t { 
        inline vec3() {}
        inline vec3( float x_, float y_, float z_ ) { x = x_; y = y_; z = z_; }
        inline vec3( vec3_t v ) { x = v.x; y = v.y; z = v.z; }
        inline vec3( vec2_t v, float f ) { x = v.x; y = v.y; z = f; }
        inline vec3( float f, vec2_t v  ) { x = f; y = v.x; z = v.y; }
        inline vec3( float v ) { x = v; y = v; z = v; }
        inline float operator[]( int index ) const { return ( (float*) this)[ index ]; }
        inline float& operator[]( int index ) { return ( (float*) this )[ index ]; }

        inline vec2_t xx() { vec2_t r = { x, x }; return r; }
        inline vec2_t xy() { vec2_t r = { x, y }; return r; }
        inline vec2_t xz() { vec2_t r = { x, z }; return r; }
        inline vec2_t yx() { vec2_t r = { y, x }; return r; }
        inline vec2_t yy() { vec2_t r = { y, y }; return r; }
        inline vec2_t yz() { vec2_t r = { y, z }; return r; }
        inline vec2_t zx() { vec2_t r = { z, x }; return r; }
        inline vec2_t zy() { vec2_t r = { z, y }; return r; }
        inline vec2_t zz() { vec2_t r = { z, z }; return r; }

        inline vec3_t xxx() { vec3_t r = { x, x, x }; return r; }
        inline vec3_t xxy() { vec3_t r = { x, x, y }; return r; }
        inline vec3_t xxz() { vec3_t r = { x, x, z }; return r; }
        inline vec3_t xyx() { vec3_t r = { x, y, x }; return r; }
        inline vec3_t xyy() { vec3_t r = { x, y, y }; return r; }
        inline vec3_t xyz() { vec3_t r = { x, y, z }; return r; }
        inline vec3_t xzx() { vec3_t r = { x, z, x }; return r; }
        inline vec3_t xzy() { vec3_t r = { x, z, y }; return r; }
        inline vec3_t xzz() { vec3_t r = { x, z, z }; return r; }
        inline vec3_t yxx() { vec3_t r = { y, x, x }; return r; }
        inline vec3_t yxy() { vec3_t r = { y, x, y }; return r; }
        inline vec3_t yxz() { vec3_t r = { y, x, z }; return r; }
        inline vec3_t yyx() { vec3_t r = { y, y, x }; return r; }
        inline vec3_t yyy() { vec3_t r = { y, y, y }; return r; }
        inline vec3_t yyz() { vec3_t r = { y, y, z }; return r; }
        inline vec3_t yzx() { vec3_t r = { y, z, x }; return r; }
        inline vec3_t yzy() { vec3_t r = { y, z, y }; return r; }
        inline vec3_t yzz() { vec3_t r = { y, z, z }; return r; }
        inline vec3_t zxx() { vec3_t r = { z, x, x }; return r; }
        inline vec3_t zxy() { vec3_t r = { z, x, y }; return r; }
        inline vec3_t zxz() { vec3_t r = { z, x, z }; return r; }
        inline vec3_t zyx() { vec3_t r = { z, y, x }; return r; }
        inline vec3_t zyy() { vec3_t r = { z, y, y }; return r; }
        inline vec3_t zyz() { vec3_t r = { z, y, z }; return r; }
        inline vec3_t zzx() { vec3_t r = { z, z, x }; return r; }
        inline vec3_t zzy() { vec3_t r = { z, z, y }; return r; }
        inline vec3_t zzz() { vec3_t r = { z, z, z }; return r; }

        inline vec4_t xxxx() { vec4_t r = { x, x, x, x }; return r; }
        inline vec4_t xxxy() { vec4_t r = { x, x, x, y }; return r; }
        inline vec4_t xxxz() { vec4_t r = { x, x, x, z }; return r; }
        inline vec4_t xxyx() { vec4_t r = { x, x, y, x }; return r; }
        inline vec4_t xxyy() { vec4_t r = { x, x, y, y }; return r; }
        inline vec4_t xxyz() { vec4_t r = { x, x, y, z }; return r; }
        inline vec4_t xxzx() { vec4_t r = { x, x, z, x }; return r; }
        inline vec4_t xxzy() { vec4_t r = { x, x, z, y }; return r; }
        inline vec4_t xxzz() { vec4_t r = { x, x, z, z }; return r; }
        inline vec4_t xyxx() { vec4_t r = { x, y, x, x }; return r; }
        inline vec4_t xyxy() { vec4_t r = { x, y, x, y }; return r; }
        inline vec4_t xyxz() { vec4_t r = { x, y, x, z }; return r; }
        inline vec4_t xyyx() { vec4_t r = { x, y, y, x }; return r; }
        inline vec4_t xyyy() { vec4_t r = { x, y, y, y }; return r; }
        inline vec4_t xyyz() { vec4_t r = { x, y, y, z }; return r; }
        inline vec4_t xyzx() { vec4_t r = { x, y, z, x }; return r; }
        inline vec4_t xyzy() { vec4_t r = { x, y, z, y }; return r; }
        inline vec4_t xyzz() { vec4_t r = { x, y, z, z }; return r; }
        inline vec4_t xzxx() { vec4_t r = { x, z, x, x }; return r; }
        inline vec4_t xzxy() { vec4_t r = { x, z, x, y }; return r; }
        inline vec4_t xzxz() { vec4_t r = { x, z, x, z }; return r; }
        inline vec4_t xzyx() { vec4_t r = { x, z, y, x }; return r; }
        inline vec4_t xzyy() { vec4_t r = { x, z, y, y }; return r; }
        inline vec4_t xzyz() { vec4_t r = { x, z, y, z }; return r; }
        inline vec4_t xzzx() { vec4_t r = { x, z, z, x }; return r; }
        inline vec4_t xzzy() { vec4_t r = { x, z, z, y }; return r; }
        inline vec4_t xzzz() { vec4_t r = { x, z, z, z }; return r; }
        inline vec4_t yxxx() { vec4_t r = { y, x, x, x }; return r; }
        inline vec4_t yxxy() { vec4_t r = { y, x, x, y }; return r; }
        inline vec4_t yxxz() { vec4_t r = { y, x, x, z }; return r; }
        inline vec4_t yxyx() { vec4_t r = { y, x, y, x }; return r; }
        inline vec4_t yxyy() { vec4_t r = { y, x, y, y }; return r; }
        inline vec4_t yxyz() { vec4_t r = { y, x, y, z }; return r; }
        inline vec4_t yxzx() { vec4_t r = { y, x, z, x }; return r; }
        inline vec4_t yxzy() { vec4_t r = { y, x, z, y }; return r; }
        inline vec4_t yxzz() { vec4_t r = { y, x, z, z }; return r; }
        inline vec4_t yyxx() { vec4_t r = { y, y, x, x }; return r; }
        inline vec4_t yyxy() { vec4_t r = { y, y, x, y }; return r; }
        inline vec4_t yyxz() { vec4_t r = { y, y, x, z }; return r; }
        inline vec4_t yyyx() { vec4_t r = { y, y, y, x }; return r; }
        inline vec4_t yyyy() { vec4_t r = { y, y, y, y }; return r; }
        inline vec4_t yyyz() { vec4_t r = { y, y, y, z }; return r; }
        inline vec4_t yyzx() { vec4_t r = { y, y, z, x }; return r; }
        inline vec4_t yyzy() { vec4_t r = { y, y, z, y }; return r; }
        inline vec4_t yyzz() { vec4_t r = { y, y, z, z }; return r; }
        inline vec4_t yzxx() { vec4_t r = { y, z, x, x }; return r; }
        inline vec4_t yzxy() { vec4_t r = { y, z, x, y }; return r; }
        inline vec4_t yzxz() { vec4_t r = { y, z, x, z }; return r; }
        inline vec4_t yzyx() { vec4_t r = { y, z, y, x }; return r; }
        inline vec4_t yzyy() { vec4_t r = { y, z, y, y }; return r; }
        inline vec4_t yzyz() { vec4_t r = { y, z, y, z }; return r; }
        inline vec4_t yzzx() { vec4_t r = { y, z, z, x }; return r; }
        inline vec4_t yzzy() { vec4_t r = { y, z, z, y }; return r; }
        inline vec4_t yzzz() { vec4_t r = { y, z, z, z }; return r; }
        inline vec4_t zxxx() { vec4_t r = { z, x, x, x }; return r; }
        inline vec4_t zxxy() { vec4_t r = { z, x, x, y }; return r; }
        inline vec4_t zxxz() { vec4_t r = { z, x, x, z }; return r; }
        inline vec4_t zxyx() { vec4_t r = { z, x, y, x }; return r; }
        inline vec4_t zxyy() { vec4_t r = { z, x, y, y }; return r; }
        inline vec4_t zxyz() { vec4_t r = { z, x, y, z }; return r; }
        inline vec4_t zxzx() { vec4_t r = { z, x, z, x }; return r; }
        inline vec4_t zxzy() { vec4_t r = { z, x, z, y }; return r; }
        inline vec4_t zxzz() { vec4_t r = { z, x, z, z }; return r; }
        inline vec4_t zyxx() { vec4_t r = { z, y, x, x }; return r; }
        inline vec4_t zyxy() { vec4_t r = { z, y, x, y }; return r; }
        inline vec4_t zyxz() { vec4_t r = { z, y, x, z }; return r; }
        inline vec4_t zyyx() { vec4_t r = { z, y, y, x }; return r; }
        inline vec4_t zyyy() { vec4_t r = { z, y, y, y }; return r; }
        inline vec4_t zyyz() { vec4_t r = { z, y, y, z }; return r; }
        inline vec4_t zyzx() { vec4_t r = { z, y, z, x }; return r; }
        inline vec4_t zyzy() { vec4_t r = { z, y, z, y }; return r; }
        inline vec4_t zyzz() { vec4_t r = { z, y, z, z }; return r; }
        inline vec4_t zzxx() { vec4_t r = { z, z, x, x }; return r; }
        inline vec4_t zzxy() { vec4_t r = { z, z, x, y }; return r; }
        inline vec4_t zzxz() { vec4_t r = { z, z, x, z }; return r; }
        inline vec4_t zzyx() { vec4_t r = { z, z, y, x }; return r; }
        inline vec4_t zzyy() { vec4_t r = { z, z, y, y }; return r; }
        inline vec4_t zzyz() { vec4_t r = { z, z, y, z }; return r; }
        inline vec4_t zzzx() { vec4_t r = { z, z, z, x }; return r; }
        inline vec4_t zzzy() { vec4_t r = { z, z, z, y }; return r; }
        inline vec4_t zzzz() { vec4_t r = { z, z, z, z }; return r; }
    };
#else
    VECMATH_INLINE vec3_t vec3( float x, float y, float z ) { vec3_t vec; vec.x = x; vec.y = y; vec.z = z; return vec; }
#endif
VECMATH_INLINE vec3_t vec3f( float v ) { vec3_t vec; vec.x = v; vec.y = v; vec.z = v; return vec; }
VECMATH_INLINE vec3_t vec3v2f( vec2_t v, float f ) { vec3_t vec; vec.x = v.x; vec.y = v.y; vec.z = f; return vec; }
VECMATH_INLINE vec3_t vec3fv2( float f, vec2_t v ) { vec3_t vec; vec.x = f; vec.y = v.x; vec.z = v.y; return vec; }
    
VECMATH_INLINE float vec3_get( vec3_t vec, int index ) { return ( (float*) &vec )[ index ]; }
VECMATH_INLINE void vec3_set( vec3_t* vec, int index, float f ) { ( (float*) vec )[ index ] = f; }

// operators
VECMATH_INLINE vec3_t vec3_neg( vec3_t v ) { return vec3( -v.x, -v.y, -v.z ); }
VECMATH_INLINE int vec3_eq( vec3_t a, vec3_t b ) { return a.x == b.x && a.y == b.y && a.z == b.z; }
VECMATH_INLINE vec3_t vec3_add( vec3_t a, vec3_t b ) { return vec3( a.x + b.x, a.y + b.y, a.z + b.z ); }
VECMATH_INLINE vec3_t vec3_sub( vec3_t a, vec3_t b ) { return vec3( a.x - b.x, a.y - b.y, a.z - b.z ); }
VECMATH_INLINE vec3_t vec3_mul( vec3_t a, vec3_t b ) { return vec3( a.x * b.x, a.y * b.y, a.z * b.z ); }
VECMATH_INLINE vec3_t vec3_div( vec3_t a, vec3_t b ) { return vec3( a.x / b.x, a.y / b.y, a.z / b.z ); }
VECMATH_INLINE vec3_t vec3_addf( vec3_t a, float s ) { return vec3( a.x + s, a.y + s, a.z + s ); }
VECMATH_INLINE vec3_t vec3_subf( vec3_t a, float s ) { return vec3( a.x - s, a.y - s, a.z - s ); }
VECMATH_INLINE vec3_t vec3_mulf( vec3_t a, float s ) { return vec3( a.x * s, a.y * s, a.z * s ); }
VECMATH_INLINE vec3_t vec3_divf( vec3_t a, float s ) { return vec3( a.x / s, a.y / s, a.z / s ); }
VECMATH_INLINE vec3_t vec3_fadd( float s, vec3_t a ) { return vec3_addf( a, s ); }
VECMATH_INLINE vec3_t vec3_fsub( float s, vec3_t a ) { return vec3_sub( vec3f( s ), a ); }
VECMATH_INLINE vec3_t vec3_fmul( float s, vec3_t a ) { return vec3_mulf( a, s ); }
VECMATH_INLINE vec3_t vec3_fdiv( float s, vec3_t a ) { return vec3_div( vec3f( s ), a ); }

// functions
VECMATH_INLINE vec3_t vec3_abs( vec3_t v ) { return vec3( vecmath_abs( v.x ), vecmath_abs( v.y ), vecmath_abs( v.z ) ); }
VECMATH_INLINE vec3_t vec3_acos( vec3_t v ) { return vec3( vecmath_acos( v.x ), vecmath_acos( v.y ), vecmath_acos( v.z ) ); }
VECMATH_INLINE int vec3_all( vec3_t v ) { return v.x != 0.0f && v.y != 0.0f && v.z != 0.0f; }
VECMATH_INLINE int vec3_any( vec3_t v ) { return v.x != 0.0f || v.y != 0.0f || v.z != 0.0f; }
VECMATH_INLINE vec3_t vec3_asin( vec3_t v ) { return vec3( vecmath_asin( v.x ), vecmath_asin( v.y ), vecmath_asin( v.z ) ); }
VECMATH_INLINE vec3_t vec3_atan( vec3_t v ) { return vec3( vecmath_atan( v.x ), vecmath_atan( v.y ), vecmath_atan( v.z ) ); }
VECMATH_INLINE vec3_t vec3_atan2( vec3_t y, vec3_t x ) { return vec3( vecmath_atan2( y.x, x.x ), vecmath_atan2( y.y, x.y ), vecmath_atan2( y.z, x.z ) ); }
VECMATH_INLINE vec3_t vec3_ceil( vec3_t v ) { return vec3( vecmath_ceil( v.x ), vecmath_ceil( v.y ), vecmath_ceil( v.z ) ); }
VECMATH_INLINE vec3_t vec3_clamp( vec3_t v, vec3_t min_v, vec3_t max_v ) { return vec3( vecmath_clamp( v.x, min_v.x, max_v.x ), vecmath_clamp( v.y, min_v.y, max_v.y ), vecmath_clamp( v.z, min_v.z, max_v.z ) ); }
VECMATH_INLINE vec3_t vec3_cos( vec3_t v ) { return vec3( vecmath_cos( v.x ), vecmath_cos( v.y ), vecmath_cos( v.z ) ); }
VECMATH_INLINE vec3_t vec3_cosh( vec3_t v ) { return vec3( vecmath_cosh( v.x ), vecmath_cosh( v.y ), vecmath_cosh( v.z ) ); }
VECMATH_INLINE vec3_t vec3_cross( vec3_t a, vec3_t b ) { return vec3( a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x ); }
VECMATH_INLINE vec3_t vec3_degrees( vec3_t v ) { return vec3( vecmath_degrees( v.x ), vecmath_degrees( v.y ), vecmath_degrees( v.z ) ); } 
VECMATH_INLINE float vec3_distancesq( vec3_t a, vec3_t b ) { float x = b.x - a.x; float y = b.y - a.y; float z = b.z - a.z; return x * x + y * y + z * z; }
VECMATH_INLINE float vec3_distance( vec3_t a, vec3_t b ) { float x = b.x - a.x; float y = b.y - a.y; float z = b.z - a.z; return vecmath_sqrt( x * x + y * y + z * z ); }
VECMATH_INLINE float vec3_dot( vec3_t a, vec3_t b ) { return a.x * b.x + a.y * b.y + a.z * b.z; }
VECMATH_INLINE vec3_t vec3_exp( vec3_t v ) { return vec3( vecmath_exp( v.x ), vecmath_exp( v.y ), vecmath_exp( v.z ) ); }
VECMATH_INLINE vec3_t vec3_exp2( vec3_t v ) { return vec3( vecmath_exp2( v.x ), vecmath_exp2( v.y ), vecmath_exp2( v.z ) ); }
VECMATH_INLINE vec3_t vec3_floor( vec3_t v ) { return vec3( vecmath_floor( v.x ), vecmath_floor( v.y ), vecmath_floor( v.z ) ); }
VECMATH_INLINE vec3_t vec3_fmod( vec3_t a, vec3_t b ) { return vec3( vecmath_fmod( a.x, b.x ), vecmath_fmod( a.y, b.y ), vecmath_fmod( a.z, b.z ) ); }
VECMATH_INLINE vec3_t vec3_frac( vec3_t v ) { return vec3( vecmath_frac( v.x ), vecmath_frac( v.y ), vecmath_frac( v.z ) ); }
VECMATH_INLINE float vec3_lengthsq( vec3_t v ) { return v.x * v.x + v.y * v.y + v.z * v.z; }
VECMATH_INLINE float vec3_length( vec3_t v ) { return vecmath_sqrt( v.x * v.x + v.y * v.y + v.z * v.z ); }
VECMATH_INLINE vec3_t vec3_lerp( vec3_t a, vec3_t b, float s ) { return vec3( vecmath_lerp( a.x, b.x, s ), vecmath_lerp( a.y, b.y, s ), vecmath_lerp( a.z, b.z, s ) ); }
VECMATH_INLINE vec3_t vec3_log( vec3_t v ) { return vec3( vecmath_log( v.x ), vecmath_log( v.y ), vecmath_log( v.z ) ); }
VECMATH_INLINE vec3_t vec3_log2( vec3_t v ) { return vec3( vecmath_log2( v.x ), vecmath_log2( v.y ), vecmath_log2( v.z ) ); }
VECMATH_INLINE vec3_t vec3_log10( vec3_t v ) { return vec3( vecmath_log10( v.x ), vecmath_log10( v.y ), vecmath_log10( v.z ) ); }
VECMATH_INLINE vec3_t vec3_max( vec3_t a, vec3_t b ) { return vec3( vecmath_max( a.x, b.x ), vecmath_max( a.y, b.y ), vecmath_max( a.z, b.z ) ); }
VECMATH_INLINE vec3_t vec3_min( vec3_t a, vec3_t b ) { return vec3( vecmath_min( a.x, b.x ), vecmath_min( a.y, b.y ), vecmath_min( a.z, b.z ) ); }
VECMATH_INLINE vec3_t vec3_normalize( vec3_t v ) { float l = vecmath_sqrt( v.x * v.x + v.y * v.y + v.z * v.z ); return l == 0.0f ? v : vec3( v.x / l, v.y / l, v.z / l ); }
VECMATH_INLINE vec3_t vec3_pow( vec3_t a, vec3_t b ) { return vec3( vecmath_pow( a.x, b.x ), vecmath_pow( a.y, b.y ), vecmath_pow( a.z, b.z ) ); }
VECMATH_INLINE vec3_t vec3_radians( vec3_t v ) { return vec3( vecmath_radians( v.x ), vecmath_radians( v.y ), vecmath_radians( v.z ) ); } 
VECMATH_INLINE vec3_t vec3_rcp( vec3_t v ) { return vec3( vecmath_rcp( v.x ), vecmath_rcp( v.y ), vecmath_rcp( v.z ) ); }
VECMATH_INLINE vec3_t vec3_reflect( vec3_t i, vec3_t n ) { return vec3_sub( i, vec3_mulf( n, 2.0f * vec3_dot( i, n ) ) ); }
VECMATH_INLINE vec3_t vec3_refract( vec3_t i, vec3_t n, float r ) { float d = vec3_dot( n, i ); float k = 1.0f - r * r * ( 1.0f - d * d ); return k < 0.0f ? vec3f( 0.0f ) : vec3_sub( vec3_mulf( i, r ), vec3_mulf( n, r * d + vecmath_sqrt( k ) ) ); }
VECMATH_INLINE vec3_t vec3_round( vec3_t v ) { return vec3( vecmath_round( v.x ), vecmath_round( v.y ), vecmath_round( v.z ) ); }
VECMATH_INLINE vec3_t vec3_rsqrt( vec3_t v ) { return vec3( vecmath_rcp( vecmath_sqrt( v.x ) ), vecmath_rcp( vecmath_sqrt( v.y ) ), vecmath_rcp( vecmath_sqrt( v.z ) ) ); }
VECMATH_INLINE vec3_t vec3_saturate( vec3_t v ) { return vec3( vecmath_saturate( v.x ), vecmath_saturate( v.y ), vecmath_saturate( v.z ) ); }
VECMATH_INLINE vec3_t vec3_sign( vec3_t v ) { return vec3( vecmath_sign( v.x ), vecmath_sign( v.y ), vecmath_sign( v.z ) ); }
VECMATH_INLINE vec3_t vec3_sin( vec3_t v ) { return vec3( vecmath_sin( v.x ), vecmath_sin( v.y ), vecmath_sin( v.z ) ); }
VECMATH_INLINE vec3_t vec3_sinh( vec3_t v ) { return vec3( vecmath_sinh( v.x ), vecmath_sinh( v.y ), vecmath_sinh( v.z ) ); }
VECMATH_INLINE vec3_t vec3_smoothstep( vec3_t min_v, vec3_t max_v, vec3_t v ) { return vec3( vecmath_smoothstep( min_v.x, max_v.x, v.x ), vecmath_smoothstep( min_v.y, max_v.y, v.y ), vecmath_smoothstep( min_v.z, max_v.z, v.z ) ); }
VECMATH_INLINE vec3_t vec3_smootherstep( vec3_t min_v, vec3_t max_v, vec3_t v ) { return vec3( vecmath_smootherstep( min_v.x, max_v.x, v.x ), vecmath_smootherstep( min_v.y, max_v.y, v.y ), vecmath_smootherstep( min_v.z, max_v.z, v.z ) ); }
VECMATH_INLINE vec3_t vec3_sqrt( vec3_t v ) { return vec3( vecmath_sqrt( v.x ), vecmath_sqrt( v.y ), vecmath_sqrt( v.z ) ); }
VECMATH_INLINE vec3_t vec3_step( vec3_t a, vec3_t b ) { return vec3( vecmath_step( a.x, b.x ), vecmath_step( a.y, b.y ), vecmath_step( a.z, b.z ) ); }
VECMATH_INLINE vec3_t vec3_tan( vec3_t v ) { return vec3( vecmath_tan( v.x ), vecmath_tan( v.y ), vecmath_tan( v.z ) ); }
VECMATH_INLINE vec3_t vec3_tanh( vec3_t v ) { return vec3( vecmath_tanh( v.x ), vecmath_tanh( v.y ), vecmath_tanh( v.z ) ); }
VECMATH_INLINE vec3_t vec3_trunc( vec3_t v ) { return vec3( vecmath_trunc( v.x ), vecmath_trunc( v.y ), vecmath_trunc( v.z ) ); }


// vec4
#ifdef __cplusplus
    struct vec4 : vec4_t { 
        inline vec4() {}
        inline vec4( float x_, float y_, float z_, float w_ ) { x = x_; y = y_; z = z_; w = w_; }
        inline vec4( vec4_t v ) { x = v.x; y = v.y; z = v.z; w = v.w; }
        inline vec4( vec2_t a, vec2_t b ) { x = a.x; y = a.y; z = b.x; w = b.y; }
        inline vec4( vec3_t v, float f ) { x = v.x; y = v.y; z = v.z; w = f; }
        inline vec4( float f, vec3_t v  ) { x = f; y = v.x; z = v.y; w = v.z; }
        inline vec4( float v ) { x = v; y = v; z = v; w = v; }
        inline float operator[]( int index ) const { return ( (float*) this)[ index ]; }
        inline float& operator[]( int index ) { return ( (float*) this )[ index ]; }

        inline vec2_t xx() { vec2_t r = { x, x }; return r; }
        inline vec2_t xy() { vec2_t r = { x, y }; return r; }
        inline vec2_t xz() { vec2_t r = { x, z }; return r; }
        inline vec2_t xw() { vec2_t r = { x, w }; return r; }
        inline vec2_t yx() { vec2_t r = { y, x }; return r; }
        inline vec2_t yy() { vec2_t r = { y, y }; return r; }
        inline vec2_t yz() { vec2_t r = { y, z }; return r; }
        inline vec2_t yw() { vec2_t r = { y, w }; return r; }
        inline vec2_t zx() { vec2_t r = { z, x }; return r; }
        inline vec2_t zy() { vec2_t r = { z, y }; return r; }
        inline vec2_t zz() { vec2_t r = { z, z }; return r; }
        inline vec2_t zw() { vec2_t r = { z, w }; return r; }
        inline vec2_t wx() { vec2_t r = { w, x }; return r; }
        inline vec2_t wy() { vec2_t r = { w, y }; return r; }
        inline vec2_t wz() { vec2_t r = { w, z }; return r; }
        inline vec2_t ww() { vec2_t r = { w, w }; return r; }

        inline vec3_t xxx() { vec3_t r = { x, x, x }; return r; }
        inline vec3_t xxy() { vec3_t r = { x, x, y }; return r; }
        inline vec3_t xxz() { vec3_t r = { x, x, z }; return r; }
        inline vec3_t xxw() { vec3_t r = { x, x, w }; return r; }
        inline vec3_t xyx() { vec3_t r = { x, y, x }; return r; }
        inline vec3_t xyy() { vec3_t r = { x, y, y }; return r; }
        inline vec3_t xyz() { vec3_t r = { x, y, z }; return r; }
        inline vec3_t xyw() { vec3_t r = { x, y, w }; return r; }
        inline vec3_t xzx() { vec3_t r = { x, z, x }; return r; }
        inline vec3_t xzy() { vec3_t r = { x, z, y }; return r; }
        inline vec3_t xzz() { vec3_t r = { x, z, z }; return r; }
        inline vec3_t xzw() { vec3_t r = { x, z, w }; return r; }
        inline vec3_t xwx() { vec3_t r = { x, w, x }; return r; }
        inline vec3_t xwy() { vec3_t r = { x, w, y }; return r; }
        inline vec3_t xwz() { vec3_t r = { x, w, z }; return r; }
        inline vec3_t xww() { vec3_t r = { x, w, w }; return r; }
        inline vec3_t yxx() { vec3_t r = { y, x, x }; return r; }
        inline vec3_t yxy() { vec3_t r = { y, x, y }; return r; }
        inline vec3_t yxz() { vec3_t r = { y, x, z }; return r; }
        inline vec3_t yxw() { vec3_t r = { y, x, w }; return r; }
        inline vec3_t yyx() { vec3_t r = { y, y, x }; return r; }
        inline vec3_t yyy() { vec3_t r = { y, y, y }; return r; }
        inline vec3_t yyz() { vec3_t r = { y, y, z }; return r; }
        inline vec3_t yyw() { vec3_t r = { y, y, w }; return r; }
        inline vec3_t yzx() { vec3_t r = { y, z, x }; return r; }
        inline vec3_t yzy() { vec3_t r = { y, z, y }; return r; }
        inline vec3_t yzz() { vec3_t r = { y, z, z }; return r; }
        inline vec3_t yzw() { vec3_t r = { y, z, w }; return r; }
        inline vec3_t ywx() { vec3_t r = { y, w, x }; return r; }
        inline vec3_t ywy() { vec3_t r = { y, w, y }; return r; }
        inline vec3_t ywz() { vec3_t r = { y, w, z }; return r; }
        inline vec3_t yww() { vec3_t r = { y, w, w }; return r; }
        inline vec3_t zxx() { vec3_t r = { z, x, x }; return r; }
        inline vec3_t zxy() { vec3_t r = { z, x, y }; return r; }
        inline vec3_t zxz() { vec3_t r = { z, x, z }; return r; }
        inline vec3_t zxw() { vec3_t r = { z, x, w }; return r; }
        inline vec3_t zyx() { vec3_t r = { z, y, x }; return r; }
        inline vec3_t zyy() { vec3_t r = { z, y, y }; return r; }
        inline vec3_t zyz() { vec3_t r = { z, y, z }; return r; }
        inline vec3_t zyw() { vec3_t r = { z, y, w }; return r; }
        inline vec3_t zzx() { vec3_t r = { z, z, x }; return r; }
        inline vec3_t zzy() { vec3_t r = { z, z, y }; return r; }
        inline vec3_t zzz() { vec3_t r = { z, z, z }; return r; }
        inline vec3_t zzw() { vec3_t r = { z, z, w }; return r; }
        inline vec3_t zwx() { vec3_t r = { z, w, x }; return r; }
        inline vec3_t zwy() { vec3_t r = { z, w, y }; return r; }
        inline vec3_t zwz() { vec3_t r = { z, w, z }; return r; }
        inline vec3_t zww() { vec3_t r = { z, w, w }; return r; }
        inline vec3_t wxx() { vec3_t r = { w, x, x }; return r; }
        inline vec3_t wxy() { vec3_t r = { w, x, y }; return r; }
        inline vec3_t wxz() { vec3_t r = { w, x, z }; return r; }
        inline vec3_t wxw() { vec3_t r = { w, x, w }; return r; }
        inline vec3_t wyx() { vec3_t r = { w, y, x }; return r; }
        inline vec3_t wyy() { vec3_t r = { w, y, y }; return r; }
        inline vec3_t wyz() { vec3_t r = { w, y, z }; return r; }
        inline vec3_t wyw() { vec3_t r = { w, y, w }; return r; }
        inline vec3_t wzx() { vec3_t r = { w, z, x }; return r; }
        inline vec3_t wzy() { vec3_t r = { w, z, y }; return r; }
        inline vec3_t wzz() { vec3_t r = { w, z, z }; return r; }
        inline vec3_t wzw() { vec3_t r = { w, z, w }; return r; }
        inline vec3_t wwx() { vec3_t r = { w, w, x }; return r; }
        inline vec3_t wwy() { vec3_t r = { w, w, y }; return r; }
        inline vec3_t wwz() { vec3_t r = { w, w, z }; return r; }
        inline vec3_t www() { vec3_t r = { w, w, w }; return r; }

        inline vec4_t xxxx() { vec4_t r = { x, x, x, x }; return r; }
        inline vec4_t xxxy() { vec4_t r = { x, x, x, y }; return r; }
        inline vec4_t xxxz() { vec4_t r = { x, x, x, z }; return r; }
        inline vec4_t xxxw() { vec4_t r = { x, x, x, w }; return r; }
        inline vec4_t xxyx() { vec4_t r = { x, x, y, x }; return r; }
        inline vec4_t xxyy() { vec4_t r = { x, x, y, y }; return r; }
        inline vec4_t xxyz() { vec4_t r = { x, x, y, z }; return r; }
        inline vec4_t xxyw() { vec4_t r = { x, x, y, w }; return r; }
        inline vec4_t xxzx() { vec4_t r = { x, x, z, x }; return r; }
        inline vec4_t xxzy() { vec4_t r = { x, x, z, y }; return r; }
        inline vec4_t xxzz() { vec4_t r = { x, x, z, z }; return r; }
        inline vec4_t xxzw() { vec4_t r = { x, x, z, w }; return r; }
        inline vec4_t xxwx() { vec4_t r = { x, x, w, x }; return r; }
        inline vec4_t xxwy() { vec4_t r = { x, x, w, y }; return r; }
        inline vec4_t xxwz() { vec4_t r = { x, x, w, z }; return r; }
        inline vec4_t xxww() { vec4_t r = { x, x, w, w }; return r; }
        inline vec4_t xyxx() { vec4_t r = { x, y, x, x }; return r; }
        inline vec4_t xyxy() { vec4_t r = { x, y, x, y }; return r; }
        inline vec4_t xyxz() { vec4_t r = { x, y, x, z }; return r; }
        inline vec4_t xyxw() { vec4_t r = { x, y, x, w }; return r; }
        inline vec4_t xyyx() { vec4_t r = { x, y, y, x }; return r; }
        inline vec4_t xyyy() { vec4_t r = { x, y, y, y }; return r; }
        inline vec4_t xyyz() { vec4_t r = { x, y, y, z }; return r; }
        inline vec4_t xyyw() { vec4_t r = { x, y, y, w }; return r; }
        inline vec4_t xyzx() { vec4_t r = { x, y, z, x }; return r; }
        inline vec4_t xyzy() { vec4_t r = { x, y, z, y }; return r; }
        inline vec4_t xyzz() { vec4_t r = { x, y, z, z }; return r; }
        inline vec4_t xyzw() { vec4_t r = { x, y, z, w }; return r; }
        inline vec4_t xywx() { vec4_t r = { x, y, w, x }; return r; }
        inline vec4_t xywy() { vec4_t r = { x, y, w, y }; return r; }
        inline vec4_t xywz() { vec4_t r = { x, y, w, z }; return r; }
        inline vec4_t xyww() { vec4_t r = { x, y, w, w }; return r; }
        inline vec4_t xzxx() { vec4_t r = { x, z, x, x }; return r; }
        inline vec4_t xzxy() { vec4_t r = { x, z, x, y }; return r; }
        inline vec4_t xzxz() { vec4_t r = { x, z, x, z }; return r; }
        inline vec4_t xzxw() { vec4_t r = { x, z, x, w }; return r; }
        inline vec4_t xzyx() { vec4_t r = { x, z, y, x }; return r; }
        inline vec4_t xzyy() { vec4_t r = { x, z, y, y }; return r; }
        inline vec4_t xzyz() { vec4_t r = { x, z, y, z }; return r; }
        inline vec4_t xzyw() { vec4_t r = { x, z, y, w }; return r; }
        inline vec4_t xzzx() { vec4_t r = { x, z, z, x }; return r; }
        inline vec4_t xzzy() { vec4_t r = { x, z, z, y }; return r; }
        inline vec4_t xzzz() { vec4_t r = { x, z, z, z }; return r; }
        inline vec4_t xzzw() { vec4_t r = { x, z, z, w }; return r; }
        inline vec4_t xzwx() { vec4_t r = { x, z, w, x }; return r; }
        inline vec4_t xzwy() { vec4_t r = { x, z, w, y }; return r; }
        inline vec4_t xzwz() { vec4_t r = { x, z, w, z }; return r; }
        inline vec4_t xzww() { vec4_t r = { x, z, w, w }; return r; }
        inline vec4_t xwxx() { vec4_t r = { x, w, x, x }; return r; }
        inline vec4_t xwxy() { vec4_t r = { x, w, x, y }; return r; }
        inline vec4_t xwxz() { vec4_t r = { x, w, x, z }; return r; }
        inline vec4_t xwxw() { vec4_t r = { x, w, x, w }; return r; }
        inline vec4_t xwyx() { vec4_t r = { x, w, y, x }; return r; }
        inline vec4_t xwyy() { vec4_t r = { x, w, y, y }; return r; }
        inline vec4_t xwyz() { vec4_t r = { x, w, y, z }; return r; }
        inline vec4_t xwyw() { vec4_t r = { x, w, y, w }; return r; }
        inline vec4_t xwzx() { vec4_t r = { x, w, z, x }; return r; }
        inline vec4_t xwzy() { vec4_t r = { x, w, z, y }; return r; }
        inline vec4_t xwzz() { vec4_t r = { x, w, z, z }; return r; }
        inline vec4_t xwzw() { vec4_t r = { x, w, z, w }; return r; }
        inline vec4_t xwwx() { vec4_t r = { x, w, w, x }; return r; }
        inline vec4_t xwwy() { vec4_t r = { x, w, w, y }; return r; }
        inline vec4_t xwwz() { vec4_t r = { x, w, w, z }; return r; }
        inline vec4_t xwww() { vec4_t r = { x, w, w, w }; return r; }
        inline vec4_t yxxx() { vec4_t r = { y, x, x, x }; return r; }
        inline vec4_t yxxy() { vec4_t r = { y, x, x, y }; return r; }
        inline vec4_t yxxz() { vec4_t r = { y, x, x, z }; return r; }
        inline vec4_t yxxw() { vec4_t r = { y, x, x, w }; return r; }
        inline vec4_t yxyx() { vec4_t r = { y, x, y, x }; return r; }
        inline vec4_t yxyy() { vec4_t r = { y, x, y, y }; return r; }
        inline vec4_t yxyz() { vec4_t r = { y, x, y, z }; return r; }
        inline vec4_t yxyw() { vec4_t r = { y, x, y, w }; return r; }
        inline vec4_t yxzx() { vec4_t r = { y, x, z, x }; return r; }
        inline vec4_t yxzy() { vec4_t r = { y, x, z, y }; return r; }
        inline vec4_t yxzz() { vec4_t r = { y, x, z, z }; return r; }
        inline vec4_t yxzw() { vec4_t r = { y, x, z, w }; return r; }
        inline vec4_t yxwx() { vec4_t r = { y, x, w, x }; return r; }
        inline vec4_t yxwy() { vec4_t r = { y, x, w, y }; return r; }
        inline vec4_t yxwz() { vec4_t r = { y, x, w, z }; return r; }
        inline vec4_t yxww() { vec4_t r = { y, x, w, w }; return r; }
        inline vec4_t yyxx() { vec4_t r = { y, y, x, x }; return r; }
        inline vec4_t yyxy() { vec4_t r = { y, y, x, y }; return r; }
        inline vec4_t yyxz() { vec4_t r = { y, y, x, z }; return r; }
        inline vec4_t yyxw() { vec4_t r = { y, y, x, w }; return r; }
        inline vec4_t yyyx() { vec4_t r = { y, y, y, x }; return r; }
        inline vec4_t yyyy() { vec4_t r = { y, y, y, y }; return r; }
        inline vec4_t yyyz() { vec4_t r = { y, y, y, z }; return r; }
        inline vec4_t yyyw() { vec4_t r = { y, y, y, w }; return r; }
        inline vec4_t yyzx() { vec4_t r = { y, y, z, x }; return r; }
        inline vec4_t yyzy() { vec4_t r = { y, y, z, y }; return r; }
        inline vec4_t yyzz() { vec4_t r = { y, y, z, z }; return r; }
        inline vec4_t yyzw() { vec4_t r = { y, y, z, w }; return r; }
        inline vec4_t yywx() { vec4_t r = { y, y, w, x }; return r; }
        inline vec4_t yywy() { vec4_t r = { y, y, w, y }; return r; }
        inline vec4_t yywz() { vec4_t r = { y, y, w, z }; return r; }
        inline vec4_t yyww() { vec4_t r = { y, y, w, w }; return r; }
        inline vec4_t yzxx() { vec4_t r = { y, z, x, x }; return r; }
        inline vec4_t yzxy() { vec4_t r = { y, z, x, y }; return r; }
        inline vec4_t yzxz() { vec4_t r = { y, z, x, z }; return r; }
        inline vec4_t yzxw() { vec4_t r = { y, z, x, w }; return r; }
        inline vec4_t yzyx() { vec4_t r = { y, z, y, x }; return r; }
        inline vec4_t yzyy() { vec4_t r = { y, z, y, y }; return r; }
        inline vec4_t yzyz() { vec4_t r = { y, z, y, z }; return r; }
        inline vec4_t yzyw() { vec4_t r = { y, z, y, w }; return r; }
        inline vec4_t yzzx() { vec4_t r = { y, z, z, x }; return r; }
        inline vec4_t yzzy() { vec4_t r = { y, z, z, y }; return r; }
        inline vec4_t yzzz() { vec4_t r = { y, z, z, z }; return r; }
        inline vec4_t yzzw() { vec4_t r = { y, z, z, w }; return r; }
        inline vec4_t yzwx() { vec4_t r = { y, z, w, x }; return r; }
        inline vec4_t yzwy() { vec4_t r = { y, z, w, y }; return r; }
        inline vec4_t yzwz() { vec4_t r = { y, z, w, z }; return r; }
        inline vec4_t yzww() { vec4_t r = { y, z, w, w }; return r; }
        inline vec4_t ywxx() { vec4_t r = { y, w, x, x }; return r; }
        inline vec4_t ywxy() { vec4_t r = { y, w, x, y }; return r; }
        inline vec4_t ywxz() { vec4_t r = { y, w, x, z }; return r; }
        inline vec4_t ywxw() { vec4_t r = { y, w, x, w }; return r; }
        inline vec4_t ywyx() { vec4_t r = { y, w, y, x }; return r; }
        inline vec4_t ywyy() { vec4_t r = { y, w, y, y }; return r; }
        inline vec4_t ywyz() { vec4_t r = { y, w, y, z }; return r; }
        inline vec4_t ywyw() { vec4_t r = { y, w, y, w }; return r; }
        inline vec4_t ywzx() { vec4_t r = { y, w, z, x }; return r; }
        inline vec4_t ywzy() { vec4_t r = { y, w, z, y }; return r; }
        inline vec4_t ywzz() { vec4_t r = { y, w, z, z }; return r; }
        inline vec4_t ywzw() { vec4_t r = { y, w, z, w }; return r; }
        inline vec4_t ywwx() { vec4_t r = { y, w, w, x }; return r; }
        inline vec4_t ywwy() { vec4_t r = { y, w, w, y }; return r; }
        inline vec4_t ywwz() { vec4_t r = { y, w, w, z }; return r; }
        inline vec4_t ywww() { vec4_t r = { y, w, w, w }; return r; }
        inline vec4_t zxxx() { vec4_t r = { z, x, x, x }; return r; }
        inline vec4_t zxxy() { vec4_t r = { z, x, x, y }; return r; }
        inline vec4_t zxxz() { vec4_t r = { z, x, x, z }; return r; }
        inline vec4_t zxxw() { vec4_t r = { z, x, x, w }; return r; }
        inline vec4_t zxyx() { vec4_t r = { z, x, y, x }; return r; }
        inline vec4_t zxyy() { vec4_t r = { z, x, y, y }; return r; }
        inline vec4_t zxyz() { vec4_t r = { z, x, y, z }; return r; }
        inline vec4_t zxyw() { vec4_t r = { z, x, y, w }; return r; }
        inline vec4_t zxzx() { vec4_t r = { z, x, z, x }; return r; }
        inline vec4_t zxzy() { vec4_t r = { z, x, z, y }; return r; }
        inline vec4_t zxzz() { vec4_t r = { z, x, z, z }; return r; }
        inline vec4_t zxzw() { vec4_t r = { z, x, z, w }; return r; }
        inline vec4_t zxwx() { vec4_t r = { z, x, w, x }; return r; }
        inline vec4_t zxwy() { vec4_t r = { z, x, w, y }; return r; }
        inline vec4_t zxwz() { vec4_t r = { z, x, w, z }; return r; }
        inline vec4_t zxww() { vec4_t r = { z, x, w, w }; return r; }
        inline vec4_t zyxx() { vec4_t r = { z, y, x, x }; return r; }
        inline vec4_t zyxy() { vec4_t r = { z, y, x, y }; return r; }
        inline vec4_t zyxz() { vec4_t r = { z, y, x, z }; return r; }
        inline vec4_t zyxw() { vec4_t r = { z, y, x, w }; return r; }
        inline vec4_t zyyx() { vec4_t r = { z, y, y, x }; return r; }
        inline vec4_t zyyy() { vec4_t r = { z, y, y, y }; return r; }
        inline vec4_t zyyz() { vec4_t r = { z, y, y, z }; return r; }
        inline vec4_t zyyw() { vec4_t r = { z, y, y, w }; return r; }
        inline vec4_t zyzx() { vec4_t r = { z, y, z, x }; return r; }
        inline vec4_t zyzy() { vec4_t r = { z, y, z, y }; return r; }
        inline vec4_t zyzz() { vec4_t r = { z, y, z, z }; return r; }
        inline vec4_t zyzw() { vec4_t r = { z, y, z, w }; return r; }
        inline vec4_t zywx() { vec4_t r = { z, y, w, x }; return r; }
        inline vec4_t zywy() { vec4_t r = { z, y, w, y }; return r; }
        inline vec4_t zywz() { vec4_t r = { z, y, w, z }; return r; }
        inline vec4_t zyww() { vec4_t r = { z, y, w, w }; return r; }
        inline vec4_t zzxx() { vec4_t r = { z, z, x, x }; return r; }
        inline vec4_t zzxy() { vec4_t r = { z, z, x, y }; return r; }
        inline vec4_t zzxz() { vec4_t r = { z, z, x, z }; return r; }
        inline vec4_t zzxw() { vec4_t r = { z, z, x, w }; return r; }
        inline vec4_t zzyx() { vec4_t r = { z, z, y, x }; return r; }
        inline vec4_t zzyy() { vec4_t r = { z, z, y, y }; return r; }
        inline vec4_t zzyz() { vec4_t r = { z, z, y, z }; return r; }
        inline vec4_t zzyw() { vec4_t r = { z, z, y, w }; return r; }
        inline vec4_t zzzx() { vec4_t r = { z, z, z, x }; return r; }
        inline vec4_t zzzy() { vec4_t r = { z, z, z, y }; return r; }
        inline vec4_t zzzz() { vec4_t r = { z, z, z, z }; return r; }
        inline vec4_t zzzw() { vec4_t r = { z, z, z, w }; return r; }
        inline vec4_t zzwx() { vec4_t r = { z, z, w, x }; return r; }
        inline vec4_t zzwy() { vec4_t r = { z, z, w, y }; return r; }
        inline vec4_t zzwz() { vec4_t r = { z, z, w, z }; return r; }
        inline vec4_t zzww() { vec4_t r = { z, z, w, w }; return r; }
        inline vec4_t zwxx() { vec4_t r = { z, w, x, x }; return r; }
        inline vec4_t zwxy() { vec4_t r = { z, w, x, y }; return r; }
        inline vec4_t zwxz() { vec4_t r = { z, w, x, z }; return r; }
        inline vec4_t zwxw() { vec4_t r = { z, w, x, w }; return r; }
        inline vec4_t zwyx() { vec4_t r = { z, w, y, x }; return r; }
        inline vec4_t zwyy() { vec4_t r = { z, w, y, y }; return r; }
        inline vec4_t zwyz() { vec4_t r = { z, w, y, z }; return r; }
        inline vec4_t zwyw() { vec4_t r = { z, w, y, w }; return r; }
        inline vec4_t zwzx() { vec4_t r = { z, w, z, x }; return r; }
        inline vec4_t zwzy() { vec4_t r = { z, w, z, y }; return r; }
        inline vec4_t zwzz() { vec4_t r = { z, w, z, z }; return r; }
        inline vec4_t zwzw() { vec4_t r = { z, w, z, w }; return r; }
        inline vec4_t zwwx() { vec4_t r = { z, w, w, x }; return r; }
        inline vec4_t zwwy() { vec4_t r = { z, w, w, y }; return r; }
        inline vec4_t zwwz() { vec4_t r = { z, w, w, z }; return r; }
        inline vec4_t zwww() { vec4_t r = { z, w, w, w }; return r; }
        inline vec4_t wxxx() { vec4_t r = { w, x, x, x }; return r; }
        inline vec4_t wxxy() { vec4_t r = { w, x, x, y }; return r; }
        inline vec4_t wxxz() { vec4_t r = { w, x, x, z }; return r; }
        inline vec4_t wxxw() { vec4_t r = { w, x, x, w }; return r; }
        inline vec4_t wxyx() { vec4_t r = { w, x, y, x }; return r; }
        inline vec4_t wxyy() { vec4_t r = { w, x, y, y }; return r; }
        inline vec4_t wxyz() { vec4_t r = { w, x, y, z }; return r; }
        inline vec4_t wxyw() { vec4_t r = { w, x, y, w }; return r; }
        inline vec4_t wxzx() { vec4_t r = { w, x, z, x }; return r; }
        inline vec4_t wxzy() { vec4_t r = { w, x, z, y }; return r; }
        inline vec4_t wxzz() { vec4_t r = { w, x, z, z }; return r; }
        inline vec4_t wxzw() { vec4_t r = { w, x, z, w }; return r; }
        inline vec4_t wxwx() { vec4_t r = { w, x, w, x }; return r; }
        inline vec4_t wxwy() { vec4_t r = { w, x, w, y }; return r; }
        inline vec4_t wxwz() { vec4_t r = { w, x, w, z }; return r; }
        inline vec4_t wxww() { vec4_t r = { w, x, w, w }; return r; }
        inline vec4_t wyxx() { vec4_t r = { w, y, x, x }; return r; }
        inline vec4_t wyxy() { vec4_t r = { w, y, x, y }; return r; }
        inline vec4_t wyxz() { vec4_t r = { w, y, x, z }; return r; }
        inline vec4_t wyxw() { vec4_t r = { w, y, x, w }; return r; }
        inline vec4_t wyyx() { vec4_t r = { w, y, y, x }; return r; }
        inline vec4_t wyyy() { vec4_t r = { w, y, y, y }; return r; }
        inline vec4_t wyyz() { vec4_t r = { w, y, y, z }; return r; }
        inline vec4_t wyyw() { vec4_t r = { w, y, y, w }; return r; }
        inline vec4_t wyzx() { vec4_t r = { w, y, z, x }; return r; }
        inline vec4_t wyzy() { vec4_t r = { w, y, z, y }; return r; }
        inline vec4_t wyzz() { vec4_t r = { w, y, z, z }; return r; }
        inline vec4_t wyzw() { vec4_t r = { w, y, z, w }; return r; }
        inline vec4_t wywx() { vec4_t r = { w, y, w, x }; return r; }
        inline vec4_t wywy() { vec4_t r = { w, y, w, y }; return r; }
        inline vec4_t wywz() { vec4_t r = { w, y, w, z }; return r; }
        inline vec4_t wyww() { vec4_t r = { w, y, w, w }; return r; }
        inline vec4_t wzxx() { vec4_t r = { w, z, x, x }; return r; }
        inline vec4_t wzxy() { vec4_t r = { w, z, x, y }; return r; }
        inline vec4_t wzxz() { vec4_t r = { w, z, x, z }; return r; }
        inline vec4_t wzxw() { vec4_t r = { w, z, x, w }; return r; }
        inline vec4_t wzyx() { vec4_t r = { w, z, y, x }; return r; }
        inline vec4_t wzyy() { vec4_t r = { w, z, y, y }; return r; }
        inline vec4_t wzyz() { vec4_t r = { w, z, y, z }; return r; }
        inline vec4_t wzyw() { vec4_t r = { w, z, y, w }; return r; }
        inline vec4_t wzzx() { vec4_t r = { w, z, z, x }; return r; }
        inline vec4_t wzzy() { vec4_t r = { w, z, z, y }; return r; }
        inline vec4_t wzzz() { vec4_t r = { w, z, z, z }; return r; }
        inline vec4_t wzzw() { vec4_t r = { w, z, z, w }; return r; }
        inline vec4_t wzwx() { vec4_t r = { w, z, w, x }; return r; }
        inline vec4_t wzwy() { vec4_t r = { w, z, w, y }; return r; }
        inline vec4_t wzwz() { vec4_t r = { w, z, w, z }; return r; }
        inline vec4_t wzww() { vec4_t r = { w, z, w, w }; return r; }
        inline vec4_t wwxx() { vec4_t r = { w, w, x, x }; return r; }
        inline vec4_t wwxy() { vec4_t r = { w, w, x, y }; return r; }
        inline vec4_t wwxz() { vec4_t r = { w, w, x, z }; return r; }
        inline vec4_t wwxw() { vec4_t r = { w, w, x, w }; return r; }
        inline vec4_t wwyx() { vec4_t r = { w, w, y, x }; return r; }
        inline vec4_t wwyy() { vec4_t r = { w, w, y, y }; return r; }
        inline vec4_t wwyz() { vec4_t r = { w, w, y, z }; return r; }
        inline vec4_t wwyw() { vec4_t r = { w, w, y, w }; return r; }
        inline vec4_t wwzx() { vec4_t r = { w, w, z, x }; return r; }
        inline vec4_t wwzy() { vec4_t r = { w, w, z, y }; return r; }
        inline vec4_t wwzz() { vec4_t r = { w, w, z, z }; return r; }
        inline vec4_t wwzw() { vec4_t r = { w, w, z, w }; return r; }
        inline vec4_t wwwx() { vec4_t r = { w, w, w, x }; return r; }
        inline vec4_t wwwy() { vec4_t r = { w, w, w, y }; return r; }
        inline vec4_t wwwz() { vec4_t r = { w, w, w, z }; return r; }
        inline vec4_t wwww() { vec4_t r = { w, w, w, w }; return r; }
    };
#else
    VECMATH_INLINE vec4_t vec4( float x, float y, float z, float w ) { vec4_t vec; vec.x = x; vec.y = y; vec.z = z; vec.w = w; return vec; }
#endif
VECMATH_INLINE vec4_t vec4f( float v ) { vec4_t vec; vec.x = v; vec.y = v; vec.z = v; vec.w = v; return vec; }
VECMATH_INLINE vec4_t vec4v3f( vec3_t v, float f ) { vec4_t vec; vec.x = v.x; vec.y = v.y; vec.z = v.z; vec.w = f; return vec; }
VECMATH_INLINE vec4_t vec4fv3( float f, vec3_t v ) { vec4_t vec; vec.x = f; vec.y = v.x; vec.z = v.y; vec.w = v.z; return vec; }
VECMATH_INLINE vec4_t vec4v2( vec2_t a, vec2_t b ) { vec4_t vec; vec.x = a.x; vec.y = a.y; vec.z = b.x; vec.w = b.y; return vec; }
    
VECMATH_INLINE float vec4_get( vec4_t vec, int index ) { return ( (float*) &vec )[ index ]; }
VECMATH_INLINE void vec4_set( vec4_t* vec, int index, float f ) { ( (float*) vec )[ index ] = f; }

// operators
VECMATH_INLINE vec4_t vec4_neg( vec4_t v ) { return vec4( -v.x, -v.y, -v.z, -v.w ); }
VECMATH_INLINE int vec4_eq( vec4_t a, vec4_t b ) { return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w; }
VECMATH_INLINE vec4_t vec4_add( vec4_t a, vec4_t b ) { return vec4( a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w ); }
VECMATH_INLINE vec4_t vec4_sub( vec4_t a, vec4_t b ) { return vec4( a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w ); }
VECMATH_INLINE vec4_t vec4_mul( vec4_t a, vec4_t b ) { return vec4( a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w ); }
VECMATH_INLINE vec4_t vec4_div( vec4_t a, vec4_t b ) { return vec4( a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w ); }
VECMATH_INLINE vec4_t vec4_addf( vec4_t a, float s ) { return vec4( a.x + s, a.y + s, a.z + s, a.w + s ); }
VECMATH_INLINE vec4_t vec4_subf( vec4_t a, float s ) { return vec4( a.x - s, a.y - s, a.z - s, a.w - s ); }
VECMATH_INLINE vec4_t vec4_mulf( vec4_t a, float s ) { return vec4( a.x * s, a.y * s, a.z * s, a.w * s ); }
VECMATH_INLINE vec4_t vec4_divf( vec4_t a, float s ) { return vec4( a.x / s, a.y / s, a.z / s, a.w / s ); }
VECMATH_INLINE vec4_t vec4_fadd( float s, vec4_t a ) { return vec4_addf( a, s ); }
VECMATH_INLINE vec4_t vec4_fsub( float s, vec4_t a ) { return vec4_sub( vec4f( s ), a ); }
VECMATH_INLINE vec4_t vec4_fmul( float s, vec4_t a ) { return vec4_mulf( a, s ); }
VECMATH_INLINE vec4_t vec4_fdiv( float s, vec4_t a ) { return vec4_div( vec4f( s ), a ); }

// functions
VECMATH_INLINE vec4_t vec4_abs( vec4_t v ) { return vec4( vecmath_abs( v.x ), vecmath_abs( v.y ), vecmath_abs( v.z ), vecmath_abs( v.w ) ); }
VECMATH_INLINE vec4_t vec4_acos( vec4_t v ) { return vec4( vecmath_acos( v.x ), vecmath_acos( v.y ), vecmath_acos( v.z ), vecmath_acos( v.w ) ); }
VECMATH_INLINE int vec4_all( vec4_t v ) { return v.x != 0.0f && v.y != 0.0f && v.z != 0.0f && v.w != 0.0f; }
VECMATH_INLINE int vec4_any( vec4_t v ) { return v.x != 0.0f || v.y != 0.0f || v.z != 0.0f || v.w != 0.0f; }
VECMATH_INLINE vec4_t vec4_asin( vec4_t v ) { return vec4( vecmath_asin( v.x ), vecmath_asin( v.y ), vecmath_asin( v.z ), vecmath_asin( v.w ) ); }
VECMATH_INLINE vec4_t vec4_atan( vec4_t v ) { return vec4( vecmath_atan( v.x ), vecmath_atan( v.y ), vecmath_atan( v.z ), vecmath_atan( v.w ) ); }
VECMATH_INLINE vec4_t vec4_atan2( vec4_t y, vec4_t x ) { return vec4( vecmath_atan2( y.x, x.x ), vecmath_atan2( y.y, x.y ), vecmath_atan2( y.z, x.z ), vecmath_atan2( y.w, x.w ) ); }
VECMATH_INLINE vec4_t vec4_ceil( vec4_t v ) { return vec4( vecmath_ceil( v.x ), vecmath_ceil( v.y ), vecmath_ceil( v.z ), vecmath_ceil( v.w ) ); }
VECMATH_INLINE vec4_t vec4_clamp( vec4_t v, vec4_t min_v, vec4_t max_v ) { return vec4( vecmath_clamp( v.x, min_v.x, max_v.x ), vecmath_clamp( v.y, min_v.y, max_v.y ), vecmath_clamp( v.z, min_v.z, max_v.z ), vecmath_clamp( v.w, min_v.w, max_v.w ) ); }
VECMATH_INLINE vec4_t vec4_cos( vec4_t v ) { return vec4( vecmath_cos( v.x ), vecmath_cos( v.y ), vecmath_cos( v.z ), vecmath_cos( v.w ) ); }
VECMATH_INLINE vec4_t vec4_cosh( vec4_t v ) { return vec4( vecmath_cosh( v.x ), vecmath_cosh( v.y ), vecmath_cosh( v.z ), vecmath_cosh( v.w ) ); }
VECMATH_INLINE vec4_t vec4_degrees( vec4_t v ) { return vec4( vecmath_degrees( v.x ), vecmath_degrees( v.y ), vecmath_degrees( v.z ), vecmath_degrees( v.w ) ); } 
VECMATH_INLINE float vec4_distancesq( vec4_t a, vec4_t b ) { float x = b.x - a.x; float y = b.y - a.y; float z = b.z - a.z; float w = b.w - a.w; return x * x + y * y + z * z + w * w; }
VECMATH_INLINE float vec4_distance( vec4_t a, vec4_t b ) { float x = b.x - a.x; float y = b.y - a.y; float z = b.z - a.z; float w = b.w - a.w; return vecmath_sqrt( x * x + y * y + z * z + w * w ); }
VECMATH_INLINE float vec4_dot( vec4_t a, vec4_t b ) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }
VECMATH_INLINE vec4_t vec4_exp( vec4_t v ) { return vec4( vecmath_exp( v.x ), vecmath_exp( v.y ), vecmath_exp( v.z ), vecmath_exp( v.w ) ); }
VECMATH_INLINE vec4_t vec4_exp2( vec4_t v ) { return vec4( vecmath_exp2( v.x ), vecmath_exp2( v.y ), vecmath_exp2( v.z ), vecmath_exp2( v.w ) ); }
VECMATH_INLINE vec4_t vec4_floor( vec4_t v ) { return vec4( vecmath_floor( v.x ), vecmath_floor( v.y ), vecmath_floor( v.z ), vecmath_floor( v.w ) ); }
VECMATH_INLINE vec4_t vec4_fmod( vec4_t a, vec4_t b ) { return vec4( vecmath_fmod( a.x, b.x ), vecmath_fmod( a.y, b.y ), vecmath_fmod( a.z, b.z ), vecmath_fmod( a.w, b.w ) ); }
VECMATH_INLINE vec4_t vec4_frac( vec4_t v ) { return vec4( vecmath_frac( v.x ), vecmath_frac( v.y ), vecmath_frac( v.z ), vecmath_frac( v.w ) ); }
VECMATH_INLINE float vec4_lengthsq( vec4_t v ) { return v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w; }
VECMATH_INLINE float vec4_length( vec4_t v ) { return vecmath_sqrt( v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w ); }
VECMATH_INLINE vec4_t vec4_lerp( vec4_t a, vec4_t b, float s ) { return vec4( vecmath_lerp( a.x, b.x, s ), vecmath_lerp( a.y, b.y, s ), vecmath_lerp( a.z, b.z, s ), vecmath_lerp( a.w, b.w, s ) ); }
VECMATH_INLINE vec4_t vec4_log( vec4_t v ) { return vec4( vecmath_log( v.x ), vecmath_log( v.y ), vecmath_log( v.z ), vecmath_log( v.w ) ); }
VECMATH_INLINE vec4_t vec4_log2( vec4_t v ) { return vec4( vecmath_log2( v.x ), vecmath_log2( v.y ), vecmath_log2( v.z ), vecmath_log2( v.w ) ); }
VECMATH_INLINE vec4_t vec4_log10( vec4_t v ) { return vec4( vecmath_log10( v.x ), vecmath_log10( v.y ), vecmath_log10( v.z ), vecmath_log10( v.w ) ); }
VECMATH_INLINE vec4_t vec4_max( vec4_t a, vec4_t b ) { return vec4( vecmath_max( a.x, b.x ), vecmath_max( a.y, b.y ), vecmath_max( a.z, b.z ), vecmath_max( a.w, b.w ) ); }
VECMATH_INLINE vec4_t vec4_min( vec4_t a, vec4_t b ) { return vec4( vecmath_min( a.x, b.x ), vecmath_min( a.y, b.y ), vecmath_min( a.z, b.z ), vecmath_min( a.w, b.w ) ); }
VECMATH_INLINE vec4_t vec4_normalize( vec4_t v ) { float l = vecmath_sqrt( v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w ); return l == 0.0f ? v : vec4( v.x / l, v.y / l, v.z / l, v.w / l ); }
VECMATH_INLINE vec4_t vec4_pow( vec4_t a, vec4_t b ) { return vec4( vecmath_pow( a.x, b.x ), vecmath_pow( a.y, b.y ), vecmath_pow( a.z, b.z ), vecmath_pow( a.w, b.w ) ); }
VECMATH_INLINE vec4_t vec4_radians( vec4_t v ) { return vec4( vecmath_radians( v.x ), vecmath_radians( v.y ), vecmath_radians( v.z ), vecmath_radians( v.w ) ); } 
VECMATH_INLINE vec4_t vec4_rcp( vec4_t v ) { return vec4( vecmath_rcp( v.x ), vecmath_rcp( v.y ), vecmath_rcp( v.z ), vecmath_rcp( v.w ) ); }
VECMATH_INLINE vec4_t vec4_reflect( vec4_t i, vec4_t n ) { return vec4_sub( i, vec4_mulf( n, 2.0f * vec4_dot( i, n ) ) ); }
VECMATH_INLINE vec4_t vec4_refract( vec4_t i, vec4_t n, float r ) { float d = vec4_dot( n, i ); float k = 1.0f - r * r * ( 1.0f - d * d ); return k < 0.0f ? vec4f( 0.0f ) : vec4_sub( vec4_mulf( i, r ), vec4_mulf( n, r * d + vecmath_sqrt( k ) ) ); }
VECMATH_INLINE vec4_t vec4_round( vec4_t v ) { return vec4( vecmath_round( v.x ), vecmath_round( v.y ), vecmath_round( v.z ), vecmath_round( v.w ) ); }
VECMATH_INLINE vec4_t vec4_rsqrt( vec4_t v ) { return vec4( vecmath_rcp( vecmath_sqrt( v.x ) ), vecmath_rcp( vecmath_sqrt( v.y ) ), vecmath_rcp( vecmath_sqrt( v.z ) ), vecmath_rcp( vecmath_sqrt( v.w ) ) ); }
VECMATH_INLINE vec4_t vec4_saturate( vec4_t v ) { return vec4( vecmath_saturate( v.x ), vecmath_saturate( v.y ), vecmath_saturate( v.z ), vecmath_saturate( v.w ) ); }
VECMATH_INLINE vec4_t vec4_sign( vec4_t v ) { return vec4( vecmath_sign( v.x ), vecmath_sign( v.y ), vecmath_sign( v.z ), vecmath_sign( v.w ) ); }
VECMATH_INLINE vec4_t vec4_sin( vec4_t v ) { return vec4( vecmath_sin( v.x ), vecmath_sin( v.y ), vecmath_sin( v.z ), vecmath_sin( v.w ) ); }
VECMATH_INLINE vec4_t vec4_sinh( vec4_t v ) { return vec4( vecmath_sinh( v.x ), vecmath_sinh( v.y ), vecmath_sinh( v.z ), vecmath_sinh( v.w ) ); }
VECMATH_INLINE vec4_t vec4_smoothstep( vec4_t min_v, vec4_t max_v, vec4_t v ) { return vec4( vecmath_smoothstep( min_v.x, max_v.x, v.x ), vecmath_smoothstep( min_v.y, max_v.y, v.y ), vecmath_smoothstep( min_v.z, max_v.z, v.z ), vecmath_smoothstep( min_v.w, max_v.w, v.w ) ); }
VECMATH_INLINE vec4_t vec4_smootherstep( vec4_t min_v, vec4_t max_v, vec4_t v ) { return vec4( vecmath_smootherstep( min_v.x, max_v.x, v.x ), vecmath_smootherstep( min_v.y, max_v.y, v.y ), vecmath_smootherstep( min_v.z, max_v.z, v.z ), vecmath_smootherstep( min_v.w, max_v.w, v.w ) ); }
VECMATH_INLINE vec4_t vec4_sqrt( vec4_t v ) { return vec4( vecmath_sqrt( v.x ), vecmath_sqrt( v.y ), vecmath_sqrt( v.z ), vecmath_sqrt( v.w ) ); }
VECMATH_INLINE vec4_t vec4_step( vec4_t a, vec4_t b ) { return vec4( vecmath_step( a.x, b.x ), vecmath_step( a.y, b.y ), vecmath_step( a.z, b.z ), vecmath_step( a.w, b.w ) ); }
VECMATH_INLINE vec4_t vec4_tan( vec4_t v ) { return vec4( vecmath_tan( v.x ), vecmath_tan( v.y ), vecmath_tan( v.z ), vecmath_tan( v.w ) ); }
VECMATH_INLINE vec4_t vec4_tanh( vec4_t v ) { return vec4( vecmath_tanh( v.x ), vecmath_tanh( v.y ), vecmath_tanh( v.z ), vecmath_tanh( v.w ) ); }
VECMATH_INLINE vec4_t vec4_trunc( vec4_t v ) { return vec4( vecmath_trunc( v.x ), vecmath_trunc( v.y ), vecmath_trunc( v.z ), vecmath_trunc( v.w ) ); }


// mat22
#ifdef __cplusplus
 struct mat22 : mat22_t {
        inline mat22() {}
        inline mat22( vec2_t x_, vec2_t y_ ) { x = x_; y = y_; }
        inline mat22( mat22_t m ) { x = m.x; y = m.y; }
        inline mat22( float f ) { x = vec2( f ); y = vec2( f ); }
        inline vec2 operator[]( int index ) const { return ( (vec2*) this )[ index ]; }
        inline vec2& operator[]( int index ) { return ( (vec2*) this )[ index ]; }
    };
#else
    VECMATH_INLINE mat22_t mat22( vec2_t x, vec2_t y ) { mat22_t m; m.x = x; m.y = y; return m; }
#endif
VECMATH_INLINE mat22_t mat22f( float v ) { vec2_t t = vec2f( v ); return mat22( t, t ); }

VECMATH_INLINE vec2_t mat22_get( mat22_t m, int row ) { return ( (vec2_t*) &m )[ row ]; }
VECMATH_INLINE void mat22_set( mat22_t* m, int row, vec2_t v ) { ( (vec2_t*) m )[ row ] = v; }

// operators
VECMATH_INLINE mat22_t mat22_neg( mat22_t m ) { return mat22( vec2_neg( m.x ), vec2_neg( m.y ) ); }
VECMATH_INLINE int mat22_eq( mat22_t a, mat22_t b ) { return vec2_eq( a.x, b.x ) && vec2_eq( a.y, b.y ); }
VECMATH_INLINE mat22_t mat22_add( mat22_t a, mat22_t b ) { return mat22( vec2_add( a.x, b.x ), vec2_add( a.y, b.y ) ); }
VECMATH_INLINE mat22_t mat22_sub( mat22_t a, mat22_t b ) { return mat22( vec2_sub( a.x, b.x ), vec2_sub( a.y, b.y ) ); }
VECMATH_INLINE mat22_t mat22_mul_elem( mat22_t a, mat22_t b ) { return mat22( vec2_mul( a.x, b.x ), vec2_mul( a.y, b.y ) ); }
VECMATH_INLINE mat22_t mat22_div( mat22_t a, mat22_t b ) { return mat22( vec2_div( a.x, b.x ), vec2_div( a.y, b.y ) ); }
VECMATH_INLINE mat22_t mat22_addf( mat22_t a, float s ) { return mat22( vec2_addf( a.x, s ), vec2_addf( a.y, s ) ); }
VECMATH_INLINE mat22_t mat22_subf( mat22_t a, float s ) { return mat22( vec2_subf( a.x, s ), vec2_subf( a.y, s ) ); }
VECMATH_INLINE mat22_t mat22_mulf( mat22_t a, float s ) { return mat22( vec2_mulf( a.x, s ), vec2_mulf( a.y, s ) ); }
VECMATH_INLINE mat22_t mat22_divf( mat22_t a, float s ) { return mat22( vec2_divf( a.x, s ), vec2_divf( a.y, s ) ); }
VECMATH_INLINE mat22_t mat22_fadd( float s, mat22_t a ) { return mat22_addf( a, s ); }
VECMATH_INLINE mat22_t mat22_fsub( float s, mat22_t a ) { return mat22_sub( mat22f( s ), a ); }
VECMATH_INLINE mat22_t mat22_fmul( float s, mat22_t a ) { return mat22_mulf( a, s ); }
VECMATH_INLINE mat22_t mat22_fdiv( float s, mat22_t a ) { return mat22_div( mat22f( s ), a ); }

// functions
VECMATH_INLINE mat22_t mat22_abs( mat22_t m ) { return mat22( vec2_abs( m.x ), vec2_abs( m.y ) ); }
VECMATH_INLINE mat22_t mat22_acos( mat22_t m ) { return mat22( vec2_acos( m.x ), vec2_acos( m.y ) ); }
VECMATH_INLINE int mat22_all( mat22_t m ) { return vec2_all( m.x ) && vec2_all( m.y ); }
VECMATH_INLINE int mat22_any( mat22_t m ) { return vec2_any( m.x ) || vec2_any( m.y ); }
VECMATH_INLINE mat22_t mat22_asin( mat22_t m ) { return mat22( vec2_asin( m.x ), vec2_asin( m.y ) ); }
VECMATH_INLINE mat22_t mat22_atan( mat22_t m ) { return mat22( vec2_atan( m.x ), vec2_atan( m.y ) ); }
VECMATH_INLINE mat22_t mat22_atan2( mat22_t y, mat22_t x ) { return mat22( vec2_atan2( y.x, x.x ), vec2_atan2( y.y, x.y ) ); }
VECMATH_INLINE mat22_t mat22_ceil( mat22_t m ) { return mat22( vec2_ceil( m.x ), vec2_ceil( m.y ) ); }
VECMATH_INLINE mat22_t mat22_clamp( mat22_t m, mat22_t min_v, mat22_t max_v ) { return mat22( vec2_clamp( m.x, min_v.x, max_v.x ), vec2_clamp( m.y, min_v.y, max_v.y ) ); }
VECMATH_INLINE mat22_t mat22_cos( mat22_t m ) { return mat22( vec2_cos( m.x ), vec2_cos( m.y ) ); }
VECMATH_INLINE mat22_t mat22_cosh( mat22_t m ) { return mat22( vec2_cosh( m.x ), vec2_cosh( m.y ) ); }
VECMATH_INLINE mat22_t mat22_degrees( mat22_t m ) { return mat22( vec2_degrees( m.x ), vec2_degrees( m.y ) ); }
VECMATH_INLINE mat22_t mat22_exp( mat22_t m ) { return mat22( vec2_exp( m.x ), vec2_exp( m.y ) ); }
VECMATH_INLINE mat22_t mat22_exp2( mat22_t m ) { return mat22( vec2_exp2( m.x ), vec2_exp2( m.y ) ); }
VECMATH_INLINE mat22_t mat22_floor( mat22_t m ) { return mat22( vec2_floor( m.x ), vec2_floor( m.y ) ); }
VECMATH_INLINE mat22_t mat22_fmod( mat22_t a, mat22_t b ) { return mat22( vec2_fmod( a.x, b.x ), vec2_fmod( a.y, b.y ) ); }
VECMATH_INLINE mat22_t mat22_frac( mat22_t m ) { return mat22( vec2_frac( m.x ), vec2_frac( m.y ) ); }
VECMATH_INLINE mat22_t mat22_lerp( mat22_t a, mat22_t b, float s ) { return mat22( vec2_lerp( a.x, b.x, s ), vec2_lerp( a.y, b.y, s ) ); }
VECMATH_INLINE mat22_t mat22_log( mat22_t m ) { return mat22( vec2_log( m.x ), vec2_log( m.y ) ); }
VECMATH_INLINE mat22_t mat22_log2( mat22_t m ) { return mat22( vec2_log2( m.x ), vec2_log2( m.y ) ); }
VECMATH_INLINE mat22_t mat22_log10( mat22_t m ) { return mat22( vec2_log10( m.x ), vec2_log10( m.y ) ); }
VECMATH_INLINE mat22_t mat22_max( mat22_t a, mat22_t b ) { return mat22( vec2_max( a.x, b.x ), vec2_max( a.y, b.y ) ); }
VECMATH_INLINE mat22_t mat22_min( mat22_t a, mat22_t b ) { return mat22( vec2_min( a.x, b.x ), vec2_min( a.y, b.y ) ); }
VECMATH_INLINE mat22_t mat22_pow( mat22_t a, mat22_t b ) { return mat22( vec2_pow( a.x, b.x ), vec2_pow( a.y, b.y ) ); }
VECMATH_INLINE mat22_t mat22_radians( mat22_t m ) { return mat22( vec2_radians( m.x ), vec2_radians( m.y ) ); }
VECMATH_INLINE mat22_t mat22_rcp( mat22_t m ) { return mat22( vec2_rcp( m.x ), vec2_rcp( m.y ) ); }
VECMATH_INLINE mat22_t mat22_round( mat22_t m ) { return mat22( vec2_round( m.x ), vec2_round( m.y ) ); }
VECMATH_INLINE mat22_t mat22_rsqrt( mat22_t m ) { return mat22( vec2_rsqrt( m.x ), vec2_rsqrt( m.y ) ); }
VECMATH_INLINE mat22_t mat22_saturate( mat22_t m ) { return mat22( vec2_saturate( m.x ), vec2_saturate( m.y ) ); }
VECMATH_INLINE mat22_t mat22_sign( mat22_t m ) { return mat22( vec2_sign( m.x ), vec2_sign( m.y ) ); }
VECMATH_INLINE mat22_t mat22_sin( mat22_t m ) { return mat22( vec2_sin( m.x ), vec2_sin( m.y ) ); }
VECMATH_INLINE mat22_t mat22_sinh( mat22_t m ) { return mat22( vec2_sinh( m.x ), vec2_sinh( m.y ) ); }
VECMATH_INLINE mat22_t mat22_smoothstep( mat22_t min_v, mat22_t max_v, mat22_t m ) { return mat22( vec2_smoothstep( min_v.x, max_v.x, m.x ), vec2_smoothstep( min_v.y, max_v.y, m.y ) ); }
VECMATH_INLINE mat22_t mat22_smootherstep( mat22_t min_v, mat22_t max_v, mat22_t m ) { return mat22( vec2_smootherstep( min_v.x, max_v.x, m.x ), vec2_smootherstep( min_v.y, max_v.y, m.y ) ); }
VECMATH_INLINE mat22_t mat22_sqrt( mat22_t m ) { return mat22( vec2_sqrt( m.x ), vec2_sqrt( m.y ) ); }
VECMATH_INLINE mat22_t mat22_step( mat22_t a, mat22_t b ) { return mat22( vec2_step( a.x, b.x ), vec2_step( a.y, b.y ) ); }
VECMATH_INLINE mat22_t mat22_tan( mat22_t m ) { return mat22( vec2_tan( m.x ), vec2_tan( m.y ) ); }
VECMATH_INLINE mat22_t mat22_tanh( mat22_t m ) { return mat22( vec2_tanh( m.x ), vec2_tanh( m.y ) ); }
VECMATH_INLINE mat22_t mat22_trunc( mat22_t m ) { return mat22( vec2_trunc( m.x ), vec2_trunc( m.y ) ); }


// mat23
#ifdef __cplusplus
    struct mat23 : mat23_t {
        inline mat23() {}
        inline mat23( vec3_t x_, vec3_t y_ ) { x = x_; y = y_; }
        inline mat23( mat23_t m ) { x = m.x; y = m.y; }
        inline mat23( float f ) { x = vec3( f ); y = vec3( f ); }
        inline vec3 operator[]( int index ) const { return ( (vec3*) this )[ index ]; }
        inline vec3& operator[]( int index ) { return ( (vec3*) this )[ index ]; }
    };
#else
    VECMATH_INLINE mat23_t mat23( vec3_t x, vec3_t y ) { mat23_t m; m.x = x; m.y = y; return m; }
#endif
VECMATH_INLINE mat23_t mat23f( float v ) { vec3_t t = vec3f( v ); return mat23( t, t ); }

VECMATH_INLINE vec3_t mat23_get( mat23_t m, int row ) { return ( (vec3_t*) &m )[ row ]; }
VECMATH_INLINE void mat23_set( mat23_t* m, int row, vec3_t v ) { ( (vec3_t*) m )[ row ] = v; }

// operators
VECMATH_INLINE mat23_t mat23_neg( mat23_t m ) { return mat23( vec3_neg( m.x ), vec3_neg( m.y ) ); }
VECMATH_INLINE int mat23_eq( mat23_t a, mat23_t b ) { return vec3_eq( a.x, b.x ) && vec3_eq( a.y, b.y ); }
VECMATH_INLINE mat23_t mat23_add( mat23_t a, mat23_t b ) { return mat23( vec3_add( a.x, b.x ), vec3_add( a.y, b.y ) ); }
VECMATH_INLINE mat23_t mat23_sub( mat23_t a, mat23_t b ) { return mat23( vec3_sub( a.x, b.x ), vec3_sub( a.y, b.y ) ); }
VECMATH_INLINE mat23_t mat23_mul_elem( mat23_t a, mat23_t b ) { return mat23( vec3_mul( a.x, b.x ), vec3_mul( a.y, b.y ) ); }
VECMATH_INLINE mat23_t mat23_div( mat23_t a, mat23_t b ) { return mat23( vec3_div( a.x, b.x ), vec3_div( a.y, b.y ) ); }
VECMATH_INLINE mat23_t mat23_addf( mat23_t a, float s ) { return mat23( vec3_addf( a.x, s ), vec3_addf( a.y, s ) ); }
VECMATH_INLINE mat23_t mat23_subf( mat23_t a, float s ) { return mat23( vec3_subf( a.x, s ), vec3_subf( a.y, s ) ); }
VECMATH_INLINE mat23_t mat23_mulf( mat23_t a, float s ) { return mat23( vec3_mulf( a.x, s ), vec3_mulf( a.y, s ) ); }
VECMATH_INLINE mat23_t mat23_divf( mat23_t a, float s ) { return mat23( vec3_divf( a.x, s ), vec3_divf( a.y, s ) ); }
VECMATH_INLINE mat23_t mat23_fadd( float s, mat23_t a ) { return mat23_addf( a, s ); }
VECMATH_INLINE mat23_t mat23_fsub( float s, mat23_t a ) { return mat23_sub( mat23f( s ), a ); }
VECMATH_INLINE mat23_t mat23_fmul( float s, mat23_t a ) { return mat23_mulf( a, s ); }
VECMATH_INLINE mat23_t mat23_fdiv( float s, mat23_t a ) { return mat23_div( mat23f( s ), a ); }

// functions
VECMATH_INLINE mat23_t mat23_abs( mat23_t m ) { return mat23( vec3_abs( m.x ), vec3_abs( m.y ) ); }
VECMATH_INLINE mat23_t mat23_acos( mat23_t m ) { return mat23( vec3_acos( m.x ), vec3_acos( m.y ) ); }
VECMATH_INLINE int mat23_all( mat23_t m ) { return vec3_all( m.x ) && vec3_all( m.y ); }
VECMATH_INLINE int mat23_any( mat23_t m ) { return vec3_any( m.x ) || vec3_any( m.y ); }
VECMATH_INLINE mat23_t mat23_asin( mat23_t m ) { return mat23( vec3_asin( m.x ), vec3_asin( m.y ) ); }
VECMATH_INLINE mat23_t mat23_atan( mat23_t m ) { return mat23( vec3_atan( m.x ), vec3_atan( m.y ) ); }
VECMATH_INLINE mat23_t mat23_atan2( mat23_t y, mat23_t x ) { return mat23( vec3_atan2( y.x, x.x ), vec3_atan2( y.y, x.y ) ); }
VECMATH_INLINE mat23_t mat23_ceil( mat23_t m ) { return mat23( vec3_ceil( m.x ), vec3_ceil( m.y ) ); }
VECMATH_INLINE mat23_t mat23_clamp( mat23_t m, mat23_t min_v, mat23_t max_v ) { return mat23( vec3_clamp( m.x, min_v.x, max_v.x ), vec3_clamp( m.y, min_v.y, max_v.y ) ); }
VECMATH_INLINE mat23_t mat23_cos( mat23_t m ) { return mat23( vec3_cos( m.x ), vec3_cos( m.y ) ); }
VECMATH_INLINE mat23_t mat23_cosh( mat23_t m ) { return mat23( vec3_cosh( m.x ), vec3_cosh( m.y ) ); }
VECMATH_INLINE mat23_t mat23_degrees( mat23_t m ) { return mat23( vec3_degrees( m.x ), vec3_degrees( m.y ) ); }
VECMATH_INLINE mat23_t mat23_exp( mat23_t m ) { return mat23( vec3_exp( m.x ), vec3_exp( m.y ) ); }
VECMATH_INLINE mat23_t mat23_exp2( mat23_t m ) { return mat23( vec3_exp2( m.x ), vec3_exp2( m.y ) ); }
VECMATH_INLINE mat23_t mat23_floor( mat23_t m ) { return mat23( vec3_floor( m.x ), vec3_floor( m.y ) ); }
VECMATH_INLINE mat23_t mat23_fmod( mat23_t a, mat23_t b ) { return mat23( vec3_fmod( a.x, b.x ), vec3_fmod( a.y, b.y ) ); }
VECMATH_INLINE mat23_t mat23_frac( mat23_t m ) { return mat23( vec3_frac( m.x ), vec3_frac( m.y ) ); }
VECMATH_INLINE mat23_t mat23_lerp( mat23_t a, mat23_t b, float s ) { return mat23( vec3_lerp( a.x, b.x, s ), vec3_lerp( a.y, b.y, s ) ); }
VECMATH_INLINE mat23_t mat23_log( mat23_t m ) { return mat23( vec3_log( m.x ), vec3_log( m.y ) ); }
VECMATH_INLINE mat23_t mat23_log2( mat23_t m ) { return mat23( vec3_log2( m.x ), vec3_log2( m.y ) ); }
VECMATH_INLINE mat23_t mat23_log10( mat23_t m ) { return mat23( vec3_log10( m.x ), vec3_log10( m.y ) ); }
VECMATH_INLINE mat23_t mat23_max( mat23_t a, mat23_t b ) { return mat23( vec3_max( a.x, b.x ), vec3_max( a.y, b.y ) ); }
VECMATH_INLINE mat23_t mat23_min( mat23_t a, mat23_t b ) { return mat23( vec3_min( a.x, b.x ), vec3_min( a.y, b.y ) ); }
VECMATH_INLINE mat23_t mat23_pow( mat23_t a, mat23_t b ) { return mat23( vec3_pow( a.x, b.x ), vec3_pow( a.y, b.y ) ); }
VECMATH_INLINE mat23_t mat23_radians( mat23_t m ) { return mat23( vec3_radians( m.x ), vec3_radians( m.y ) ); }
VECMATH_INLINE mat23_t mat23_rcp( mat23_t m ) { return mat23( vec3_rcp( m.x ), vec3_rcp( m.y ) ); }
VECMATH_INLINE mat23_t mat23_round( mat23_t m ) { return mat23( vec3_round( m.x ), vec3_round( m.y ) ); }
VECMATH_INLINE mat23_t mat23_rsqrt( mat23_t m ) { return mat23( vec3_rsqrt( m.x ), vec3_rsqrt( m.y ) ); }
VECMATH_INLINE mat23_t mat23_saturate( mat23_t m ) { return mat23( vec3_saturate( m.x ), vec3_saturate( m.y ) ); }
VECMATH_INLINE mat23_t mat23_sign( mat23_t m ) { return mat23( vec3_sign( m.x ), vec3_sign( m.y ) ); }
VECMATH_INLINE mat23_t mat23_sin( mat23_t m ) { return mat23( vec3_sin( m.x ), vec3_sin( m.y ) ); }
VECMATH_INLINE mat23_t mat23_sinh( mat23_t m ) { return mat23( vec3_sinh( m.x ), vec3_sinh( m.y ) ); }
VECMATH_INLINE mat23_t mat23_smoothstep( mat23_t min_v, mat23_t max_v, mat23_t m ) { return mat23( vec3_smoothstep( min_v.x, max_v.x, m.x ), vec3_smoothstep( min_v.y, max_v.y, m.y ) ); }
VECMATH_INLINE mat23_t mat23_smootherstep( mat23_t min_v, mat23_t max_v, mat23_t m ) { return mat23( vec3_smootherstep( min_v.x, max_v.x, m.x ), vec3_smootherstep( min_v.y, max_v.y, m.y ) ); }
VECMATH_INLINE mat23_t mat23_sqrt( mat23_t m ) { return mat23( vec3_sqrt( m.x ), vec3_sqrt( m.y ) ); }
VECMATH_INLINE mat23_t mat23_step( mat23_t a, mat23_t b ) { return mat23( vec3_step( a.x, b.x ), vec3_step( a.y, b.y ) ); }
VECMATH_INLINE mat23_t mat23_tan( mat23_t m ) { return mat23( vec3_tan( m.x ), vec3_tan( m.y ) ); }
VECMATH_INLINE mat23_t mat23_tanh( mat23_t m ) { return mat23( vec3_tanh( m.x ), vec3_tanh( m.y ) ); }
VECMATH_INLINE mat23_t mat23_trunc( mat23_t m ) { return mat23( vec3_trunc( m.x ), vec3_trunc( m.y ) ); }


// mat24
#ifdef __cplusplus
    struct mat24 : mat24_t {
        inline mat24() {}
        inline mat24( vec4_t x_, vec4_t y_ ) { x = x_; y = y_; }
        inline mat24( mat24_t m ) { x = m.x; y = m.y; }
        inline mat24( float f ) { x = vec4( f ); y = vec4( f );  }
        inline vec4 operator[]( int index ) const { return ( (vec4*) this )[ index ]; }
        inline vec4& operator[]( int index ) { return ( (vec4*) this )[ index ]; }
    };
#else
    VECMATH_INLINE mat24_t mat24( vec4_t x, vec4_t y ) { mat24_t m; m.x = x; m.y = y; return m; }
#endif
VECMATH_INLINE mat24_t mat24f( float v ) { vec4_t t = vec4f( v ); return mat24( t, t ); }

VECMATH_INLINE vec4_t mat24_get( mat24_t m, int row ) { return ( (vec4_t*) &m )[ row ]; }
VECMATH_INLINE void mat24_set( mat24_t* m, int row, vec4_t v ) { ( (vec4_t*) m )[ row ] = v; }

// operators
VECMATH_INLINE mat24_t mat24_neg( mat24_t m ) { return mat24( vec4_neg( m.x ), vec4_neg( m.y ) ); }
VECMATH_INLINE int mat24_eq( mat24_t a, mat24_t b ) { return vec4_eq( a.x, b.x ) && vec4_eq( a.y, b.y ); }
VECMATH_INLINE mat24_t mat24_add( mat24_t a, mat24_t b ) { return mat24( vec4_add( a.x, b.x ), vec4_add( a.y, b.y ) ); }
VECMATH_INLINE mat24_t mat24_sub( mat24_t a, mat24_t b ) { return mat24( vec4_sub( a.x, b.x ), vec4_sub( a.y, b.y ) ); }
VECMATH_INLINE mat24_t mat24_mul_elem( mat24_t a, mat24_t b ) { return mat24( vec4_mul( a.x, b.x ), vec4_mul( a.y, b.y ) ); }
VECMATH_INLINE mat24_t mat24_div( mat24_t a, mat24_t b ) { return mat24( vec4_div( a.x, b.x ), vec4_div( a.y, b.y ) ); }
VECMATH_INLINE mat24_t mat24_addf( mat24_t a, float s ) { return mat24( vec4_addf( a.x, s ), vec4_addf( a.y, s ) ); }
VECMATH_INLINE mat24_t mat24_subf( mat24_t a, float s ) { return mat24( vec4_subf( a.x, s ), vec4_subf( a.y, s ) ); }
VECMATH_INLINE mat24_t mat24_mulf( mat24_t a, float s ) { return mat24( vec4_mulf( a.x, s ), vec4_mulf( a.y, s ) ); }
VECMATH_INLINE mat24_t mat24_divf( mat24_t a, float s ) { return mat24( vec4_divf( a.x, s ), vec4_divf( a.y, s ) ); }
VECMATH_INLINE mat24_t mat24_fadd( float s, mat24_t a ) { return mat24_addf( a, s ); }
VECMATH_INLINE mat24_t mat24_fsub( float s, mat24_t a ) { return mat24_sub( mat24f( s ), a ); }
VECMATH_INLINE mat24_t mat24_fmul( float s, mat24_t a ) { return mat24_mulf( a, s ); }
VECMATH_INLINE mat24_t mat24_fdiv( float s, mat24_t a ) { return mat24_div( mat24f( s ), a ); }

// functions
VECMATH_INLINE mat24_t mat24_abs( mat24_t m ) { return mat24( vec4_abs( m.x ), vec4_abs( m.y ) ); }
VECMATH_INLINE mat24_t mat24_acos( mat24_t m ) { return mat24( vec4_acos( m.x ), vec4_acos( m.y ) ); }
VECMATH_INLINE int mat24_all( mat24_t m ) { return vec4_all( m.x ) && vec4_all( m.y ); }
VECMATH_INLINE int mat24_any( mat24_t m ) { return vec4_any( m.x ) || vec4_any( m.y ); }
VECMATH_INLINE mat24_t mat24_asin( mat24_t m ) { return mat24( vec4_asin( m.x ), vec4_asin( m.y ) ); }
VECMATH_INLINE mat24_t mat24_atan( mat24_t m ) { return mat24( vec4_atan( m.x ), vec4_atan( m.y ) ); }
VECMATH_INLINE mat24_t mat24_atan2( mat24_t y, mat24_t x ) { return mat24( vec4_atan2( y.x, x.x ), vec4_atan2( y.y, x.y ) ); }
VECMATH_INLINE mat24_t mat24_ceil( mat24_t m ) { return mat24( vec4_ceil( m.x ), vec4_ceil( m.y ) ); }
VECMATH_INLINE mat24_t mat24_clamp( mat24_t m, mat24_t min_v, mat24_t max_v ) { return mat24( vec4_clamp( m.x, min_v.x, max_v.x ), vec4_clamp( m.y, min_v.y, max_v.y ) ); }
VECMATH_INLINE mat24_t mat24_cos( mat24_t m ) { return mat24( vec4_cos( m.x ), vec4_cos( m.y ) ); }
VECMATH_INLINE mat24_t mat24_cosh( mat24_t m ) { return mat24( vec4_cosh( m.x ), vec4_cosh( m.y ) ); }
VECMATH_INLINE mat24_t mat24_degrees( mat24_t m ) { return mat24( vec4_degrees( m.x ), vec4_degrees( m.y ) ); }
VECMATH_INLINE mat24_t mat24_exp( mat24_t m ) { return mat24( vec4_exp( m.x ), vec4_exp( m.y ) ); }
VECMATH_INLINE mat24_t mat24_exp2( mat24_t m ) { return mat24( vec4_exp2( m.x ), vec4_exp2( m.y ) ); }
VECMATH_INLINE mat24_t mat24_floor( mat24_t m ) { return mat24( vec4_floor( m.x ), vec4_floor( m.y ) ); }
VECMATH_INLINE mat24_t mat24_fmod( mat24_t a, mat24_t b ) { return mat24( vec4_fmod( a.x, b.x ), vec4_fmod( a.y, b.y ) ); }
VECMATH_INLINE mat24_t mat24_frac( mat24_t m ) { return mat24( vec4_frac( m.x ), vec4_frac( m.y ) ); }
VECMATH_INLINE mat24_t mat24_lerp( mat24_t a, mat24_t b, float s ) { return mat24( vec4_lerp( a.x, b.x, s ), vec4_lerp( a.y, b.y, s ) ); }
VECMATH_INLINE mat24_t mat24_log( mat24_t m ) { return mat24( vec4_log( m.x ), vec4_log( m.y ) ); }
VECMATH_INLINE mat24_t mat24_log2( mat24_t m ) { return mat24( vec4_log2( m.x ), vec4_log2( m.y ) ); }
VECMATH_INLINE mat24_t mat24_log10( mat24_t m ) { return mat24( vec4_log10( m.x ), vec4_log10( m.y ) ); }
VECMATH_INLINE mat24_t mat24_max( mat24_t a, mat24_t b ) { return mat24( vec4_max( a.x, b.x ), vec4_max( a.y, b.y ) ); }
VECMATH_INLINE mat24_t mat24_min( mat24_t a, mat24_t b ) { return mat24( vec4_min( a.x, b.x ), vec4_min( a.y, b.y ) ); }
VECMATH_INLINE mat24_t mat24_pow( mat24_t a, mat24_t b ) { return mat24( vec4_pow( a.x, b.x ), vec4_pow( a.y, b.y ) ); }
VECMATH_INLINE mat24_t mat24_radians( mat24_t m ) { return mat24( vec4_radians( m.x ), vec4_radians( m.y ) ); }
VECMATH_INLINE mat24_t mat24_rcp( mat24_t m ) { return mat24( vec4_rcp( m.x ), vec4_rcp( m.y ) ); }
VECMATH_INLINE mat24_t mat24_round( mat24_t m ) { return mat24( vec4_round( m.x ), vec4_round( m.y ) ); }
VECMATH_INLINE mat24_t mat24_rsqrt( mat24_t m ) { return mat24( vec4_rsqrt( m.x ), vec4_rsqrt( m.y ) ); }
VECMATH_INLINE mat24_t mat24_saturate( mat24_t m ) { return mat24( vec4_saturate( m.x ), vec4_saturate( m.y ) ); }
VECMATH_INLINE mat24_t mat24_sign( mat24_t m ) { return mat24( vec4_sign( m.x ), vec4_sign( m.y ) ); }
VECMATH_INLINE mat24_t mat24_sin( mat24_t m ) { return mat24( vec4_sin( m.x ), vec4_sin( m.y ) ); }
VECMATH_INLINE mat24_t mat24_sinh( mat24_t m ) { return mat24( vec4_sinh( m.x ), vec4_sinh( m.y ) ); }
VECMATH_INLINE mat24_t mat24_smoothstep( mat24_t min_v, mat24_t max_v, mat24_t m ) { return mat24( vec4_smoothstep( min_v.x, max_v.x, m.x ), vec4_smoothstep( min_v.y, max_v.y, m.y ) ); }
VECMATH_INLINE mat24_t mat24_smootherstep( mat24_t min_v, mat24_t max_v, mat24_t m ) { return mat24( vec4_smootherstep( min_v.x, max_v.x, m.x ), vec4_smootherstep( min_v.y, max_v.y, m.y ) ); }
VECMATH_INLINE mat24_t mat24_sqrt( mat24_t m ) { return mat24( vec4_sqrt( m.x ), vec4_sqrt( m.y ) ); }
VECMATH_INLINE mat24_t mat24_step( mat24_t a, mat24_t b ) { return mat24( vec4_step( a.x, b.x ), vec4_step( a.y, b.y ) ); }
VECMATH_INLINE mat24_t mat24_tan( mat24_t m ) { return mat24( vec4_tan( m.x ), vec4_tan( m.y ) ); }
VECMATH_INLINE mat24_t mat24_tanh( mat24_t m ) { return mat24( vec4_tanh( m.x ), vec4_tanh( m.y ) ); }
VECMATH_INLINE mat24_t mat24_trunc( mat24_t m ) { return mat24( vec4_trunc( m.x ), vec4_trunc( m.y ) ); }


// mat32
#ifdef __cplusplus
    struct mat32 : mat32_t {
        inline mat32() {}
        inline mat32( vec2_t x_, vec2_t y_, vec2_t z_ ) { x = x_; y = y_; z = z_; }
        inline mat32( mat32_t m ) { x = m.x; y = m.y; z = m.z; }
        inline mat32( float f ) { x = vec2( f ); y = vec2( f ); z = vec2( f ); }
        inline vec2 operator[]( int index ) const { return ( (vec2*) this )[ index ]; }
        inline vec2& operator[]( int index ) { return ( (vec2*) this )[ index ]; }
    };
#else
    VECMATH_INLINE mat32_t mat32( vec2_t x, vec2_t y, vec2_t z ) { mat32_t m; m.x = x; m.y = y; m.z = z; return m; }
#endif
VECMATH_INLINE mat32_t mat32f( float v ) { vec2_t t = vec2f( v ); return mat32( t, t, t ); }

VECMATH_INLINE vec2_t mat32_get( mat32_t m, int row ) { return ( (vec2_t*) &m )[ row ]; }
VECMATH_INLINE void mat32_set( mat32_t* m, int row, vec2_t v ) { ( (vec2_t*) m )[ row ] = v; }

// operators
VECMATH_INLINE mat32_t mat32_neg( mat32_t m ) { return mat32( vec2_neg( m.x ), vec2_neg( m.y ), vec2_neg( m.z ) ); }
VECMATH_INLINE int mat32_eq( mat32_t a, mat32_t b ) { return vec2_eq( a.x, b.x ) && vec2_eq( a.y, b.y ) && vec2_eq( a.z, b.z ); }
VECMATH_INLINE mat32_t mat32_add( mat32_t a, mat32_t b ) { return mat32( vec2_add( a.x, b.x ), vec2_add( a.y, b.y ), vec2_add( a.z, b.z ) ); }
VECMATH_INLINE mat32_t mat32_sub( mat32_t a, mat32_t b ) { return mat32( vec2_sub( a.x, b.x ), vec2_sub( a.y, b.y ), vec2_sub( a.z, b.z ) ); }
VECMATH_INLINE mat32_t mat32_mul_elem( mat32_t a, mat32_t b ) { return mat32( vec2_mul( a.x, b.x ), vec2_mul( a.y, b.y ), vec2_mul( a.z, b.z ) ); }
VECMATH_INLINE mat32_t mat32_div( mat32_t a, mat32_t b ) { return mat32( vec2_div( a.x, b.x ), vec2_div( a.y, b.y ), vec2_div( a.z, b.z ) ); }
VECMATH_INLINE mat32_t mat32_addf( mat32_t a, float s ) { return mat32( vec2_addf( a.x, s ), vec2_addf( a.y, s ), vec2_addf( a.z, s ) ); }
VECMATH_INLINE mat32_t mat32_subf( mat32_t a, float s ) { return mat32( vec2_subf( a.x, s ), vec2_subf( a.y, s ), vec2_subf( a.z, s ) ); }
VECMATH_INLINE mat32_t mat32_mulf( mat32_t a, float s ) { return mat32( vec2_mulf( a.x, s ), vec2_mulf( a.y, s ), vec2_mulf( a.z, s ) ); }
VECMATH_INLINE mat32_t mat32_divf( mat32_t a, float s ) { return mat32( vec2_divf( a.x, s ), vec2_divf( a.y, s ), vec2_divf( a.z, s ) ); }
VECMATH_INLINE mat32_t mat32_fadd( float s, mat32_t a ) { return mat32_addf( a, s ); }
VECMATH_INLINE mat32_t mat32_fsub( float s, mat32_t a ) { return mat32_sub( mat32f( s ), a ); }
VECMATH_INLINE mat32_t mat32_fmul( float s, mat32_t a ) { return mat32_mulf( a, s ); }
VECMATH_INLINE mat32_t mat32_fdiv( float s, mat32_t a ) { return mat32_div( mat32f( s ), a ); }

// functions
VECMATH_INLINE mat32_t mat32_abs( mat32_t m ) { return mat32( vec2_abs( m.x ), vec2_abs( m.y ), vec2_abs( m.z ) ); }
VECMATH_INLINE mat32_t mat32_acos( mat32_t m ) { return mat32( vec2_acos( m.x ), vec2_acos( m.y ), vec2_acos( m.z ) ); }
VECMATH_INLINE int mat32_all( mat32_t m ) { return vec2_all( m.x ) && vec2_all( m.y ) && vec2_all( m.z ); }
VECMATH_INLINE int mat32_any( mat32_t m ) { return vec2_any( m.x ) || vec2_any( m.y ) || vec2_any( m.z ); }
VECMATH_INLINE mat32_t mat32_asin( mat32_t m ) { return mat32( vec2_asin( m.x ), vec2_asin( m.y ), vec2_asin( m.z ) ); }
VECMATH_INLINE mat32_t mat32_atan( mat32_t m ) { return mat32( vec2_atan( m.x ), vec2_atan( m.y ), vec2_atan( m.z ) ); }
VECMATH_INLINE mat32_t mat32_atan2( mat32_t y, mat32_t x ) { return mat32( vec2_atan2( y.x, x.x ), vec2_atan2( y.y, x.y ), vec2_atan2( y.z, x.z ) ); }
VECMATH_INLINE mat32_t mat32_ceil( mat32_t m ) { return mat32( vec2_ceil( m.x ), vec2_ceil( m.y ), vec2_ceil( m.z ) ); }
VECMATH_INLINE mat32_t mat32_clamp( mat32_t m, mat32_t min_v, mat32_t max_v ) { return mat32( vec2_clamp( m.x, min_v.x, max_v.x ), vec2_clamp( m.y, min_v.y, max_v.y ), vec2_clamp( m.z, min_v.z, max_v.z ) ); }
VECMATH_INLINE mat32_t mat32_cos( mat32_t m ) { return mat32( vec2_cos( m.x ), vec2_cos( m.y ), vec2_cos( m.z ) ); }
VECMATH_INLINE mat32_t mat32_cosh( mat32_t m ) { return mat32( vec2_cosh( m.x ), vec2_cosh( m.y ), vec2_cosh( m.z ) ); }
VECMATH_INLINE mat32_t mat32_degrees( mat32_t m ) { return mat32( vec2_degrees( m.x ), vec2_degrees( m.y ), vec2_degrees( m.z ) ); }
VECMATH_INLINE mat32_t mat32_exp( mat32_t m ) { return mat32( vec2_exp( m.x ), vec2_exp( m.y ), vec2_exp( m.z ) ); }
VECMATH_INLINE mat32_t mat32_exp2( mat32_t m ) { return mat32( vec2_exp2( m.x ), vec2_exp2( m.y ), vec2_exp2( m.z ) ); }
VECMATH_INLINE mat32_t mat32_floor( mat32_t m ) { return mat32( vec2_floor( m.x ), vec2_floor( m.y ), vec2_floor( m.z ) ); }
VECMATH_INLINE mat32_t mat32_fmod( mat32_t a, mat32_t b ) { return mat32( vec2_fmod( a.x, b.x ), vec2_fmod( a.y, b.y ), vec2_fmod( a.z, b.z ) ); }
VECMATH_INLINE mat32_t mat32_frac( mat32_t m ) { return mat32( vec2_frac( m.x ), vec2_frac( m.y ), vec2_frac( m.z ) ); }
VECMATH_INLINE mat32_t mat32_lerp( mat32_t a, mat32_t b, float s ) { return mat32( vec2_lerp( a.x, b.x, s ), vec2_lerp( a.y, b.y, s ), vec2_lerp( a.z, b.z, s ) ); }
VECMATH_INLINE mat32_t mat32_log( mat32_t m ) { return mat32( vec2_log( m.x ), vec2_log( m.y ), vec2_log( m.z ) ); }
VECMATH_INLINE mat32_t mat32_log2( mat32_t m ) { return mat32( vec2_log2( m.x ), vec2_log2( m.y ), vec2_log2( m.z ) ); }
VECMATH_INLINE mat32_t mat32_log10( mat32_t m ) { return mat32( vec2_log10( m.x ), vec2_log10( m.y ), vec2_log10( m.z ) ); }
VECMATH_INLINE mat32_t mat32_max( mat32_t a, mat32_t b ) { return mat32( vec2_max( a.x, b.x ), vec2_max( a.y, b.y ), vec2_max( a.z, b.z ) ); }
VECMATH_INLINE mat32_t mat32_min( mat32_t a, mat32_t b ) { return mat32( vec2_min( a.x, b.x ), vec2_min( a.y, b.y ), vec2_min( a.z, b.z ) ); }
VECMATH_INLINE mat32_t mat32_pow( mat32_t a, mat32_t b ) { return mat32( vec2_pow( a.x, b.x ), vec2_pow( a.y, b.y ), vec2_pow( a.z, b.z ) ); }
VECMATH_INLINE mat32_t mat32_radians( mat32_t m ) { return mat32( vec2_radians( m.x ), vec2_radians( m.y ), vec2_radians( m.z ) ); }
VECMATH_INLINE mat32_t mat32_rcp( mat32_t m ) { return mat32( vec2_rcp( m.x ), vec2_rcp( m.y ), vec2_rcp( m.z ) ); }
VECMATH_INLINE mat32_t mat32_round( mat32_t m ) { return mat32( vec2_round( m.x ), vec2_round( m.y ), vec2_round( m.z ) ); }
VECMATH_INLINE mat32_t mat32_rsqrt( mat32_t m ) { return mat32( vec2_rsqrt( m.x ), vec2_rsqrt( m.y ), vec2_rsqrt( m.z ) ); }
VECMATH_INLINE mat32_t mat32_saturate( mat32_t m ) { return mat32( vec2_saturate( m.x ), vec2_saturate( m.y ), vec2_saturate( m.z ) ); }
VECMATH_INLINE mat32_t mat32_sign( mat32_t m ) { return mat32( vec2_sign( m.x ), vec2_sign( m.y ), vec2_sign( m.z ) ); }
VECMATH_INLINE mat32_t mat32_sin( mat32_t m ) { return mat32( vec2_sin( m.x ), vec2_sin( m.y ), vec2_sin( m.z ) ); }
VECMATH_INLINE mat32_t mat32_sinh( mat32_t m ) { return mat32( vec2_sinh( m.x ), vec2_sinh( m.y ), vec2_sinh( m.z ) ); }
VECMATH_INLINE mat32_t mat32_smoothstep( mat32_t min_v, mat32_t max_v, mat32_t m ) { return mat32( vec2_smoothstep( min_v.x, max_v.x, m.x ), vec2_smoothstep( min_v.y, max_v.y, m.y ), vec2_smoothstep( min_v.z, max_v.z, m.z ) ); }
VECMATH_INLINE mat32_t mat32_smootherstep( mat32_t min_v, mat32_t max_v, mat32_t m ) { return mat32( vec2_smootherstep( min_v.x, max_v.x, m.x ), vec2_smootherstep( min_v.y, max_v.y, m.y ), vec2_smootherstep( min_v.z, max_v.z, m.z ) ); }
VECMATH_INLINE mat32_t mat32_sqrt( mat32_t m ) { return mat32( vec2_sqrt( m.x ), vec2_sqrt( m.y ), vec2_sqrt( m.z ) ); }
VECMATH_INLINE mat32_t mat32_step( mat32_t a, mat32_t b ) { return mat32( vec2_step( a.x, b.x ), vec2_step( a.y, b.y ), vec2_step( a.z, b.z ) ); }
VECMATH_INLINE mat32_t mat32_tan( mat32_t m ) { return mat32( vec2_tan( m.x ), vec2_tan( m.y ), vec2_tan( m.z ) ); }
VECMATH_INLINE mat32_t mat32_tanh( mat32_t m ) { return mat32( vec2_tanh( m.x ), vec2_tanh( m.y ), vec2_tanh( m.z ) ); }
VECMATH_INLINE mat32_t mat32_trunc( mat32_t m ) { return mat32( vec2_trunc( m.x ), vec2_trunc( m.y ), vec2_trunc( m.z ) ); }


// mat33
#ifdef __cplusplus
    struct mat33 : mat33_t {
        inline mat33() {}
        inline mat33( vec3_t x_, vec3_t y_, vec3_t z_ ) { x = x_; y = y_; z = z_; }
        inline mat33( mat33_t m ) { x = m.x; y = m.y; z = m.z; }
        inline mat33( float f ) { x = vec3( f ); y = vec3( f ); z = vec3( f ); }
        inline vec3 operator[]( int index ) const { return ( (vec3*) this )[ index ]; }
        inline vec3& operator[]( int index ) { return ( (vec3*) this )[ index ]; }
    };
#else
    VECMATH_INLINE mat33_t mat33( vec3_t x, vec3_t y, vec3_t z ) { mat33_t m; m.x = x; m.y = y; m.z = z; return m; }
#endif
VECMATH_INLINE mat33_t mat33f( float v ) { vec3_t t = vec3f( v ); return mat33( t, t, t ); }

VECMATH_INLINE vec3_t mat33_get( mat33_t m, int row ) { return ( (vec3_t*) &m )[ row ]; }
VECMATH_INLINE void mat33_set( mat33_t* m, int row, vec3_t v ) { ( (vec3_t*) m )[ row ] = v; }

// operators
VECMATH_INLINE mat33_t mat33_neg( mat33_t m ) { return mat33( vec3_neg( m.x ), vec3_neg( m.y ), vec3_neg( m.z ) ); }
VECMATH_INLINE int mat33_eq( mat33_t a, mat33_t b ) { return vec3_eq( a.x, b.x ) && vec3_eq( a.y, b.y ) && vec3_eq( a.z, b.z ); }
VECMATH_INLINE mat33_t mat33_add( mat33_t a, mat33_t b ) { return mat33( vec3_add( a.x, b.x ), vec3_add( a.y, b.y ), vec3_add( a.z, b.z ) ); }
VECMATH_INLINE mat33_t mat33_sub( mat33_t a, mat33_t b ) { return mat33( vec3_sub( a.x, b.x ), vec3_sub( a.y, b.y ), vec3_sub( a.z, b.z ) ); }
VECMATH_INLINE mat33_t mat33_mul_elem( mat33_t a, mat33_t b ) { return mat33( vec3_mul( a.x, b.x ), vec3_mul( a.y, b.y ), vec3_mul( a.z, b.z ) ); }
VECMATH_INLINE mat33_t mat33_div( mat33_t a, mat33_t b ) { return mat33( vec3_div( a.x, b.x ), vec3_div( a.y, b.y ), vec3_div( a.z, b.z ) ); }
VECMATH_INLINE mat33_t mat33_addf( mat33_t a, float s ) { return mat33( vec3_addf( a.x, s ), vec3_addf( a.y, s ), vec3_addf( a.z, s ) ); }
VECMATH_INLINE mat33_t mat33_subf( mat33_t a, float s ) { return mat33( vec3_subf( a.x, s ), vec3_subf( a.y, s ), vec3_subf( a.z, s ) ); }
VECMATH_INLINE mat33_t mat33_mulf( mat33_t a, float s ) { return mat33( vec3_mulf( a.x, s ), vec3_mulf( a.y, s ), vec3_mulf( a.z, s ) ); }
VECMATH_INLINE mat33_t mat33_divf( mat33_t a, float s ) { return mat33( vec3_divf( a.x, s ), vec3_divf( a.y, s ), vec3_divf( a.z, s ) ); }
VECMATH_INLINE mat33_t mat33_fadd( float s, mat33_t a ) { return mat33_addf( a, s ); }
VECMATH_INLINE mat33_t mat33_fsub( float s, mat33_t a ) { return mat33_sub( mat33f( s ), a ); }
VECMATH_INLINE mat33_t mat33_fmul( float s, mat33_t a ) { return mat33_mulf( a, s ); }
VECMATH_INLINE mat33_t mat33_fdiv( float s, mat33_t a ) { return mat33_div( mat33f( s ), a ); }

// functions
VECMATH_INLINE mat33_t mat33_abs( mat33_t m ) { return mat33( vec3_abs( m.x ), vec3_abs( m.y ), vec3_abs( m.z ) ); }
VECMATH_INLINE mat33_t mat33_acos( mat33_t m ) { return mat33( vec3_acos( m.x ), vec3_acos( m.y ), vec3_acos( m.z ) ); }
VECMATH_INLINE int mat33_all( mat33_t m ) { return vec3_all( m.x ) && vec3_all( m.y ) && vec3_all( m.z ); }
VECMATH_INLINE int mat33_any( mat33_t m ) { return vec3_any( m.x ) || vec3_any( m.y ) || vec3_any( m.z ); }
VECMATH_INLINE mat33_t mat33_asin( mat33_t m ) { return mat33( vec3_asin( m.x ), vec3_asin( m.y ), vec3_asin( m.z ) ); }
VECMATH_INLINE mat33_t mat33_atan( mat33_t m ) { return mat33( vec3_atan( m.x ), vec3_atan( m.y ), vec3_atan( m.z ) ); }
VECMATH_INLINE mat33_t mat33_atan2( mat33_t y, mat33_t x ) { return mat33( vec3_atan2( y.x, x.x ), vec3_atan2( y.y, x.y ), vec3_atan2( y.z, x.z ) ); }
VECMATH_INLINE mat33_t mat33_ceil( mat33_t m ) { return mat33( vec3_ceil( m.x ), vec3_ceil( m.y ), vec3_ceil( m.z ) ); }
VECMATH_INLINE mat33_t mat33_clamp( mat33_t m, mat33_t min_v, mat33_t max_v ) { return mat33( vec3_clamp( m.x, min_v.x, max_v.x ), vec3_clamp( m.y, min_v.y, max_v.y ), vec3_clamp( m.z, min_v.z, max_v.z ) ); }
VECMATH_INLINE mat33_t mat33_cos( mat33_t m ) { return mat33( vec3_cos( m.x ), vec3_cos( m.y ), vec3_cos( m.z ) ); }
VECMATH_INLINE mat33_t mat33_cosh( mat33_t m ) { return mat33( vec3_cosh( m.x ), vec3_cosh( m.y ), vec3_cosh( m.z ) ); }
VECMATH_INLINE mat33_t mat33_degrees( mat33_t m ) { return mat33( vec3_degrees( m.x ), vec3_degrees( m.y ), vec3_degrees( m.z ) ); }
VECMATH_INLINE mat33_t mat33_exp( mat33_t m ) { return mat33( vec3_exp( m.x ), vec3_exp( m.y ), vec3_exp( m.z ) ); }
VECMATH_INLINE mat33_t mat33_exp2( mat33_t m ) { return mat33( vec3_exp2( m.x ), vec3_exp2( m.y ), vec3_exp2( m.z ) ); }
VECMATH_INLINE mat33_t mat33_floor( mat33_t m ) { return mat33( vec3_floor( m.x ), vec3_floor( m.y ), vec3_floor( m.z ) ); }
VECMATH_INLINE mat33_t mat33_fmod( mat33_t a, mat33_t b ) { return mat33( vec3_fmod( a.x, b.x ), vec3_fmod( a.y, b.y ), vec3_fmod( a.z, b.z ) ); }
VECMATH_INLINE mat33_t mat33_frac( mat33_t m ) { return mat33( vec3_frac( m.x ), vec3_frac( m.y ), vec3_frac( m.z ) ); }
VECMATH_INLINE mat33_t mat33_lerp( mat33_t a, mat33_t b, float s ) { return mat33( vec3_lerp( a.x, b.x, s ), vec3_lerp( a.y, b.y, s ), vec3_lerp( a.z, b.z, s ) ); }
VECMATH_INLINE mat33_t mat33_log( mat33_t m ) { return mat33( vec3_log( m.x ), vec3_log( m.y ), vec3_log( m.z ) ); }
VECMATH_INLINE mat33_t mat33_log2( mat33_t m ) { return mat33( vec3_log2( m.x ), vec3_log2( m.y ), vec3_log2( m.z ) ); }
VECMATH_INLINE mat33_t mat33_log10( mat33_t m ) { return mat33( vec3_log10( m.x ), vec3_log10( m.y ), vec3_log10( m.z ) ); }
VECMATH_INLINE mat33_t mat33_max( mat33_t a, mat33_t b ) { return mat33( vec3_max( a.x, b.x ), vec3_max( a.y, b.y ), vec3_max( a.z, b.z ) ); }
VECMATH_INLINE mat33_t mat33_min( mat33_t a, mat33_t b ) { return mat33( vec3_min( a.x, b.x ), vec3_min( a.y, b.y ), vec3_min( a.z, b.z ) ); }
VECMATH_INLINE mat33_t mat33_pow( mat33_t a, mat33_t b ) { return mat33( vec3_pow( a.x, b.x ), vec3_pow( a.y, b.y ), vec3_pow( a.z, b.z ) ); }
VECMATH_INLINE mat33_t mat33_radians( mat33_t m ) { return mat33( vec3_radians( m.x ), vec3_radians( m.y ), vec3_radians( m.z ) ); }
VECMATH_INLINE mat33_t mat33_rcp( mat33_t m ) { return mat33( vec3_rcp( m.x ), vec3_rcp( m.y ), vec3_rcp( m.z ) ); }
VECMATH_INLINE mat33_t mat33_round( mat33_t m ) { return mat33( vec3_round( m.x ), vec3_round( m.y ), vec3_round( m.z ) ); }
VECMATH_INLINE mat33_t mat33_rsqrt( mat33_t m ) { return mat33( vec3_rsqrt( m.x ), vec3_rsqrt( m.y ), vec3_rsqrt( m.z ) ); }
VECMATH_INLINE mat33_t mat33_saturate( mat33_t m ) { return mat33( vec3_saturate( m.x ), vec3_saturate( m.y ), vec3_saturate( m.z ) ); }
VECMATH_INLINE mat33_t mat33_sign( mat33_t m ) { return mat33( vec3_sign( m.x ), vec3_sign( m.y ), vec3_sign( m.z ) ); }
VECMATH_INLINE mat33_t mat33_sin( mat33_t m ) { return mat33( vec3_sin( m.x ), vec3_sin( m.y ), vec3_sin( m.z ) ); }
VECMATH_INLINE mat33_t mat33_sinh( mat33_t m ) { return mat33( vec3_sinh( m.x ), vec3_sinh( m.y ), vec3_sinh( m.z ) ); }
VECMATH_INLINE mat33_t mat33_smoothstep( mat33_t min_v, mat33_t max_v, mat33_t m ) { return mat33( vec3_smoothstep( min_v.x, max_v.x, m.x ), vec3_smoothstep( min_v.y, max_v.y, m.y ), vec3_smoothstep( min_v.z, max_v.z, m.z ) ); }
VECMATH_INLINE mat33_t mat33_smootherstep( mat33_t min_v, mat33_t max_v, mat33_t m ) { return mat33( vec3_smootherstep( min_v.x, max_v.x, m.x ), vec3_smootherstep( min_v.y, max_v.y, m.y ), vec3_smootherstep( min_v.z, max_v.z, m.z ) ); }
VECMATH_INLINE mat33_t mat33_sqrt( mat33_t m ) { return mat33( vec3_sqrt( m.x ), vec3_sqrt( m.y ), vec3_sqrt( m.z ) ); }
VECMATH_INLINE mat33_t mat33_step( mat33_t a, mat33_t b ) { return mat33( vec3_step( a.x, b.x ), vec3_step( a.y, b.y ), vec3_step( a.z, b.z ) ); }
VECMATH_INLINE mat33_t mat33_tan( mat33_t m ) { return mat33( vec3_tan( m.x ), vec3_tan( m.y ), vec3_tan( m.z ) ); }
VECMATH_INLINE mat33_t mat33_tanh( mat33_t m ) { return mat33( vec3_tanh( m.x ), vec3_tanh( m.y ), vec3_tanh( m.z ) ); }
VECMATH_INLINE mat33_t mat33_trunc( mat33_t m ) { return mat33( vec3_trunc( m.x ), vec3_trunc( m.y ), vec3_trunc( m.z ) ); }


// mat34
#ifdef __cplusplus
    struct mat34 : mat34_t {
        inline mat34() {}
        inline mat34( vec4_t x_, vec4_t y_, vec4_t z_ ) { x = x_; y = y_; z = z_; }
        inline mat34( mat34_t m ) { x = m.x; y = m.y; z = m.z; }
        inline mat34( float f ) { x = vec4( f ); y = vec4( f ); z = vec4( f ); }
        inline vec4 operator[]( int index ) const { return ( (vec4*) this )[ index ]; }
        inline vec4& operator[]( int index ) { return ( (vec4*) this )[ index ]; }
    };
#else
    VECMATH_INLINE mat34_t mat34( vec4_t x, vec4_t y, vec4_t z ) { mat34_t m; m.x = x; m.y = y; m.z = z; return m; }
#endif
VECMATH_INLINE mat34_t mat34f( float v ) { vec4_t t = vec4f( v ); return mat34( t, t, t ); }

VECMATH_INLINE vec4_t mat34_get( mat34_t m, int row ) { return ( (vec4_t*) &m )[ row ]; }
VECMATH_INLINE void mat34_set( mat34_t* m, int row, vec4_t v ) { ( (vec4_t*) m )[ row ] = v; }

// operators
VECMATH_INLINE mat34_t mat34_neg( mat34_t m ) { return mat34( vec4_neg( m.x ), vec4_neg( m.y ), vec4_neg( m.z ) ); }
VECMATH_INLINE int mat34_eq( mat34_t a, mat34_t b ) { return vec4_eq( a.x, b.x ) && vec4_eq( a.y, b.y ) && vec4_eq( a.z, b.z ); }
VECMATH_INLINE mat34_t mat34_add( mat34_t a, mat34_t b ) { return mat34( vec4_add( a.x, b.x ), vec4_add( a.y, b.y ), vec4_add( a.z, b.z ) ); }
VECMATH_INLINE mat34_t mat34_sub( mat34_t a, mat34_t b ) { return mat34( vec4_sub( a.x, b.x ), vec4_sub( a.y, b.y ), vec4_sub( a.z, b.z ) ); }
VECMATH_INLINE mat34_t mat34_mul_elem( mat34_t a, mat34_t b ) { return mat34( vec4_mul( a.x, b.x ), vec4_mul( a.y, b.y ), vec4_mul( a.z, b.z ) ); }
VECMATH_INLINE mat34_t mat34_div( mat34_t a, mat34_t b ) { return mat34( vec4_div( a.x, b.x ), vec4_div( a.y, b.y ), vec4_div( a.z, b.z ) ); }
VECMATH_INLINE mat34_t mat34_addf( mat34_t a, float s ) { return mat34( vec4_addf( a.x, s ), vec4_addf( a.y, s ), vec4_addf( a.z, s ) ); }
VECMATH_INLINE mat34_t mat34_subf( mat34_t a, float s ) { return mat34( vec4_subf( a.x, s ), vec4_subf( a.y, s ), vec4_subf( a.z, s ) ); }
VECMATH_INLINE mat34_t mat34_mulf( mat34_t a, float s ) { return mat34( vec4_mulf( a.x, s ), vec4_mulf( a.y, s ), vec4_mulf( a.z, s ) ); }
VECMATH_INLINE mat34_t mat34_divf( mat34_t a, float s ) { return mat34( vec4_divf( a.x, s ), vec4_divf( a.y, s ), vec4_divf( a.z, s ) ); }
VECMATH_INLINE mat34_t mat34_fadd( float s, mat34_t a ) { return mat34_addf( a, s ); }
VECMATH_INLINE mat34_t mat34_fsub( float s, mat34_t a ) { return mat34_sub( mat34f( s ), a ); }
VECMATH_INLINE mat34_t mat34_fmul( float s, mat34_t a ) { return mat34_mulf( a, s ); }
VECMATH_INLINE mat34_t mat34_fdiv( float s, mat34_t a ) { return mat34_div( mat34f( s ), a ); }

// functions
VECMATH_INLINE mat34_t mat34_abs( mat34_t m ) { return mat34( vec4_abs( m.x ), vec4_abs( m.y ), vec4_abs( m.z ) ); }
VECMATH_INLINE mat34_t mat34_acos( mat34_t m ) { return mat34( vec4_acos( m.x ), vec4_acos( m.y ), vec4_acos( m.z ) ); }
VECMATH_INLINE int mat34_all( mat34_t m ) { return vec4_all( m.x ) && vec4_all( m.y ) && vec4_all( m.z ); }
VECMATH_INLINE int mat34_any( mat34_t m ) { return vec4_any( m.x ) || vec4_any( m.y ) || vec4_any( m.z ); }
VECMATH_INLINE mat34_t mat34_asin( mat34_t m ) { return mat34( vec4_asin( m.x ), vec4_asin( m.y ), vec4_asin( m.z ) ); }
VECMATH_INLINE mat34_t mat34_atan( mat34_t m ) { return mat34( vec4_atan( m.x ), vec4_atan( m.y ), vec4_atan( m.z ) ); }
VECMATH_INLINE mat34_t mat34_atan2( mat34_t y, mat34_t x ) { return mat34( vec4_atan2( y.x, x.x ), vec4_atan2( y.y, x.y ), vec4_atan2( y.z, x.z ) ); }
VECMATH_INLINE mat34_t mat34_ceil( mat34_t m ) { return mat34( vec4_ceil( m.x ), vec4_ceil( m.y ), vec4_ceil( m.z ) ); }
VECMATH_INLINE mat34_t mat34_clamp( mat34_t m, mat34_t min_v, mat34_t max_v ) { return mat34( vec4_clamp( m.x, min_v.x, max_v.x ), vec4_clamp( m.y, min_v.y, max_v.y ), vec4_clamp( m.z, min_v.z, max_v.z ) ); }
VECMATH_INLINE mat34_t mat34_cos( mat34_t m ) { return mat34( vec4_cos( m.x ), vec4_cos( m.y ), vec4_cos( m.z ) ); }
VECMATH_INLINE mat34_t mat34_cosh( mat34_t m ) { return mat34( vec4_cosh( m.x ), vec4_cosh( m.y ), vec4_cosh( m.z ) ); }
VECMATH_INLINE mat34_t mat34_degrees( mat34_t m ) { return mat34( vec4_degrees( m.x ), vec4_degrees( m.y ), vec4_degrees( m.z ) ); }
VECMATH_INLINE mat34_t mat34_exp( mat34_t m ) { return mat34( vec4_exp( m.x ), vec4_exp( m.y ), vec4_exp( m.z ) ); }
VECMATH_INLINE mat34_t mat34_exp2( mat34_t m ) { return mat34( vec4_exp2( m.x ), vec4_exp2( m.y ), vec4_exp2( m.z ) ); }
VECMATH_INLINE mat34_t mat34_floor( mat34_t m ) { return mat34( vec4_floor( m.x ), vec4_floor( m.y ), vec4_floor( m.z ) ); }
VECMATH_INLINE mat34_t mat34_fmod( mat34_t a, mat34_t b ) { return mat34( vec4_fmod( a.x, b.x ), vec4_fmod( a.y, b.y ), vec4_fmod( a.z, b.z ) ); }
VECMATH_INLINE mat34_t mat34_frac( mat34_t m ) { return mat34( vec4_frac( m.x ), vec4_frac( m.y ), vec4_frac( m.z ) ); }
VECMATH_INLINE mat34_t mat34_lerp( mat34_t a, mat34_t b, float s ) { return mat34( vec4_lerp( a.x, b.x, s ), vec4_lerp( a.y, b.y, s ), vec4_lerp( a.z, b.z, s ) ); }
VECMATH_INLINE mat34_t mat34_log( mat34_t m ) { return mat34( vec4_log( m.x ), vec4_log( m.y ), vec4_log( m.z ) ); }
VECMATH_INLINE mat34_t mat34_log2( mat34_t m ) { return mat34( vec4_log2( m.x ), vec4_log2( m.y ), vec4_log2( m.z ) ); }
VECMATH_INLINE mat34_t mat34_log10( mat34_t m ) { return mat34( vec4_log10( m.x ), vec4_log10( m.y ), vec4_log10( m.z ) ); }
VECMATH_INLINE mat34_t mat34_max( mat34_t a, mat34_t b ) { return mat34( vec4_max( a.x, b.x ), vec4_max( a.y, b.y ), vec4_max( a.z, b.z ) ); }
VECMATH_INLINE mat34_t mat34_min( mat34_t a, mat34_t b ) { return mat34( vec4_min( a.x, b.x ), vec4_min( a.y, b.y ), vec4_min( a.z, b.z ) ); }
VECMATH_INLINE mat34_t mat34_pow( mat34_t a, mat34_t b ) { return mat34( vec4_pow( a.x, b.x ), vec4_pow( a.y, b.y ), vec4_pow( a.z, b.z ) ); }
VECMATH_INLINE mat34_t mat34_radians( mat34_t m ) { return mat34( vec4_radians( m.x ), vec4_radians( m.y ), vec4_radians( m.z ) ); }
VECMATH_INLINE mat34_t mat34_rcp( mat34_t m ) { return mat34( vec4_rcp( m.x ), vec4_rcp( m.y ), vec4_rcp( m.z ) ); }
VECMATH_INLINE mat34_t mat34_round( mat34_t m ) { return mat34( vec4_round( m.x ), vec4_round( m.y ), vec4_round( m.z ) ); }
VECMATH_INLINE mat34_t mat34_rsqrt( mat34_t m ) { return mat34( vec4_rsqrt( m.x ), vec4_rsqrt( m.y ), vec4_rsqrt( m.z ) ); }
VECMATH_INLINE mat34_t mat34_saturate( mat34_t m ) { return mat34( vec4_saturate( m.x ), vec4_saturate( m.y ), vec4_saturate( m.z ) ); }
VECMATH_INLINE mat34_t mat34_sign( mat34_t m ) { return mat34( vec4_sign( m.x ), vec4_sign( m.y ), vec4_sign( m.z ) ); }
VECMATH_INLINE mat34_t mat34_sin( mat34_t m ) { return mat34( vec4_sin( m.x ), vec4_sin( m.y ), vec4_sin( m.z ) ); }
VECMATH_INLINE mat34_t mat34_sinh( mat34_t m ) { return mat34( vec4_sinh( m.x ), vec4_sinh( m.y ), vec4_sinh( m.z ) ); }
VECMATH_INLINE mat34_t mat34_smoothstep( mat34_t min_v, mat34_t max_v, mat34_t m ) { return mat34( vec4_smoothstep( min_v.x, max_v.x, m.x ), vec4_smoothstep( min_v.y, max_v.y, m.y ), vec4_smoothstep( min_v.z, max_v.z, m.z ) ); }
VECMATH_INLINE mat34_t mat34_smootherstep( mat34_t min_v, mat34_t max_v, mat34_t m ) { return mat34( vec4_smootherstep( min_v.x, max_v.x, m.x ), vec4_smootherstep( min_v.y, max_v.y, m.y ), vec4_smootherstep( min_v.z, max_v.z, m.z ) ); }
VECMATH_INLINE mat34_t mat34_sqrt( mat34_t m ) { return mat34( vec4_sqrt( m.x ), vec4_sqrt( m.y ), vec4_sqrt( m.z ) ); }
VECMATH_INLINE mat34_t mat34_step( mat34_t a, mat34_t b ) { return mat34( vec4_step( a.x, b.x ), vec4_step( a.y, b.y ), vec4_step( a.z, b.z ) ); }
VECMATH_INLINE mat34_t mat34_tan( mat34_t m ) { return mat34( vec4_tan( m.x ), vec4_tan( m.y ), vec4_tan( m.z ) ); }
VECMATH_INLINE mat34_t mat34_tanh( mat34_t m ) { return mat34( vec4_tanh( m.x ), vec4_tanh( m.y ), vec4_tanh( m.z ) ); }
VECMATH_INLINE mat34_t mat34_trunc( mat34_t m ) { return mat34( vec4_trunc( m.x ), vec4_trunc( m.y ), vec4_trunc( m.z ) ); }


// mat42
#ifdef __cplusplus
    struct mat42 : mat42_t {
        inline mat42() {}
        inline mat42( vec2_t x_, vec2_t y_, vec2_t z_, vec2_t w_ ) { x = x_; y = y_; z = z_; w = w_; }
        inline mat42( mat42_t m ) { x = m.x; y = m.y; z = m.z; w = m.w; }
        inline mat42( float f ) { x = vec2( f ); y = vec2( f ); z = vec2( f ); w = vec2( f ); }
        inline vec2 operator[]( int index ) const { return ( (vec2*) this )[ index ]; }
        inline vec2& operator[]( int index ) { return ( (vec2*) this )[ index ]; }
    };
#else
    VECMATH_INLINE mat42_t mat42( vec2_t x, vec2_t y, vec2_t z, vec2_t w ) { mat42_t m; m.x = x; m.y = y; m.z = z; m.w = w; return m; }
#endif
VECMATH_INLINE mat42_t mat42f( float v ) { vec2_t t = vec2f( v ); return mat42( t, t, t, t ); }

VECMATH_INLINE vec2_t mat42_get( mat42_t m, int row ) { return ( (vec2_t*) &m )[ row ]; }
VECMATH_INLINE void mat42_set( mat42_t* m, int row, vec2_t v ) { ( (vec2_t*) m )[ row ] = v; }

// operators
VECMATH_INLINE mat42_t mat42_neg( mat42_t m ) { return mat42( vec2_neg( m.x ), vec2_neg( m.y ), vec2_neg( m.z ), vec2_neg( m.w ) ); }
VECMATH_INLINE int mat42_eq( mat42_t a, mat42_t b ) { return vec2_eq( a.x, b.x ) && vec2_eq( a.y, b.y ) && vec2_eq( a.z, b.z ) && vec2_eq( a.w, b.w ); }
VECMATH_INLINE mat42_t mat42_add( mat42_t a, mat42_t b ) { return mat42( vec2_add( a.x, b.x ), vec2_add( a.y, b.y ), vec2_add( a.z, b.z ), vec2_add( a.w, b.w ) ); }
VECMATH_INLINE mat42_t mat42_sub( mat42_t a, mat42_t b ) { return mat42( vec2_sub( a.x, b.x ), vec2_sub( a.y, b.y ), vec2_sub( a.z, b.z ), vec2_sub( a.w, b.w ) ); }
VECMATH_INLINE mat42_t mat42_mul_elem( mat42_t a, mat42_t b ) { return mat42( vec2_mul( a.x, b.x ), vec2_mul( a.y, b.y ), vec2_mul( a.z, b.z ), vec2_mul( a.w, b.w ) ); }
VECMATH_INLINE mat42_t mat42_div( mat42_t a, mat42_t b ) { return mat42( vec2_div( a.x, b.x ), vec2_div( a.y, b.y ), vec2_div( a.z, b.z ), vec2_div( a.w, b.w ) ); }
VECMATH_INLINE mat42_t mat42_addf( mat42_t a, float s ) { return mat42( vec2_addf( a.x, s ), vec2_addf( a.y, s ), vec2_addf( a.z, s ), vec2_addf( a.w, s ) ); }
VECMATH_INLINE mat42_t mat42_subf( mat42_t a, float s ) { return mat42( vec2_subf( a.x, s ), vec2_subf( a.y, s ), vec2_subf( a.z, s ), vec2_subf( a.w, s ) ); }
VECMATH_INLINE mat42_t mat42_mulf( mat42_t a, float s ) { return mat42( vec2_mulf( a.x, s ), vec2_mulf( a.y, s ), vec2_mulf( a.z, s ), vec2_mulf( a.w, s ) ); }
VECMATH_INLINE mat42_t mat42_divf( mat42_t a, float s ) { return mat42( vec2_divf( a.x, s ), vec2_divf( a.y, s ), vec2_divf( a.z, s ), vec2_divf( a.w, s ) ); }
VECMATH_INLINE mat42_t mat42_fadd( float s, mat42_t a ) { return mat42_addf( a, s ); }
VECMATH_INLINE mat42_t mat42_fsub( float s, mat42_t a ) { return mat42_sub( mat42f( s ), a ); }
VECMATH_INLINE mat42_t mat42_fmul( float s, mat42_t a ) { return mat42_mulf( a, s ); }
VECMATH_INLINE mat42_t mat42_fdiv( float s, mat42_t a ) { return mat42_div( mat42f( s ), a ); }

// functions
VECMATH_INLINE mat42_t mat42_abs( mat42_t m ) { return mat42( vec2_abs( m.x ), vec2_abs( m.y ), vec2_abs( m.z ), vec2_abs( m.w ) ); }
VECMATH_INLINE mat42_t mat42_acos( mat42_t m ) { return mat42( vec2_acos( m.x ), vec2_acos( m.y ), vec2_acos( m.z ), vec2_acos( m.w ) ); }
VECMATH_INLINE int mat42_all( mat42_t m ) { return vec2_all( m.x ) && vec2_all( m.y ) && vec2_all( m.z ) && vec2_all( m.w ); }
VECMATH_INLINE int mat42_any( mat42_t m ) { return vec2_any( m.x ) || vec2_any( m.y ) || vec2_any( m.z ) || vec2_any( m.w ); }
VECMATH_INLINE mat42_t mat42_asin( mat42_t m ) { return mat42( vec2_asin( m.x ), vec2_asin( m.y ), vec2_asin( m.z ), vec2_asin( m.w ) ); }
VECMATH_INLINE mat42_t mat42_atan( mat42_t m ) { return mat42( vec2_atan( m.x ), vec2_atan( m.y ), vec2_atan( m.z ), vec2_atan( m.w ) ); }
VECMATH_INLINE mat42_t mat42_atan2( mat42_t y, mat42_t x ) { return mat42( vec2_atan2( y.x, x.x ), vec2_atan2( y.y, x.y ), vec2_atan2( y.z, x.z ), vec2_atan2( y.w, x.w ) ); }
VECMATH_INLINE mat42_t mat42_ceil( mat42_t m ) { return mat42( vec2_ceil( m.x ), vec2_ceil( m.y ), vec2_ceil( m.z ), vec2_ceil( m.w ) ); }
VECMATH_INLINE mat42_t mat42_clamp( mat42_t m, mat42_t min_v, mat42_t max_v ) { return mat42( vec2_clamp( m.x, min_v.x, max_v.x ), vec2_clamp( m.y, min_v.y, max_v.y ), vec2_clamp( m.z, min_v.z, max_v.z ), vec2_clamp( m.w, min_v.w, max_v.w ) ); }
VECMATH_INLINE mat42_t mat42_cos( mat42_t m ) { return mat42( vec2_cos( m.x ), vec2_cos( m.y ), vec2_cos( m.z ), vec2_cos( m.w ) ); }
VECMATH_INLINE mat42_t mat42_cosh( mat42_t m ) { return mat42( vec2_cosh( m.x ), vec2_cosh( m.y ), vec2_cosh( m.z ), vec2_cosh( m.w ) ); }
VECMATH_INLINE mat42_t mat42_degrees( mat42_t m ) { return mat42( vec2_degrees( m.x ), vec2_degrees( m.y ), vec2_degrees( m.z ), vec2_degrees( m.w ) ); }
VECMATH_INLINE mat42_t mat42_exp( mat42_t m ) { return mat42( vec2_exp( m.x ), vec2_exp( m.y ), vec2_exp( m.z ), vec2_exp( m.w ) ); }
VECMATH_INLINE mat42_t mat42_exp2( mat42_t m ) { return mat42( vec2_exp2( m.x ), vec2_exp2( m.y ), vec2_exp2( m.z ), vec2_exp2( m.w ) ); }
VECMATH_INLINE mat42_t mat42_floor( mat42_t m ) { return mat42( vec2_floor( m.x ), vec2_floor( m.y ), vec2_floor( m.z ), vec2_floor( m.w ) ); }
VECMATH_INLINE mat42_t mat42_fmod( mat42_t a, mat42_t b ) { return mat42( vec2_fmod( a.x, b.x ), vec2_fmod( a.y, b.y ), vec2_fmod( a.z, b.z ), vec2_fmod( a.w, b.w ) ); }
VECMATH_INLINE mat42_t mat42_frac( mat42_t m ) { return mat42( vec2_frac( m.x ), vec2_frac( m.y ), vec2_frac( m.z ), vec2_frac( m.w ) ); }
VECMATH_INLINE mat42_t mat42_lerp( mat42_t a, mat42_t b, float s ) { return mat42( vec2_lerp( a.x, b.x, s ), vec2_lerp( a.y, b.y, s ), vec2_lerp( a.z, b.z, s ), vec2_lerp( a.w, b.w, s ) ); }
VECMATH_INLINE mat42_t mat42_log( mat42_t m ) { return mat42( vec2_log( m.x ), vec2_log( m.y ), vec2_log( m.z ), vec2_log( m.w ) ); }
VECMATH_INLINE mat42_t mat42_log2( mat42_t m ) { return mat42( vec2_log2( m.x ), vec2_log2( m.y ), vec2_log2( m.z ), vec2_log2( m.w ) ); }
VECMATH_INLINE mat42_t mat42_log10( mat42_t m ) { return mat42( vec2_log10( m.x ), vec2_log10( m.y ), vec2_log10( m.z ), vec2_log10( m.w ) ); }
VECMATH_INLINE mat42_t mat42_max( mat42_t a, mat42_t b ) { return mat42( vec2_max( a.x, b.x ), vec2_max( a.y, b.y ), vec2_max( a.z, b.z ), vec2_max( a.w, b.w ) ); }
VECMATH_INLINE mat42_t mat42_min( mat42_t a, mat42_t b ) { return mat42( vec2_min( a.x, b.x ), vec2_min( a.y, b.y ), vec2_min( a.z, b.z ), vec2_min( a.w, b.w ) ); }
VECMATH_INLINE mat42_t mat42_pow( mat42_t a, mat42_t b ) { return mat42( vec2_pow( a.x, b.x ), vec2_pow( a.y, b.y ), vec2_pow( a.z, b.z ), vec2_pow( a.w, b.w ) ); }
VECMATH_INLINE mat42_t mat42_radians( mat42_t m ) { return mat42( vec2_radians( m.x ), vec2_radians( m.y ), vec2_radians( m.z ), vec2_radians( m.w ) ); }
VECMATH_INLINE mat42_t mat42_rcp( mat42_t m ) { return mat42( vec2_rcp( m.x ), vec2_rcp( m.y ), vec2_rcp( m.z ), vec2_rcp( m.w ) ); }
VECMATH_INLINE mat42_t mat42_round( mat42_t m ) { return mat42( vec2_round( m.x ), vec2_round( m.y ), vec2_round( m.z ), vec2_round( m.w ) ); }
VECMATH_INLINE mat42_t mat42_rsqrt( mat42_t m ) { return mat42( vec2_rsqrt( m.x ), vec2_rsqrt( m.y ), vec2_rsqrt( m.z ), vec2_rsqrt( m.w ) ); }
VECMATH_INLINE mat42_t mat42_saturate( mat42_t m ) { return mat42( vec2_saturate( m.x ), vec2_saturate( m.y ), vec2_saturate( m.z ), vec2_saturate( m.w ) ); }
VECMATH_INLINE mat42_t mat42_sign( mat42_t m ) { return mat42( vec2_sign( m.x ), vec2_sign( m.y ), vec2_sign( m.z ), vec2_sign( m.w ) ); }
VECMATH_INLINE mat42_t mat42_sin( mat42_t m ) { return mat42( vec2_sin( m.x ), vec2_sin( m.y ), vec2_sin( m.z ), vec2_sin( m.w ) ); }
VECMATH_INLINE mat42_t mat42_sinh( mat42_t m ) { return mat42( vec2_sinh( m.x ), vec2_sinh( m.y ), vec2_sinh( m.z ), vec2_sinh( m.w ) ); }
VECMATH_INLINE mat42_t mat42_smoothstep( mat42_t min_v, mat42_t max_v, mat42_t m ) { return mat42( vec2_smoothstep( min_v.x, max_v.x, m.x ), vec2_smoothstep( min_v.y, max_v.y, m.y ), vec2_smoothstep( min_v.z, max_v.z, m.z ), vec2_smoothstep( min_v.w, max_v.w, m.w ) ); }
VECMATH_INLINE mat42_t mat42_smootherstep( mat42_t min_v, mat42_t max_v, mat42_t m ) { return mat42( vec2_smootherstep( min_v.x, max_v.x, m.x ), vec2_smootherstep( min_v.y, max_v.y, m.y ), vec2_smootherstep( min_v.z, max_v.z, m.z ), vec2_smootherstep( min_v.w, max_v.w, m.w ) ); }
VECMATH_INLINE mat42_t mat42_sqrt( mat42_t m ) { return mat42( vec2_sqrt( m.x ), vec2_sqrt( m.y ), vec2_sqrt( m.z ), vec2_sqrt( m.w ) ); }
VECMATH_INLINE mat42_t mat42_step( mat42_t a, mat42_t b ) { return mat42( vec2_step( a.x, b.x ), vec2_step( a.y, b.y ), vec2_step( a.z, b.z ), vec2_step( a.w, b.w ) ); }
VECMATH_INLINE mat42_t mat42_tan( mat42_t m ) { return mat42( vec2_tan( m.x ), vec2_tan( m.y ), vec2_tan( m.z ), vec2_tan( m.w ) ); }
VECMATH_INLINE mat42_t mat42_tanh( mat42_t m ) { return mat42( vec2_tanh( m.x ), vec2_tanh( m.y ), vec2_tanh( m.z ), vec2_tanh( m.w ) ); }
VECMATH_INLINE mat42_t mat42_trunc( mat42_t m ) { return mat42( vec2_trunc( m.x ), vec2_trunc( m.y ), vec2_trunc( m.z ), vec2_trunc( m.w ) ); }


// mat43
#ifdef __cplusplus
    struct mat43 : mat43_t {
        inline mat43() {}
        inline mat43( vec3_t x_, vec3_t y_, vec3_t z_, vec3_t w_ ) { x = x_; y = y_; z = z_; w = w_; }
        inline mat43( mat43_t m ) { x = m.x; y = m.y; z = m.z; w = m.w; }
        inline mat43( float f ) { x = vec3( f ); y = vec3( f ); z = vec3( f ); w = vec3( f ); }
        inline vec3 operator[]( int index ) const { return ( (vec3*) this )[ index ]; }
        inline vec3& operator[]( int index ) { return ( (vec3*) this )[ index ]; }
    };
#else
    VECMATH_INLINE mat43_t mat43( vec3_t x, vec3_t y, vec3_t z, vec3_t w ) { mat43_t m; m.x = x; m.y = y; m.z = z; m.w = w; return m; }
#endif
VECMATH_INLINE mat43_t mat43f( float v ) { vec3_t t = vec3f( v ); return mat43( t, t, t, t ); }

VECMATH_INLINE vec3_t mat43_get( mat43_t m, int row ) { return ( (vec3_t*) &m )[ row ]; }
VECMATH_INLINE void mat43_set( mat43_t* m, int row, vec3_t v ) { ( (vec3_t*) m )[ row ] = v; }

// operators
VECMATH_INLINE mat43_t mat43_neg( mat43_t m ) { return mat43( vec3_neg( m.x ), vec3_neg( m.y ), vec3_neg( m.z ), vec3_neg( m.w ) ); }
VECMATH_INLINE int mat43_eq( mat43_t a, mat43_t b ) { return vec3_eq( a.x, b.x ) && vec3_eq( a.y, b.y ) && vec3_eq( a.z, b.z ) && vec3_eq( a.w, b.w ); }
VECMATH_INLINE mat43_t mat43_add( mat43_t a, mat43_t b ) { return mat43( vec3_add( a.x, b.x ), vec3_add( a.y, b.y ), vec3_add( a.z, b.z ), vec3_add( a.w, b.w ) ); }
VECMATH_INLINE mat43_t mat43_sub( mat43_t a, mat43_t b ) { return mat43( vec3_sub( a.x, b.x ), vec3_sub( a.y, b.y ), vec3_sub( a.z, b.z ), vec3_sub( a.w, b.w ) ); }
VECMATH_INLINE mat43_t mat43_mul_elem( mat43_t a, mat43_t b ) { return mat43( vec3_mul( a.x, b.x ), vec3_mul( a.y, b.y ), vec3_mul( a.z, b.z ), vec3_mul( a.w, b.w ) ); }
VECMATH_INLINE mat43_t mat43_div( mat43_t a, mat43_t b ) { return mat43( vec3_div( a.x, b.x ), vec3_div( a.y, b.y ), vec3_div( a.z, b.z ), vec3_div( a.w, b.w ) ); }
VECMATH_INLINE mat43_t mat43_addf( mat43_t a, float s ) { return mat43( vec3_addf( a.x, s ), vec3_addf( a.y, s ), vec3_addf( a.z, s ), vec3_addf( a.w, s ) ); }
VECMATH_INLINE mat43_t mat43_subf( mat43_t a, float s ) { return mat43( vec3_subf( a.x, s ), vec3_subf( a.y, s ), vec3_subf( a.z, s ), vec3_subf( a.w, s ) ); }
VECMATH_INLINE mat43_t mat43_mulf( mat43_t a, float s ) { return mat43( vec3_mulf( a.x, s ), vec3_mulf( a.y, s ), vec3_mulf( a.z, s ), vec3_mulf( a.w, s ) ); }
VECMATH_INLINE mat43_t mat43_divf( mat43_t a, float s ) { return mat43( vec3_divf( a.x, s ), vec3_divf( a.y, s ), vec3_divf( a.z, s ), vec3_divf( a.w, s ) ); }
VECMATH_INLINE mat43_t mat43_fadd( float s, mat43_t a ) { return mat43_addf( a, s ); }
VECMATH_INLINE mat43_t mat43_fsub( float s, mat43_t a ) { return mat43_sub( mat43f( s ), a ); }
VECMATH_INLINE mat43_t mat43_fmul( float s, mat43_t a ) { return mat43_mulf( a, s ); }
VECMATH_INLINE mat43_t mat43_fdiv( float s, mat43_t a ) { return mat43_div( mat43f( s ), a ); }

// functions
VECMATH_INLINE mat43_t mat43_abs( mat43_t m ) { return mat43( vec3_abs( m.x ), vec3_abs( m.y ), vec3_abs( m.z ), vec3_abs( m.w ) ); }
VECMATH_INLINE mat43_t mat43_acos( mat43_t m ) { return mat43( vec3_acos( m.x ), vec3_acos( m.y ), vec3_acos( m.z ), vec3_acos( m.w ) ); }
VECMATH_INLINE int mat43_all( mat43_t m ) { return vec3_all( m.x ) && vec3_all( m.y ) && vec3_all( m.z ) && vec3_all( m.w ); }
VECMATH_INLINE int mat43_any( mat43_t m ) { return vec3_any( m.x ) || vec3_any( m.y ) || vec3_any( m.z ) || vec3_any( m.w ); }
VECMATH_INLINE mat43_t mat43_asin( mat43_t m ) { return mat43( vec3_asin( m.x ), vec3_asin( m.y ), vec3_asin( m.z ), vec3_asin( m.w ) ); }
VECMATH_INLINE mat43_t mat43_atan( mat43_t m ) { return mat43( vec3_atan( m.x ), vec3_atan( m.y ), vec3_atan( m.z ), vec3_atan( m.w ) ); }
VECMATH_INLINE mat43_t mat43_atan2( mat43_t y, mat43_t x ) { return mat43( vec3_atan2( y.x, x.x ), vec3_atan2( y.y, x.y ), vec3_atan2( y.z, x.z ), vec3_atan2( y.w, x.w ) ); }
VECMATH_INLINE mat43_t mat43_ceil( mat43_t m ) { return mat43( vec3_ceil( m.x ), vec3_ceil( m.y ), vec3_ceil( m.z ), vec3_ceil( m.w ) ); }
VECMATH_INLINE mat43_t mat43_clamp( mat43_t m, mat43_t min_v, mat43_t max_v ) { return mat43( vec3_clamp( m.x, min_v.x, max_v.x ), vec3_clamp( m.y, min_v.y, max_v.y ), vec3_clamp( m.z, min_v.z, max_v.z ), vec3_clamp( m.w, min_v.w, max_v.w ) ); }
VECMATH_INLINE mat43_t mat43_cos( mat43_t m ) { return mat43( vec3_cos( m.x ), vec3_cos( m.y ), vec3_cos( m.z ), vec3_cos( m.w ) ); }
VECMATH_INLINE mat43_t mat43_cosh( mat43_t m ) { return mat43( vec3_cosh( m.x ), vec3_cosh( m.y ), vec3_cosh( m.z ), vec3_cosh( m.w ) ); }
VECMATH_INLINE mat43_t mat43_degrees( mat43_t m ) { return mat43( vec3_degrees( m.x ), vec3_degrees( m.y ), vec3_degrees( m.z ), vec3_degrees( m.w ) ); }
VECMATH_INLINE mat43_t mat43_exp( mat43_t m ) { return mat43( vec3_exp( m.x ), vec3_exp( m.y ), vec3_exp( m.z ), vec3_exp( m.w ) ); }
VECMATH_INLINE mat43_t mat43_exp2( mat43_t m ) { return mat43( vec3_exp2( m.x ), vec3_exp2( m.y ), vec3_exp2( m.z ), vec3_exp2( m.w ) ); }
VECMATH_INLINE mat43_t mat43_floor( mat43_t m ) { return mat43( vec3_floor( m.x ), vec3_floor( m.y ), vec3_floor( m.z ), vec3_floor( m.w ) ); }
VECMATH_INLINE mat43_t mat43_fmod( mat43_t a, mat43_t b ) { return mat43( vec3_fmod( a.x, b.x ), vec3_fmod( a.y, b.y ), vec3_fmod( a.z, b.z ), vec3_fmod( a.w, b.w ) ); }
VECMATH_INLINE mat43_t mat43_frac( mat43_t m ) { return mat43( vec3_frac( m.x ), vec3_frac( m.y ), vec3_frac( m.z ), vec3_frac( m.w ) ); }
VECMATH_INLINE mat43_t mat43_lerp( mat43_t a, mat43_t b, float s ) { return mat43( vec3_lerp( a.x, b.x, s ), vec3_lerp( a.y, b.y, s ), vec3_lerp( a.z, b.z, s ), vec3_lerp( a.w, b.w, s ) ); }
VECMATH_INLINE mat43_t mat43_log( mat43_t m ) { return mat43( vec3_log( m.x ), vec3_log( m.y ), vec3_log( m.z ), vec3_log( m.w ) ); }
VECMATH_INLINE mat43_t mat43_log2( mat43_t m ) { return mat43( vec3_log2( m.x ), vec3_log2( m.y ), vec3_log2( m.z ), vec3_log2( m.w ) ); }
VECMATH_INLINE mat43_t mat43_log10( mat43_t m ) { return mat43( vec3_log10( m.x ), vec3_log10( m.y ), vec3_log10( m.z ), vec3_log10( m.w ) ); }
VECMATH_INLINE mat43_t mat43_max( mat43_t a, mat43_t b ) { return mat43( vec3_max( a.x, b.x ), vec3_max( a.y, b.y ), vec3_max( a.z, b.z ), vec3_max( a.w, b.w ) ); }
VECMATH_INLINE mat43_t mat43_min( mat43_t a, mat43_t b ) { return mat43( vec3_min( a.x, b.x ), vec3_min( a.y, b.y ), vec3_min( a.z, b.z ), vec3_min( a.w, b.w ) ); }
VECMATH_INLINE mat43_t mat43_pow( mat43_t a, mat43_t b ) { return mat43( vec3_pow( a.x, b.x ), vec3_pow( a.y, b.y ), vec3_pow( a.z, b.z ), vec3_pow( a.w, b.w ) ); }
VECMATH_INLINE mat43_t mat43_radians( mat43_t m ) { return mat43( vec3_radians( m.x ), vec3_radians( m.y ), vec3_radians( m.z ), vec3_radians( m.w ) ); }
VECMATH_INLINE mat43_t mat43_rcp( mat43_t m ) { return mat43( vec3_rcp( m.x ), vec3_rcp( m.y ), vec3_rcp( m.z ), vec3_rcp( m.w ) ); }
VECMATH_INLINE mat43_t mat43_round( mat43_t m ) { return mat43( vec3_round( m.x ), vec3_round( m.y ), vec3_round( m.z ), vec3_round( m.w ) ); }
VECMATH_INLINE mat43_t mat43_rsqrt( mat43_t m ) { return mat43( vec3_rsqrt( m.x ), vec3_rsqrt( m.y ), vec3_rsqrt( m.z ), vec3_rsqrt( m.w ) ); }
VECMATH_INLINE mat43_t mat43_saturate( mat43_t m ) { return mat43( vec3_saturate( m.x ), vec3_saturate( m.y ), vec3_saturate( m.z ), vec3_saturate( m.w ) ); }
VECMATH_INLINE mat43_t mat43_sign( mat43_t m ) { return mat43( vec3_sign( m.x ), vec3_sign( m.y ), vec3_sign( m.z ), vec3_sign( m.w ) ); }
VECMATH_INLINE mat43_t mat43_sin( mat43_t m ) { return mat43( vec3_sin( m.x ), vec3_sin( m.y ), vec3_sin( m.z ), vec3_sin( m.w ) ); }
VECMATH_INLINE mat43_t mat43_sinh( mat43_t m ) { return mat43( vec3_sinh( m.x ), vec3_sinh( m.y ), vec3_sinh( m.z ), vec3_sinh( m.w ) ); }
VECMATH_INLINE mat43_t mat43_smoothstep( mat43_t min_v, mat43_t max_v, mat43_t m ) { return mat43( vec3_smoothstep( min_v.x, max_v.x, m.x ), vec3_smoothstep( min_v.y, max_v.y, m.y ), vec3_smoothstep( min_v.z, max_v.z, m.z ), vec3_smoothstep( min_v.w, max_v.w, m.w ) ); }
VECMATH_INLINE mat43_t mat43_smootherstep( mat43_t min_v, mat43_t max_v, mat43_t m ) { return mat43( vec3_smootherstep( min_v.x, max_v.x, m.x ), vec3_smootherstep( min_v.y, max_v.y, m.y ), vec3_smootherstep( min_v.z, max_v.z, m.z ), vec3_smootherstep( min_v.w, max_v.w, m.w ) ); }
VECMATH_INLINE mat43_t mat43_sqrt( mat43_t m ) { return mat43( vec3_sqrt( m.x ), vec3_sqrt( m.y ), vec3_sqrt( m.z ), vec3_sqrt( m.w ) ); }
VECMATH_INLINE mat43_t mat43_step( mat43_t a, mat43_t b ) { return mat43( vec3_step( a.x, b.x ), vec3_step( a.y, b.y ), vec3_step( a.z, b.z ), vec3_step( a.w, b.w ) ); }
VECMATH_INLINE mat43_t mat43_tan( mat43_t m ) { return mat43( vec3_tan( m.x ), vec3_tan( m.y ), vec3_tan( m.z ), vec3_tan( m.w ) ); }
VECMATH_INLINE mat43_t mat43_tanh( mat43_t m ) { return mat43( vec3_tanh( m.x ), vec3_tanh( m.y ), vec3_tanh( m.z ), vec3_tanh( m.w ) ); }
VECMATH_INLINE mat43_t mat43_trunc( mat43_t m ) { return mat43( vec3_trunc( m.x ), vec3_trunc( m.y ), vec3_trunc( m.z ), vec3_trunc( m.w ) ); }


// mat44
#ifdef __cplusplus
    struct mat44 : mat44_t {
        inline mat44() {}
        inline mat44( vec4_t x_, vec4_t y_, vec4_t z_, vec4_t w_ ) { x = x_; y = y_; z = z_; w = w_; }
        inline mat44( mat44_t m ) { x = m.x; y = m.y; z = m.z; w = m.w; }
        inline mat44( float f ) { x = vec4( f ); y = vec4( f ); z = vec4( f ); w = vec4( f ); }
        inline vec4 operator[]( int index ) const { return ( (vec4*) this )[ index ]; }
        inline vec4& operator[]( int index ) { return ( (vec4*) this )[ index ]; }
    };
#else
    VECMATH_INLINE mat44_t mat44( vec4_t x, vec4_t y, vec4_t z, vec4_t w ) { mat44_t m; m.x = x; m.y = y; m.z = z; m.w = w; return m; }
#endif
VECMATH_INLINE mat44_t mat44f( float v ) { mat44_t m; m.x = vec4f( v ); m.y = vec4f( v ); m.z = vec4f( v ); m.w = vec4f( v ); return m; }
    
VECMATH_INLINE vec4_t mat44_get( mat44_t m, int row ) { return ( (vec4_t*) &m )[ row ]; }
VECMATH_INLINE void mat44_set( mat44_t* m, int row, vec4_t v ) { ( (vec4_t*) m )[ row ] = v; }

// operators
VECMATH_INLINE mat44_t mat44_neg( mat44_t m ) { return mat44( vec4_neg( m.x ), vec4_neg( m.y ), vec4_neg( m.z ), vec4_neg( m.w ) ); }
VECMATH_INLINE int mat44_eq( mat44_t a, mat44_t b ) { return vec4_eq( a.x, b.x ) && vec4_eq( a.y, b.y ) && vec4_eq( a.z, b.z ) && vec4_eq( a.w, b.w ); }
VECMATH_INLINE mat44_t mat44_add( mat44_t a, mat44_t b ) { return mat44( vec4_add( a.x, b.x ), vec4_add( a.y, b.y ), vec4_add( a.z, b.z ), vec4_add( a.w, b.w ) ); }
VECMATH_INLINE mat44_t mat44_sub( mat44_t a, mat44_t b ) { return mat44( vec4_sub( a.x, b.x ), vec4_sub( a.y, b.y ), vec4_sub( a.z, b.z ), vec4_sub( a.w, b.w ) ); }
VECMATH_INLINE mat44_t mat44_mul_elem( mat44_t a, mat44_t b ) { return mat44( vec4_mul( a.x, b.x ), vec4_mul( a.y, b.y ), vec4_mul( a.z, b.z ), vec4_mul( a.w, b.w ) ); }
VECMATH_INLINE mat44_t mat44_div( mat44_t a, mat44_t b ) { return mat44( vec4_div( a.x, b.x ), vec4_div( a.y, b.y ), vec4_div( a.z, b.z ), vec4_div( a.w, b.w ) ); }
VECMATH_INLINE mat44_t mat44_addf( mat44_t a, float s ) { return mat44( vec4_addf( a.x, s ), vec4_addf( a.y, s ), vec4_addf( a.z, s ), vec4_addf( a.w, s ) ); }
VECMATH_INLINE mat44_t mat44_subf( mat44_t a, float s ) { return mat44( vec4_subf( a.x, s ), vec4_subf( a.y, s ), vec4_subf( a.z, s ), vec4_subf( a.w, s ) ); }
VECMATH_INLINE mat44_t mat44_mulf( mat44_t a, float s ) { return mat44( vec4_mulf( a.x, s ), vec4_mulf( a.y, s ), vec4_mulf( a.z, s ), vec4_mulf( a.w, s ) ); }
VECMATH_INLINE mat44_t mat44_divf( mat44_t a, float s ) { return mat44( vec4_divf( a.x, s ), vec4_divf( a.y, s ), vec4_divf( a.z, s ), vec4_divf( a.w, s ) ); }
VECMATH_INLINE mat44_t mat44_fadd( float s, mat44_t a ) { return mat44_addf( a, s ); }
VECMATH_INLINE mat44_t mat44_fsub( float s, mat44_t a ) { return mat44_sub( mat44f( s ), a ); }
VECMATH_INLINE mat44_t mat44_fmul( float s, mat44_t a ) { return mat44_mulf( a, s ); }
VECMATH_INLINE mat44_t mat44_fdiv( float s, mat44_t a ) { return mat44_div( mat44f( s ), a ); }
// functions
VECMATH_INLINE mat44_t mat44_abs( mat44_t m ) { return mat44( vec4_abs( m.x ), vec4_abs( m.y ), vec4_abs( m.z ), vec4_abs( m.w ) ); }
VECMATH_INLINE mat44_t mat44_acos( mat44_t m ) { return mat44( vec4_acos( m.x ), vec4_acos( m.y ), vec4_acos( m.z ), vec4_acos( m.w ) ); }
VECMATH_INLINE int mat44_all( mat44_t m ) { return vec4_all( m.x ) && vec4_all( m.y ) && vec4_all( m.z ) && vec4_all( m.w ); }
VECMATH_INLINE int mat44_any( mat44_t m ) { return vec4_any( m.x ) || vec4_any( m.y ) || vec4_any( m.z ) || vec4_any( m.w ); }
VECMATH_INLINE mat44_t mat44_asin( mat44_t m ) { return mat44( vec4_asin( m.x ), vec4_asin( m.y ), vec4_asin( m.z ), vec4_asin( m.w ) ); }
VECMATH_INLINE mat44_t mat44_atan( mat44_t m ) { return mat44( vec4_atan( m.x ), vec4_atan( m.y ), vec4_atan( m.z ), vec4_atan( m.w ) ); }
VECMATH_INLINE mat44_t mat44_atan2( mat44_t y, mat44_t x ) { return mat44( vec4_atan2( y.x, x.x ), vec4_atan2( y.y, x.y ), vec4_atan2( y.z, x.z ), vec4_atan2( y.w, x.w ) ); }
VECMATH_INLINE mat44_t mat44_ceil( mat44_t m ) { return mat44( vec4_ceil( m.x ), vec4_ceil( m.y ), vec4_ceil( m.z ), vec4_ceil( m.w ) ); }
VECMATH_INLINE mat44_t mat44_clamp( mat44_t m, mat44_t min_v, mat44_t max_v ) { return mat44( vec4_clamp( m.x, min_v.x, max_v.x ), vec4_clamp( m.y, min_v.y, max_v.y ), vec4_clamp( m.z, min_v.z, max_v.z ), vec4_clamp( m.w, min_v.w, max_v.w ) ); }
VECMATH_INLINE mat44_t mat44_cos( mat44_t m ) { return mat44( vec4_cos( m.x ), vec4_cos( m.y ), vec4_cos( m.z ), vec4_cos( m.w ) ); }
VECMATH_INLINE mat44_t mat44_cosh( mat44_t m ) { return mat44( vec4_cosh( m.x ), vec4_cosh( m.y ), vec4_cosh( m.z ), vec4_cosh( m.w ) ); }
VECMATH_INLINE mat44_t mat44_degrees( mat44_t m ) { return mat44( vec4_degrees( m.x ), vec4_degrees( m.y ), vec4_degrees( m.z ), vec4_degrees( m.w ) ); } 
VECMATH_INLINE mat44_t mat44_exp( mat44_t m ) { return mat44( vec4_exp( m.x ), vec4_exp( m.y ), vec4_exp( m.z ), vec4_exp( m.w ) ); }
VECMATH_INLINE mat44_t mat44_exp2( mat44_t m ) { return mat44( vec4_exp2( m.x ), vec4_exp2( m.y ), vec4_exp2( m.z ), vec4_exp2( m.w ) ); }
VECMATH_INLINE mat44_t mat44_floor( mat44_t m ) { return mat44( vec4_floor( m.x ), vec4_floor( m.y ), vec4_floor( m.z ), vec4_floor( m.w ) ); }
VECMATH_INLINE mat44_t mat44_fmod( mat44_t a, mat44_t b ) { return mat44( vec4_fmod( a.x, b.x ), vec4_fmod( a.y, b.y ), vec4_fmod( a.z, b.z ), vec4_fmod( a.w, b.w ) ); }
VECMATH_INLINE mat44_t mat44_frac( mat44_t m ) { return mat44( vec4_frac( m.x ), vec4_frac( m.y ), vec4_frac( m.z ), vec4_frac( m.w ) ); }
VECMATH_INLINE mat44_t mat44_lerp( mat44_t a, mat44_t b, float s ) { return mat44( vec4_lerp( a.x, b.x, s ), vec4_lerp( a.y, b.y, s ), vec4_lerp( a.z, b.z, s ), vec4_lerp( a.w, b.w, s ) ); }
VECMATH_INLINE mat44_t mat44_log( mat44_t m ) { return mat44( vec4_log( m.x ), vec4_log( m.y ), vec4_log( m.z ), vec4_log( m.w ) ); }
VECMATH_INLINE mat44_t mat44_log2( mat44_t m ) { return mat44( vec4_log2( m.x ), vec4_log2( m.y ), vec4_log2( m.z ), vec4_log2( m.w ) ); }
VECMATH_INLINE mat44_t mat44_log10( mat44_t m ) { return mat44( vec4_log10( m.x ), vec4_log10( m.y ), vec4_log10( m.z ), vec4_log10( m.w ) ); }
VECMATH_INLINE mat44_t mat44_max( mat44_t a, mat44_t b ) { return mat44( vec4_max( a.x, b.x ), vec4_max( a.y, b.y ), vec4_max( a.z, b.z ), vec4_max( a.w, b.w ) ); }
VECMATH_INLINE mat44_t mat44_min( mat44_t a, mat44_t b ) { return mat44( vec4_min( a.x, b.x ), vec4_min( a.y, b.y ), vec4_min( a.z, b.z ), vec4_min( a.w, b.w ) ); }
VECMATH_INLINE mat44_t mat44_pow( mat44_t a, mat44_t b ) { return mat44( vec4_pow( a.x, b.x ), vec4_pow( a.y, b.y ), vec4_pow( a.z, b.z ), vec4_pow( a.w, b.w ) ); }
VECMATH_INLINE mat44_t mat44_radians( mat44_t m ) { return mat44( vec4_radians( m.x ), vec4_radians( m.y ), vec4_radians( m.z ), vec4_radians( m.w ) ); } 
VECMATH_INLINE mat44_t mat44_rcp( mat44_t m ) { return mat44( vec4_rcp( m.x ), vec4_rcp( m.y ), vec4_rcp( m.z ), vec4_rcp( m.w ) ); }
VECMATH_INLINE mat44_t mat44_round( mat44_t m ) { return mat44( vec4_round( m.x ), vec4_round( m.y ), vec4_round( m.z ), vec4_round( m.w ) ); }
VECMATH_INLINE mat44_t mat44_rsqrt( mat44_t m ) { return mat44( vec4_rsqrt( m.x ), vec4_rsqrt( m.y ), vec4_rsqrt( m.z ), vec4_rsqrt( m.w ) ); }
VECMATH_INLINE mat44_t mat44_saturate( mat44_t m ) { return mat44( vec4_saturate( m.x ), vec4_saturate( m.y ), vec4_saturate( m.z ), vec4_saturate( m.w ) ); }
VECMATH_INLINE mat44_t mat44_sign( mat44_t m ) { return mat44( vec4_sign( m.x ), vec4_sign( m.y ), vec4_sign( m.z ), vec4_sign( m.w ) ); }
VECMATH_INLINE mat44_t mat44_sin( mat44_t m ) { return mat44( vec4_sin( m.x ), vec4_sin( m.y ), vec4_sin( m.z ), vec4_sin( m.w ) ); }
VECMATH_INLINE mat44_t mat44_sinh( mat44_t m ) { return mat44( vec4_sinh( m.x ), vec4_sinh( m.y ), vec4_sinh( m.z ), vec4_sinh( m.w ) ); }
VECMATH_INLINE mat44_t mat44_smoothstep( mat44_t min_v, mat44_t max_v, mat44_t m ) { return mat44( vec4_smoothstep( min_v.x, max_v.x, m.x ), vec4_smoothstep( min_v.y, max_v.y, m.y ), vec4_smoothstep( min_v.z, max_v.z, m.z ), vec4_smoothstep( min_v.w, max_v.w, m.w ) ); }
VECMATH_INLINE mat44_t mat44_smootherstep( mat44_t min_v, mat44_t max_v, mat44_t m ) { return mat44( vec4_smootherstep( min_v.x, max_v.x, m.x ), vec4_smootherstep( min_v.y, max_v.y, m.y ), vec4_smootherstep( min_v.z, max_v.z, m.z ), vec4_smootherstep( min_v.w, max_v.w, m.w ) ); }
VECMATH_INLINE mat44_t mat44_sqrt( mat44_t m ) { return mat44( vec4_sqrt( m.x ), vec4_sqrt( m.y ), vec4_sqrt( m.z ), vec4_sqrt( m.w ) ); }
VECMATH_INLINE mat44_t mat44_step( mat44_t a, mat44_t b ) { return mat44( vec4_step( a.x, b.x ), vec4_step( a.y, b.y ), vec4_step( a.z, b.z ), vec4_step( a.w, b.w ) ); }
VECMATH_INLINE mat44_t mat44_tan( mat44_t m ) { return mat44( vec4_tan( m.x ), vec4_tan( m.y ), vec4_tan( m.z ), vec4_tan( m.w ) ); }
VECMATH_INLINE mat44_t mat44_tanh( mat44_t m ) { return mat44( vec4_tanh( m.x ), vec4_tanh( m.y ), vec4_tanh( m.z ), vec4_tanh( m.w ) ); }
VECMATH_INLINE mat44_t mat44_trunc( mat44_t m ) { return mat44( vec4_trunc( m.x ), vec4_trunc( m.y ), vec4_trunc( m.z ), vec4_trunc( m.w ) ); }


// matrix math

VECMATH_INLINE mat22_t mat22_transpose( mat22_t m ) { return mat22( vec2( m.x.x, m.y.x ), vec2( m.x.y, m.y.y ) ); }
VECMATH_INLINE mat32_t mat23_transpose( mat23_t m ) { return mat32( vec2( m.x.x, m.y.x ), vec2( m.x.y, m.y.y ), vec2( m.x.z, m.y.z ) ); }
VECMATH_INLINE mat23_t mat32_transpose( mat32_t m ) { return mat23( vec3( m.x.x, m.y.x, m.z.x ), vec3( m.x.y, m.y.y, m.z.y ) ); }
VECMATH_INLINE mat33_t mat33_transpose( mat33_t m ) { return mat33( vec3( m.x.x, m.y.x, m.z.x ), vec3( m.x.y, m.y.y, m.z.y ), vec3( m.x.z, m.y.z, m.z.z ) ); }
VECMATH_INLINE mat42_t mat24_transpose( mat24_t m ) { return mat42( vec2( m.x.x, m.y.x ), vec2( m.x.y, m.y.y ), vec2( m.x.z, m.y.z ), vec2( m.x.w, m.y.w ) ); }
VECMATH_INLINE mat43_t mat34_transpose( mat34_t m ) { return mat43( vec3( m.x.x, m.y.x, m.z.x ), vec3( m.x.y, m.y.y, m.z.y ), vec3( m.x.z, m.y.z, m.z.z ), vec3( m.x.w, m.y.w, m.z.w ) ); }
VECMATH_INLINE mat24_t mat42_transpose( mat42_t m ) { return mat24( vec4( m.x.x, m.y.x, m.z.x, m.w.x ), vec4( m.x.y, m.y.y, m.z.y, m.w.y ) ); }
VECMATH_INLINE mat34_t mat43_transpose( mat43_t m ) { return mat34( vec4( m.x.x, m.y.x, m.z.x, m.w.x ), vec4( m.x.y, m.y.y, m.z.y, m.w.y ), vec4( m.x.z, m.y.z, m.z.z, m.w.z ) ); }
VECMATH_INLINE mat44_t mat44_transpose( mat44_t m ) { return mat44( vec4( m.x.x, m.y.x, m.z.x, m.w.x ), vec4( m.x.y, m.y.y, m.z.y, m.w.y ), vec4( m.x.z, m.y.z, m.z.z, m.w.z ), vec4( m.x.w, m.y.w, m.z.w, m.w.w ) ); }

VECMATH_INLINE float mat22_determinant( mat22_t m) { return m.x.x * m.y.y - m.x.y * m.y.x; }
VECMATH_INLINE float mat33_determinant( mat33_t m) { return m.x.x * m.y.y * m.z.z + m.x.y * m.y.z * m.z.x + m.x.z * m.y.x * m.z.y - m.x.x * m.y.z * m.z.y - m.x.y * m.y.x * m.z.z - m.x.z * m.y.y * m.z.x; }
VECMATH_INLINE float mat44_determinant( mat44_t m) { return m.x.w * m.y.z * m.z.y * m.w.x - m.x.z * m.y.w * m.z.y * m.w.x - m.x.w * m.y.y * m.z.z * m.w.x + m.x.y * m.y.w * m.z.z * m.w.x + m.x.z * m.y.y * m.z.w * m.w.x - m.x.y * m.y.z * m.z.w * m.w.x - m.x.w * m.y.z * m.z.x * m.w.y + m.x.z * m.y.w * m.z.x * m.w.y + m.x.w * m.y.x * m.z.z * m.w.y - m.x.x * m.y.w * m.z.z * m.w.y - m.x.z * m.y.x * m.z.w * m.w.y + m.x.x * m.y.z * m.z.w * m.w.y + m.x.w * m.y.y * m.z.x * m.w.z - m.x.y * m.y.w * m.z.x * m.w.z - m.x.w * m.y.x * m.z.y * m.w.z + m.x.x * m.y.w * m.z.y * m.w.z + m.x.y * m.y.x * m.z.w * m.w.z - m.x.x * m.y.y * m.z.w * m.w.z - m.x.z * m.y.y * m.z.x * m.w.w + m.x.y * m.y.z * m.z.x * m.w.w + m.x.z * m.y.x * m.z.y * m.w.w - m.x.x * m.y.z * m.z.y * m.w.w - m.x.y * m.y.x * m.z.z * m.w.w + m.x.x * m.y.y * m.z.z * m.w.w; }

VECMATH_INLINE int mat22_inverse( mat22_t* out_matrix, float* out_determinant, mat22_t m ) { float d = mat22_determinant( m ); if( out_determinant ) *out_determinant = d; if( d != 0.0f && out_matrix ) { *out_matrix = mat22( vec2( m.y.y / d, - m.x.y / d), vec2( - m.y.x / d, m.x.x / d ) ); } return d != 0.0f; }
VECMATH_INLINE int mat33_inverse( mat33_t* out_matrix, float* out_determinant, mat33_t m ) { float d = mat33_determinant( m ); if( out_determinant ) *out_determinant = d; if( d != 0.0f && out_matrix ) { *out_matrix = mat33( vec3( ( m.y.y * m.z.z - m.y.z * m.z.y ) / d, ( m.x.z * m.z.y - m.x.y * m.z.z ) / d, ( m.x.y * m.y.z - m.x.z * m.y.y ) / d ), vec3( ( m.y.z * m.z.x - m.y.x * m.z.z ) / d, ( m.x.x * m.z.z - m.x.z * m.z.x ) / d, ( m.x.z * m.y.x - m.x.x * m.y.z ) / d ), vec3( ( m.y.x * m.z.y - m.y.y * m.z.x ) / d, ( m.x.y * m.z.x - m.x.x * m.z.y ) / d, ( m.x.x * m.y.y - m.x.y * m.y.x ) / d ) ); } return d != 0.0f; }
VECMATH_INLINE int mat44_inverse( mat44_t* out_matrix, float* out_determinant, mat44_t m ) { float d = mat44_determinant( m ); if( out_determinant ) *out_determinant = d; if( d != 0.0f && out_matrix ) { *out_matrix = mat44( vec4( ( m.y.z * m.z.w * m.w.y - m.y.w * m.z.z * m.w.y + m.y.w * m.z.y * m.w.z - m.y.y * m.z.w * m.w.z - m.y.z * m.z.y * m.w.w + m.y.y * m.z.z * m.w.w ) / d, ( m.x.w * m.z.z * m.w.y - m.x.z * m.z.w * m.w.y - m.x.w * m.z.y * m.w.z + m.x.y * m.z.w * m.w.z + m.x.z * m.z.y * m.w.w - m.x.y * m.z.z * m.w.w ) / d, ( m.x.z * m.y.w * m.w.y - m.x.w * m.y.z * m.w.y + m.x.w * m.y.y * m.w.z - m.x.y * m.y.w * m.w.z - m.x.z * m.y.y * m.w.w + m.x.y * m.y.z * m.w.w ) / d, ( m.x.w * m.y.z * m.z.y - m.x.z * m.y.w * m.z.y - m.x.w * m.y.y * m.z.z + m.x.y * m.y.w * m.z.z + m.x.z * m.y.y * m.z.w - m.x.y * m.y.z * m.z.w ) / d ), vec4( ( m.y.w * m.z.z * m.w.x - m.y.z * m.z.w * m.w.x - m.y.w * m.z.x * m.w.z + m.y.x * m.z.w * m.w.z + m.y.z * m.z.x * m.w.w - m.y.x * m.z.z * m.w.w ) / d, ( m.x.z * m.z.w * m.w.x - m.x.w * m.z.z * m.w.x + m.x.w * m.z.x * m.w.z - m.x.x * m.z.w * m.w.z - m.x.z * m.z.x * m.w.w + m.x.x * m.z.z * m.w.w ) / d, ( m.x.w * m.y.z * m.w.x - m.x.z * m.y.w * m.w.x - m.x.w * m.y.x * m.w.z + m.x.x * m.y.w * m.w.z + m.x.z * m.y.x * m.w.w - m.x.x * m.y.z * m.w.w ) / d, ( m.x.z * m.y.w * m.z.x - m.x.w * m.y.z * m.z.x + m.x.w * m.y.x * m.z.z - m.x.x * m.y.w * m.z.z - m.x.z * m.y.x * m.z.w + m.x.x * m.y.z * m.z.w ) / d ), vec4( ( m.y.y * m.z.w * m.w.x - m.y.w * m.z.y * m.w.x + m.y.w * m.z.x * m.w.y - m.y.x * m.z.w * m.w.y - m.y.y * m.z.x * m.w.w + m.y.x * m.z.y * m.w.w ) / d, ( m.x.w * m.z.y * m.w.x - m.x.y * m.z.w * m.w.x - m.x.w * m.z.x * m.w.y + m.x.x * m.z.w * m.w.y + m.x.y * m.z.x * m.w.w - m.x.x * m.z.y * m.w.w ) / d, ( m.x.y * m.y.w * m.w.x - m.x.w * m.y.y * m.w.x + m.x.w * m.y.x * m.w.y - m.x.x * m.y.w * m.w.y - m.x.y * m.y.x * m.w.w + m.x.x * m.y.y * m.w.w ) / d, ( m.x.w * m.y.y * m.z.x - m.x.y * m.y.w * m.z.x - m.x.w * m.y.x * m.z.y + m.x.x * m.y.w * m.z.y + m.x.y * m.y.x * m.z.w - m.x.x * m.y.y * m.z.w ) / d ), vec4( ( m.y.z * m.z.y * m.w.x - m.y.y * m.z.z * m.w.x - m.y.z * m.z.x * m.w.y + m.y.x * m.z.z * m.w.y + m.y.y * m.z.x * m.w.z - m.y.x * m.z.y * m.w.z ) / d, ( m.x.y * m.z.z * m.w.x - m.x.z * m.z.y * m.w.x + m.x.z * m.z.x * m.w.y - m.x.x * m.z.z * m.w.y - m.x.y * m.z.x * m.w.z + m.x.x * m.z.y * m.w.z ) / d, ( m.x.z * m.y.y * m.w.x - m.x.y * m.y.z * m.w.x - m.x.z * m.y.x * m.w.y + m.x.x * m.y.z * m.w.y + m.x.y * m.y.x * m.w.z - m.x.x * m.y.y * m.w.z ) / d, ( m.x.y * m.y.z * m.z.x - m.x.z * m.y.y * m.z.x + m.x.z * m.y.x * m.z.y - m.x.x * m.y.z * m.z.y - m.x.y * m.y.x * m.z.z + m.x.x * m.y.y * m.z.z ) / d ) ); } return d != 0.0f; }     

VECMATH_INLINE mat22_t mat22_identity( void ) { return mat22( vec2( 1.0f, 0.0f ), vec2( 0.0f, 1.0f ) ); }
VECMATH_INLINE mat33_t mat33_identity( void ) { return mat33( vec3( 1.0f, 0.0f, 0.0f ), vec3( 0.0f, 1.0f, 0.0f ), vec3( 0.0f, 0.0f, 1.0f ) ); }
VECMATH_INLINE mat44_t mat44_identity( void ) { return mat44( vec4( 1.0f, 0.0f, 0.0f, 0.0f ), vec4( 0.0f, 1.0f, 0.0f, 0.0f ), vec4( 0.0f, 0.0f, 1.0f, 0.0f ), vec4( 0.0f, 0.0f, 0.0f, 1.0f ) ); }

VECMATH_INLINE int mat22_is_identity( mat22_t m ) { return m.x.x == 1.0f && m.x.y == 0.0f && m.y.x == 0.0f && m.y.y == 1.0f; }
VECMATH_INLINE int mat33_is_identity( mat33_t m ) { return m.x.x == 1.0f && m.x.y == 0.0f && m.x.z == 0.0f && m.y.x == 0.0f && m.y.y == 1.0f && m.y.z == 0.0f && m.z.x == 0.0f && m.z.y == 0.0f && m.z.z == 1.0f; }
VECMATH_INLINE int mat44_is_identity( mat44_t m ) { return m.x.x == 1.0f && m.x.y == 0.0f && m.x.z == 0.0f && m.x.w == 0.0f && m.y.x == 0.0f && m.y.y == 1.0f && m.y.z == 0.0f && m.y.w == 0.0f && m.z.x == 0.0f && m.z.y == 0.0f && m.z.z == 1.0f && m.z.w == 0.0f && m.w.x == 0.0f && m.w.y == 0.0f && m.w.z == 0.0f && m.w.w == 1.0f; }

         

// matrix multiplications        

VECMATH_INLINE float vec2_mul_vec2( vec2_t a, vec2_t b ) { return vec2_dot( a, b ); }
VECMATH_INLINE float vec3_mul_vec3( vec3_t a, vec3_t b ) { return vec3_dot( a, b ); }
VECMATH_INLINE float vec4_mul_vec4( vec4_t a, vec4_t b ) { return vec4_dot( a, b ); }

VECMATH_INLINE vec2_t vec2_mul_mat22( vec2_t a, mat22_t b ) { return vec2( a.x * b.x.x + a.y * b.y.x, a.x * b.x.y + a.y * b.y.y ); }
VECMATH_INLINE vec3_t vec2_mul_mat23( vec2_t a, mat23_t b ) { return vec3( a.x * b.x.x + a.y * b.y.x, a.x * b.x.y + a.y * b.y.y, a.x * b.x.z + a.y * b.y.z ); }
VECMATH_INLINE vec4_t vec2_mul_mat24( vec2_t a, mat24_t b ) { return vec4( a.x * b.x.x + a.y * b.y.x, a.x * b.x.y + a.y * b.y.y, a.x * b.x.z + a.y * b.y.z, a.x * b.x.w + a.y * b.y.w ); }
VECMATH_INLINE vec2_t vec3_mul_mat32( vec3_t a, mat32_t b ) { return vec2( a.x * b.x.x + a.y * b.y.x + a.z * b.z.x, a.x * b.x.y + a.y * b.y.y + a.z * b.z.y ); }
VECMATH_INLINE vec3_t vec3_mul_mat33( vec3_t a, mat33_t b ) { return vec3( a.x * b.x.x + a.y * b.y.x + a.z * b.z.x, a.x * b.x.y + a.y * b.y.y + a.z * b.z.y, a.x * b.x.z + a.y * b.y.z + a.z * b.z.z ); }
VECMATH_INLINE vec4_t vec3_mul_mat34( vec3_t a, mat34_t b ) { return vec4( a.x * b.x.x + a.y * b.y.x + a.z * b.z.x, a.x * b.x.y + a.y * b.y.y + a.z * b.z.y, a.x * b.x.z + a.y * b.y.z + a.z * b.z.z, a.x * b.x.w + a.y * b.y.w + a.z * b.z.w ); }
VECMATH_INLINE vec2_t vec4_mul_mat42( vec4_t a, mat42_t b ) { return vec2( a.x * b.x.x + a.y * b.y.x + a.z * b.z.x + a.w * b.w.x, a.x * b.x.y + a.y * b.y.y + a.z * b.z.y + a.w * b.w.y ); }
VECMATH_INLINE vec3_t vec4_mul_mat43( vec4_t a, mat43_t b ) { return vec3( a.x * b.x.x + a.y * b.y.x + a.z * b.z.x + a.w * b.w.x, a.x * b.x.y + a.y * b.y.y + a.z * b.z.y + a.w * b.w.y, a.x * b.x.z + a.y * b.y.z + a.z * b.z.z + a.w * b.w.z ); }
VECMATH_INLINE vec4_t vec4_mul_mat44( vec4_t a, mat44_t b ) { return vec4( a.x * b.x.x + a.y * b.y.x + a.z * b.z.x + a.w * b.w.x, a.x * b.x.y + a.y * b.y.y + a.z * b.z.y + a.w * b.w.y, a.x * b.x.z + a.y * b.y.z + a.z * b.z.z + a.w * b.w.z, a.x * b.x.w + a.y * b.y.w + a.z * b.z.w + a.w * b.w.w ); }

VECMATH_INLINE vec2_t mat22_mul_vec2( mat22_t a, vec2_t b ) { return vec2( a.x.x * b.x + a.x.y * b.y, a.y.x * b.x + a.y.y * b.y ); }
VECMATH_INLINE vec3_t mat32_mul_vec2( mat32_t a, vec2_t b ) { return vec3( a.x.x * b.x + a.x.y * b.y, a.y.x * b.x + a.y.y * b.y, a.z.x * b.x + a.z.y * b.y ); }
VECMATH_INLINE vec4_t mat42_mul_vec2( mat42_t a, vec2_t b ) { return vec4( a.x.x * b.x + a.x.y * b.y, a.y.x * b.x + a.y.y * b.y, a.z.x * b.x + a.z.y * b.y, a.w.x * b.x + a.w.y * b.y ); }
VECMATH_INLINE vec2_t mat23_mul_vec3( mat23_t a, vec3_t b ) { return vec2( a.x.x * b.x + a.x.y * b.y + a.x.z * b.z, a.y.x * b.x + a.y.y * b.y + a.y.z * b.z ); }
VECMATH_INLINE vec3_t mat33_mul_vec3( mat33_t a, vec3_t b ) { return vec3( a.x.x * b.x + a.x.y * b.y + a.x.z * b.z, a.y.x * b.x + a.y.y * b.y + a.y.z * b.z, a.z.x * b.x + a.z.y * b.y + a.z.z * b.z ); }
VECMATH_INLINE vec4_t mat43_mul_vec3( mat43_t a, vec3_t b ) { return vec4( a.x.x * b.x + a.x.y * b.y + a.x.z * b.z, a.y.x * b.x + a.y.y * b.y + a.y.z * b.z, a.z.x * b.x + a.z.y * b.y + a.z.z * b.z, a.w.x * b.x + a.w.y * b.y + a.w.z * b.z ); }
VECMATH_INLINE vec2_t mat24_mul_vec4( mat24_t a, vec4_t b ) { return vec2( a.x.x * b.x + a.x.y * b.y + a.x.z * b.z + a.x.w * b.w, a.y.x * b.x + a.y.y * b.y + a.y.z * b.z + a.y.w * b.w ); }
VECMATH_INLINE vec3_t mat34_mul_vec4( mat34_t a, vec4_t b ) { return vec3( a.x.x * b.x + a.x.y * b.y + a.x.z * b.z + a.x.w * b.w, a.y.x * b.x + a.y.y * b.y + a.y.z * b.z + a.y.w * b.w, a.z.x * b.x + a.z.y * b.y + a.z.z * b.z + a.z.w * b.w ); }
VECMATH_INLINE vec4_t mat44_mul_vec4( mat44_t a, vec4_t b ) { return vec4( a.x.x * b.x + a.x.y * b.y + a.x.z * b.z + a.x.w * b.w, a.y.x * b.x + a.y.y * b.y + a.y.z * b.z + a.y.w * b.w, a.z.x * b.x + a.z.y * b.y + a.z.z * b.z + a.z.w * b.w, a.w.x * b.x + a.w.y * b.y + a.w.z * b.z + a.w.w * b.w );}

VECMATH_INLINE mat22_t mat22_mul_mat22( mat22_t a, mat22_t b ) { return mat22( vec2( a.x.x * b.x.x + a.x.y * b.y.x, a.x.x * b.x.y + a.x.y * b.y.y ), vec2( a.y.x * b.x.x + a.y.y * b.y.x, a.y.x * b.x.y + a.y.y * b.y.y ) ); }
VECMATH_INLINE mat23_t mat22_mul_mat23( mat22_t a, mat23_t b ) { return mat23( vec3( a.x.x * b.x.x + a.x.y * b.y.x, a.x.x * b.x.y + a.x.y * b.y.y, a.x.x * b.x.z + a.x.y * b.y.z ), vec3( a.y.x * b.x.x + a.y.y * b.y.x, a.y.x * b.x.y + a.y.y * b.y.y, a.y.x * b.x.z + a.y.y * b.y.z ) ); }
VECMATH_INLINE mat24_t mat22_mul_mat24( mat22_t a, mat24_t b ) { return mat24( vec4( a.x.x * b.x.x + a.x.y * b.y.x, a.x.x * b.x.y + a.x.y * b.y.y, a.x.x * b.x.z + a.x.y * b.y.z, a.x.x * b.x.w + a.x.y * b.y.w ), vec4( a.y.x * b.x.x + a.y.y * b.y.x, a.y.x * b.x.y + a.y.y * b.y.y, a.y.x * b.x.z + a.y.y * b.y.z, a.y.x * b.x.w + a.y.y * b.y.w ) ); }
VECMATH_INLINE mat22_t mat23_mul_mat32( mat23_t a, mat32_t b ) { return mat22( vec2( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y ), vec2( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y ) ); }
VECMATH_INLINE mat23_t mat23_mul_mat33( mat23_t a, mat33_t b ) { return mat23( vec3( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z ), vec3( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z ) ); }
VECMATH_INLINE mat24_t mat23_mul_mat34( mat23_t a, mat34_t b ) { return mat24( vec4( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z, a.x.x * b.x.w + a.x.y * b.y.w + a.x.z * b.z.w ), vec4( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z, a.y.x * b.x.w + a.y.y * b.y.w + a.y.z * b.z.w ) ); }
VECMATH_INLINE mat22_t mat24_mul_mat42( mat24_t a, mat42_t b ) { return mat22( vec2( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x + a.x.w * b.w.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y + a.x.w * b.w.y ), vec2( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x + a.y.w * b.w.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y + a.y.w * b.w.y ) ); }
VECMATH_INLINE mat23_t mat24_mul_mat43( mat24_t a, mat43_t b ) { return mat23( vec3( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x + a.x.w * b.w.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y + a.x.w * b.w.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z + a.x.w * b.w.z ), vec3( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x + a.y.w * b.w.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y + a.y.w * b.w.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z + a.y.w * b.w.z ) ); }
VECMATH_INLINE mat24_t mat24_mul_mat44( mat24_t a, mat44_t b ) { return mat24( vec4( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x + a.x.w * b.w.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y + a.x.w * b.w.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z + a.x.w * b.w.z, a.x.x * b.x.w + a.x.y * b.y.w + a.x.z * b.z.w + a.x.w * b.w.w ), vec4( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x + a.y.w * b.w.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y + a.y.w * b.w.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z + a.y.w * b.w.z, a.y.x * b.x.w + a.y.y * b.y.w + a.y.z * b.z.w + a.y.w * b.w.w ) ); }

VECMATH_INLINE mat32_t mat32_mul_mat22( mat32_t a, mat22_t b ) { return mat32( vec2( a.x.x * b.x.x + a.x.y * b.y.x, a.x.x * b.x.y + a.x.y * b.y.y ), vec2( a.y.x * b.x.x + a.y.y * b.y.x, a.y.x * b.x.y + a.y.y * b.y.y ), vec2( a.z.x * b.x.x + a.z.y * b.y.x, a.z.x * b.x.y + a.z.y * b.y.y ) ); }
VECMATH_INLINE mat33_t mat32_mul_mat23( mat32_t a, mat23_t b ) { return mat33( vec3( a.x.x * b.x.x + a.x.y * b.y.x, a.x.x * b.x.y + a.x.y * b.y.y, a.x.x * b.x.z + a.x.y * b.y.z ), vec3( a.y.x * b.x.x + a.y.y * b.y.x, a.y.x * b.x.y + a.y.y * b.y.y, a.y.x * b.x.z + a.y.y * b.y.z ), vec3( a.z.x * b.x.x + a.z.y * b.y.x, a.z.x * b.x.y + a.z.y * b.y.y, a.z.x * b.x.z + a.z.y * b.y.z ) ); }
VECMATH_INLINE mat34_t mat32_mul_mat24( mat32_t a, mat24_t b ) { return mat34( vec4( a.x.x * b.x.x + a.x.y * b.y.x, a.x.x * b.x.y + a.x.y * b.y.y, a.x.x * b.x.z + a.x.y * b.y.z, a.x.x * b.x.w + a.x.y * b.y.w ), vec4( a.y.x * b.x.x + a.y.y * b.y.x, a.y.x * b.x.y + a.y.y * b.y.y, a.y.x * b.x.z + a.y.y * b.y.z, a.y.x * b.x.w + a.y.y * b.y.w ), vec4( a.z.x * b.x.x + a.z.y * b.y.x, a.z.x * b.x.y + a.z.y * b.y.y, a.z.x * b.x.z + a.z.y * b.y.z, a.z.x * b.x.w + a.z.y * b.y.w ) ); }
VECMATH_INLINE mat32_t mat33_mul_mat32( mat33_t a, mat32_t b ) { return mat32( vec2( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y ), vec2( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y ), vec2( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y ) ); }
VECMATH_INLINE mat33_t mat33_mul_mat33( mat33_t a, mat33_t b ) { return mat33( vec3( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z ), vec3( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z ), vec3( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y, a.z.x * b.x.z + a.z.y * b.y.z + a.z.z * b.z.z ) ); }
VECMATH_INLINE mat34_t mat33_mul_mat34( mat33_t a, mat34_t b ) { return mat34( vec4( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z, a.x.x * b.x.w + a.x.y * b.y.w + a.x.z * b.z.w ), vec4( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z, a.y.x * b.x.w + a.y.y * b.y.w + a.y.z * b.z.w ), vec4( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y, a.z.x * b.x.z + a.z.y * b.y.z + a.z.z * b.z.z, a.z.x * b.x.w + a.z.y * b.y.w + a.z.z * b.z.w ) ); }
VECMATH_INLINE mat32_t mat34_mul_mat42( mat34_t a, mat42_t b ) { return mat32( vec2( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x + a.x.w * b.w.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y + a.x.w * b.w.y ), vec2( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x + a.y.w * b.w.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y + a.y.w * b.w.y ), vec2( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x + a.z.w * b.w.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y + a.z.w * b.w.y ) ); }
VECMATH_INLINE mat33_t mat34_mul_mat43( mat34_t a, mat43_t b ) { return mat33( vec3( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x + a.x.w * b.w.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y + a.x.w * b.w.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z + a.x.w * b.w.z ), vec3( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x + a.y.w * b.w.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y + a.y.w * b.w.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z + a.y.w * b.w.z ), vec3( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x + a.z.w * b.w.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y + a.z.w * b.w.y, a.z.x * b.x.z + a.z.y * b.y.z + a.z.z * b.z.z + a.z.w * b.w.z ) );}
VECMATH_INLINE mat34_t mat34_mul_mat44( mat34_t a, mat44_t b ) { return mat34( vec4( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x + a.x.w * b.w.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y + a.x.w * b.w.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z + a.x.w * b.w.z, a.x.x * b.x.w + a.x.y * b.y.w + a.x.z * b.z.w + a.x.w * b.w.w ), vec4( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x + a.y.w * b.w.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y + a.y.w * b.w.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z + a.y.w * b.w.z, a.y.x * b.x.w + a.y.y * b.y.w + a.y.z * b.z.w + a.y.w * b.w.w ), vec4( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x + a.z.w * b.w.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y + a.z.w * b.w.y, a.z.x * b.x.z + a.z.y * b.y.z + a.z.z * b.z.z + a.z.w * b.w.z, a.z.x * b.x.w + a.z.y * b.y.w + a.z.z * b.z.w + a.z.w * b.w.w ) ); }

VECMATH_INLINE mat42_t mat42_mul_mat22( mat42_t a, mat22_t b ) { return mat42( vec2( a.x.x * b.x.x + a.x.y * b.y.x, a.x.x * b.x.y + a.x.y * b.y.y ), vec2( a.y.x * b.x.x + a.y.y * b.y.x, a.y.x * b.x.y + a.y.y * b.y.y ), vec2( a.z.x * b.x.x + a.z.y * b.y.x, a.z.x * b.x.y + a.z.y * b.y.y ), vec2( a.w.x * b.x.x + a.w.y * b.y.x, a.w.x * b.x.y + a.w.y * b.y.y ) ); }
VECMATH_INLINE mat43_t mat42_mul_mat23( mat42_t a, mat23_t b ) { return mat43( vec3( a.x.x * b.x.x + a.x.y * b.y.x, a.x.x * b.x.y + a.x.y * b.y.y, a.x.x * b.x.z + a.x.y * b.y.z ), vec3( a.y.x * b.x.x + a.y.y * b.y.x, a.y.x * b.x.y + a.y.y * b.y.y, a.y.x * b.x.z + a.y.y * b.y.z ), vec3( a.z.x * b.x.x + a.z.y * b.y.x, a.z.x * b.x.y + a.z.y * b.y.y, a.z.x * b.x.z + a.z.y * b.y.z ), vec3( a.w.x * b.x.x + a.w.y * b.y.x, a.w.x * b.x.y + a.w.y * b.y.y, a.w.x * b.x.z + a.w.y * b.y.z ) ); }
VECMATH_INLINE mat44_t mat42_mul_mat24( mat42_t a, mat24_t b ) { return mat44( vec4( a.x.x * b.x.x + a.x.y * b.y.x, a.x.x * b.x.y + a.x.y * b.y.y, a.x.x * b.x.z + a.x.y * b.y.z, a.x.x * b.x.w + a.x.y * b.y.w ), vec4( a.y.x * b.x.x + a.y.y * b.y.x, a.y.x * b.x.y + a.y.y * b.y.y, a.y.x * b.x.z + a.y.y * b.y.z, a.y.x * b.x.w + a.y.y * b.y.w ), vec4( a.z.x * b.x.x + a.z.y * b.y.x, a.z.x * b.x.y + a.z.y * b.y.y, a.z.x * b.x.z + a.z.y * b.y.z, a.z.x * b.x.w + a.z.y * b.y.w ), vec4( a.w.x * b.x.x + a.w.y * b.y.x, a.w.x * b.x.y + a.w.y * b.y.y, a.w.x * b.x.z + a.w.y * b.y.z, a.w.x * b.x.w + a.w.y * b.y.w ) ); }
VECMATH_INLINE mat42_t mat43_mul_mat32( mat43_t a, mat32_t b ) { return mat42( vec2( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y ), vec2( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y ), vec2( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y ), vec2( a.w.x * b.x.x + a.w.y * b.y.x + a.w.z * b.z.x, a.w.x * b.x.y + a.w.y * b.y.y + a.w.z * b.z.y ) ); }
VECMATH_INLINE mat43_t mat43_mul_mat33( mat43_t a, mat33_t b ) { return mat43( vec3( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z ), vec3( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z ), vec3( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y, a.z.x * b.x.z + a.z.y * b.y.z + a.z.z * b.z.z ), vec3( a.w.x * b.x.x + a.w.y * b.y.x + a.w.z * b.z.x, a.w.x * b.x.y + a.w.y * b.y.y + a.w.z * b.z.y, a.w.x * b.x.z + a.w.y * b.y.z + a.w.z * b.z.z ) ); }
VECMATH_INLINE mat44_t mat43_mul_mat34( mat43_t a, mat34_t b ) { return mat44( vec4( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z, a.x.x * b.x.w + a.x.y * b.y.w + a.x.z * b.z.w ), vec4( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z, a.y.x * b.x.w + a.y.y * b.y.w + a.y.z * b.z.w ), vec4( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y, a.z.x * b.x.z + a.z.y * b.y.z + a.z.z * b.z.z, a.z.x * b.x.w + a.z.y * b.y.w + a.z.z * b.z.w ), vec4( a.w.x * b.x.x + a.w.y * b.y.x + a.w.z * b.z.x, a.w.x * b.x.y + a.w.y * b.y.y + a.w.z * b.z.y, a.w.x * b.x.z + a.w.y * b.y.z + a.w.z * b.z.z, a.w.x * b.x.w + a.w.y * b.y.w + a.w.z * b.z.w ) ); }
VECMATH_INLINE mat42_t mat44_mul_mat42( mat44_t a, mat42_t b ) { return mat42( vec2( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x + a.x.w * b.w.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y + a.x.w * b.w.y ), vec2( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x + a.y.w * b.w.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y + a.y.w * b.w.y ), vec2( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x + a.z.w * b.w.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y + a.z.w * b.w.y ), vec2( a.w.x * b.x.x + a.w.y * b.y.x + a.w.z * b.z.x + a.w.w * b.w.x, a.w.x * b.x.y + a.w.y * b.y.y + a.w.z * b.z.y + a.w.w * b.w.y ) ); }
VECMATH_INLINE mat43_t mat44_mul_mat43( mat44_t a, mat43_t b ) { return mat43( vec3( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x + a.x.w * b.w.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y + a.x.w * b.w.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z + a.x.w * b.w.z ), vec3( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x + a.y.w * b.w.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y + a.y.w * b.w.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z + a.y.w * b.w.z ), vec3( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x + a.z.w * b.w.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y + a.z.w * b.w.y, a.z.x * b.x.z + a.z.y * b.y.z + a.z.z * b.z.z + a.z.w * b.w.z ), vec3( a.w.x * b.x.x + a.w.y * b.y.x + a.w.z * b.z.x + a.w.w * b.w.x, a.w.x * b.x.y + a.w.y * b.y.y + a.w.z * b.z.y + a.w.w * b.w.y, a.w.x * b.x.z + a.w.y * b.y.z + a.w.z * b.z.z + a.w.w * b.w.z ) ); }
VECMATH_INLINE mat44_t mat44_mul_mat44( mat44_t a, mat44_t b ) { return mat44( vec4( a.x.x * b.x.x + a.x.y * b.y.x + a.x.z * b.z.x + a.x.w * b.w.x, a.x.x * b.x.y + a.x.y * b.y.y + a.x.z * b.z.y + a.x.w * b.w.y, a.x.x * b.x.z + a.x.y * b.y.z + a.x.z * b.z.z + a.x.w * b.w.z, a.x.x * b.x.w + a.x.y * b.y.w + a.x.z * b.z.w + a.x.w * b.w.w ), vec4( a.y.x * b.x.x + a.y.y * b.y.x + a.y.z * b.z.x + a.y.w * b.w.x, a.y.x * b.x.y + a.y.y * b.y.y + a.y.z * b.z.y + a.y.w * b.w.y, a.y.x * b.x.z + a.y.y * b.y.z + a.y.z * b.z.z + a.y.w * b.w.z, a.y.x * b.x.w + a.y.y * b.y.w + a.y.z * b.z.w + a.y.w * b.w.w ), vec4( a.z.x * b.x.x + a.z.y * b.y.x + a.z.z * b.z.x + a.z.w * b.w.x, a.z.x * b.x.y + a.z.y * b.y.y + a.z.z * b.z.y + a.z.w * b.w.y, a.z.x * b.x.z + a.z.y * b.y.z + a.z.z * b.z.z + a.z.w * b.w.z, a.z.x * b.x.w + a.z.y * b.y.w + a.z.z * b.z.w + a.z.w * b.w.w ), vec4( a.w.x * b.x.x + a.w.y * b.y.x + a.w.z * b.z.x + a.w.w * b.w.x, a.w.x * b.x.y + a.w.y * b.y.y + a.w.z * b.z.y + a.w.w * b.w.y, a.w.x * b.x.z + a.w.y * b.y.z + a.w.z * b.z.z + a.w.w * b.w.z, a.w.x * b.x.w + a.w.y * b.y.w + a.w.z * b.z.w + a.w.w * b.w.w ) ); }


// quaternions

VECMATH_INLINE vec4_t quat_normalize( vec4_t q ) { return vec4_normalize( q ); } 
VECMATH_INLINE vec4_t quat_slerp( vec4_t a, vec4_t b, float t ) { float dot = vec4_dot( a, b ); if( dot < 0.0f ) { b = vec4_neg( b ); dot = -dot; } if( dot > 0.9995f ) { vec4_t result = vec4_add( vec4_mulf( a, 1.0f - t ), vec4_mulf( b, t ) ); return quat_normalize( result ); } float theta = vecmath_acos( dot ); float sin_theta = vecmath_sin( theta ); float s0 = vecmath_sin( ( 1.0f - t ) * theta ) / sin_theta; float s1 = vecmath_sin( t * theta ) / sin_theta; return vec4_add( vec4_mulf( a, s0 ), vec4_mulf( b, s1 ) ); } 
VECMATH_INLINE vec4_t quat_barycentric( vec4_t q1, vec4_t q2, vec4_t q3, float f, float g ) { float fg = f + g; return fg == 0.0f ? q1 : quat_slerp( quat_slerp( q1, q2, fg ), quat_slerp( q1, q3, fg ), g / fg ); } 
VECMATH_INLINE vec4_t quat_conjugate( vec4_t q ) { return vec4( -q.x, -q.y, -q.z, q.w ); } 
VECMATH_INLINE vec4_t quat_exp( vec4_t q ) { vec3_t v = vec3( q.x, q.y, q.z ); float angle = vecmath_sqrt( vec3_dot( v, v ) ); float s = (angle > 0.00001f) ? vecmath_sin( angle ) / angle : 1.0f; return vec4( v.x * s, v.y * s, v.z * s, vecmath_cos( angle ) ); }
VECMATH_INLINE vec4_t quat_identity( void ) { return vec4( 0.0f, 0.0f, 0.0f, 1.0f ); } 
VECMATH_INLINE vec4_t quat_inverse( vec4_t q ) { float dot = vec4_dot( q, q ); return dot == 0.0f ? quat_identity() : vec4_mulf( vec4( -q.x, -q.y, -q.z, q.w ), 1.0f / dot ); } 
VECMATH_INLINE int quat_is_identity( vec4_t q ) { return q.x == 0.0f && q.y == 0.0f && q.z == 0.0f && q.w == 1.0f; } 
VECMATH_INLINE vec4_t quat_ln( vec4_t q ) { float epsilon = 1.0f - 0.00001f; float w = q.w; vec3_t v = vec3( q.x, q.y, q.z ); vec4_t result; if( vecmath_abs(w) < epsilon ) { float theta = vecmath_acos(w); float sin_theta = vecmath_sin( theta ); float scale = theta / sin_theta; result = vec4( v.x * scale, v.y * scale, v.z * scale, 0.0f ); } else { result = vec4( v.x, v.y, v.z, 0.0f ); } return result; }
VECMATH_INLINE vec4_t quat_mul( vec4_t a, vec4_t b ) { return vec4( b.w*a.x + b.x*a.w + b.y*a.z - b.z*a.y, b.w*a.y - b.x*a.z + b.y*a.w + b.z*a.x, b.w*a.z + b.x*a.y - b.y*a.x + b.z*a.w, b.w*a.w - b.x*a.x - b.y*a.y - b.z*a.z ); }
VECMATH_INLINE vec4_t quat_rotation_axis( vec3_t axis, float angle ) { return vec4v3f( vec3_mulf( vec3_normalize( axis ), vecmath_sin( angle * 0.5f ) ), vecmath_cos( angle * 0.5f ) ); } 
VECMATH_INLINE vec4_t quat_rotation_matrix( mat44_t m ) { float trace = m.x.x + m.y.y + m.z.z; if( trace > 0.0f ) { float s = vecmath_sqrt( trace + 1.0f ) * 2.0f; return vec4( ( m.y.z - m.z.y ) / s, ( m.z.x - m.x.z ) / s, ( m.x.y - m.y.x ) / s, 0.25f * s ); } else if( m.x.x > m.y.y && m.x.x > m.z.z ) { float s = vecmath_sqrt( 1.0f + m.x.x - m.y.y - m.z.z ) * 2.0f; return vec4( 0.25f * s, ( m.x.y + m.y.x ) / s, ( m.x.z + m.z.x ) / s, ( m.y.z - m.z.y ) / s ); } else if( m.y.y > m.z.z ) { float s = vecmath_sqrt( 1.0f + m.y.y - m.x.x - m.z.z ) * 2.0f; return vec4( ( m.y.x + m.x.y ) / s, 0.25f * s, ( m.y.z + m.z.y ) / s, ( m.z.x - m.x.z ) / s ); } else { float s = vecmath_sqrt( 1.0f + m.z.z - m.x.x - m.y.y ) * 2.0f; return vec4( ( m.z.x + m.x.z ) / s, ( m.z.y + m.y.z ) / s, 0.25f * s, ( m.x.y - m.y.x ) / s ); } } 
VECMATH_INLINE vec4_t quat_rotation_yaw_pitch_roll(float yaw, float pitch, float roll) { float hy = yaw * 0.5f; float hp = pitch * 0.5f; float hr = roll * 0.5f; float cy = vecmath_cos( hy ); float sy = vecmath_sin( hy ); float cp = vecmath_cos( hp ); float sp = vecmath_sin( hp ); float cr = vecmath_cos( hr ); float sr = vecmath_sin( hr ); return vec4( cr * sp * cy + sr * cp * sy, cr * cp * sy - sr * sp * cy, sr * cp * cy - cr * sp * sy, cr * cp * cy + sr * sp * sy ); }
VECMATH_INLINE void quat_squad_setup( vec4_t* out_a, vec4_t* out_b, vec4_t* out_c, vec4_t q0, vec4_t q1, vec4_t q2, vec4_t q3 ) { vec4_t sq2 = vec4_dot(vec4_add(q1, q2), vec4_add(q1, q2)) < vec4_dot(vec4_sub(q1, q2), vec4_sub(q1, q2)) ? vec4_neg(q2) : q2; vec4_t sq0 = vec4_dot(vec4_add(q0, q1), vec4_add(q0, q1)) < vec4_dot(vec4_sub(q0, q1), vec4_sub(q0, q1)) ? vec4_neg(q0) : q0; vec4_t sq3 = vec4_dot(vec4_add(sq2, q3), vec4_add(sq2, q3)) < vec4_dot(vec4_sub(sq2, q3), vec4_sub(sq2, q3)) ? vec4_neg(q3) : q3; vec4_t invq1 = quat_inverse(q1); vec4_t invq2 = quat_inverse(sq2); vec4_t lnq0 = quat_ln(quat_mul(invq1, sq0)); vec4_t lnq2 = quat_ln(quat_mul(invq1, sq2)); vec4_t lnq1 = quat_ln(quat_mul(invq2, q1)); vec4_t lnq3 = quat_ln(quat_mul(invq2, sq3)); vec4_t expq02 = quat_exp(vec4_mulf(vec4_add(lnq0, lnq2), -0.25f)); vec4_t expq13 = quat_exp(vec4_mulf(vec4_add(lnq1, lnq3), -0.25f)); if( out_a ) *out_a = quat_mul(q1, expq02); if( out_b ) *out_b = quat_mul(sq2, expq13); if( out_c ) *out_c = sq2; }
VECMATH_INLINE vec4_t quat_squad(vec4_t q1, vec4_t a, vec4_t b, vec4_t c, float t ) { return quat_slerp( quat_slerp( q1, c, t ), quat_slerp( a, b, t ), 2.0f * t * ( 1.0f - t ) ); }
VECMATH_INLINE void quat_to_axis_angle( vec4_t q, vec3_t* out_axis, float* out_angle ) { if( out_angle ) *out_angle = 2.0f * vecmath_acos( q.w ); if( out_axis ) *out_axis = vec3( q.x, q.y, q.z ); }
VECMATH_INLINE vec3_t quat_rotate_vector( vec3_t v, vec4_t q ) { vec3_t u = vec3( q.x, q.y, q.z ); float s = q.w; vec3_t t = vec3_mulf( vec3_cross( u, v ), 2.0f ); return vec3_add( v, vec3_add( vec3_mulf( t, s ), vec3_cross( u, t ) ) ); } 
VECMATH_INLINE vec4_t quat_shortest_arc( vec3_t from, vec3_t to ) { vec3_t f = vec3_normalize( from ); vec3_t t = vec3_normalize( to ); float d = vec3_dot( f, t ); if ( d == 1.0f ) { return quat_identity( ); } if ( d == -1.0f ) { vec3_t axis = vecmath_abs( f.x ) < 1.0f ? vec3( 1, 0, 0 ) : vec3( 0, 1, 0 ); axis = vec3_normalize( vec3_cross( f, axis ) ); return quat_rotation_axis( axis, 3.14159265f ); } vec3_t axis = vec3_cross( f, t ); float s = vecmath_sqrt( ( 1.0f + d ) * 2.0f ); float invs = 1.0f / s; return vec4( axis.x * invs, axis.y * invs, axis.z * invs, 0.5f * s ); } 
VECMATH_INLINE vec4_t quat_from_mat33( mat33_t m ) { float trace = m.x.x + m.y.y + m.z.z; if ( trace > 0.0f ) { float s = vecmath_sqrt( trace + 1.0f ) * 2.0f; float invs = 1.0f / s; return vec4( ( m.y.z - m.z.y ) * invs, ( m.z.x - m.x.z ) * invs, ( m.x.y - m.y.x ) * invs, 0.25f * s ); } if ( m.x.x > m.y.y && m.x.x > m.z.z ) { float s = vecmath_sqrt( 1.0f + m.x.x - m.y.y - m.z.z ) * 2.0f; float invs = 1.0f / s; return vec4( 0.25f * s, ( m.x.y + m.y.x ) * invs, ( m.x.z + m.z.x ) * invs, ( m.y.z - m.z.y ) * invs ); } if ( m.y.y > m.z.z ) { float s = vecmath_sqrt( 1.0f + m.y.y - m.x.x - m.z.z ) * 2.0f; float invs = 1.0f / s; return vec4( ( m.x.y + m.y.x ) * invs, 0.25f * s, ( m.y.z + m.z.y ) * invs, ( m.z.x - m.x.z ) * invs ); } float s = vecmath_sqrt( 1.0f + m.z.z - m.x.x - m.y.y ) * 2.0f; float invs = 1.0f / s; return vec4( ( m.x.z + m.z.x ) * invs, ( m.y.z + m.z.y ) * invs, 0.25f * s, ( m.x.y - m.y.x ) * invs ); } 
VECMATH_INLINE vec4_t quat_from_mat44( mat44_t m ) { return quat_from_mat33( mat33( vec3( m.x.x, m.x.y, m.x.z ), vec3( m.y.x, m.y.y, m.y.z ), vec3( m.z.x, m.z.y, m.z.z ) ) ); } 
VECMATH_INLINE float quat_angle( vec4_t a, vec4_t b ) { float d = vec4_dot( a, b ); d = vecmath_clamp( d, -1.0f, 1.0f ); return 2.0f * vecmath_acos( vecmath_abs( d ) ); } 
VECMATH_INLINE mat33_t mat33_from_quat( vec4_t q ) { float x = q.x, y = q.y, z = q.z, w = q.w; float xx = x * x, yy = y * y, zz = z * z; float xy = x * y, xz = x * z, yz = y * z; float wx = w * x, wy = w * y, wz = w * z; return mat33( vec3( 1.0f - 2.0f * (yy + zz), 2.0f * (xy + wz), 2.0f * (xz - wy) ), vec3( 2.0f * (xy - wz), 1.0f - 2.0f * (xx + zz), 2.0f * (yz + wx) ), vec3( 2.0f * (xz + wy), 2.0f * (yz - wx), 1.0f - 2.0f * (xx + yy) ) ); }
VECMATH_INLINE mat44_t mat44_from_quat( vec4_t q ) { mat33_t r = mat33_from_quat( q ); return mat44( vec4( r.x.x, r.x.y, r.x.z, 0.0f ), vec4( r.y.x, r.y.y, r.y.z, 0.0f ), vec4( r.z.x, r.z.y, r.z.z, 0.0f ), vec4( 0.0f, 0.0f, 0.0f, 1.0f ) ); } 


// matrix utils

VECMATH_INLINE mat44_t mat44_look_at_lh( vec3_t eye, vec3_t at, vec3_t up ) { vec3_t zaxis = vec3_normalize( vec3_sub( at, eye ) ); vec3_t xaxis = vec3_normalize( vec3_cross( up, zaxis ) ); vec3_t yaxis = vec3_cross( zaxis, xaxis ); return mat44( vec4( xaxis.x, yaxis.x, zaxis.x, 0.0f ), vec4( xaxis.y, yaxis.y, zaxis.y, 0.0f ), vec4( xaxis.z, yaxis.z, zaxis.z, 0.0f ), vec4( -vec3_dot( xaxis, eye ), -vec3_dot( yaxis, eye ), -vec3_dot( zaxis, eye ), 1.0f ) ); }
VECMATH_INLINE mat44_t mat44_look_at_rh( vec3_t eye, vec3_t at, vec3_t up ) { vec3_t zaxis = vec3_normalize( vec3_sub( eye, at ) ); vec3_t xaxis = vec3_normalize( vec3_cross( up, zaxis ) ); vec3_t yaxis = vec3_cross( zaxis, xaxis ); return mat44( vec4( xaxis.x, yaxis.x, zaxis.x, 0.0f ), vec4( xaxis.y, yaxis.y, zaxis.y, 0.0f ), vec4( xaxis.z, yaxis.z, zaxis.z, 0.0f ), vec4( -vec3_dot( xaxis, eye ), -vec3_dot( yaxis, eye ), -vec3_dot( zaxis, eye ), 1.0f ) ); } 
VECMATH_INLINE mat44_t mat44_ortho_lh( float w, float h, float zn, float zf ) { return mat44( vec4( 2.0f / w, 0.0f, 0.0f, 0.0f ), vec4( 0.0f, 2.0f / h, 0.0f, 0.0f ), vec4( 0.0f, 0.0f, 1.0f / ( zf - zn ), 0.0f ), vec4( 0.0f, 0.0f, zn / ( zn - zf ), 1.0f ) ); } 
VECMATH_INLINE mat44_t mat44_ortho_rh( float w, float h, float zn, float zf ) { return mat44( vec4( 2.0f / w, 0.0f, 0.0f, 0.0f ), vec4( 0.0f, 2.0f / h, 0.0f, 0.0f ), vec4( 0.0f, 0.0f, 1.0f / ( zn - zf ), 0.0f ), vec4( 0.0f, 0.0f, zn / ( zn - zf ), 1.0f ) ); } 
VECMATH_INLINE mat44_t mat44_ortho_off_center_lh( float l, float r, float b, float t, float zn, float zf ) { return mat44( vec4( 2.0f / ( r - l ), 0.0f, 0.0f, 0.0f ), vec4( 0.0f, 2.0f / ( t - b ), 0.0f, 0.0f ), vec4( 0.0f, 0.0f, 1.0f / ( zf - zn ), 0.0f ), vec4( ( l + r ) / ( l - r ), ( t + b ) / ( b - t ), zn / ( zn - zf ), 1.0f ) ); } 
VECMATH_INLINE mat44_t mat44_ortho_off_center_rh( float l, float r, float b, float t, float zn, float zf ) { return mat44( vec4( 2.0f / ( r - l ), 0.0f, 0.0f, 0.0f ), vec4( 0.0f, 2.0f / ( t - b ), 0.0f, 0.0f ), vec4( 0.0f, 0.0f, 1.0f / ( zn - zf ), 0.0f ), vec4( ( l + r ) / ( l - r ), ( t + b ) / ( b - t ), zn / ( zn - zf ), 1.0f ) ); } 
VECMATH_INLINE mat44_t mat44_perspective_lh( float w, float h, float zn, float zf ) { return mat44( vec4( 2.0f * zn / w, 0.0f, 0.0f, 0.0f ), vec4( 0.0f, 2.0f * zn / h, 0.0f, 0.0f ), vec4( 0.0f, 0.0f, zf / ( zf - zn ), 1.0f ), vec4( 0.0f, 0.0f, zn * zf / ( zn - zf ), 0.0f ) ); } 
VECMATH_INLINE mat44_t mat44_perspective_rh( float w, float h, float zn, float zf ) { return mat44( vec4( 2.0f * zn / w, 0.0f, 0.0f, 0.0f ), vec4( 0.0f, 2.0f * zn / h, 0.0f, 0.0f ), vec4( 0.0f, 0.0f, zf / ( zn - zf ), -1.0f ), vec4( 0.0f, 0.0f, zn * zf / ( zn - zf ), 0.0f ) ); } 
VECMATH_INLINE mat44_t mat44_perspective_off_center_lh( float l, float r, float b, float t, float zn, float zf ) { return mat44( vec4( 2.0f * zn / ( r - l ), 0.0f, 0.0f, 0.0f ), vec4( 0.0f, 2.0f * zn / ( t - b ), 0.0f, 0.0f ), vec4( ( l + r ) / ( l - r ), ( t + b ) / ( b - t ), zf / ( zf - zn ), 1.0f ), vec4( 0.0f, 0.0f, zn * zf / ( zn - zf ), 0.0f ) ); } 
VECMATH_INLINE mat44_t mat44_perspective_off_center_rh( float l, float r, float b, float t, float zn, float zf ) { return mat44( vec4( 2.0f * zn / ( r - l ), 0.0f, 0.0f, 0.0f ), vec4( 0.0f, 2.0f * zn / ( t - b ), 0.0f, 0.0f ), vec4( ( l + r ) / ( r - l ), ( t + b ) / ( t - b ), zf / ( zn - zf ), -1.0f ), vec4( 0.0f, 0.0f, zn * zf / ( zn - zf ), 0.0f ) ); } 
VECMATH_INLINE mat44_t mat44_perspective_fov_lh( float fovy, float aspect, float zn, float zf ) { float yscale = 1.0f / vecmath_tan( fovy * 0.5f ); float xscale = yscale / aspect; return mat44( vec4( xscale, 0.0f, 0.0f, 0.0f ), vec4( 0.0f, yscale, 0.0f, 0.0f ), vec4( 0.0f, 0.0f, zf / ( zf - zn ), 1.0f ), vec4( 0.0f, 0.0f, -zn * zf / ( zf - zn ), 0.0f ) ); } 
VECMATH_INLINE mat44_t mat44_perspective_fov_rh( float fovy, float aspect, float zn, float zf ) { float yscale = 1.0f / vecmath_tan( fovy * 0.5f ); float xscale = yscale / aspect; return mat44( vec4( xscale, 0.0f, 0.0f, 0.0f ), vec4( 0.0f, yscale, 0.0f, 0.0f ), vec4( 0.0f, 0.0f, zf / ( zn - zf ), -1.0f ), vec4( 0.0f, 0.0f, zn * zf / ( zn - zf ), 0.0f ) ); } 
VECMATH_INLINE mat44_t mat44_rotation_axis( vec3_t axis, float angle ) { axis = vec3_normalize( axis ); float s = vecmath_sin( angle ); float c = vecmath_cos( angle ); float ic = 1.0f - c; float xyic = axis.x * axis.y * ic; float xzic = axis.x * axis.z * ic; float yzic = axis.y * axis.z * ic; float xs = axis.x * s; float ys = axis.y * s; float zs = axis.z * s; return mat44( vec4( c + axis.x * axis.x * ic, xyic + zs, xzic - ys, 0.0f ), vec4( xyic - zs, c + axis.y * axis.y * ic, yzic + xs, 0.0f ), vec4( xzic + ys, yzic - xs, c + axis.z * axis.z * ic, 0.0f ), vec4( 0.0f, 0.0f, 0.0f, 1.0f ) ); } 
VECMATH_INLINE mat44_t mat44_rotation_x( float angle ) { float s = vecmath_sin( angle ), c = vecmath_cos( angle ); return mat44( vec4( 1.0f, 0.0f, 0.0f, 0.0f ), vec4( 0.0f, c, s, 0.0f ), vec4( 0.0f, -s, c, 0.0f ), vec4( 0.0f, 0.0f, 0.0f, 1.0f ) ); } 
VECMATH_INLINE mat44_t mat44_rotation_y( float angle ) { float s = vecmath_sin( angle ), c = vecmath_cos( angle ); return mat44( vec4( c, 0.0f, -s, 0.0f ), vec4( 0.0f, 1.0f, 0.0f, 0.0f ), vec4( s, 0.0f, c, 0.0f ), vec4( 0.0f, 0.0f, 0.0f, 1.0f ) ); } 
VECMATH_INLINE mat44_t mat44_rotation_z( float angle ) { float s = vecmath_sin( angle ), c = vecmath_cos( angle ); return mat44( vec4( c, s, 0.0f, 0.0f ), vec4( -s, c, 0.0f, 0.0f ), vec4( 0.0f, 0.0f, 1.0f, 0.0f ), vec4( 0.0f, 0.0f, 0.0f, 1.0f ) ); } 
VECMATH_INLINE mat44_t mat44_rotation_yaw_pitch_roll( float yaw, float pitch, float roll ) { return mat44_mul_mat44( mat44_mul_mat44( mat44_rotation_z( roll ), mat44_rotation_x( pitch ) ), mat44_rotation_y( yaw ) ); }
VECMATH_INLINE mat44_t mat44_scaling( float sx, float sy, float sz ) { return mat44( vec4( sx, 0.0f, 0.0f, 0.0f ), vec4( 0.0f, sy, 0.0f, 0.0f ), vec4( 0.0f, 0.0f, sz, 0.0f ), vec4( 0.0f, 0.0f, 0.0f, 1.0f ) ); } 
VECMATH_INLINE mat44_t mat44_translation( float tx, float ty, float tz ) { return mat44( vec4( 1.0f, 0.0f, 0.0f, 0.0f ), vec4( 0.0f, 1.0f, 0.0f, 0.0f ), vec4( 0.0f, 0.0f, 1.0f, 0.0f ), vec4( tx, ty, tz, 1.0f ) ); } 
VECMATH_INLINE int mat44_decompose( vec3_t* out_scale, vec4_t* out_rotation, vec3_t* out_translation, mat44_t m ) { vec3_t x = vec3( m.x.x, m.x.y, m.x.z ); vec3_t y = vec3( m.y.x, m.y.y, m.y.z ); vec3_t z = vec3( m.z.x, m.z.y, m.z.z ); float sx = vec3_length( x ); float sy = vec3_length( y ); float sz = vec3_length( z ); int i0, i1, i2; if ( sx < sy ) { if ( sy < sz ) { i0 = 2; i1 = 1; i2 = 0; } else { i0 = 1; ( sx < sz ) ? ( i1 = 2, i2 = 0 ) : ( i1 = 0, i2 = 2 ); } } else { if ( sx < sz ) { i0 = 2; i1 = 0; i2 = 1; } else { i0 = 0; ( sy < sz ) ? ( i1 = 2, i2 = 1 ) : ( i1 = 1, i2 = 2 ); } } vec3_t* v[ 3 ] = { &x, &y, &z }; float* s[ 3 ] = { &sx, &sy, &sz }; if ( *s[ i0 ] < 0.0001f ) *v[ i0 ] = vec3( i0 == 0 ? 1.0f : 0.0f, i0 == 1 ? 1.0f : 0.0f, i0 == 2 ? 1.0f : 0.0f ); *v[ i0 ] = vec3_normalize( *v[ i0 ] ); if ( *s[ i1 ] < 0.0001f ) { float ax = vecmath_abs( v[ i0 ]->x ); float ay = vecmath_abs( v[ i0 ]->y ); float az = vecmath_abs( v[ i0 ]->z ); int j2; if ( ax < ay ) { if ( ay < az ) { j2 = 0; } else { ( ax < az ) ? ( j2 = 0 ) : ( j2 = 2 ); } } else { if ( ax < az ) { j2 = 1; } else { ( ay < az ) ? ( j2 = 1 ) : (  j2 = 2 ); } } *v[ i1 ] = vec3_cross( *v[ i0 ], vec3( j2 == 0 ? 1.0f : 0.0f, j2 == 1 ? 1.0f : 0.0f, j2 == 2 ? 1.0f : 0.0f ) ); } *v[ i1 ] = vec3_normalize( *v[ i1 ] ); if ( *s[ i2 ] < 0.0001f ) *v[ i2 ] = vec3_cross( *v[ i0 ], *v[ i1 ] ); *v[ i2 ] = vec3_normalize( *v[ i2 ] ); float det = vec3_dot( x, vec3_cross( y, z ) ); if ( det < 0.0f ) { *s[ i0 ] = -*s[ i0 ]; *v[ i0 ] = vec3_neg( *v[ i0 ] ); det = -det; } if ( vecmath_abs( det - 1.0f ) > 0.0001f ) return 0; float trace = x.x + y.y + z.z; float w, qx, qy, qz; if ( trace > 0.0f ) { float r = vecmath_sqrt( trace + 1.0f ) * 2.0f; w = 0.25f * r; qx = ( z.y - y.z ) / r; qy = ( x.z - z.x ) / r; qz = ( y.x - x.y ) / r; } else if ( x.x > y.y && x.x > z.z ) { float r = vecmath_sqrt( 1.0f + x.x - y.y - z.z ) * 2.0f; w = ( z.y - y.z ) / r; qx = 0.25f * r; qy = ( x.y + y.x ) / r; qz = ( x.z + z.x ) / r; } else if ( y.y > z.z ) { float r = vecmath_sqrt( 1.0f + y.y - x.x - z.z ) * 2.0f; w = ( x.z - z.x ) / r; qx = ( x.y + y.x ) / r; qy = 0.25f * r; qz = ( y.z + z.y ) / r; } else { float r = vecmath_sqrt( 1.0f + z.z - x.x - y.y ) * 2.0f; w = ( y.x - x.y ) / r; qx = ( x.z + z.x ) / r; qy = ( y.z + z.y ) / r; qz = 0.25f * r; } if ( out_translation ) *out_translation = vec3( m.w.x, m.w.y, m.w.z ); if ( out_rotation ) *out_rotation = vec4( qx, qy, qz, w ); if ( out_scale ) *out_scale = vec3( sx, sy, sz ); return 1; }

VECMATH_INLINE vec4_t vec2_transform( vec2_t v, mat44_t m ) { return vec4_mul_mat44( vec4( v.x, v.y, 0.0f, 1.0f ), m ); }
VECMATH_INLINE vec2_t vec2_transform_coord( vec2_t v, mat44_t m ) { vec4_t t = vec4_mul_mat44( vec4( v.x, v.y, 0.0f, 1.0f ), m ); return vec2( t.x / t.w, t.y / t.w ); }
VECMATH_INLINE vec2_t vec2_transform_normal( vec2_t v, mat44_t m ) { vec4_t t = vec4_mul_mat44( vec4( v.x, v.y, 0.0f, 0.0f ), m ); return vec2( t.x, t.y ); }
VECMATH_INLINE vec4_t vec3_transform( vec3_t v, mat44_t m ) { return vec4_mul_mat44( vec4( v.x, v.y, v.z, 1.0f ), m ); }
VECMATH_INLINE vec3_t vec3_transform_coord( vec3_t v, mat44_t m ) { vec4_t t = vec4_mul_mat44( vec4( v.x, v.y, v.z, 1.0f ), m ); return vec3( t.x / t.w, t.y / t.w, t.z / t.w ); }
VECMATH_INLINE vec3_t vec3_transform_normal( vec3_t v, mat44_t m ) { vec4_t t = vec4_mul_mat44( vec4( v.x, v.y, v.z, 0.0f ), m ); return vec3( t.x, t.y, t.z ); }
VECMATH_INLINE vec4_t vec4_transform( vec4_t v, mat44_t m ) { return vec4_mul_mat44( v, m ); }


// swizzling

VECMATH_INLINE vec2_t vec2_xx( vec2_t v ) { return vec2( v.x, v.x ); }
VECMATH_INLINE vec2_t vec2_xy( vec2_t v ) { return vec2( v.x, v.y ); }
VECMATH_INLINE vec2_t vec2_yx( vec2_t v ) { return vec2( v.y, v.x ); }
VECMATH_INLINE vec2_t vec2_yy( vec2_t v ) { return vec2( v.y, v.y ); }

VECMATH_INLINE vec2_t vec3_xx( vec3_t v ) { return vec2( v.x, v.x ); }
VECMATH_INLINE vec2_t vec3_xy( vec3_t v ) { return vec2( v.x, v.y ); }
VECMATH_INLINE vec2_t vec3_xz( vec3_t v ) { return vec2( v.x, v.z ); }
VECMATH_INLINE vec2_t vec3_yx( vec3_t v ) { return vec2( v.y, v.x ); }
VECMATH_INLINE vec2_t vec3_yy( vec3_t v ) { return vec2( v.y, v.y ); }
VECMATH_INLINE vec2_t vec3_yz( vec3_t v ) { return vec2( v.y, v.z ); }
VECMATH_INLINE vec2_t vec3_zx( vec3_t v ) { return vec2( v.z, v.x ); }
VECMATH_INLINE vec2_t vec3_zy( vec3_t v ) { return vec2( v.z, v.y ); }
VECMATH_INLINE vec2_t vec3_zz( vec3_t v ) { return vec2( v.z, v.z ); }

VECMATH_INLINE vec2_t vec4_xx( vec4_t v ) { return vec2( v.x, v.x ); }
VECMATH_INLINE vec2_t vec4_xy( vec4_t v ) { return vec2( v.x, v.y ); }
VECMATH_INLINE vec2_t vec4_xz( vec4_t v ) { return vec2( v.x, v.z ); }
VECMATH_INLINE vec2_t vec4_xw( vec4_t v ) { return vec2( v.x, v.w ); }
VECMATH_INLINE vec2_t vec4_yx( vec4_t v ) { return vec2( v.y, v.x ); }
VECMATH_INLINE vec2_t vec4_yy( vec4_t v ) { return vec2( v.y, v.y ); }
VECMATH_INLINE vec2_t vec4_yz( vec4_t v ) { return vec2( v.y, v.z ); }
VECMATH_INLINE vec2_t vec4_yw( vec4_t v ) { return vec2( v.y, v.w ); }
VECMATH_INLINE vec2_t vec4_zx( vec4_t v ) { return vec2( v.z, v.x ); }
VECMATH_INLINE vec2_t vec4_zy( vec4_t v ) { return vec2( v.z, v.y ); }
VECMATH_INLINE vec2_t vec4_zz( vec4_t v ) { return vec2( v.z, v.z ); }
VECMATH_INLINE vec2_t vec4_zw( vec4_t v ) { return vec2( v.z, v.w ); }
VECMATH_INLINE vec2_t vec4_wx( vec4_t v ) { return vec2( v.w, v.x ); }
VECMATH_INLINE vec2_t vec4_wy( vec4_t v ) { return vec2( v.w, v.y ); }
VECMATH_INLINE vec2_t vec4_wz( vec4_t v ) { return vec2( v.w, v.z ); }
VECMATH_INLINE vec2_t vec4_ww( vec4_t v ) { return vec2( v.w, v.w ); }

VECMATH_INLINE vec3_t vec2_xxx( vec2_t v ) { return vec3( v.x, v.x, v.x ); }
VECMATH_INLINE vec3_t vec2_xxy( vec2_t v ) { return vec3( v.x, v.x, v.y ); }
VECMATH_INLINE vec3_t vec2_xyx( vec2_t v ) { return vec3( v.x, v.y, v.x ); }
VECMATH_INLINE vec3_t vec2_xyy( vec2_t v ) { return vec3( v.x, v.y, v.y ); }
VECMATH_INLINE vec3_t vec2_yxx( vec2_t v ) { return vec3( v.y, v.x, v.x ); }
VECMATH_INLINE vec3_t vec2_yxy( vec2_t v ) { return vec3( v.y, v.x, v.y ); }
VECMATH_INLINE vec3_t vec2_yyx( vec2_t v ) { return vec3( v.y, v.y, v.x ); }
VECMATH_INLINE vec3_t vec2_yyy( vec2_t v ) { return vec3( v.y, v.y, v.y ); }

VECMATH_INLINE vec3_t vec3_xxx( vec3_t v ) { return vec3( v.x, v.x, v.x ); }
VECMATH_INLINE vec3_t vec3_xxy( vec3_t v ) { return vec3( v.x, v.x, v.y ); }
VECMATH_INLINE vec3_t vec3_xxz( vec3_t v ) { return vec3( v.x, v.x, v.z ); }
VECMATH_INLINE vec3_t vec3_xyx( vec3_t v ) { return vec3( v.x, v.y, v.x ); }
VECMATH_INLINE vec3_t vec3_xyy( vec3_t v ) { return vec3( v.x, v.y, v.y ); }
VECMATH_INLINE vec3_t vec3_xyz( vec3_t v ) { return vec3( v.x, v.y, v.z ); }
VECMATH_INLINE vec3_t vec3_xzx( vec3_t v ) { return vec3( v.x, v.z, v.x ); }
VECMATH_INLINE vec3_t vec3_xzy( vec3_t v ) { return vec3( v.x, v.z, v.y ); }
VECMATH_INLINE vec3_t vec3_xzz( vec3_t v ) { return vec3( v.x, v.z, v.z ); }
VECMATH_INLINE vec3_t vec3_yxx( vec3_t v ) { return vec3( v.y, v.x, v.x ); }
VECMATH_INLINE vec3_t vec3_yxy( vec3_t v ) { return vec3( v.y, v.x, v.y ); }
VECMATH_INLINE vec3_t vec3_yxz( vec3_t v ) { return vec3( v.y, v.x, v.z ); }
VECMATH_INLINE vec3_t vec3_yyx( vec3_t v ) { return vec3( v.y, v.y, v.x ); }
VECMATH_INLINE vec3_t vec3_yyy( vec3_t v ) { return vec3( v.y, v.y, v.y ); }
VECMATH_INLINE vec3_t vec3_yyz( vec3_t v ) { return vec3( v.y, v.y, v.z ); }
VECMATH_INLINE vec3_t vec3_yzx( vec3_t v ) { return vec3( v.y, v.z, v.x ); }
VECMATH_INLINE vec3_t vec3_yzy( vec3_t v ) { return vec3( v.y, v.z, v.y ); }
VECMATH_INLINE vec3_t vec3_yzz( vec3_t v ) { return vec3( v.y, v.z, v.z ); }
VECMATH_INLINE vec3_t vec3_zxx( vec3_t v ) { return vec3( v.z, v.x, v.x ); }
VECMATH_INLINE vec3_t vec3_zxy( vec3_t v ) { return vec3( v.z, v.x, v.y ); }
VECMATH_INLINE vec3_t vec3_zxz( vec3_t v ) { return vec3( v.z, v.x, v.z ); }
VECMATH_INLINE vec3_t vec3_zyx( vec3_t v ) { return vec3( v.z, v.y, v.x ); }
VECMATH_INLINE vec3_t vec3_zyy( vec3_t v ) { return vec3( v.z, v.y, v.y ); }
VECMATH_INLINE vec3_t vec3_zyz( vec3_t v ) { return vec3( v.z, v.y, v.z ); }
VECMATH_INLINE vec3_t vec3_zzx( vec3_t v ) { return vec3( v.z, v.z, v.x ); }
VECMATH_INLINE vec3_t vec3_zzy( vec3_t v ) { return vec3( v.z, v.z, v.y ); }
VECMATH_INLINE vec3_t vec3_zzz( vec3_t v ) { return vec3( v.z, v.z, v.z ); }

VECMATH_INLINE vec3_t vec4_xxx( vec4_t v ) { return vec3( v.x, v.x, v.x ); }
VECMATH_INLINE vec3_t vec4_xxy( vec4_t v ) { return vec3( v.x, v.x, v.y ); }
VECMATH_INLINE vec3_t vec4_xxz( vec4_t v ) { return vec3( v.x, v.x, v.z ); }
VECMATH_INLINE vec3_t vec4_xxw( vec4_t v ) { return vec3( v.x, v.x, v.w ); }
VECMATH_INLINE vec3_t vec4_xyx( vec4_t v ) { return vec3( v.x, v.y, v.x ); }
VECMATH_INLINE vec3_t vec4_xyy( vec4_t v ) { return vec3( v.x, v.y, v.y ); }
VECMATH_INLINE vec3_t vec4_xyz( vec4_t v ) { return vec3( v.x, v.y, v.z ); }
VECMATH_INLINE vec3_t vec4_xyw( vec4_t v ) { return vec3( v.x, v.y, v.w ); }
VECMATH_INLINE vec3_t vec4_xzx( vec4_t v ) { return vec3( v.x, v.z, v.x ); }
VECMATH_INLINE vec3_t vec4_xzy( vec4_t v ) { return vec3( v.x, v.z, v.y ); }
VECMATH_INLINE vec3_t vec4_xzz( vec4_t v ) { return vec3( v.x, v.z, v.z ); }
VECMATH_INLINE vec3_t vec4_xzw( vec4_t v ) { return vec3( v.x, v.z, v.w ); }
VECMATH_INLINE vec3_t vec4_xwx( vec4_t v ) { return vec3( v.x, v.w, v.x ); }
VECMATH_INLINE vec3_t vec4_xwy( vec4_t v ) { return vec3( v.x, v.w, v.y ); }
VECMATH_INLINE vec3_t vec4_xwz( vec4_t v ) { return vec3( v.x, v.w, v.z ); }
VECMATH_INLINE vec3_t vec4_xww( vec4_t v ) { return vec3( v.x, v.w, v.w ); }
VECMATH_INLINE vec3_t vec4_yxx( vec4_t v ) { return vec3( v.y, v.x, v.x ); }
VECMATH_INLINE vec3_t vec4_yxy( vec4_t v ) { return vec3( v.y, v.x, v.y ); }
VECMATH_INLINE vec3_t vec4_yxz( vec4_t v ) { return vec3( v.y, v.x, v.z ); }
VECMATH_INLINE vec3_t vec4_yxw( vec4_t v ) { return vec3( v.y, v.x, v.w ); }
VECMATH_INLINE vec3_t vec4_yyx( vec4_t v ) { return vec3( v.y, v.y, v.x ); }
VECMATH_INLINE vec3_t vec4_yyy( vec4_t v ) { return vec3( v.y, v.y, v.y ); }
VECMATH_INLINE vec3_t vec4_yyz( vec4_t v ) { return vec3( v.y, v.y, v.z ); }
VECMATH_INLINE vec3_t vec4_yyw( vec4_t v ) { return vec3( v.y, v.y, v.w ); }
VECMATH_INLINE vec3_t vec4_yzx( vec4_t v ) { return vec3( v.y, v.z, v.x ); }
VECMATH_INLINE vec3_t vec4_yzy( vec4_t v ) { return vec3( v.y, v.z, v.y ); }
VECMATH_INLINE vec3_t vec4_yzz( vec4_t v ) { return vec3( v.y, v.z, v.z ); }
VECMATH_INLINE vec3_t vec4_yzw( vec4_t v ) { return vec3( v.y, v.z, v.w ); }
VECMATH_INLINE vec3_t vec4_ywx( vec4_t v ) { return vec3( v.y, v.w, v.x ); }
VECMATH_INLINE vec3_t vec4_ywy( vec4_t v ) { return vec3( v.y, v.w, v.y ); }
VECMATH_INLINE vec3_t vec4_ywz( vec4_t v ) { return vec3( v.y, v.w, v.z ); }
VECMATH_INLINE vec3_t vec4_yww( vec4_t v ) { return vec3( v.y, v.w, v.w ); }
VECMATH_INLINE vec3_t vec4_zxx( vec4_t v ) { return vec3( v.z, v.x, v.x ); }
VECMATH_INLINE vec3_t vec4_zxy( vec4_t v ) { return vec3( v.z, v.x, v.y ); }
VECMATH_INLINE vec3_t vec4_zxz( vec4_t v ) { return vec3( v.z, v.x, v.z ); }
VECMATH_INLINE vec3_t vec4_zxw( vec4_t v ) { return vec3( v.z, v.x, v.w ); }
VECMATH_INLINE vec3_t vec4_zyx( vec4_t v ) { return vec3( v.z, v.y, v.x ); }
VECMATH_INLINE vec3_t vec4_zyy( vec4_t v ) { return vec3( v.z, v.y, v.y ); }
VECMATH_INLINE vec3_t vec4_zyz( vec4_t v ) { return vec3( v.z, v.y, v.z ); }
VECMATH_INLINE vec3_t vec4_zyw( vec4_t v ) { return vec3( v.z, v.y, v.w ); }
VECMATH_INLINE vec3_t vec4_zzx( vec4_t v ) { return vec3( v.z, v.z, v.x ); }
VECMATH_INLINE vec3_t vec4_zzy( vec4_t v ) { return vec3( v.z, v.z, v.y ); }
VECMATH_INLINE vec3_t vec4_zzz( vec4_t v ) { return vec3( v.z, v.z, v.z ); }
VECMATH_INLINE vec3_t vec4_zzw( vec4_t v ) { return vec3( v.z, v.z, v.w ); }
VECMATH_INLINE vec3_t vec4_zwx( vec4_t v ) { return vec3( v.z, v.w, v.x ); }
VECMATH_INLINE vec3_t vec4_zwy( vec4_t v ) { return vec3( v.z, v.w, v.y ); }
VECMATH_INLINE vec3_t vec4_zwz( vec4_t v ) { return vec3( v.z, v.w, v.z ); }
VECMATH_INLINE vec3_t vec4_zww( vec4_t v ) { return vec3( v.z, v.w, v.w ); }
VECMATH_INLINE vec3_t vec4_wxx( vec4_t v ) { return vec3( v.w, v.x, v.x ); }
VECMATH_INLINE vec3_t vec4_wxy( vec4_t v ) { return vec3( v.w, v.x, v.y ); }
VECMATH_INLINE vec3_t vec4_wxz( vec4_t v ) { return vec3( v.w, v.x, v.z ); }
VECMATH_INLINE vec3_t vec4_wxw( vec4_t v ) { return vec3( v.w, v.x, v.w ); }
VECMATH_INLINE vec3_t vec4_wyx( vec4_t v ) { return vec3( v.w, v.y, v.x ); }
VECMATH_INLINE vec3_t vec4_wyy( vec4_t v ) { return vec3( v.w, v.y, v.y ); }
VECMATH_INLINE vec3_t vec4_wyz( vec4_t v ) { return vec3( v.w, v.y, v.z ); }
VECMATH_INLINE vec3_t vec4_wyw( vec4_t v ) { return vec3( v.w, v.y, v.w ); }
VECMATH_INLINE vec3_t vec4_wzx( vec4_t v ) { return vec3( v.w, v.z, v.x ); }
VECMATH_INLINE vec3_t vec4_wzy( vec4_t v ) { return vec3( v.w, v.z, v.y ); }
VECMATH_INLINE vec3_t vec4_wzz( vec4_t v ) { return vec3( v.w, v.z, v.z ); }
VECMATH_INLINE vec3_t vec4_wzw( vec4_t v ) { return vec3( v.w, v.z, v.w ); }
VECMATH_INLINE vec3_t vec4_wwx( vec4_t v ) { return vec3( v.w, v.w, v.x ); }
VECMATH_INLINE vec3_t vec4_wwy( vec4_t v ) { return vec3( v.w, v.w, v.y ); }
VECMATH_INLINE vec3_t vec4_wwz( vec4_t v ) { return vec3( v.w, v.w, v.z ); }
VECMATH_INLINE vec3_t vec4_www( vec4_t v ) { return vec3( v.w, v.w, v.w ); }

VECMATH_INLINE vec4_t vec2_xxxx( vec2_t v ) { return vec4( v.x, v.x, v.x, v.x ); }
VECMATH_INLINE vec4_t vec2_xxxy( vec2_t v ) { return vec4( v.x, v.x, v.x, v.y ); }
VECMATH_INLINE vec4_t vec2_xxyx( vec2_t v ) { return vec4( v.x, v.x, v.y, v.x ); }
VECMATH_INLINE vec4_t vec2_xxyy( vec2_t v ) { return vec4( v.x, v.x, v.y, v.y ); }
VECMATH_INLINE vec4_t vec2_xyxx( vec2_t v ) { return vec4( v.x, v.y, v.x, v.x ); }
VECMATH_INLINE vec4_t vec2_xyxy( vec2_t v ) { return vec4( v.x, v.y, v.x, v.y ); }
VECMATH_INLINE vec4_t vec2_xyyx( vec2_t v ) { return vec4( v.x, v.y, v.y, v.x ); }
VECMATH_INLINE vec4_t vec2_xyyy( vec2_t v ) { return vec4( v.x, v.y, v.y, v.y ); }
VECMATH_INLINE vec4_t vec2_yxxx( vec2_t v ) { return vec4( v.y, v.x, v.x, v.x ); }
VECMATH_INLINE vec4_t vec2_yxxy( vec2_t v ) { return vec4( v.y, v.x, v.x, v.y ); }
VECMATH_INLINE vec4_t vec2_yxyx( vec2_t v ) { return vec4( v.y, v.x, v.y, v.x ); }
VECMATH_INLINE vec4_t vec2_yxyy( vec2_t v ) { return vec4( v.y, v.x, v.y, v.y ); }
VECMATH_INLINE vec4_t vec2_yyxx( vec2_t v ) { return vec4( v.y, v.y, v.x, v.x ); }
VECMATH_INLINE vec4_t vec2_yyxy( vec2_t v ) { return vec4( v.y, v.y, v.x, v.y ); }
VECMATH_INLINE vec4_t vec2_yyyx( vec2_t v ) { return vec4( v.y, v.y, v.y, v.x ); }
VECMATH_INLINE vec4_t vec2_yyyy( vec2_t v ) { return vec4( v.y, v.y, v.y, v.y ); }

VECMATH_INLINE vec4_t vec3_xxxx( vec3_t v ) { return vec4( v.x, v.x, v.x, v.x ); }
VECMATH_INLINE vec4_t vec3_xxxy( vec3_t v ) { return vec4( v.x, v.x, v.x, v.y ); }
VECMATH_INLINE vec4_t vec3_xxxz( vec3_t v ) { return vec4( v.x, v.x, v.x, v.z ); }
VECMATH_INLINE vec4_t vec3_xxyx( vec3_t v ) { return vec4( v.x, v.x, v.y, v.x ); }
VECMATH_INLINE vec4_t vec3_xxyy( vec3_t v ) { return vec4( v.x, v.x, v.y, v.y ); }
VECMATH_INLINE vec4_t vec3_xxyz( vec3_t v ) { return vec4( v.x, v.x, v.y, v.z ); }
VECMATH_INLINE vec4_t vec3_xxzx( vec3_t v ) { return vec4( v.x, v.x, v.z, v.x ); }
VECMATH_INLINE vec4_t vec3_xxzy( vec3_t v ) { return vec4( v.x, v.x, v.z, v.y ); }
VECMATH_INLINE vec4_t vec3_xxzz( vec3_t v ) { return vec4( v.x, v.x, v.z, v.z ); }
VECMATH_INLINE vec4_t vec3_xyxx( vec3_t v ) { return vec4( v.x, v.y, v.x, v.x ); }
VECMATH_INLINE vec4_t vec3_xyxy( vec3_t v ) { return vec4( v.x, v.y, v.x, v.y ); }
VECMATH_INLINE vec4_t vec3_xyxz( vec3_t v ) { return vec4( v.x, v.y, v.x, v.z ); }
VECMATH_INLINE vec4_t vec3_xyyx( vec3_t v ) { return vec4( v.x, v.y, v.y, v.x ); }
VECMATH_INLINE vec4_t vec3_xyyy( vec3_t v ) { return vec4( v.x, v.y, v.y, v.y ); }
VECMATH_INLINE vec4_t vec3_xyyz( vec3_t v ) { return vec4( v.x, v.y, v.y, v.z ); }
VECMATH_INLINE vec4_t vec3_xyzx( vec3_t v ) { return vec4( v.x, v.y, v.z, v.x ); }
VECMATH_INLINE vec4_t vec3_xyzy( vec3_t v ) { return vec4( v.x, v.y, v.z, v.y ); }
VECMATH_INLINE vec4_t vec3_xyzz( vec3_t v ) { return vec4( v.x, v.y, v.z, v.z ); }
VECMATH_INLINE vec4_t vec3_xzxx( vec3_t v ) { return vec4( v.x, v.z, v.x, v.x ); }
VECMATH_INLINE vec4_t vec3_xzxy( vec3_t v ) { return vec4( v.x, v.z, v.x, v.y ); }
VECMATH_INLINE vec4_t vec3_xzxz( vec3_t v ) { return vec4( v.x, v.z, v.x, v.z ); }
VECMATH_INLINE vec4_t vec3_xzyx( vec3_t v ) { return vec4( v.x, v.z, v.y, v.x ); }
VECMATH_INLINE vec4_t vec3_xzyy( vec3_t v ) { return vec4( v.x, v.z, v.y, v.y ); }
VECMATH_INLINE vec4_t vec3_xzyz( vec3_t v ) { return vec4( v.x, v.z, v.y, v.z ); }
VECMATH_INLINE vec4_t vec3_xzzx( vec3_t v ) { return vec4( v.x, v.z, v.z, v.x ); }
VECMATH_INLINE vec4_t vec3_xzzy( vec3_t v ) { return vec4( v.x, v.z, v.z, v.y ); }
VECMATH_INLINE vec4_t vec3_xzzz( vec3_t v ) { return vec4( v.x, v.z, v.z, v.z ); }
VECMATH_INLINE vec4_t vec3_yxxx( vec3_t v ) { return vec4( v.y, v.x, v.x, v.x ); }
VECMATH_INLINE vec4_t vec3_yxxy( vec3_t v ) { return vec4( v.y, v.x, v.x, v.y ); }
VECMATH_INLINE vec4_t vec3_yxxz( vec3_t v ) { return vec4( v.y, v.x, v.x, v.z ); }
VECMATH_INLINE vec4_t vec3_yxyx( vec3_t v ) { return vec4( v.y, v.x, v.y, v.x ); }
VECMATH_INLINE vec4_t vec3_yxyy( vec3_t v ) { return vec4( v.y, v.x, v.y, v.y ); }
VECMATH_INLINE vec4_t vec3_yxyz( vec3_t v ) { return vec4( v.y, v.x, v.y, v.z ); }
VECMATH_INLINE vec4_t vec3_yxzx( vec3_t v ) { return vec4( v.y, v.x, v.z, v.x ); }
VECMATH_INLINE vec4_t vec3_yxzy( vec3_t v ) { return vec4( v.y, v.x, v.z, v.y ); }
VECMATH_INLINE vec4_t vec3_yxzz( vec3_t v ) { return vec4( v.y, v.x, v.z, v.z ); }
VECMATH_INLINE vec4_t vec3_yyxx( vec3_t v ) { return vec4( v.y, v.y, v.x, v.x ); }
VECMATH_INLINE vec4_t vec3_yyxy( vec3_t v ) { return vec4( v.y, v.y, v.x, v.y ); }
VECMATH_INLINE vec4_t vec3_yyxz( vec3_t v ) { return vec4( v.y, v.y, v.x, v.z ); }
VECMATH_INLINE vec4_t vec3_yyyx( vec3_t v ) { return vec4( v.y, v.y, v.y, v.x ); }
VECMATH_INLINE vec4_t vec3_yyyy( vec3_t v ) { return vec4( v.y, v.y, v.y, v.y ); }
VECMATH_INLINE vec4_t vec3_yyyz( vec3_t v ) { return vec4( v.y, v.y, v.y, v.z ); }
VECMATH_INLINE vec4_t vec3_yyzx( vec3_t v ) { return vec4( v.y, v.y, v.z, v.x ); }
VECMATH_INLINE vec4_t vec3_yyzy( vec3_t v ) { return vec4( v.y, v.y, v.z, v.y ); }
VECMATH_INLINE vec4_t vec3_yyzz( vec3_t v ) { return vec4( v.y, v.y, v.z, v.z ); }
VECMATH_INLINE vec4_t vec3_yzxx( vec3_t v ) { return vec4( v.y, v.z, v.x, v.x ); }
VECMATH_INLINE vec4_t vec3_yzxy( vec3_t v ) { return vec4( v.y, v.z, v.x, v.y ); }
VECMATH_INLINE vec4_t vec3_yzxz( vec3_t v ) { return vec4( v.y, v.z, v.x, v.z ); }
VECMATH_INLINE vec4_t vec3_yzyx( vec3_t v ) { return vec4( v.y, v.z, v.y, v.x ); }
VECMATH_INLINE vec4_t vec3_yzyy( vec3_t v ) { return vec4( v.y, v.z, v.y, v.y ); }
VECMATH_INLINE vec4_t vec3_yzyz( vec3_t v ) { return vec4( v.y, v.z, v.y, v.z ); }
VECMATH_INLINE vec4_t vec3_yzzx( vec3_t v ) { return vec4( v.y, v.z, v.z, v.x ); }
VECMATH_INLINE vec4_t vec3_yzzy( vec3_t v ) { return vec4( v.y, v.z, v.z, v.y ); }
VECMATH_INLINE vec4_t vec3_yzzz( vec3_t v ) { return vec4( v.y, v.z, v.z, v.z ); }
VECMATH_INLINE vec4_t vec3_zxxx( vec3_t v ) { return vec4( v.z, v.x, v.x, v.x ); }
VECMATH_INLINE vec4_t vec3_zxxy( vec3_t v ) { return vec4( v.z, v.x, v.x, v.y ); }
VECMATH_INLINE vec4_t vec3_zxxz( vec3_t v ) { return vec4( v.z, v.x, v.x, v.z ); }
VECMATH_INLINE vec4_t vec3_zxyx( vec3_t v ) { return vec4( v.z, v.x, v.y, v.x ); }
VECMATH_INLINE vec4_t vec3_zxyy( vec3_t v ) { return vec4( v.z, v.x, v.y, v.y ); }
VECMATH_INLINE vec4_t vec3_zxyz( vec3_t v ) { return vec4( v.z, v.x, v.y, v.z ); }
VECMATH_INLINE vec4_t vec3_zxzx( vec3_t v ) { return vec4( v.z, v.x, v.z, v.x ); }
VECMATH_INLINE vec4_t vec3_zxzy( vec3_t v ) { return vec4( v.z, v.x, v.z, v.y ); }
VECMATH_INLINE vec4_t vec3_zxzz( vec3_t v ) { return vec4( v.z, v.x, v.z, v.z ); }
VECMATH_INLINE vec4_t vec3_zyxx( vec3_t v ) { return vec4( v.z, v.y, v.x, v.x ); }
VECMATH_INLINE vec4_t vec3_zyxy( vec3_t v ) { return vec4( v.z, v.y, v.x, v.y ); }
VECMATH_INLINE vec4_t vec3_zyxz( vec3_t v ) { return vec4( v.z, v.y, v.x, v.z ); }
VECMATH_INLINE vec4_t vec3_zyyx( vec3_t v ) { return vec4( v.z, v.y, v.y, v.x ); }
VECMATH_INLINE vec4_t vec3_zyyy( vec3_t v ) { return vec4( v.z, v.y, v.y, v.y ); }
VECMATH_INLINE vec4_t vec3_zyyz( vec3_t v ) { return vec4( v.z, v.y, v.y, v.z ); }
VECMATH_INLINE vec4_t vec3_zyzx( vec3_t v ) { return vec4( v.z, v.y, v.z, v.x ); }
VECMATH_INLINE vec4_t vec3_zyzy( vec3_t v ) { return vec4( v.z, v.y, v.z, v.y ); }
VECMATH_INLINE vec4_t vec3_zyzz( vec3_t v ) { return vec4( v.z, v.y, v.z, v.z ); }
VECMATH_INLINE vec4_t vec3_zzxx( vec3_t v ) { return vec4( v.z, v.z, v.x, v.x ); }
VECMATH_INLINE vec4_t vec3_zzxy( vec3_t v ) { return vec4( v.z, v.z, v.x, v.y ); }
VECMATH_INLINE vec4_t vec3_zzxz( vec3_t v ) { return vec4( v.z, v.z, v.x, v.z ); }
VECMATH_INLINE vec4_t vec3_zzyx( vec3_t v ) { return vec4( v.z, v.z, v.y, v.x ); }
VECMATH_INLINE vec4_t vec3_zzyy( vec3_t v ) { return vec4( v.z, v.z, v.y, v.y ); }
VECMATH_INLINE vec4_t vec3_zzyz( vec3_t v ) { return vec4( v.z, v.z, v.y, v.z ); }
VECMATH_INLINE vec4_t vec3_zzzx( vec3_t v ) { return vec4( v.z, v.z, v.z, v.x ); }
VECMATH_INLINE vec4_t vec3_zzzy( vec3_t v ) { return vec4( v.z, v.z, v.z, v.y ); }
VECMATH_INLINE vec4_t vec3_zzzz( vec3_t v ) { return vec4( v.z, v.z, v.z, v.z ); }

VECMATH_INLINE vec4_t vec4_xxxx( vec4_t v ) { return vec4( v.x, v.x, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_xxxy( vec4_t v ) { return vec4( v.x, v.x, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_xxxz( vec4_t v ) { return vec4( v.x, v.x, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_xxxw( vec4_t v ) { return vec4( v.x, v.x, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_xxyx( vec4_t v ) { return vec4( v.x, v.x, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_xxyy( vec4_t v ) { return vec4( v.x, v.x, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_xxyz( vec4_t v ) { return vec4( v.x, v.x, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_xxyw( vec4_t v ) { return vec4( v.x, v.x, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_xxzx( vec4_t v ) { return vec4( v.x, v.x, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_xxzy( vec4_t v ) { return vec4( v.x, v.x, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_xxzz( vec4_t v ) { return vec4( v.x, v.x, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_xxzw( vec4_t v ) { return vec4( v.x, v.x, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_xxwx( vec4_t v ) { return vec4( v.x, v.x, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_xxwy( vec4_t v ) { return vec4( v.x, v.x, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_xxwz( vec4_t v ) { return vec4( v.x, v.x, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_xxww( vec4_t v ) { return vec4( v.x, v.x, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_xyxx( vec4_t v ) { return vec4( v.x, v.y, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_xyxy( vec4_t v ) { return vec4( v.x, v.y, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_xyxz( vec4_t v ) { return vec4( v.x, v.y, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_xyxw( vec4_t v ) { return vec4( v.x, v.y, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_xyyx( vec4_t v ) { return vec4( v.x, v.y, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_xyyy( vec4_t v ) { return vec4( v.x, v.y, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_xyyz( vec4_t v ) { return vec4( v.x, v.y, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_xyyw( vec4_t v ) { return vec4( v.x, v.y, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_xyzx( vec4_t v ) { return vec4( v.x, v.y, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_xyzy( vec4_t v ) { return vec4( v.x, v.y, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_xyzz( vec4_t v ) { return vec4( v.x, v.y, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_xyzw( vec4_t v ) { return vec4( v.x, v.y, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_xywx( vec4_t v ) { return vec4( v.x, v.y, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_xywy( vec4_t v ) { return vec4( v.x, v.y, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_xywz( vec4_t v ) { return vec4( v.x, v.y, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_xyww( vec4_t v ) { return vec4( v.x, v.y, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_xzxx( vec4_t v ) { return vec4( v.x, v.z, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_xzxy( vec4_t v ) { return vec4( v.x, v.z, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_xzxz( vec4_t v ) { return vec4( v.x, v.z, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_xzxw( vec4_t v ) { return vec4( v.x, v.z, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_xzyx( vec4_t v ) { return vec4( v.x, v.z, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_xzyy( vec4_t v ) { return vec4( v.x, v.z, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_xzyz( vec4_t v ) { return vec4( v.x, v.z, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_xzyw( vec4_t v ) { return vec4( v.x, v.z, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_xzzx( vec4_t v ) { return vec4( v.x, v.z, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_xzzy( vec4_t v ) { return vec4( v.x, v.z, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_xzzz( vec4_t v ) { return vec4( v.x, v.z, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_xzzw( vec4_t v ) { return vec4( v.x, v.z, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_xzwx( vec4_t v ) { return vec4( v.x, v.z, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_xzwy( vec4_t v ) { return vec4( v.x, v.z, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_xzwz( vec4_t v ) { return vec4( v.x, v.z, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_xzww( vec4_t v ) { return vec4( v.x, v.z, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_xwxx( vec4_t v ) { return vec4( v.x, v.w, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_xwxy( vec4_t v ) { return vec4( v.x, v.w, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_xwxz( vec4_t v ) { return vec4( v.x, v.w, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_xwxw( vec4_t v ) { return vec4( v.x, v.w, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_xwyx( vec4_t v ) { return vec4( v.x, v.w, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_xwyy( vec4_t v ) { return vec4( v.x, v.w, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_xwyz( vec4_t v ) { return vec4( v.x, v.w, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_xwyw( vec4_t v ) { return vec4( v.x, v.w, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_xwzx( vec4_t v ) { return vec4( v.x, v.w, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_xwzy( vec4_t v ) { return vec4( v.x, v.w, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_xwzz( vec4_t v ) { return vec4( v.x, v.w, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_xwzw( vec4_t v ) { return vec4( v.x, v.w, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_xwwx( vec4_t v ) { return vec4( v.x, v.w, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_xwwy( vec4_t v ) { return vec4( v.x, v.w, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_xwwz( vec4_t v ) { return vec4( v.x, v.w, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_xwww( vec4_t v ) { return vec4( v.x, v.w, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_yxxx( vec4_t v ) { return vec4( v.y, v.x, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_yxxy( vec4_t v ) { return vec4( v.y, v.x, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_yxxz( vec4_t v ) { return vec4( v.y, v.x, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_yxxw( vec4_t v ) { return vec4( v.y, v.x, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_yxyx( vec4_t v ) { return vec4( v.y, v.x, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_yxyy( vec4_t v ) { return vec4( v.y, v.x, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_yxyz( vec4_t v ) { return vec4( v.y, v.x, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_yxyw( vec4_t v ) { return vec4( v.y, v.x, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_yxzx( vec4_t v ) { return vec4( v.y, v.x, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_yxzy( vec4_t v ) { return vec4( v.y, v.x, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_yxzz( vec4_t v ) { return vec4( v.y, v.x, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_yxzw( vec4_t v ) { return vec4( v.y, v.x, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_yxwx( vec4_t v ) { return vec4( v.y, v.x, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_yxwy( vec4_t v ) { return vec4( v.y, v.x, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_yxwz( vec4_t v ) { return vec4( v.y, v.x, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_yxww( vec4_t v ) { return vec4( v.y, v.x, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_yyxx( vec4_t v ) { return vec4( v.y, v.y, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_yyxy( vec4_t v ) { return vec4( v.y, v.y, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_yyxz( vec4_t v ) { return vec4( v.y, v.y, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_yyxw( vec4_t v ) { return vec4( v.y, v.y, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_yyyx( vec4_t v ) { return vec4( v.y, v.y, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_yyyy( vec4_t v ) { return vec4( v.y, v.y, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_yyyz( vec4_t v ) { return vec4( v.y, v.y, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_yyyw( vec4_t v ) { return vec4( v.y, v.y, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_yyzx( vec4_t v ) { return vec4( v.y, v.y, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_yyzy( vec4_t v ) { return vec4( v.y, v.y, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_yyzz( vec4_t v ) { return vec4( v.y, v.y, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_yyzw( vec4_t v ) { return vec4( v.y, v.y, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_yywx( vec4_t v ) { return vec4( v.y, v.y, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_yywy( vec4_t v ) { return vec4( v.y, v.y, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_yywz( vec4_t v ) { return vec4( v.y, v.y, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_yyww( vec4_t v ) { return vec4( v.y, v.y, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_yzxx( vec4_t v ) { return vec4( v.y, v.z, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_yzxy( vec4_t v ) { return vec4( v.y, v.z, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_yzxz( vec4_t v ) { return vec4( v.y, v.z, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_yzxw( vec4_t v ) { return vec4( v.y, v.z, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_yzyx( vec4_t v ) { return vec4( v.y, v.z, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_yzyy( vec4_t v ) { return vec4( v.y, v.z, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_yzyz( vec4_t v ) { return vec4( v.y, v.z, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_yzyw( vec4_t v ) { return vec4( v.y, v.z, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_yzzx( vec4_t v ) { return vec4( v.y, v.z, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_yzzy( vec4_t v ) { return vec4( v.y, v.z, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_yzzz( vec4_t v ) { return vec4( v.y, v.z, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_yzzw( vec4_t v ) { return vec4( v.y, v.z, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_yzwx( vec4_t v ) { return vec4( v.y, v.z, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_yzwy( vec4_t v ) { return vec4( v.y, v.z, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_yzwz( vec4_t v ) { return vec4( v.y, v.z, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_yzww( vec4_t v ) { return vec4( v.y, v.z, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_ywxx( vec4_t v ) { return vec4( v.y, v.w, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_ywxy( vec4_t v ) { return vec4( v.y, v.w, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_ywxz( vec4_t v ) { return vec4( v.y, v.w, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_ywxw( vec4_t v ) { return vec4( v.y, v.w, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_ywyx( vec4_t v ) { return vec4( v.y, v.w, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_ywyy( vec4_t v ) { return vec4( v.y, v.w, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_ywyz( vec4_t v ) { return vec4( v.y, v.w, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_ywyw( vec4_t v ) { return vec4( v.y, v.w, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_ywzx( vec4_t v ) { return vec4( v.y, v.w, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_ywzy( vec4_t v ) { return vec4( v.y, v.w, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_ywzz( vec4_t v ) { return vec4( v.y, v.w, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_ywzw( vec4_t v ) { return vec4( v.y, v.w, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_ywwx( vec4_t v ) { return vec4( v.y, v.w, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_ywwy( vec4_t v ) { return vec4( v.y, v.w, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_ywwz( vec4_t v ) { return vec4( v.y, v.w, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_ywww( vec4_t v ) { return vec4( v.y, v.w, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_zxxx( vec4_t v ) { return vec4( v.z, v.x, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_zxxy( vec4_t v ) { return vec4( v.z, v.x, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_zxxz( vec4_t v ) { return vec4( v.z, v.x, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_zxxw( vec4_t v ) { return vec4( v.z, v.x, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_zxyx( vec4_t v ) { return vec4( v.z, v.x, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_zxyy( vec4_t v ) { return vec4( v.z, v.x, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_zxyz( vec4_t v ) { return vec4( v.z, v.x, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_zxyw( vec4_t v ) { return vec4( v.z, v.x, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_zxzx( vec4_t v ) { return vec4( v.z, v.x, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_zxzy( vec4_t v ) { return vec4( v.z, v.x, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_zxzz( vec4_t v ) { return vec4( v.z, v.x, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_zxzw( vec4_t v ) { return vec4( v.z, v.x, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_zxwx( vec4_t v ) { return vec4( v.z, v.x, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_zxwy( vec4_t v ) { return vec4( v.z, v.x, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_zxwz( vec4_t v ) { return vec4( v.z, v.x, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_zxww( vec4_t v ) { return vec4( v.z, v.x, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_zyxx( vec4_t v ) { return vec4( v.z, v.y, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_zyxy( vec4_t v ) { return vec4( v.z, v.y, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_zyxz( vec4_t v ) { return vec4( v.z, v.y, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_zyxw( vec4_t v ) { return vec4( v.z, v.y, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_zyyx( vec4_t v ) { return vec4( v.z, v.y, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_zyyy( vec4_t v ) { return vec4( v.z, v.y, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_zyyz( vec4_t v ) { return vec4( v.z, v.y, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_zyyw( vec4_t v ) { return vec4( v.z, v.y, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_zyzx( vec4_t v ) { return vec4( v.z, v.y, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_zyzy( vec4_t v ) { return vec4( v.z, v.y, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_zyzz( vec4_t v ) { return vec4( v.z, v.y, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_zyzw( vec4_t v ) { return vec4( v.z, v.y, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_zywx( vec4_t v ) { return vec4( v.z, v.y, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_zywy( vec4_t v ) { return vec4( v.z, v.y, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_zywz( vec4_t v ) { return vec4( v.z, v.y, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_zyww( vec4_t v ) { return vec4( v.z, v.y, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_zzxx( vec4_t v ) { return vec4( v.z, v.z, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_zzxy( vec4_t v ) { return vec4( v.z, v.z, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_zzxz( vec4_t v ) { return vec4( v.z, v.z, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_zzxw( vec4_t v ) { return vec4( v.z, v.z, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_zzyx( vec4_t v ) { return vec4( v.z, v.z, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_zzyy( vec4_t v ) { return vec4( v.z, v.z, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_zzyz( vec4_t v ) { return vec4( v.z, v.z, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_zzyw( vec4_t v ) { return vec4( v.z, v.z, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_zzzx( vec4_t v ) { return vec4( v.z, v.z, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_zzzy( vec4_t v ) { return vec4( v.z, v.z, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_zzzz( vec4_t v ) { return vec4( v.z, v.z, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_zzzw( vec4_t v ) { return vec4( v.z, v.z, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_zzwx( vec4_t v ) { return vec4( v.z, v.z, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_zzwy( vec4_t v ) { return vec4( v.z, v.z, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_zzwz( vec4_t v ) { return vec4( v.z, v.z, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_zzww( vec4_t v ) { return vec4( v.z, v.z, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_zwxx( vec4_t v ) { return vec4( v.z, v.w, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_zwxy( vec4_t v ) { return vec4( v.z, v.w, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_zwxz( vec4_t v ) { return vec4( v.z, v.w, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_zwxw( vec4_t v ) { return vec4( v.z, v.w, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_zwyx( vec4_t v ) { return vec4( v.z, v.w, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_zwyy( vec4_t v ) { return vec4( v.z, v.w, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_zwyz( vec4_t v ) { return vec4( v.z, v.w, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_zwyw( vec4_t v ) { return vec4( v.z, v.w, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_zwzx( vec4_t v ) { return vec4( v.z, v.w, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_zwzy( vec4_t v ) { return vec4( v.z, v.w, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_zwzz( vec4_t v ) { return vec4( v.z, v.w, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_zwzw( vec4_t v ) { return vec4( v.z, v.w, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_zwwx( vec4_t v ) { return vec4( v.z, v.w, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_zwwy( vec4_t v ) { return vec4( v.z, v.w, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_zwwz( vec4_t v ) { return vec4( v.z, v.w, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_zwww( vec4_t v ) { return vec4( v.z, v.w, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_wxxx( vec4_t v ) { return vec4( v.w, v.x, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_wxxy( vec4_t v ) { return vec4( v.w, v.x, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_wxxz( vec4_t v ) { return vec4( v.w, v.x, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_wxxw( vec4_t v ) { return vec4( v.w, v.x, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_wxyx( vec4_t v ) { return vec4( v.w, v.x, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_wxyy( vec4_t v ) { return vec4( v.w, v.x, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_wxyz( vec4_t v ) { return vec4( v.w, v.x, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_wxyw( vec4_t v ) { return vec4( v.w, v.x, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_wxzx( vec4_t v ) { return vec4( v.w, v.x, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_wxzy( vec4_t v ) { return vec4( v.w, v.x, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_wxzz( vec4_t v ) { return vec4( v.w, v.x, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_wxzw( vec4_t v ) { return vec4( v.w, v.x, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_wxwx( vec4_t v ) { return vec4( v.w, v.x, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_wxwy( vec4_t v ) { return vec4( v.w, v.x, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_wxwz( vec4_t v ) { return vec4( v.w, v.x, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_wxww( vec4_t v ) { return vec4( v.w, v.x, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_wyxx( vec4_t v ) { return vec4( v.w, v.y, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_wyxy( vec4_t v ) { return vec4( v.w, v.y, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_wyxz( vec4_t v ) { return vec4( v.w, v.y, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_wyxw( vec4_t v ) { return vec4( v.w, v.y, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_wyyx( vec4_t v ) { return vec4( v.w, v.y, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_wyyy( vec4_t v ) { return vec4( v.w, v.y, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_wyyz( vec4_t v ) { return vec4( v.w, v.y, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_wyyw( vec4_t v ) { return vec4( v.w, v.y, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_wyzx( vec4_t v ) { return vec4( v.w, v.y, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_wyzy( vec4_t v ) { return vec4( v.w, v.y, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_wyzz( vec4_t v ) { return vec4( v.w, v.y, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_wyzw( vec4_t v ) { return vec4( v.w, v.y, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_wywx( vec4_t v ) { return vec4( v.w, v.y, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_wywy( vec4_t v ) { return vec4( v.w, v.y, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_wywz( vec4_t v ) { return vec4( v.w, v.y, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_wyww( vec4_t v ) { return vec4( v.w, v.y, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_wzxx( vec4_t v ) { return vec4( v.w, v.z, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_wzxy( vec4_t v ) { return vec4( v.w, v.z, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_wzxz( vec4_t v ) { return vec4( v.w, v.z, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_wzxw( vec4_t v ) { return vec4( v.w, v.z, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_wzyx( vec4_t v ) { return vec4( v.w, v.z, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_wzyy( vec4_t v ) { return vec4( v.w, v.z, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_wzyz( vec4_t v ) { return vec4( v.w, v.z, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_wzyw( vec4_t v ) { return vec4( v.w, v.z, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_wzzx( vec4_t v ) { return vec4( v.w, v.z, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_wzzy( vec4_t v ) { return vec4( v.w, v.z, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_wzzz( vec4_t v ) { return vec4( v.w, v.z, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_wzzw( vec4_t v ) { return vec4( v.w, v.z, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_wzwx( vec4_t v ) { return vec4( v.w, v.z, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_wzwy( vec4_t v ) { return vec4( v.w, v.z, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_wzwz( vec4_t v ) { return vec4( v.w, v.z, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_wzww( vec4_t v ) { return vec4( v.w, v.z, v.w, v.w ); }
VECMATH_INLINE vec4_t vec4_wwxx( vec4_t v ) { return vec4( v.w, v.w, v.x, v.x ); }
VECMATH_INLINE vec4_t vec4_wwxy( vec4_t v ) { return vec4( v.w, v.w, v.x, v.y ); }
VECMATH_INLINE vec4_t vec4_wwxz( vec4_t v ) { return vec4( v.w, v.w, v.x, v.z ); }
VECMATH_INLINE vec4_t vec4_wwxw( vec4_t v ) { return vec4( v.w, v.w, v.x, v.w ); }
VECMATH_INLINE vec4_t vec4_wwyx( vec4_t v ) { return vec4( v.w, v.w, v.y, v.x ); }
VECMATH_INLINE vec4_t vec4_wwyy( vec4_t v ) { return vec4( v.w, v.w, v.y, v.y ); }
VECMATH_INLINE vec4_t vec4_wwyz( vec4_t v ) { return vec4( v.w, v.w, v.y, v.z ); }
VECMATH_INLINE vec4_t vec4_wwyw( vec4_t v ) { return vec4( v.w, v.w, v.y, v.w ); }
VECMATH_INLINE vec4_t vec4_wwzx( vec4_t v ) { return vec4( v.w, v.w, v.z, v.x ); }
VECMATH_INLINE vec4_t vec4_wwzy( vec4_t v ) { return vec4( v.w, v.w, v.z, v.y ); }
VECMATH_INLINE vec4_t vec4_wwzz( vec4_t v ) { return vec4( v.w, v.w, v.z, v.z ); }
VECMATH_INLINE vec4_t vec4_wwzw( vec4_t v ) { return vec4( v.w, v.w, v.z, v.w ); }
VECMATH_INLINE vec4_t vec4_wwwx( vec4_t v ) { return vec4( v.w, v.w, v.w, v.x ); }
VECMATH_INLINE vec4_t vec4_wwwy( vec4_t v ) { return vec4( v.w, v.w, v.w, v.y ); }
VECMATH_INLINE vec4_t vec4_wwwz( vec4_t v ) { return vec4( v.w, v.w, v.w, v.z ); }
VECMATH_INLINE vec4_t vec4_wwww( vec4_t v ) { return vec4( v.w, v.w, v.w, v.w ); }


// c++ operators
#ifdef __cplusplus
    // vec2
    VECMATH_INLINE vec2_t operator-( vec2_t v ) { return vec2_neg( v ); }
    VECMATH_INLINE bool operator==( vec2_t a, vec2_t b ) { return (bool)vec2_eq( a, b ); }
    VECMATH_INLINE bool operator!=( vec2_t a, vec2_t b ) { return (bool)!vec2_eq( a, b ); }

    VECMATH_INLINE vec2_t operator+( vec2_t a, vec2_t b ) { return vec2_add( a, b ); }
    VECMATH_INLINE vec2_t operator-( vec2_t a, vec2_t b ) { return vec2_sub( a, b ); }
    VECMATH_INLINE vec2_t operator*( vec2_t a, vec2_t b ) { return vec2_mul( a, b ); }
    VECMATH_INLINE vec2_t operator/( vec2_t a, vec2_t b ) { return vec2_div( a, b ); }

    VECMATH_INLINE vec2_t operator+( vec2_t a, float b ) { return vec2_addf( a, b ); }
    VECMATH_INLINE vec2_t operator-( vec2_t a, float b ) { return vec2_subf( a, b ); }
    VECMATH_INLINE vec2_t operator*( vec2_t a, float b ) { return vec2_mulf( a, b ); }
    VECMATH_INLINE vec2_t operator/( vec2_t a, float b ) { return vec2_divf( a, b ); }

    VECMATH_INLINE vec2_t operator+( float a, vec2_t b ) { return vec2_addf( b, a ); }
    VECMATH_INLINE vec2_t operator-( float a, vec2_t b ) { return vec2_addf( vec2_neg( b ), a ); }
    VECMATH_INLINE vec2_t operator*( float a, vec2_t b ) { return vec2_mulf( b, a ); }
    VECMATH_INLINE vec2_t operator/( float a, vec2_t b ) { return vec2_mul( vec2f( a ), vec2_rcp( b ) ); }

    VECMATH_INLINE vec2_t& operator+=( vec2_t& a, vec2_t b ) { return a = vec2_add( a, b ); }
    VECMATH_INLINE vec2_t& operator-=( vec2_t& a, vec2_t b ) { return a = vec2_sub( a, b ); }
    VECMATH_INLINE vec2_t& operator*=( vec2_t& a, vec2_t b ) { return a = vec2_mul( a, b ); }
    VECMATH_INLINE vec2_t& operator/=( vec2_t& a, vec2_t b ) { return a = vec2_div( a, b ); }

    VECMATH_INLINE vec2_t& operator+=( vec2_t& a, float b ) { return a = vec2_addf( a, b ); }
    VECMATH_INLINE vec2_t& operator-=( vec2_t& a, float b ) { return a = vec2_subf( a, b ); }
    VECMATH_INLINE vec2_t& operator*=( vec2_t& a, float b ) { return a = vec2_mulf( a, b ); }
    VECMATH_INLINE vec2_t& operator/=( vec2_t& a, float b ) { return a = vec2_divf( a, b ); }

    // vec3
    VECMATH_INLINE vec3_t operator-( vec3_t v ) { return vec3_neg( v ); }
    VECMATH_INLINE bool operator==( vec3_t a, vec3_t b ) { return (bool)vec3_eq( a, b ); }
    VECMATH_INLINE bool operator!=( vec3_t a, vec3_t b ) { return (bool)!vec3_eq( a, b ); }

    VECMATH_INLINE vec3_t operator+( vec3_t a, vec3_t b ) { return vec3_add( a, b ); }
    VECMATH_INLINE vec3_t operator-( vec3_t a, vec3_t b ) { return vec3_sub( a, b ); }
    VECMATH_INLINE vec3_t operator*( vec3_t a, vec3_t b ) { return vec3_mul( a, b ); }
    VECMATH_INLINE vec3_t operator/( vec3_t a, vec3_t b ) { return vec3_div( a, b ); }

    VECMATH_INLINE vec3_t operator+( vec3_t a, float b ) { return vec3_addf( a, b ); }
    VECMATH_INLINE vec3_t operator-( vec3_t a, float b ) { return vec3_subf( a, b ); }
    VECMATH_INLINE vec3_t operator*( vec3_t a, float b ) { return vec3_mulf( a, b ); }
    VECMATH_INLINE vec3_t operator/( vec3_t a, float b ) { return vec3_divf( a, b ); }

    VECMATH_INLINE vec3_t operator+( float a, vec3_t b ) { return vec3_addf( b, a ); }
    VECMATH_INLINE vec3_t operator-( float a, vec3_t b ) { return vec3_addf( vec3_neg( b ), a ); }
    VECMATH_INLINE vec3_t operator*( float a, vec3_t b ) { return vec3_mulf( b, a ); }
    VECMATH_INLINE vec3_t operator/( float a, vec3_t b ) { return vec3_mul( vec3f( a ), vec3_rcp( b ) ); }

    VECMATH_INLINE vec3_t& operator+=( vec3_t& a, vec3_t b ) { return a = vec3_add( a, b ); }
    VECMATH_INLINE vec3_t& operator-=( vec3_t& a, vec3_t b ) { return a = vec3_sub( a, b ); }
    VECMATH_INLINE vec3_t& operator*=( vec3_t& a, vec3_t b ) { return a = vec3_mul( a, b ); }
    VECMATH_INLINE vec3_t& operator/=( vec3_t& a, vec3_t b ) { return a = vec3_div( a, b ); }

    VECMATH_INLINE vec3_t& operator+=( vec3_t& a, float b ) { return a = vec3_addf( a, b ); }
    VECMATH_INLINE vec3_t& operator-=( vec3_t& a, float b ) { return a = vec3_subf( a, b ); }
    VECMATH_INLINE vec3_t& operator*=( vec3_t& a, float b ) { return a = vec3_mulf( a, b ); }
    VECMATH_INLINE vec3_t& operator/=( vec3_t& a, float b ) { return a = vec3_divf( a, b ); }

    // vec4
    VECMATH_INLINE vec4_t operator-( vec4_t v ) { return vec4_neg( v ); }
    VECMATH_INLINE bool operator==( vec4_t a, vec4_t b ) { return (bool)vec4_eq( a, b ); }
    VECMATH_INLINE bool operator!=( vec4_t a, vec4_t b ) { return (bool)!vec4_eq( a, b ); }

    VECMATH_INLINE vec4_t operator+( vec4_t a, vec4_t b ) { return vec4_add( a, b ); }
    VECMATH_INLINE vec4_t operator-( vec4_t a, vec4_t b ) { return vec4_sub( a, b ); }
    VECMATH_INLINE vec4_t operator*( vec4_t a, vec4_t b ) { return vec4_mul( a, b ); }
    VECMATH_INLINE vec4_t operator/( vec4_t a, vec4_t b ) { return vec4_div( a, b ); }

    VECMATH_INLINE vec4_t operator+( vec4_t a, float b ) { return vec4_addf( a, b ); }
    VECMATH_INLINE vec4_t operator-( vec4_t a, float b ) { return vec4_subf( a, b ); }
    VECMATH_INLINE vec4_t operator*( vec4_t a, float b ) { return vec4_mulf( a, b ); }
    VECMATH_INLINE vec4_t operator/( vec4_t a, float b ) { return vec4_divf( a, b ); }

    VECMATH_INLINE vec4_t operator+( float a, vec4_t b ) { return vec4_addf( b, a ); }
    VECMATH_INLINE vec4_t operator-( float a, vec4_t b ) { return vec4_addf( vec4_neg( b ), a ); }
    VECMATH_INLINE vec4_t operator*( float a, vec4_t b ) { return vec4_mulf( b, a ); }
    VECMATH_INLINE vec4_t operator/( float a, vec4_t b ) { return vec4_mul( vec4f( a ), vec4_rcp( b ) ); }

    VECMATH_INLINE vec4_t& operator+=( vec4_t& a, vec4_t b ) { return a = vec4_add( a, b ); }
    VECMATH_INLINE vec4_t& operator-=( vec4_t& a, vec4_t b ) { return a = vec4_sub( a, b ); }
    VECMATH_INLINE vec4_t& operator*=( vec4_t& a, vec4_t b ) { return a = vec4_mul( a, b ); }
    VECMATH_INLINE vec4_t& operator/=( vec4_t& a, vec4_t b ) { return a = vec4_div( a, b ); }

    VECMATH_INLINE vec4_t& operator+=( vec4_t& a, float b ) { return a = vec4_addf( a, b ); }
    VECMATH_INLINE vec4_t& operator-=( vec4_t& a, float b ) { return a = vec4_subf( a, b ); }
    VECMATH_INLINE vec4_t& operator*=( vec4_t& a, float b ) { return a = vec4_mulf( a, b ); }
    VECMATH_INLINE vec4_t& operator/=( vec4_t& a, float b ) { return a = vec4_divf( a, b ); }


    // mat22
    VECMATH_INLINE mat22_t operator-( mat22_t v ) { return mat22_neg( v ); }
    VECMATH_INLINE bool operator==( mat22_t a, mat22_t b ) { return (bool)mat22_eq( a, b ); }
    VECMATH_INLINE bool operator!=( mat22_t a, mat22_t b ) { return (bool)!mat22_eq( a, b ); }

    VECMATH_INLINE mat22_t operator+( mat22_t a, mat22_t b ) { return mat22_add( a, b ); }
    VECMATH_INLINE mat22_t operator-( mat22_t a, mat22_t b ) { return mat22_sub( a, b ); }
    VECMATH_INLINE mat22_t operator/( mat22_t a, mat22_t b ) { return mat22_div( a, b ); }

    VECMATH_INLINE mat22_t operator+( mat22_t a, float b ) { return mat22_addf( a, b ); }
    VECMATH_INLINE mat22_t operator-( mat22_t a, float b ) { return mat22_subf( a, b ); }
    VECMATH_INLINE mat22_t operator*( mat22_t a, float b ) { return mat22_mulf( a, b ); }
    VECMATH_INLINE mat22_t operator/( mat22_t a, float b ) { return mat22_divf( a, b ); }

    VECMATH_INLINE mat22_t operator+( float a, mat22_t b ) { return mat22_addf( b, a ); }
    VECMATH_INLINE mat22_t operator-( float a, mat22_t b ) { return mat22_addf( mat22_neg( b ), a ); }
    VECMATH_INLINE mat22_t operator*( float a, mat22_t b ) { return mat22_mulf( b, a ); }
    VECMATH_INLINE mat22_t operator/( float a, mat22_t b ) { return mat22_div( mat22f( a ), b ); }

    VECMATH_INLINE mat22_t& operator+=( mat22_t& a, mat22_t b ) { return a = mat22_add( a, b ); }
    VECMATH_INLINE mat22_t& operator-=( mat22_t& a, mat22_t b ) { return a = mat22_sub( a, b ); }
    VECMATH_INLINE mat22_t& operator/=( mat22_t& a, mat22_t b ) { return a = mat22_div( a, b ); }

    VECMATH_INLINE mat22_t& operator+=( mat22_t& a, float b ) { return a = mat22_addf( a, b ); }
    VECMATH_INLINE mat22_t& operator-=( mat22_t& a, float b ) { return a = mat22_subf( a, b ); }
    VECMATH_INLINE mat22_t& operator*=( mat22_t& a, float b ) { return a = mat22_mulf( a, b ); }
    VECMATH_INLINE mat22_t& operator/=( mat22_t& a, float b ) { return a = mat22_divf( a, b ); }


    // mat23
    VECMATH_INLINE mat23_t operator-( mat23_t v ) { return mat23_neg( v ); }
    VECMATH_INLINE bool operator==( mat23_t a, mat23_t b ) { return (bool)mat23_eq( a, b ); }
    VECMATH_INLINE bool operator!=( mat23_t a, mat23_t b ) { return (bool)!mat23_eq( a, b ); }

    VECMATH_INLINE mat23_t operator+( mat23_t a, mat23_t b ) { return mat23_add( a, b ); }
    VECMATH_INLINE mat23_t operator-( mat23_t a, mat23_t b ) { return mat23_sub( a, b ); }
    VECMATH_INLINE mat23_t operator/( mat23_t a, mat23_t b ) { return mat23_div( a, b ); }

    VECMATH_INLINE mat23_t operator+( mat23_t a, float b ) { return mat23_addf( a, b ); }
    VECMATH_INLINE mat23_t operator-( mat23_t a, float b ) { return mat23_subf( a, b ); }
    VECMATH_INLINE mat23_t operator*( mat23_t a, float b ) { return mat23_mulf( a, b ); }
    VECMATH_INLINE mat23_t operator/( mat23_t a, float b ) { return mat23_divf( a, b ); }

    VECMATH_INLINE mat23_t operator+( float a, mat23_t b ) { return mat23_addf( b, a ); }
    VECMATH_INLINE mat23_t operator-( float a, mat23_t b ) { return mat23_addf( mat23_neg( b ), a ); }
    VECMATH_INLINE mat23_t operator*( float a, mat23_t b ) { return mat23_mulf( b, a ); }
    VECMATH_INLINE mat23_t operator/( float a, mat23_t b ) { return mat23_div( mat23f( a ), b ); }

    VECMATH_INLINE mat23_t& operator+=( mat23_t& a, mat23_t b ) { return a = mat23_add( a, b ); }
    VECMATH_INLINE mat23_t& operator-=( mat23_t& a, mat23_t b ) { return a = mat23_sub( a, b ); }
    VECMATH_INLINE mat23_t& operator/=( mat23_t& a, mat23_t b ) { return a = mat23_div( a, b ); }

    VECMATH_INLINE mat23_t& operator+=( mat23_t& a, float b ) { return a = mat23_addf( a, b ); }
    VECMATH_INLINE mat23_t& operator-=( mat23_t& a, float b ) { return a = mat23_subf( a, b ); }
    VECMATH_INLINE mat23_t& operator*=( mat23_t& a, float b ) { return a = mat23_mulf( a, b ); }
    VECMATH_INLINE mat23_t& operator/=( mat23_t& a, float b ) { return a = mat23_divf( a, b ); }

    // mat24
    VECMATH_INLINE mat24_t operator-( mat24_t v ) { return mat24_neg( v ); }
    VECMATH_INLINE bool operator==( mat24_t a, mat24_t b ) { return (bool)mat24_eq( a, b ); }
    VECMATH_INLINE bool operator!=( mat24_t a, mat24_t b ) { return (bool)!mat24_eq( a, b ); }

    VECMATH_INLINE mat24_t operator+( mat24_t a, mat24_t b ) { return mat24_add( a, b ); }
    VECMATH_INLINE mat24_t operator-( mat24_t a, mat24_t b ) { return mat24_sub( a, b ); }
    VECMATH_INLINE mat24_t operator/( mat24_t a, mat24_t b ) { return mat24_div( a, b ); }

    VECMATH_INLINE mat24_t operator+( mat24_t a, float b ) { return mat24_addf( a, b ); }
    VECMATH_INLINE mat24_t operator-( mat24_t a, float b ) { return mat24_subf( a, b ); }
    VECMATH_INLINE mat24_t operator*( mat24_t a, float b ) { return mat24_mulf( a, b ); }
    VECMATH_INLINE mat24_t operator/( mat24_t a, float b ) { return mat24_divf( a, b ); }

    VECMATH_INLINE mat24_t operator+( float a, mat24_t b ) { return mat24_addf( b, a ); }
    VECMATH_INLINE mat24_t operator-( float a, mat24_t b ) { return mat24_addf( mat24_neg( b ), a ); }
    VECMATH_INLINE mat24_t operator*( float a, mat24_t b ) { return mat24_mulf( b, a ); }
    VECMATH_INLINE mat24_t operator/( float a, mat24_t b ) { return mat24_div( mat24f( a ), b ); }

    VECMATH_INLINE mat24_t& operator+=( mat24_t& a, mat24_t b ) { return a = mat24_add( a, b ); }
    VECMATH_INLINE mat24_t& operator-=( mat24_t& a, mat24_t b ) { return a = mat24_sub( a, b ); }
    VECMATH_INLINE mat24_t& operator/=( mat24_t& a, mat24_t b ) { return a = mat24_div( a, b ); }

    VECMATH_INLINE mat24_t& operator+=( mat24_t& a, float b ) { return a = mat24_addf( a, b ); }
    VECMATH_INLINE mat24_t& operator-=( mat24_t& a, float b ) { return a = mat24_subf( a, b ); }
    VECMATH_INLINE mat24_t& operator*=( mat24_t& a, float b ) { return a = mat24_mulf( a, b ); }
    VECMATH_INLINE mat24_t& operator/=( mat24_t& a, float b ) { return a = mat24_divf( a, b ); }


    // mat32
    VECMATH_INLINE mat32_t operator-( mat32_t v ) { return mat32_neg( v ); }
    VECMATH_INLINE bool operator==( mat32_t a, mat32_t b ) { return (bool)mat32_eq( a, b ); }
    VECMATH_INLINE bool operator!=( mat32_t a, mat32_t b ) { return (bool)!mat32_eq( a, b ); }

    VECMATH_INLINE mat32_t operator+( mat32_t a, mat32_t b ) { return mat32_add( a, b ); }
    VECMATH_INLINE mat32_t operator-( mat32_t a, mat32_t b ) { return mat32_sub( a, b ); }
    VECMATH_INLINE mat32_t operator/( mat32_t a, mat32_t b ) { return mat32_div( a, b ); }

    VECMATH_INLINE mat32_t operator+( mat32_t a, float b ) { return mat32_addf( a, b ); }
    VECMATH_INLINE mat32_t operator-( mat32_t a, float b ) { return mat32_subf( a, b ); }
    VECMATH_INLINE mat32_t operator*( mat32_t a, float b ) { return mat32_mulf( a, b ); }
    VECMATH_INLINE mat32_t operator/( mat32_t a, float b ) { return mat32_divf( a, b ); }

    VECMATH_INLINE mat32_t operator+( float a, mat32_t b ) { return mat32_addf( b, a ); }
    VECMATH_INLINE mat32_t operator-( float a, mat32_t b ) { return mat32_addf( mat32_neg( b ), a ); }
    VECMATH_INLINE mat32_t operator*( float a, mat32_t b ) { return mat32_mulf( b, a ); }
    VECMATH_INLINE mat32_t operator/( float a, mat32_t b ) { return mat32_div( mat32f( a ), b ); }

    VECMATH_INLINE mat32_t& operator+=( mat32_t& a, mat32_t b ) { return a = mat32_add( a, b ); }
    VECMATH_INLINE mat32_t& operator-=( mat32_t& a, mat32_t b ) { return a = mat32_sub( a, b ); }
    VECMATH_INLINE mat32_t& operator/=( mat32_t& a, mat32_t b ) { return a = mat32_div( a, b ); }

    VECMATH_INLINE mat32_t& operator+=( mat32_t& a, float b ) { return a = mat32_addf( a, b ); }
    VECMATH_INLINE mat32_t& operator-=( mat32_t& a, float b ) { return a = mat32_subf( a, b ); }
    VECMATH_INLINE mat32_t& operator*=( mat32_t& a, float b ) { return a = mat32_mulf( a, b ); }
    VECMATH_INLINE mat32_t& operator/=( mat32_t& a, float b ) { return a = mat32_divf( a, b ); }


    // mat33
    VECMATH_INLINE mat33_t operator-( mat33_t v ) { return mat33_neg( v ); }
    VECMATH_INLINE bool operator==( mat33_t a, mat33_t b ) { return (bool)mat33_eq( a, b ); }
    VECMATH_INLINE bool operator!=( mat33_t a, mat33_t b ) { return (bool)!mat33_eq( a, b ); }

    VECMATH_INLINE mat33_t operator+( mat33_t a, mat33_t b ) { return mat33_add( a, b ); }
    VECMATH_INLINE mat33_t operator-( mat33_t a, mat33_t b ) { return mat33_sub( a, b ); }
    VECMATH_INLINE mat33_t operator/( mat33_t a, mat33_t b ) { return mat33_div( a, b ); }

    VECMATH_INLINE mat33_t operator+( mat33_t a, float b ) { return mat33_addf( a, b ); }
    VECMATH_INLINE mat33_t operator-( mat33_t a, float b ) { return mat33_subf( a, b ); }
    VECMATH_INLINE mat33_t operator*( mat33_t a, float b ) { return mat33_mulf( a, b ); }
    VECMATH_INLINE mat33_t operator/( mat33_t a, float b ) { return mat33_divf( a, b ); }

    VECMATH_INLINE mat33_t operator+( float a, mat33_t b ) { return mat33_addf( b, a ); }
    VECMATH_INLINE mat33_t operator-( float a, mat33_t b ) { return mat33_addf( mat33_neg( b ), a ); }
    VECMATH_INLINE mat33_t operator*( float a, mat33_t b ) { return mat33_mulf( b, a ); }
    VECMATH_INLINE mat33_t operator/( float a, mat33_t b ) { return mat33_div( mat33f( a ), b ); }

    VECMATH_INLINE mat33_t& operator+=( mat33_t& a, mat33_t b ) { return a = mat33_add( a, b ); }
    VECMATH_INLINE mat33_t& operator-=( mat33_t& a, mat33_t b ) { return a = mat33_sub( a, b ); }
    VECMATH_INLINE mat33_t& operator/=( mat33_t& a, mat33_t b ) { return a = mat33_div( a, b ); }

    VECMATH_INLINE mat33_t& operator+=( mat33_t& a, float b ) { return a = mat33_addf( a, b ); }
    VECMATH_INLINE mat33_t& operator-=( mat33_t& a, float b ) { return a = mat33_subf( a, b ); }
    VECMATH_INLINE mat33_t& operator*=( mat33_t& a, float b ) { return a = mat33_mulf( a, b ); }
    VECMATH_INLINE mat33_t& operator/=( mat33_t& a, float b ) { return a = mat33_divf( a, b ); }


    // mat34
    VECMATH_INLINE mat34_t operator-( mat34_t v ) { return mat34_neg( v ); }
    VECMATH_INLINE bool operator==( mat34_t a, mat34_t b ) { return (bool)mat34_eq( a, b ); }
    VECMATH_INLINE bool operator!=( mat34_t a, mat34_t b ) { return (bool)!mat34_eq( a, b ); }

    VECMATH_INLINE mat34_t operator+( mat34_t a, mat34_t b ) { return mat34_add( a, b ); }
    VECMATH_INLINE mat34_t operator-( mat34_t a, mat34_t b ) { return mat34_sub( a, b ); }
    VECMATH_INLINE mat34_t operator/( mat34_t a, mat34_t b ) { return mat34_div( a, b ); }

    VECMATH_INLINE mat34_t operator+( mat34_t a, float b ) { return mat34_addf( a, b ); }
    VECMATH_INLINE mat34_t operator-( mat34_t a, float b ) { return mat34_subf( a, b ); }
    VECMATH_INLINE mat34_t operator*( mat34_t a, float b ) { return mat34_mulf( a, b ); }
    VECMATH_INLINE mat34_t operator/( mat34_t a, float b ) { return mat34_divf( a, b ); }

    VECMATH_INLINE mat34_t operator+( float a, mat34_t b ) { return mat34_addf( b, a ); }
    VECMATH_INLINE mat34_t operator-( float a, mat34_t b ) { return mat34_addf( mat34_neg( b ), a ); }
    VECMATH_INLINE mat34_t operator*( float a, mat34_t b ) { return mat34_mulf( b, a ); }
    VECMATH_INLINE mat34_t operator/( float a, mat34_t b ) { return mat34_div( mat34f( a ), b ); }

    VECMATH_INLINE mat34_t& operator+=( mat34_t& a, mat34_t b ) { return a = mat34_add( a, b ); }
    VECMATH_INLINE mat34_t& operator-=( mat34_t& a, mat34_t b ) { return a = mat34_sub( a, b ); }
    VECMATH_INLINE mat34_t& operator/=( mat34_t& a, mat34_t b ) { return a = mat34_div( a, b ); }

    VECMATH_INLINE mat34_t& operator+=( mat34_t& a, float b ) { return a = mat34_addf( a, b ); }
    VECMATH_INLINE mat34_t& operator-=( mat34_t& a, float b ) { return a = mat34_subf( a, b ); }
    VECMATH_INLINE mat34_t& operator*=( mat34_t& a, float b ) { return a = mat34_mulf( a, b ); }
    VECMATH_INLINE mat34_t& operator/=( mat34_t& a, float b ) { return a = mat34_divf( a, b ); }

    // mat42
    VECMATH_INLINE mat42_t operator-( mat42_t v ) { return mat42_neg( v ); }
    VECMATH_INLINE bool operator==( mat42_t a, mat42_t b ) { return (bool)mat42_eq( a, b ); }
    VECMATH_INLINE bool operator!=( mat42_t a, mat42_t b ) { return (bool)!mat42_eq( a, b ); }

    VECMATH_INLINE mat42_t operator+( mat42_t a, mat42_t b ) { return mat42_add( a, b ); }
    VECMATH_INLINE mat42_t operator-( mat42_t a, mat42_t b ) { return mat42_sub( a, b ); }
    VECMATH_INLINE mat42_t operator/( mat42_t a, mat42_t b ) { return mat42_div( a, b ); }

    VECMATH_INLINE mat42_t operator+( mat42_t a, float b ) { return mat42_addf( a, b ); }
    VECMATH_INLINE mat42_t operator-( mat42_t a, float b ) { return mat42_subf( a, b ); }
    VECMATH_INLINE mat42_t operator*( mat42_t a, float b ) { return mat42_mulf( a, b ); }
    VECMATH_INLINE mat42_t operator/( mat42_t a, float b ) { return mat42_divf( a, b ); }

    VECMATH_INLINE mat42_t operator+( float a, mat42_t b ) { return mat42_addf( b, a ); }
    VECMATH_INLINE mat42_t operator-( float a, mat42_t b ) { return mat42_addf( mat42_neg( b ), a ); }
    VECMATH_INLINE mat42_t operator*( float a, mat42_t b ) { return mat42_mulf( b, a ); }
    VECMATH_INLINE mat42_t operator/( float a, mat42_t b ) { return mat42_div( mat42f( a ), b ); }

    VECMATH_INLINE mat42_t& operator+=( mat42_t& a, mat42_t b ) { return a = mat42_add( a, b ); }
    VECMATH_INLINE mat42_t& operator-=( mat42_t& a, mat42_t b ) { return a = mat42_sub( a, b ); }
    VECMATH_INLINE mat42_t& operator/=( mat42_t& a, mat42_t b ) { return a = mat42_div( a, b ); }

    VECMATH_INLINE mat42_t& operator+=( mat42_t& a, float b ) { return a = mat42_addf( a, b ); }
    VECMATH_INLINE mat42_t& operator-=( mat42_t& a, float b ) { return a = mat42_subf( a, b ); }
    VECMATH_INLINE mat42_t& operator*=( mat42_t& a, float b ) { return a = mat42_mulf( a, b ); }
    VECMATH_INLINE mat42_t& operator/=( mat42_t& a, float b ) { return a = mat42_divf( a, b ); }

    // mat43
    VECMATH_INLINE mat43_t operator-( mat43_t v ) { return mat43_neg( v ); }
    VECMATH_INLINE bool operator==( mat43_t a, mat43_t b ) { return (bool)mat43_eq( a, b ); }
    VECMATH_INLINE bool operator!=( mat43_t a, mat43_t b ) { return (bool)!mat43_eq( a, b ); }

    VECMATH_INLINE mat43_t operator+( mat43_t a, mat43_t b ) { return mat43_add( a, b ); }
    VECMATH_INLINE mat43_t operator-( mat43_t a, mat43_t b ) { return mat43_sub( a, b ); }
    VECMATH_INLINE mat43_t operator/( mat43_t a, mat43_t b ) { return mat43_div( a, b ); }

    VECMATH_INLINE mat43_t operator+( mat43_t a, float b ) { return mat43_addf( a, b ); }
    VECMATH_INLINE mat43_t operator-( mat43_t a, float b ) { return mat43_subf( a, b ); }
    VECMATH_INLINE mat43_t operator*( mat43_t a, float b ) { return mat43_mulf( a, b ); }
    VECMATH_INLINE mat43_t operator/( mat43_t a, float b ) { return mat43_divf( a, b ); }

    VECMATH_INLINE mat43_t operator+( float a, mat43_t b ) { return mat43_addf( b, a ); }
    VECMATH_INLINE mat43_t operator-( float a, mat43_t b ) { return mat43_addf( mat43_neg( b ), a ); }
    VECMATH_INLINE mat43_t operator*( float a, mat43_t b ) { return mat43_mulf( b, a ); }
    VECMATH_INLINE mat43_t operator/( float a, mat43_t b ) { return mat43_div( mat43f( a ), b ); }

    VECMATH_INLINE mat43_t& operator+=( mat43_t& a, mat43_t b ) { return a = mat43_add( a, b ); }
    VECMATH_INLINE mat43_t& operator-=( mat43_t& a, mat43_t b ) { return a = mat43_sub( a, b ); }
    VECMATH_INLINE mat43_t& operator/=( mat43_t& a, mat43_t b ) { return a = mat43_div( a, b ); }

    VECMATH_INLINE mat43_t& operator+=( mat43_t& a, float b ) { return a = mat43_addf( a, b ); }
    VECMATH_INLINE mat43_t& operator-=( mat43_t& a, float b ) { return a = mat43_subf( a, b ); }
    VECMATH_INLINE mat43_t& operator*=( mat43_t& a, float b ) { return a = mat43_mulf( a, b ); }
    VECMATH_INLINE mat43_t& operator/=( mat43_t& a, float b ) { return a = mat43_divf( a, b ); }


    // mat44
    VECMATH_INLINE mat44_t operator-( mat44_t v ) { return mat44_neg( v ); }
    VECMATH_INLINE bool operator==( mat44_t a, mat44_t b ) { return (bool)mat44_eq( a, b ); }
    VECMATH_INLINE bool operator!=( mat44_t a, mat44_t b ) { return (bool)!mat44_eq( a, b ); }

    VECMATH_INLINE mat44_t operator+( mat44_t a, mat44_t b ) { return mat44_add( a, b ); }
    VECMATH_INLINE mat44_t operator-( mat44_t a, mat44_t b ) { return mat44_sub( a, b ); }
    VECMATH_INLINE mat44_t operator/( mat44_t a, mat44_t b ) { return mat44_div( a, b ); }

    VECMATH_INLINE mat44_t operator+( mat44_t a, float b ) { return mat44_addf( a, b ); }
    VECMATH_INLINE mat44_t operator-( mat44_t a, float b ) { return mat44_subf( a, b ); }
    VECMATH_INLINE mat44_t operator*( mat44_t a, float b ) { return mat44_mulf( a, b ); }
    VECMATH_INLINE mat44_t operator/( mat44_t a, float b ) { return mat44_divf( a, b ); }

    VECMATH_INLINE mat44_t operator+( float a, mat44_t b ) { return mat44_addf( b, a ); }
    VECMATH_INLINE mat44_t operator-( float a, mat44_t b ) { return mat44_addf( mat44_neg( b ), a ); }
    VECMATH_INLINE mat44_t operator*( float a, mat44_t b ) { return mat44_mulf( b, a ); }
    VECMATH_INLINE mat44_t operator/( float a, mat44_t b ) { return mat44_div( mat44f( a ), b ); }

    VECMATH_INLINE mat44_t& operator+=( mat44_t& a, mat44_t b ) { return a = mat44_add( a, b ); }
    VECMATH_INLINE mat44_t& operator-=( mat44_t& a, mat44_t b ) { return a = mat44_sub( a, b ); }
    VECMATH_INLINE mat44_t& operator/=( mat44_t& a, mat44_t b ) { return a = mat44_div( a, b ); }

    VECMATH_INLINE mat44_t& operator+=( mat44_t& a, float b ) { return a = mat44_addf( a, b ); }
    VECMATH_INLINE mat44_t& operator-=( mat44_t& a, float b ) { return a = mat44_subf( a, b ); }
    VECMATH_INLINE mat44_t& operator*=( mat44_t& a, float b ) { return a = mat44_mulf( a, b ); }
    VECMATH_INLINE mat44_t& operator/=( mat44_t& a, float b ) { return a = mat44_divf( a, b ); }


    // c++ operators for matrix multiplication 
    VECMATH_INLINE vec2_t operator*( vec2_t a, mat22_t b ) { return vec2_mul_mat22( a, b ); }
    VECMATH_INLINE vec3_t operator*( vec2_t a, mat23_t b ) { return vec2_mul_mat23( a, b ); }
    VECMATH_INLINE vec4_t operator*( vec2_t a, mat24_t b ) { return vec2_mul_mat24( a, b ); }
    VECMATH_INLINE vec2_t operator*( vec3_t a, mat32_t b ) { return vec3_mul_mat32( a, b ); }
    VECMATH_INLINE vec3_t operator*( vec3_t a, mat33_t b ) { return vec3_mul_mat33( a, b ); }
    VECMATH_INLINE vec4_t operator*( vec3_t a, mat34_t b ) { return vec3_mul_mat34( a, b ); }
    VECMATH_INLINE vec2_t operator*( vec4_t a, mat42_t b ) { return vec4_mul_mat42( a, b ); }
    VECMATH_INLINE vec3_t operator*( vec4_t a, mat43_t b ) { return vec4_mul_mat43( a, b ); }
    VECMATH_INLINE vec4_t operator*( vec4_t a, mat44_t b ) { return vec4_mul_mat44( a, b ); }

    VECMATH_INLINE vec2_t operator*( mat22_t a, vec2_t b ) { return mat22_mul_vec2( a, b ); }
    VECMATH_INLINE vec3_t operator*( mat32_t a, vec2_t b ) { return mat32_mul_vec2( a, b ); }
    VECMATH_INLINE vec4_t operator*( mat42_t a, vec2_t b ) { return mat42_mul_vec2( a, b ); }
    VECMATH_INLINE vec2_t operator*( mat23_t a, vec3_t b ) { return mat23_mul_vec3( a, b ); }
    VECMATH_INLINE vec3_t operator*( mat33_t a, vec3_t b ) { return mat33_mul_vec3( a, b ); }
    VECMATH_INLINE vec4_t operator*( mat43_t a, vec3_t b ) { return mat43_mul_vec3( a, b ); }
    VECMATH_INLINE vec2_t operator*( mat24_t a, vec4_t b ) { return mat24_mul_vec4( a, b ); }
    VECMATH_INLINE vec3_t operator*( mat34_t a, vec4_t b ) { return mat34_mul_vec4( a, b ); }
    VECMATH_INLINE vec4_t operator*( mat44_t a, vec4_t b ) { return mat44_mul_vec4( a, b ); }
    
    VECMATH_INLINE mat22_t operator*( mat22_t a, mat22_t b ) { return mat22_mul_mat22( a, b ); }
    VECMATH_INLINE mat23_t operator*( mat22_t a, mat23_t b ) { return mat22_mul_mat23( a, b ); }
    VECMATH_INLINE mat24_t operator*( mat22_t a, mat24_t b ) { return mat22_mul_mat24( a, b ); }
    VECMATH_INLINE mat22_t operator*( mat23_t a, mat32_t b ) { return mat23_mul_mat32( a, b ); }
    VECMATH_INLINE mat23_t operator*( mat23_t a, mat33_t b ) { return mat23_mul_mat33( a, b ); }
    VECMATH_INLINE mat24_t operator*( mat23_t a, mat34_t b ) { return mat23_mul_mat34( a, b ); }
    VECMATH_INLINE mat22_t operator*( mat24_t a, mat42_t b ) { return mat24_mul_mat42( a, b ); }
    VECMATH_INLINE mat23_t operator*( mat24_t a, mat43_t b ) { return mat24_mul_mat43( a, b ); }
    VECMATH_INLINE mat24_t operator*( mat24_t a, mat44_t b ) { return mat24_mul_mat44( a, b ); }
    
    VECMATH_INLINE mat32_t operator*( mat32_t a, mat22_t b ) { return mat32_mul_mat22( a, b ); }
    VECMATH_INLINE mat33_t operator*( mat32_t a, mat23_t b ) { return mat32_mul_mat23( a, b ); }
    VECMATH_INLINE mat34_t operator*( mat32_t a, mat24_t b ) { return mat32_mul_mat24( a, b ); }
    VECMATH_INLINE mat32_t operator*( mat33_t a, mat32_t b ) { return mat33_mul_mat32( a, b ); }
    VECMATH_INLINE mat33_t operator*( mat33_t a, mat33_t b ) { return mat33_mul_mat33( a, b ); }
    VECMATH_INLINE mat34_t operator*( mat33_t a, mat34_t b ) { return mat33_mul_mat34( a, b ); }
    VECMATH_INLINE mat32_t operator*( mat34_t a, mat42_t b ) { return mat34_mul_mat42( a, b ); }
    VECMATH_INLINE mat33_t operator*( mat34_t a, mat43_t b ) { return mat34_mul_mat43( a, b ); }
    VECMATH_INLINE mat34_t operator*( mat34_t a, mat44_t b ) { return mat34_mul_mat44( a, b ); }
    
    VECMATH_INLINE mat42_t operator*( mat42_t a, mat22_t b ) { return mat42_mul_mat22( a, b ); }
    VECMATH_INLINE mat43_t operator*( mat42_t a, mat23_t b ) { return mat42_mul_mat23( a, b ); }
    VECMATH_INLINE mat44_t operator*( mat42_t a, mat24_t b ) { return mat42_mul_mat24( a, b ); }
    VECMATH_INLINE mat42_t operator*( mat43_t a, mat32_t b ) { return mat43_mul_mat32( a, b ); }
    VECMATH_INLINE mat43_t operator*( mat43_t a, mat33_t b ) { return mat43_mul_mat33( a, b ); }
    
    VECMATH_INLINE mat44_t operator*( mat43_t a, mat34_t b ) { return mat43_mul_mat34( a, b ); }
    VECMATH_INLINE mat42_t operator*( mat44_t a, mat42_t b ) { return mat44_mul_mat42( a, b ); }
    VECMATH_INLINE mat43_t operator*( mat44_t a, mat43_t b ) { return mat44_mul_mat43( a, b ); }
    VECMATH_INLINE mat44_t operator*( mat44_t a, mat44_t b ) { return mat44_mul_mat44( a, b ); }

    VECMATH_INLINE mat22_t& operator*=(mat22_t &a, mat22_t b) { a = mat22_mul_mat22(a, b); return a; }
    VECMATH_INLINE mat23_t& operator*=(mat23_t &a, mat33_t b) { a = mat23_mul_mat33(a, b); return a; }
    VECMATH_INLINE mat24_t& operator*=(mat24_t &a, mat44_t b) { a = mat24_mul_mat44(a, b); return a; }
    
    VECMATH_INLINE mat32_t& operator*=(mat32_t &a, mat22_t b) { a = mat32_mul_mat22(a, b); return a; }
    VECMATH_INLINE mat33_t& operator*=(mat33_t &a, mat33_t b) { a = mat33_mul_mat33(a, b); return a; }
    VECMATH_INLINE mat34_t& operator*=(mat34_t &a, mat44_t b) { a = mat34_mul_mat44(a, b); return a; }
    
    VECMATH_INLINE mat42_t& operator*=(mat42_t &a, mat22_t b) { a = mat42_mul_mat22(a, b); return a; }
    VECMATH_INLINE mat43_t& operator*=(mat43_t &a, mat33_t b) { a = mat43_mul_mat33(a, b); return a; }
    VECMATH_INLINE mat44_t& operator*=(mat44_t &a, mat44_t b) { a = mat44_mul_mat44(a, b); return a; }

#endif /* __cplusplus */


// generics
#if defined( VECMATH_GENERICS ) && ( ( defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L ) || defined(__TINYC__) )

    typedef struct { void* error; } vecmath_type_error;
    static vecmath_type_error vecmath_unsupported_types( vecmath_type_error error, ... ) { (void) error; vecmath_type_error e = { (void*)0 }; return e; }

    #define vm_neg(a) _Generic((a), float: vecmath_fneg, vec2_t: vec2_neg, vec3_t: vec3_neg, vec4_t: vec4_neg, mat22_t: mat22_neg, mat23_t: mat23_neg, mat24_t: mat24_neg, mat32_t: mat32_neg, mat33_t: mat33_neg, mat34_t: mat34_neg, mat42_t: mat42_neg, mat43_t: mat43_neg, mat44_t: mat44_neg, default: vecmath_unsupported_types )(a)
    #define vm_eq(a, b) _Generic((a), float: _Generic((b), float: vecmath_feq, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_eq, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_eq, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_eq, default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: mat22_eq, default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: mat23_eq, default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: mat24_eq, default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: mat32_eq, default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: mat33_eq, default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: mat34_eq, default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: mat42_eq, default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: mat43_eq, default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: mat44_eq, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_add(a, b) _Generic((a), float: _Generic((b), float: vecmath_fadd, vec2_t: vec2_fadd, vec3_t: vec3_fadd, vec4_t: vec4_fadd, mat22_t: mat22_fadd, mat23_t: mat23_fadd, mat24_t: mat24_fadd, mat32_t: mat32_fadd, mat33_t: mat33_fadd, mat34_t: mat34_fadd, mat42_t: mat42_fadd, mat43_t: mat43_fadd, mat44_t: mat44_fadd, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_add, float: vec2_addf, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_add, float: vec3_addf, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_add, float: vec4_addf, default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: mat22_add, float: mat22_addf, default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: mat23_add, float: mat23_addf, default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: mat24_add, float: mat24_addf, default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: mat32_add, float: mat32_addf, default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: mat33_add, float: mat33_addf, default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: mat34_add, float: mat34_addf, default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: mat42_add, float: mat42_addf, default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: mat43_add, float: mat43_addf, default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: mat44_add, float: mat44_addf, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_sub(a, b) _Generic((a), float: _Generic((b), float: vecmath_fsub, vec2_t: vec2_fsub, vec3_t: vec3_fsub, vec4_t: vec4_fsub, mat22_t: mat22_fsub, mat23_t: mat23_fsub, mat24_t: mat24_fsub, mat32_t: mat32_fsub, mat33_t: mat33_fsub, mat34_t: mat34_fsub, mat42_t: mat42_fsub, mat43_t: mat43_fsub, mat44_t: mat44_fsub, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_sub, float: vec2_subf, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_sub, float: vec3_subf, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_sub, float: vec4_subf, default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: mat22_sub, float: mat22_subf, default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: mat23_sub, float: mat23_subf, default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: mat24_sub, float: mat24_subf, default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: mat32_sub, float: mat32_subf, default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: mat33_sub, float: mat33_subf, default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: mat34_sub, float: mat34_subf, default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: mat42_sub, float: mat42_subf, default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: mat43_sub, float: mat43_subf, default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: mat44_sub, float: mat44_subf, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_mul(a, b) _Generic((a), float: _Generic((b), float: vecmath_fmul, vec2_t: vec2_fmul, vec3_t: vec3_fmul, vec4_t: vec4_fmul, mat22_t: mat22_fmul, mat23_t: mat23_fmul, mat24_t: mat24_fmul, mat32_t: mat32_fmul, mat33_t: mat33_fmul, mat34_t: mat34_fmul, mat42_t: mat42_fmul, mat43_t: mat43_fmul, mat44_t: mat44_fmul, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_mul, float: vec2_mulf, mat22_t: vec2_mul_mat22, mat23_t: vec2_mul_mat23, mat24_t: vec2_mul_mat24, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_mul, float: vec3_mulf, mat32_t: vec3_mul_mat32, mat33_t: vec3_mul_mat33, mat34_t: vec3_mul_mat34, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_mul, float: vec4_mulf, mat42_t: vec4_mul_mat42, mat43_t: vec4_mul_mat43, mat44_t: vec4_mul_mat44, default: vecmath_unsupported_types ), mat22_t: _Generic((b), float: mat22_mulf, vec2_t: mat22_mul_vec2, mat22_t: mat22_mul_mat22, mat23_t: mat22_mul_mat23, mat24_t: mat22_mul_mat24, default: vecmath_unsupported_types ), mat23_t: _Generic((b), float: mat23_mulf, vec3_t: mat23_mul_vec3, mat32_t: mat23_mul_mat32, mat33_t: mat23_mul_mat33, mat34_t: mat23_mul_mat34, default: vecmath_unsupported_types ), mat24_t: _Generic((b), float: mat24_mulf, vec4_t: mat24_mul_vec4, mat42_t: mat24_mul_mat42, mat43_t: mat24_mul_mat43, mat44_t: mat24_mul_mat44, default: vecmath_unsupported_types ), mat32_t: _Generic((b), float: mat32_mulf, vec2_t: mat32_mul_vec2, mat22_t: mat32_mul_mat22, mat23_t: mat32_mul_mat23, mat24_t: mat32_mul_mat24, default: vecmath_unsupported_types ), mat33_t: _Generic((b), float: mat33_mulf, vec3_t: mat33_mul_vec3, mat32_t: mat33_mul_mat32, mat33_t: mat33_mul_mat33, mat34_t: mat33_mul_mat34, default: vecmath_unsupported_types ), mat34_t: _Generic((b), float: mat34_mulf, vec4_t: mat34_mul_vec4, mat42_t: mat34_mul_mat42, mat43_t: mat34_mul_mat43, mat44_t: mat34_mul_mat44, default: vecmath_unsupported_types ), mat42_t: _Generic((b), float: mat42_mulf, vec2_t: mat42_mul_vec2, mat22_t: mat42_mul_mat22, mat23_t: mat42_mul_mat23, mat24_t: mat42_mul_mat24, default: vecmath_unsupported_types ), mat43_t: _Generic((b), float: mat43_mulf, vec3_t: mat43_mul_vec3, mat32_t: mat43_mul_mat32, mat33_t: mat43_mul_mat33, mat34_t: mat43_mul_mat34, default: vecmath_unsupported_types ), mat44_t: _Generic((b), float: mat44_mulf, vec4_t: mat44_mul_vec4, mat42_t: mat44_mul_mat42, mat43_t: mat44_mul_mat43, mat44_t: mat44_mul_mat44, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)  
    #define vm_div(a, b) _Generic((a), float: _Generic((b), float: vecmath_fdiv, vec2_t: vec2_fdiv, vec3_t: vec3_fdiv, vec4_t: vec4_fdiv, mat22_t: mat22_fdiv, mat23_t: mat23_fdiv, mat24_t: mat24_fdiv, mat32_t: mat32_fdiv, mat33_t: mat33_fdiv, mat34_t: mat34_fdiv, mat42_t: mat42_fdiv, mat43_t: mat43_fdiv, mat44_t: mat44_fdiv, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_div, float: vec2_divf, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_div, float: vec3_divf, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_div, float: vec4_divf, default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: mat22_div, float: mat22_divf, default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: mat23_div, float: mat23_divf, default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: mat24_div, float: mat24_divf, default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: mat32_div, float: mat32_divf, default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: mat33_div, float: mat33_divf, default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: mat34_div, float: mat34_divf, default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: mat42_div, float: mat42_divf, default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: mat43_div, float: mat43_divf, default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: mat44_div, float: mat44_divf, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_abs(a) _Generic((a), float: vecmath_abs, vec2_t: vec2_abs, vec3_t: vec3_abs, vec4_t: vec4_abs, mat22_t: mat22_abs, mat23_t: mat23_abs, mat24_t: mat24_abs, mat32_t: mat32_abs, mat33_t: mat33_abs, mat34_t: mat34_abs, mat42_t: mat42_abs, mat43_t: mat43_abs, mat44_t: mat44_abs, default: vecmath_unsupported_types )(a)
    #define vm_acos(a) _Generic((a), float: vecmath_acos, vec2_t: vec2_acos, vec3_t: vec3_acos, vec4_t: vec4_acos, mat22_t: mat22_acos, mat23_t: mat23_acos, mat24_t: mat24_acos, mat32_t: mat32_acos, mat33_t: mat33_acos, mat34_t: mat34_acos, mat42_t: mat42_acos, mat43_t: mat43_acos, mat44_t: mat44_acos, default: vecmath_unsupported_types )(a)
    #define vm_all(a) _Generic((a), vec2_t: vec2_all, vec3_t: vec3_all, vec4_t: vec4_all, mat22_t: mat22_all, mat23_t: mat23_all, mat24_t: mat24_all, mat32_t: mat32_all, mat33_t: mat33_all, mat34_t: mat34_all, mat42_t: mat42_all, mat43_t: mat43_all, mat44_t: mat44_all, default: vecmath_unsupported_types )(a)
    #define vm_any(a) _Generic((a), vec2_t: vec2_any, vec3_t: vec3_any, vec4_t: vec4_any, mat22_t: mat22_any, mat23_t: mat23_any, mat24_t: mat24_any, mat32_t: mat32_any, mat33_t: mat33_any, mat34_t: mat34_any, mat42_t: mat42_any, mat43_t: mat43_any, mat44_t: mat44_any, default: vecmath_unsupported_types )(a)
    #define vm_asin(a) _Generic((a), float: vecmath_asin, vec2_t: vec2_asin, vec3_t: vec3_asin, vec4_t: vec4_asin, mat22_t: mat22_asin, mat23_t: mat23_asin, mat24_t: mat24_asin, mat32_t: mat32_asin, mat33_t: mat33_asin, mat34_t: mat34_asin, mat42_t: mat42_asin, mat43_t: mat43_asin, mat44_t: mat44_asin, default: vecmath_unsupported_types )(a)
    #define vm_atan(a) _Generic((a), float: vecmath_atan, vec2_t: vec2_atan, vec3_t: vec3_atan, vec4_t: vec4_atan, mat22_t: mat22_atan, mat23_t: mat23_atan, mat24_t: mat24_atan, mat32_t: mat32_atan, mat33_t: mat33_atan, mat34_t: mat34_atan, mat42_t: mat42_atan, mat43_t: mat43_atan, mat44_t: mat44_atan, default: vecmath_unsupported_types )(a)
    #define vm_atan2(a, b) _Generic((a), float: _Generic((b), float: vecmath_atan2, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_atan2, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_atan2, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_atan2, default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: mat22_atan2, default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: mat23_atan2, default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: mat24_atan2, default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: mat32_atan2, default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: mat33_atan2, default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: mat34_atan2, default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: mat42_atan2, default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: mat43_atan2, default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: mat44_atan2, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_ceil(a) _Generic((a), float: vecmath_ceil, vec2_t: vec2_ceil, vec3_t: vec3_ceil, vec4_t: vec4_ceil, mat22_t: mat22_ceil, mat23_t: mat23_ceil, mat24_t: mat24_ceil, mat32_t: mat32_ceil, mat33_t: mat33_ceil, mat34_t: mat34_ceil, mat42_t: mat42_ceil, mat43_t: mat43_ceil, mat44_t: mat44_ceil, default: vecmath_unsupported_types )(a)
    #define vm_clamp(a, minv, maxv) _Generic((a), float: _Generic((minv), float: _Generic((maxv), float: vecmath_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec2_t: _Generic((minv), vec2_t: _Generic((maxv), vec2_t: vec2_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec3_t: _Generic((minv), vec3_t: _Generic((maxv), vec3_t: vec3_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec4_t: _Generic((minv), vec4_t: _Generic((maxv), vec4_t: vec4_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat22_t: _Generic((minv), mat22_t: _Generic((maxv), mat22_t: mat22_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat23_t: _Generic((minv), mat23_t: _Generic((maxv), mat23_t: mat23_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat24_t: _Generic((minv), mat24_t: _Generic((maxv), mat24_t: mat24_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat32_t: _Generic((minv), mat32_t: _Generic((maxv), mat32_t: mat32_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat33_t: _Generic((minv), mat33_t: _Generic((maxv), mat33_t: mat33_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat34_t: _Generic((minv), mat34_t: _Generic((maxv), mat34_t: mat34_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat42_t: _Generic((minv), mat42_t: _Generic((maxv), mat42_t: mat42_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat43_t: _Generic((minv), mat43_t: _Generic((maxv), mat43_t: mat43_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat44_t: _Generic((minv), mat44_t: _Generic((maxv), mat44_t: mat44_clamp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, minv, maxv)
    #define vm_cos(a) _Generic((a), float: vecmath_cos, vec2_t: vec2_cos, vec3_t: vec3_cos, vec4_t: vec4_cos, mat22_t: mat22_cos, mat23_t: mat23_cos, mat24_t: mat24_cos, mat32_t: mat32_cos, mat33_t: mat33_cos, mat34_t: mat34_cos, mat42_t: mat42_cos, mat43_t: mat43_cos, mat44_t: mat44_cos, default: vecmath_unsupported_types )(a)
    #define vm_cosh(a) _Generic((a), float: vecmath_cosh, vec2_t: vec2_cosh, vec3_t: vec3_cosh, vec4_t: vec4_cosh, mat22_t: mat22_cosh, mat23_t: mat23_cosh, mat24_t: mat24_cosh, mat32_t: mat32_cosh, mat33_t: mat33_cosh, mat34_t: mat34_cosh, mat42_t: mat42_cosh, mat43_t: mat43_cosh, mat44_t: mat44_cosh, default: vecmath_unsupported_types )(a)
    #define vm_cross(a, b) _Generic((a), vec2_t: _Generic((b), vec2_t: vec2_cross, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_cross, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_degrees(a) _Generic((a), float: vecmath_degrees, vec2_t: vec2_degrees, vec3_t: vec3_degrees, vec4_t: vec4_degrees, mat22_t: mat22_degrees, mat23_t: mat23_degrees, mat24_t: mat24_degrees, mat32_t: mat32_degrees, mat33_t: mat33_degrees, mat34_t: mat34_degrees, mat42_t: mat42_degrees, mat43_t: mat43_degrees, mat44_t: mat44_degrees, default: vecmath_unsupported_types )(a)
    #define vm_distancesq(a, b) _Generic((a), float: _Generic((b), float: vecmath_distancesq, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_distancesq, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_distancesq, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_distancesq, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_distance(a, b) _Generic((a), float: _Generic((b), float: vecmath_distance, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_distance, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_distance, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_distance, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_dot(a, b) _Generic((a), float: _Generic((b), float: vecmath_dot, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_dot, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_dot, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_dot, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_exp(a) _Generic((a), float: vecmath_exp, vec2_t: vec2_exp, vec3_t: vec3_exp, vec4_t: vec4_exp, mat22_t: mat22_exp, mat23_t: mat23_exp, mat24_t: mat24_exp, mat32_t: mat32_exp, mat33_t: mat33_exp, mat34_t: mat34_exp, mat42_t: mat42_exp, mat43_t: mat43_exp, mat44_t: mat44_exp, default: vecmath_unsupported_types )(a)
    #define vm_exp2(a) _Generic((a), float: vecmath_exp2, vec2_t: vec2_exp2, vec3_t: vec3_exp2, vec4_t: vec4_exp2, mat22_t: mat22_exp2, mat23_t: mat23_exp2, mat24_t: mat24_exp2, mat32_t: mat32_exp2, mat33_t: mat33_exp2, mat34_t: mat34_exp2, mat42_t: mat42_exp2, mat43_t: mat43_exp2, mat44_t: mat44_exp2, default: vecmath_unsupported_types )(a)
    #define vm_floor(a) _Generic((a), float: vecmath_floor, vec2_t: vec2_floor, vec3_t: vec3_floor, vec4_t: vec4_floor, mat22_t: mat22_floor, mat23_t: mat23_floor, mat24_t: mat24_floor, mat32_t: mat32_floor, mat33_t: mat33_floor, mat34_t: mat34_floor, mat42_t: mat42_floor, mat43_t: mat43_floor, mat44_t: mat44_floor, default: vecmath_unsupported_types )(a)
    #define vm_fmod(a, b) _Generic((a), float: _Generic((b), float: vecmath_fmod, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_fmod, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_fmod, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_fmod, default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: mat22_fmod, default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: mat23_fmod, default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: mat24_fmod, default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: mat32_fmod, default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: mat33_fmod, default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: mat34_fmod, default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: mat42_fmod, default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: mat43_fmod, default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: mat44_fmod, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_frac(a) _Generic((a), float: vecmath_frac, vec2_t: vec2_frac, vec3_t: vec3_frac, vec4_t: vec4_frac, mat22_t: mat22_frac, mat23_t: mat23_frac, mat24_t: mat24_frac, mat32_t: mat32_frac, mat33_t: mat33_frac, mat34_t: mat34_frac, mat42_t: mat42_frac, mat43_t: mat43_frac, mat44_t: mat44_frac, default: vecmath_unsupported_types )(a)
    #define vm_lengthsq(a) _Generic((a), float: vecmath_lengthsq, vec2_t: vec2_lengthsq, vec3_t: vec3_lengthsq, vec4_t: vec4_lengthsq, default: vecmath_unsupported_types )(a)
    #define vm_length(a) _Generic((a), float: vecmath_length, vec2_t: vec2_length, vec3_t: vec3_length, vec4_t: vec4_length, default: vecmath_unsupported_types )(a)
    #define vm_lerp(a, b, t) _Generic((a), float: _Generic((b), float: _Generic((t), float: vecmath_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: _Generic((t), float: vec2_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: _Generic((t), float: vec3_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: _Generic((t), float: vec4_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: _Generic((t), float: mat22_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: _Generic((t), float: mat23_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: _Generic((t), float: mat24_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: _Generic((t), float: mat32_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: _Generic((t), float: mat33_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: _Generic((t), float: mat34_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: _Generic((t), float: mat42_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: _Generic((t), float: mat43_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: _Generic((t), float: mat44_lerp, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b, t)
    #define vm_log(a) _Generic((a), float: vecmath_log, vec2_t: vec2_log, vec3_t: vec3_log, vec4_t: vec4_log, mat22_t: mat22_log, mat23_t: mat23_log, mat24_t: mat24_log, mat32_t: mat32_log, mat33_t: mat33_log, mat34_t: mat34_log, mat42_t: mat42_log, mat43_t: mat43_log, mat44_t: mat44_log, default: vecmath_unsupported_types )(a)
    #define vm_log2(a) _Generic((a), float: vecmath_log2, vec2_t: vec2_log2, vec3_t: vec3_log2, vec4_t: vec4_log2, mat22_t: mat22_log2, mat23_t: mat23_log2, mat24_t: mat24_log2, mat32_t: mat32_log2, mat33_t: mat33_log2, mat34_t: mat34_log2, mat42_t: mat42_log2, mat43_t: mat43_log2, mat44_t: mat44_log2, default: vecmath_unsupported_types )(a)
    #define vm_log10(a) _Generic((a), float: vecmath_log10, vec2_t: vec2_log10, vec3_t: vec3_log10, vec4_t: vec4_log10, mat22_t: mat22_log10, mat23_t: mat23_log10, mat24_t: mat24_log10, mat32_t: mat32_log10, mat33_t: mat33_log10, mat34_t: mat34_log10, mat42_t: mat42_log10, mat43_t: mat43_log10, mat44_t: mat44_log10, default: vecmath_unsupported_types )(a)
    #define vm_max(a, b) _Generic((a), float: _Generic((b), float: vecmath_max, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_max, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_max, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_max, default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: mat22_max, default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: mat23_max, default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: mat24_max, default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: mat32_max, default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: mat33_max, default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: mat34_max, default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: mat42_max, default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: mat43_max, default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: mat44_max, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_min(a, b) _Generic((a), float: _Generic((b), float: vecmath_min, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_min, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_min, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_min, default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: mat22_min, default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: mat23_min, default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: mat24_min, default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: mat32_min, default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: mat33_min, default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: mat34_min, default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: mat42_min, default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: mat43_min, default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: mat44_min, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_normalize(a) _Generic((a), float: vecmath_normalize, vec2_t: vec2_normalize, vec3_t: vec3_normalize, vec4_t: vec4_normalize, default: vecmath_unsupported_types )(a)
    #define vm_pow(a, b) _Generic((a), float: _Generic((b), float: vecmath_pow, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_pow, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_pow, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_pow, default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: mat22_pow, default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: mat23_pow, default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: mat24_pow, default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: mat32_pow, default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: mat33_pow, default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: mat34_pow, default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: mat42_pow, default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: mat43_pow, default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: mat44_pow, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_radians(a) _Generic((a), float: vecmath_radians, vec2_t: vec2_radians, vec3_t: vec3_radians, vec4_t: vec4_radians, mat22_t: mat22_radians, mat23_t: mat23_radians, mat24_t: mat24_radians, mat32_t: mat32_radians, mat33_t: mat33_radians, mat34_t: mat34_radians, mat42_t: mat42_radians, mat43_t: mat43_radians, mat44_t: mat44_radians, default: vecmath_unsupported_types )(a)
    #define vm_rcp(a) _Generic((a), float: vecmath_rcp, vec2_t: vec2_rcp, vec3_t: vec3_rcp, vec4_t: vec4_rcp, mat22_t: mat22_rcp, mat23_t: mat23_rcp, mat24_t: mat24_rcp, mat32_t: mat32_rcp, mat33_t: mat33_rcp, mat34_t: mat34_rcp, mat42_t: mat42_rcp, mat43_t: mat43_rcp, mat44_t: mat44_rcp, default: vecmath_unsupported_types )(a)
    #define vm_reflect(i, n) _Generic((i), float: _Generic((n), float: vecmath_reflect, default: vecmath_unsupported_types ), vec2_t: _Generic((n), vec2_t: vec2_reflect, default: vecmath_unsupported_types ), vec3_t: _Generic((n), vec3_t: vec3_reflect, default: vecmath_unsupported_types ), vec4_t: _Generic((n), vec4_t: vec4_reflect, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(i, n)
    #define vm_refract(i, n, r) _Generic((i), float: _Generic((n), float: _Generic((r), float: vecmath_refract, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec2_t: _Generic((n), vec2_t: _Generic((r), float: vec2_refract, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec3_t: _Generic((n), vec3_t: _Generic((r), float: vec3_refract, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec4_t: _Generic((n), vec4_t: _Generic((r), float: vec4_refract, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(i, n, r)
    #define vm_round(a) _Generic((a), float: vecmath_round, vec2_t: vec2_round, vec3_t: vec3_round, vec4_t: vec4_round, mat22_t: mat22_round, mat23_t: mat23_round, mat24_t: mat24_round, mat32_t: mat32_round, mat33_t: mat33_round, mat34_t: mat34_round, mat42_t: mat42_round, mat43_t: mat43_round, mat44_t: mat44_round, default: vecmath_unsupported_types )(a)
    #define vm_rsqrt(a) _Generic((a), float: vecmath_rsqrt, vec2_t: vec2_rsqrt, vec3_t: vec3_rsqrt, vec4_t: vec4_rsqrt, mat22_t: mat22_rsqrt, mat23_t: mat23_rsqrt, mat24_t: mat24_rsqrt, mat32_t: mat32_rsqrt, mat33_t: mat33_rsqrt, mat34_t: mat34_rsqrt, mat42_t: mat42_rsqrt, mat43_t: mat43_rsqrt, mat44_t: mat44_rsqrt, default: vecmath_unsupported_types )(a)
    #define vm_saturate(a) _Generic((a), float: vecmath_saturate, vec2_t: vec2_saturate, vec3_t: vec3_saturate, vec4_t: vec4_saturate, mat22_t: mat22_saturate, mat23_t: mat23_saturate, mat24_t: mat24_saturate, mat32_t: mat32_saturate, mat33_t: mat33_saturate, mat34_t: mat34_saturate, mat42_t: mat42_saturate, mat43_t: mat43_saturate, mat44_t: mat44_saturate, default: vecmath_unsupported_types )(a)
    #define vm_sign(a) _Generic((a), float: vecmath_sign, vec2_t: vec2_sign, vec3_t: vec3_sign, vec4_t: vec4_sign, mat22_t: mat22_sign, mat23_t: mat23_sign, mat24_t: mat24_sign, mat32_t: mat32_sign, mat33_t: mat33_sign, mat34_t: mat34_sign, mat42_t: mat42_sign, mat43_t: mat43_sign, mat44_t: mat44_sign, default: vecmath_unsupported_types )(a)
    #define vm_sin(a) _Generic((a), float: vecmath_sin, vec2_t: vec2_sin, vec3_t: vec3_sin, vec4_t: vec4_sin, mat22_t: mat22_sin, mat23_t: mat23_sin, mat24_t: mat24_sin, mat32_t: mat32_sin, mat33_t: mat33_sin, mat34_t: mat34_sin, mat42_t: mat42_sin, mat43_t: mat43_sin, mat44_t: mat44_sin, default: vecmath_unsupported_types )(a)
    #define vm_sinh(a) _Generic((a), float: vecmath_sinh, vec2_t: vec2_sinh, vec3_t: vec3_sinh, vec4_t: vec4_sinh, mat22_t: mat22_sinh, mat23_t: mat23_sinh, mat24_t: mat24_sinh, mat32_t: mat32_sinh, mat33_t: mat33_sinh, mat34_t: mat34_sinh, mat42_t: mat42_sinh, mat43_t: mat43_sinh, mat44_t: mat44_sinh, default: vecmath_unsupported_types )(a)
    #define vm_smoothstep(min, max, a) _Generic((min), float: _Generic((max), float: _Generic((a), float: vecmath_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec2_t: _Generic((max), vec2_t: _Generic((a), vec2_t: vec2_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec3_t: _Generic((max), vec3_t: _Generic((a), vec3_t: vec3_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec4_t: _Generic((max), vec4_t: _Generic((a), vec4_t: vec4_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat22_t: _Generic((max), mat22_t: _Generic((a), mat22_t: mat22_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat23_t: _Generic((max), mat23_t: _Generic((a), mat23_t: mat23_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat24_t: _Generic((max), mat24_t: _Generic((a), mat24_t: mat24_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat32_t: _Generic((max), mat32_t: _Generic((a), mat32_t: mat32_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat33_t: _Generic((max), mat33_t: _Generic((a), mat33_t: mat33_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat34_t: _Generic((max), mat34_t: _Generic((a), mat34_t: mat34_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat42_t: _Generic((max), mat42_t: _Generic((a), mat42_t: mat42_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat43_t: _Generic((max), mat43_t: _Generic((a), mat43_t: mat43_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat44_t: _Generic((max), mat44_t: _Generic((a), mat44_t: mat44_smoothstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(min, max, a)
    #define vm_smootherstep(min, max, a) _Generic((min), float: _Generic((max), float: _Generic((a), float: vecmath_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec2_t: _Generic((max), vec2_t: _Generic((a), vec2_t: vec2_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec3_t: _Generic((max), vec3_t: _Generic((a), vec3_t: vec3_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), vec4_t: _Generic((max), vec4_t: _Generic((a), vec4_t: vec4_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat22_t: _Generic((max), mat22_t: _Generic((a), mat22_t: mat22_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat23_t: _Generic((max), mat23_t: _Generic((a), mat23_t: mat23_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat24_t: _Generic((max), mat24_t: _Generic((a), mat24_t: mat24_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat32_t: _Generic((max), mat32_t: _Generic((a), mat32_t: mat32_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat33_t: _Generic((max), mat33_t: _Generic((a), mat33_t: mat33_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat34_t: _Generic((max), mat34_t: _Generic((a), mat34_t: mat34_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat42_t: _Generic((max), mat42_t: _Generic((a), mat42_t: mat42_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat43_t: _Generic((max), mat43_t: _Generic((a), mat43_t: mat43_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), mat44_t: _Generic((max), mat44_t: _Generic((a), mat44_t: mat44_smootherstep, default: vecmath_unsupported_types ), default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(min, max, a)
    #define vm_sqrt(a) _Generic((a), float: vecmath_sqrt, vec2_t: vec2_sqrt, vec3_t: vec3_sqrt, vec4_t: vec4_sqrt, mat22_t: mat22_sqrt, mat23_t: mat23_sqrt, mat24_t: mat24_sqrt, mat32_t: mat32_sqrt, mat33_t: mat33_sqrt, mat34_t: mat34_sqrt, mat42_t: mat42_sqrt, mat43_t: mat43_sqrt, mat44_t: mat44_sqrt, default: vecmath_unsupported_types )(a)
    #define vm_step(a, b) _Generic((a), float: _Generic((b), float: vecmath_step, default: vecmath_unsupported_types ), vec2_t: _Generic((b), vec2_t: vec2_step, default: vecmath_unsupported_types ), vec3_t: _Generic((b), vec3_t: vec3_step, default: vecmath_unsupported_types ), vec4_t: _Generic((b), vec4_t: vec4_step, default: vecmath_unsupported_types ), mat22_t: _Generic((b), mat22_t: mat22_step, default: vecmath_unsupported_types ), mat23_t: _Generic((b), mat23_t: mat23_step, default: vecmath_unsupported_types ), mat24_t: _Generic((b), mat24_t: mat24_step, default: vecmath_unsupported_types ), mat32_t: _Generic((b), mat32_t: mat32_step, default: vecmath_unsupported_types ), mat33_t: _Generic((b), mat33_t: mat33_step, default: vecmath_unsupported_types ), mat34_t: _Generic((b), mat34_t: mat34_step, default: vecmath_unsupported_types ), mat42_t: _Generic((b), mat42_t: mat42_step, default: vecmath_unsupported_types ), mat43_t: _Generic((b), mat43_t: mat43_step, default: vecmath_unsupported_types ), mat44_t: _Generic((b), mat44_t: mat44_step, default: vecmath_unsupported_types ), default: vecmath_unsupported_types )(a, b)
    #define vm_tan(a) _Generic((a), float: vecmath_tan, vec2_t: vec2_tan, vec3_t: vec3_tan, vec4_t: vec4_tan, mat22_t: mat22_tan, mat23_t: mat23_tan, mat24_t: mat24_tan, mat32_t: mat32_tan, mat33_t: mat33_tan, mat34_t: mat34_tan, mat42_t: mat42_tan, mat43_t: mat43_tan, mat44_t: mat44_tan, default: vecmath_unsupported_types )(a)
    #define vm_tanh(a) _Generic((a), float: vecmath_tanh, vec2_t: vec2_tanh, vec3_t: vec3_tanh, vec4_t: vec4_tanh, mat22_t: mat22_tanh, mat23_t: mat23_tanh, mat24_t: mat24_tanh, mat32_t: mat32_tanh, mat33_t: mat33_tanh, mat34_t: mat34_tanh, mat42_t: mat42_tanh, mat43_t: mat43_tanh, mat44_t: mat44_tanh, default: vecmath_unsupported_types )(a)
    #define vm_trunc(a) _Generic((a), float: vecmath_trunc, vec2_t: vec2_trunc, vec3_t: vec3_trunc, vec4_t: vec4_trunc, mat22_t: mat22_trunc, mat23_t: mat23_trunc, mat24_t: mat24_trunc, mat32_t: mat32_trunc, mat33_t: mat33_trunc, mat34_t: mat34_trunc, mat42_t: mat42_trunc, mat43_t: mat43_trunc, mat44_t: mat44_trunc, default: vecmath_unsupported_types )(a)
    #define vm_transpose(a) _Generic((a), mat22_t: mat22_transpose, mat23_t: mat23_transpose, mat24_t: mat24_transpose, mat32_t: mat32_transpose, mat33_t: mat33_transpose, mat34_t: mat34_transpose, mat42_t: mat42_transpose, mat43_t: mat43_transpose, mat44_t: mat44_transpose, default: vecmath_unsupported_types )(a)
    #define vm_determinant(a) _Generic((a), mat22_t: mat22_determinant, mat33_t: mat33_determinant, mat44_t: mat44_determinant, default: vecmath_unsupported_types )(a)

#endif /* VECMATH_GENERICS */

#if defined( VECMATH_GENERICS ) && defined(__cplusplus )
    #ifdef VECMATH_GENERICS_NO_PREFIX 
        #define vm_neg neg
        #define vm_eq eq
        #define vm_mul mul
        #define vm_add add
        #define vm_sub sub
        #define vm_div div
        #define vm_abs abs
        #define vm_acos acos
        #define vm_all all
        #define vm_any any
        #define vm_asin asin
        #define vm_atan atan
        #define vm_atan2 atan2
        #define vm_ceil ceil
        #define vm_clamp clamp
        #define vm_cos cos
        #define vm_cosh cosh
        #define vm_cross cross
        #define vm_degrees degrees
        #define vm_distancesq distancesq
        #define vm_distance distance
        #define vm_dot dot
        #define vm_exp exp
        #define vm_exp2 exp2
        #define vm_floor floor
        #define vm_fmod fmod
        #define vm_frac frac
        #define vm_lengthsq lengthsq
        #define vm_length length
        #define vm_lerp lerp
        #define vm_log log
        #define vm_log2 log2
        #define vm_log10 log10
        #define vm_max max
        #define vm_min min
        #define vm_normalize normalize
        #define vm_pow pow
        #define vm_radians radians
        #define vm_rcp rcp
        #define vm_reflect reflect
        #define vm_refract refract
        #define vm_round round
        #define vm_rsqrt rsqrt
        #define vm_saturate saturate
        #define vm_sign sign
        #define vm_sin sin
        #define vm_sinh sinh
        #define vm_smoothstep smoothstep
        #define vm_smootherstep smootherstep
        #define vm_sqrt sqrt
        #define vm_step step
        #define vm_tan tan
        #define vm_tanh tanh
        #define vm_trunc trunc
        #define vm_transpose transpose
        #define vm_determinant determinant
    #endif /* VECMATH_GENERICS_NO_PREFIX */

    VECMATH_INLINE float vm_neg( float a ) { return vecmath_fneg( a ); } VECMATH_INLINE vec2_t vm_neg( vec2_t a ) { return vec2_neg( a ); } VECMATH_INLINE vec3_t vm_neg( vec3_t a ) { return vec3_neg( a ); } VECMATH_INLINE vec4_t vm_neg( vec4_t a ) { return vec4_neg( a ); } VECMATH_INLINE mat22_t vm_neg( mat22_t a ) { return mat22_neg( a ); } VECMATH_INLINE mat23_t vm_neg( mat23_t a ) { return mat23_neg( a ); } VECMATH_INLINE mat24_t vm_neg( mat24_t a ) { return mat24_neg( a ); } VECMATH_INLINE mat32_t vm_neg( mat32_t a ) { return mat32_neg( a ); } VECMATH_INLINE mat33_t vm_neg( mat33_t a ) { return mat33_neg( a ); } VECMATH_INLINE mat34_t vm_neg( mat34_t a ) { return mat34_neg( a ); } VECMATH_INLINE mat42_t vm_neg( mat42_t a ) { return mat42_neg( a ); } VECMATH_INLINE mat43_t vm_neg( mat43_t a ) { return mat43_neg( a ); } VECMATH_INLINE mat44_t vm_neg( mat44_t a ) { return mat44_neg( a ); }
    VECMATH_INLINE bool vm_eq( float a, float b ) { return (bool) vecmath_feq( a, b ); } VECMATH_INLINE bool vm_eq( vec2_t a, vec2_t b ) { return (bool) vec2_eq( a, b ); } VECMATH_INLINE bool vm_eq( vec3_t a, vec3_t b ) { return (bool) vec3_eq( a, b ); } VECMATH_INLINE bool vm_eq( vec4_t a, vec4_t b ) { return (bool) vec4_eq( a, b ); } VECMATH_INLINE bool vm_eq( mat22_t a, mat22_t b ) { return (bool) mat22_eq( a, b ); } VECMATH_INLINE bool vm_eq( mat23_t a, mat23_t b ) { return (bool) mat23_eq( a, b ); } VECMATH_INLINE bool vm_eq( mat24_t a, mat24_t b ) { return (bool) mat24_eq( a, b ); } VECMATH_INLINE bool vm_eq( mat32_t a, mat32_t b ) { return (bool) mat32_eq( a, b ); } VECMATH_INLINE bool vm_eq( mat33_t a, mat33_t b ) { return (bool) mat33_eq( a, b ); } VECMATH_INLINE bool vm_eq( mat34_t a, mat34_t b ) { return (bool) mat34_eq( a, b ); } VECMATH_INLINE bool vm_eq( mat42_t a, mat42_t b ) { return (bool) mat42_eq( a, b ); } VECMATH_INLINE bool vm_eq( mat43_t a, mat43_t b ) { return (bool) mat43_eq( a, b ); } VECMATH_INLINE bool vm_eq( mat44_t a, mat44_t b ) { return (bool) mat44_eq( a, b ); }
    VECMATH_INLINE float vm_add( float a, float b ) { return vecmath_fadd( a, b ); } VECMATH_INLINE vec2_t vm_add( vec2_t a, vec2_t b ) { return vec2_add( a, b ); } VECMATH_INLINE vec2_t vm_add( vec2_t a, float b ) { return vec2_addf( a, b ); } VECMATH_INLINE vec2_t vm_add( float a, vec2_t b ) { return vec2_fadd( a, b ); } VECMATH_INLINE vec3_t vm_add( vec3_t a, vec3_t b ) { return vec3_add( a, b ); } VECMATH_INLINE vec3_t vm_add( vec3_t a, float b ) { return vec3_addf( a, b ); } VECMATH_INLINE vec3_t vm_add( float a, vec3_t b ) { return vec3_fadd( a, b ); } VECMATH_INLINE vec4_t vm_add( vec4_t a, vec4_t b ) { return vec4_add( a, b ); } VECMATH_INLINE vec4_t vm_add( vec4_t a, float b ) { return vec4_addf( a, b ); } VECMATH_INLINE vec4_t vm_add( float a, vec4_t b ) { return vec4_fadd( a, b ); } VECMATH_INLINE mat22_t vm_add( mat22_t a, mat22_t b ) { return mat22_add( a, b ); } VECMATH_INLINE mat22_t vm_add( mat22_t a, float b ) { return mat22_addf( a, b ); } VECMATH_INLINE mat22_t vm_add( float a, mat22_t b ) { return mat22_fadd( a, b ); } VECMATH_INLINE mat23_t vm_add( mat23_t a, mat23_t b ) { return mat23_add( a, b ); } VECMATH_INLINE mat23_t vm_add( mat23_t a, float b ) { return mat23_addf( a, b ); } VECMATH_INLINE mat23_t vm_add( float a, mat23_t b ) { return mat23_fadd( a, b ); } VECMATH_INLINE mat24_t vm_add( mat24_t a, mat24_t b ) { return mat24_add( a, b ); } VECMATH_INLINE mat24_t vm_add( mat24_t a, float b ) { return mat24_addf( a, b ); } VECMATH_INLINE mat24_t vm_add( float a, mat24_t b ) { return mat24_fadd( a, b ); } VECMATH_INLINE mat32_t vm_add( mat32_t a, mat32_t b ) { return mat32_add( a, b ); } VECMATH_INLINE mat32_t vm_add( mat32_t a, float b ) { return mat32_addf( a, b ); } VECMATH_INLINE mat32_t vm_add( float a, mat32_t b ) { return mat32_fadd( a, b ); } VECMATH_INLINE mat33_t vm_add( mat33_t a, mat33_t b ) { return mat33_add( a, b ); } VECMATH_INLINE mat33_t vm_add( mat33_t a, float b ) { return mat33_addf( a, b ); } VECMATH_INLINE mat33_t vm_add( float a, mat33_t b ) { return mat33_fadd( a, b ); } VECMATH_INLINE mat34_t vm_add( mat34_t a, mat34_t b ) { return mat34_add( a, b ); } VECMATH_INLINE mat34_t vm_add( mat34_t a, float b ) { return mat34_addf( a, b ); } VECMATH_INLINE mat34_t vm_add( float a, mat34_t b ) { return mat34_fadd( a, b ); } VECMATH_INLINE mat42_t vm_add( mat42_t a, mat42_t b ) { return mat42_add( a, b ); } VECMATH_INLINE mat42_t vm_add( mat42_t a, float b ) { return mat42_addf( a, b ); } VECMATH_INLINE mat42_t vm_add( float a, mat42_t b ) { return mat42_fadd( a, b ); } VECMATH_INLINE mat43_t vm_add( mat43_t a, mat43_t b ) { return mat43_add( a, b ); } VECMATH_INLINE mat43_t vm_add( mat43_t a, float b ) { return mat43_addf( a, b ); } VECMATH_INLINE mat43_t vm_add( float a, mat43_t b ) { return mat43_fadd( a, b ); } VECMATH_INLINE mat44_t vm_add( mat44_t a, mat44_t b ) { return mat44_add( a, b ); } VECMATH_INLINE mat44_t vm_add( mat44_t a, float b ) { return mat44_addf( a, b ); } VECMATH_INLINE mat44_t vm_add( float a, mat44_t b ) { return mat44_fadd( a, b ); }
    VECMATH_INLINE float vm_sub( float a, float b ) { return vecmath_fsub( a, b ); } VECMATH_INLINE vec2_t vm_sub( vec2_t a, vec2_t b ) { return vec2_sub( a, b ); } VECMATH_INLINE vec2_t vm_sub( vec2_t a, float b ) { return vec2_subf( a, b ); } VECMATH_INLINE vec2_t vm_sub( float a, vec2_t b ) { return vec2_fsub( a, b ); } VECMATH_INLINE vec3_t vm_sub( vec3_t a, vec3_t b ) { return vec3_sub( a, b ); } VECMATH_INLINE vec3_t vm_sub( vec3_t a, float b ) { return vec3_subf( a, b ); } VECMATH_INLINE vec3_t vm_sub( float a, vec3_t b ) { return vec3_fsub( a, b ); } VECMATH_INLINE vec4_t vm_sub( vec4_t a, vec4_t b ) { return vec4_sub( a, b ); } VECMATH_INLINE vec4_t vm_sub( vec4_t a, float b ) { return vec4_subf( a, b ); } VECMATH_INLINE vec4_t vm_sub( float a, vec4_t b ) { return vec4_fsub( a, b ); } VECMATH_INLINE mat22_t vm_sub( mat22_t a, mat22_t b ) { return mat22_sub( a, b ); } VECMATH_INLINE mat22_t vm_sub( mat22_t a, float b ) { return mat22_subf( a, b ); } VECMATH_INLINE mat22_t vm_sub( float a, mat22_t b ) { return mat22_fsub( a, b ); } VECMATH_INLINE mat23_t vm_sub( mat23_t a, mat23_t b ) { return mat23_sub( a, b ); } VECMATH_INLINE mat23_t vm_sub( mat23_t a, float b ) { return mat23_subf( a, b ); } VECMATH_INLINE mat23_t vm_sub( float a, mat23_t b ) { return mat23_fsub( a, b ); } VECMATH_INLINE mat24_t vm_sub( mat24_t a, mat24_t b ) { return mat24_sub( a, b ); } VECMATH_INLINE mat24_t vm_sub( mat24_t a, float b ) { return mat24_subf( a, b ); } VECMATH_INLINE mat24_t vm_sub( float a, mat24_t b ) { return mat24_fsub( a, b ); } VECMATH_INLINE mat32_t vm_sub( mat32_t a, mat32_t b ) { return mat32_sub( a, b ); } VECMATH_INLINE mat32_t vm_sub( mat32_t a, float b ) { return mat32_subf( a, b ); } VECMATH_INLINE mat32_t vm_sub( float a, mat32_t b ) { return mat32_fsub( a, b ); } VECMATH_INLINE mat33_t vm_sub( mat33_t a, mat33_t b ) { return mat33_sub( a, b ); } VECMATH_INLINE mat33_t vm_sub( mat33_t a, float b ) { return mat33_subf( a, b ); } VECMATH_INLINE mat33_t vm_sub( float a, mat33_t b ) { return mat33_fsub( a, b ); } VECMATH_INLINE mat34_t vm_sub( mat34_t a, mat34_t b ) { return mat34_sub( a, b ); } VECMATH_INLINE mat34_t vm_sub( mat34_t a, float b ) { return mat34_subf( a, b ); } VECMATH_INLINE mat34_t vm_sub( float a, mat34_t b ) { return mat34_fsub( a, b ); } VECMATH_INLINE mat42_t vm_sub( mat42_t a, mat42_t b ) { return mat42_sub( a, b ); } VECMATH_INLINE mat42_t vm_sub( mat42_t a, float b ) { return mat42_subf( a, b ); } VECMATH_INLINE mat42_t vm_sub( float a, mat42_t b ) { return mat42_fsub( a, b ); } VECMATH_INLINE mat43_t vm_sub( mat43_t a, mat43_t b ) { return mat43_sub( a, b ); } VECMATH_INLINE mat43_t vm_sub( mat43_t a, float b ) { return mat43_subf( a, b ); } VECMATH_INLINE mat43_t vm_sub( float a, mat43_t b ) { return mat43_fsub( a, b ); } VECMATH_INLINE mat44_t vm_sub( mat44_t a, mat44_t b ) { return mat44_sub( a, b ); } VECMATH_INLINE mat44_t vm_sub( mat44_t a, float b ) { return mat44_subf( a, b ); } VECMATH_INLINE mat44_t vm_sub( float a, mat44_t b ) { return mat44_fsub( a, b ); }
    VECMATH_INLINE float vm_mul( float a, float b ) { return vecmath_fmul( a, b ); } VECMATH_INLINE vec2_t vm_mul( float a, vec2_t b ) { return vec2_fmul( a, b ); } VECMATH_INLINE vec3_t vm_mul( float a, vec3_t b ) { return vec3_fmul( a, b ); } VECMATH_INLINE vec4_t vm_mul( float a, vec4_t b ) { return vec4_fmul( a, b ); } VECMATH_INLINE mat22_t vm_mul( float a, mat22_t b ) { return mat22_fmul( a, b ); } VECMATH_INLINE mat23_t vm_mul( float a, mat23_t b ) { return mat23_fmul( a, b ); } VECMATH_INLINE mat24_t vm_mul( float a, mat24_t b ) { return mat24_fmul( a, b ); } VECMATH_INLINE mat32_t vm_mul( float a, mat32_t b ) { return mat32_fmul( a, b ); } VECMATH_INLINE mat33_t vm_mul( float a, mat33_t b ) { return mat33_fmul( a, b ); } VECMATH_INLINE mat34_t vm_mul( float a, mat34_t b ) { return mat34_fmul( a, b ); } VECMATH_INLINE mat42_t vm_mul( float a, mat42_t b ) { return mat42_fmul( a, b ); } VECMATH_INLINE mat43_t vm_mul( float a, mat43_t b ) { return mat43_fmul( a, b ); } VECMATH_INLINE mat44_t vm_mul( float a, mat44_t b ) { return mat44_fmul( a, b ); } VECMATH_INLINE vec2_t vm_mul( vec2_t a, vec2_t b ) { return vec2_mul( a, b ); } VECMATH_INLINE vec2_t vm_mul( vec2_t a, float b ) { return vec2_mulf( a, b ); } VECMATH_INLINE vec2_t vm_mul( vec2_t a, mat22_t b ) { return vec2_mul_mat22( a, b ); } VECMATH_INLINE vec3_t vm_mul( vec2_t a, mat23_t b ) { return vec2_mul_mat23( a, b ); } VECMATH_INLINE vec4_t vm_mul( vec2_t a, mat24_t b ) { return vec2_mul_mat24( a, b ); } VECMATH_INLINE vec2_t vm_mul( mat22_t a, vec2_t b ) { return mat22_mul_vec2( a, b ); } VECMATH_INLINE mat22_t vm_mul( mat22_t a, float b ) { return mat22_mulf( a, b ); } VECMATH_INLINE mat22_t vm_mul( mat22_t a, mat22_t b ) { return mat22_mul_mat22( a, b ); } VECMATH_INLINE mat23_t vm_mul( mat22_t a, mat23_t b ) { return mat22_mul_mat23( a, b ); } VECMATH_INLINE mat24_t vm_mul( mat22_t a, mat24_t b ) { return mat22_mul_mat24( a, b ); } VECMATH_INLINE vec3_t vm_mul( vec3_t a, vec3_t b ) { return vec3_mul( a, b ); } VECMATH_INLINE vec3_t vm_mul( vec3_t a, float b ) { return vec3_mulf( a, b ); } VECMATH_INLINE vec2_t vm_mul( vec3_t a, mat32_t b ) { return vec3_mul_mat32( a, b ); } VECMATH_INLINE vec3_t vm_mul( vec3_t a, mat33_t b ) { return vec3_mul_mat33( a, b ); } VECMATH_INLINE vec4_t vm_mul( vec3_t a, mat34_t b ) { return vec3_mul_mat34( a, b ); } VECMATH_INLINE vec2_t vm_mul( mat23_t a, vec3_t b ) { return mat23_mul_vec3( a, b ); } VECMATH_INLINE mat23_t vm_mul( mat23_t a, float b ) { return mat23_mulf( a, b ); } VECMATH_INLINE mat22_t vm_mul( mat23_t a, mat32_t b ) { return mat23_mul_mat32( a, b ); } VECMATH_INLINE mat23_t vm_mul( mat23_t a, mat33_t b ) { return mat23_mul_mat33( a, b ); } VECMATH_INLINE mat24_t vm_mul( mat23_t a, mat34_t b ) { return mat23_mul_mat34( a, b ); } VECMATH_INLINE vec4_t vm_mul( vec4_t a, vec4_t b ) { return vec4_mul( a, b ); } VECMATH_INLINE vec4_t vm_mul( vec4_t a, float b ) { return vec4_mulf( a, b ); } VECMATH_INLINE vec2_t vm_mul( vec4_t a, mat42_t b ) { return vec4_mul_mat42( a, b ); } VECMATH_INLINE vec3_t vm_mul( vec4_t a, mat43_t b ) { return vec4_mul_mat43( a, b ); } VECMATH_INLINE vec4_t vm_mul( vec4_t a, mat44_t b ) { return vec4_mul_mat44( a, b ); } VECMATH_INLINE vec2_t vm_mul( mat24_t a, vec4_t b ) { return mat24_mul_vec4( a, b ); } VECMATH_INLINE mat24_t vm_mul( mat24_t a, float b ) { return mat24_mulf( a, b ); } VECMATH_INLINE mat22_t vm_mul( mat24_t a, mat42_t b ) { return mat24_mul_mat42( a, b ); } VECMATH_INLINE mat23_t vm_mul( mat24_t a, mat43_t b ) { return mat24_mul_mat43( a, b ); } VECMATH_INLINE mat24_t vm_mul( mat24_t a, mat44_t b ) { return mat24_mul_mat44( a, b ); } VECMATH_INLINE vec3_t vm_mul( mat32_t a, vec2_t b ) { return mat32_mul_vec2( a, b ); } VECMATH_INLINE mat32_t vm_mul( mat32_t a, float b ) { return mat32_mulf( a, b ); } VECMATH_INLINE mat32_t vm_mul( mat32_t a, mat22_t b ) { return mat32_mul_mat22( a, b ); } VECMATH_INLINE mat33_t vm_mul( mat32_t a, mat23_t b ) { return mat32_mul_mat23( a, b ); } VECMATH_INLINE mat34_t vm_mul( mat32_t a, mat24_t b ) { return mat32_mul_mat24( a, b ); } VECMATH_INLINE vec3_t vm_mul( mat33_t a, vec3_t b ) { return mat33_mul_vec3( a, b ); } VECMATH_INLINE mat33_t vm_mul( mat33_t a, float b ) { return mat33_mulf( a, b ); } VECMATH_INLINE mat32_t vm_mul( mat33_t a, mat32_t b ) { return mat33_mul_mat32( a, b ); } VECMATH_INLINE mat33_t vm_mul( mat33_t a, mat33_t b ) { return mat33_mul_mat33( a, b ); } VECMATH_INLINE mat34_t vm_mul( mat33_t a, mat34_t b ) { return mat33_mul_mat34( a, b ); } VECMATH_INLINE vec3_t vm_mul( mat34_t a, vec4_t b ) { return mat34_mul_vec4( a, b ); } VECMATH_INLINE mat34_t vm_mul( mat34_t a, float b ) { return mat34_mulf( a, b ); } VECMATH_INLINE mat32_t vm_mul( mat34_t a, mat42_t b ) { return mat34_mul_mat42( a, b ); } VECMATH_INLINE mat33_t vm_mul( mat34_t a, mat43_t b ) { return mat34_mul_mat43( a, b ); } VECMATH_INLINE mat34_t vm_mul( mat34_t a, mat44_t b ) { return mat34_mul_mat44( a, b ); } VECMATH_INLINE vec4_t vm_mul( mat42_t a, vec2_t b ) { return mat42_mul_vec2( a, b ); } VECMATH_INLINE mat42_t vm_mul( mat42_t a, float b ) { return mat42_mulf( a, b ); } VECMATH_INLINE mat42_t vm_mul( mat42_t a, mat22_t b ) { return mat42_mul_mat22( a, b ); } VECMATH_INLINE mat43_t vm_mul( mat42_t a, mat23_t b ) { return mat42_mul_mat23( a, b ); } VECMATH_INLINE mat44_t vm_mul( mat42_t a, mat24_t b ) { return mat42_mul_mat24( a, b ); } VECMATH_INLINE vec4_t vm_mul( mat43_t a, vec3_t b ) { return mat43_mul_vec3( a, b ); } VECMATH_INLINE mat43_t vm_mul( mat43_t a, float b ) { return mat43_mulf( a, b ); } VECMATH_INLINE mat42_t vm_mul( mat43_t a, mat32_t b ) { return mat43_mul_mat32( a, b ); } VECMATH_INLINE mat43_t vm_mul( mat43_t a, mat33_t b ) { return mat43_mul_mat33( a, b ); } VECMATH_INLINE mat44_t vm_mul( mat43_t a, mat34_t b ) { return mat43_mul_mat34( a, b ); } VECMATH_INLINE vec4_t vm_mul( mat44_t a, vec4_t b ) { return mat44_mul_vec4( a, b ); } VECMATH_INLINE mat44_t vm_mul( mat44_t a, float b ) { return mat44_mulf( a, b ); } VECMATH_INLINE mat42_t vm_mul( mat44_t a, mat42_t b ) { return mat44_mul_mat42( a, b ); } VECMATH_INLINE mat43_t vm_mul( mat44_t a, mat43_t b ) { return mat44_mul_mat43( a, b ); } VECMATH_INLINE mat44_t vm_mul( mat44_t a, mat44_t b ) { return mat44_mul_mat44( a, b ); } 
    VECMATH_INLINE float vm_div( float a, float b ) { return vecmath_fdiv( a, b ); } VECMATH_INLINE vec2_t vm_div( float a, vec2_t b ) { return vec2_fdiv( a, b ); } VECMATH_INLINE vec3_t vm_div( float a, vec3_t b ) { return vec3_fdiv( a, b ); } VECMATH_INLINE vec4_t vm_div( float a, vec4_t b ) { return vec4_fdiv( a, b ); } VECMATH_INLINE mat22_t vm_div( float a, mat22_t b ) { return mat22_fdiv( a, b ); } VECMATH_INLINE mat23_t vm_div( float a, mat23_t b ) { return mat23_fdiv( a, b ); } VECMATH_INLINE mat24_t vm_div( float a, mat24_t b ) { return mat24_fdiv( a, b ); } VECMATH_INLINE mat32_t vm_div( float a, mat32_t b ) { return mat32_fdiv( a, b ); } VECMATH_INLINE mat33_t vm_div( float a, mat33_t b ) { return mat33_fdiv( a, b ); } VECMATH_INLINE mat34_t vm_div( float a, mat34_t b ) { return mat34_fdiv( a, b ); } VECMATH_INLINE mat42_t vm_div( float a, mat42_t b ) { return mat42_fdiv( a, b ); } VECMATH_INLINE mat43_t vm_div( float a, mat43_t b ) { return mat43_fdiv( a, b ); } VECMATH_INLINE mat44_t vm_div( float a, mat44_t b ) { return mat44_fdiv( a, b ); } VECMATH_INLINE vec2_t vm_div( vec2_t a, vec2_t b ) { return vec2_div( a, b ); } VECMATH_INLINE vec2_t vm_div( vec2_t a, float b ) { return vec2_divf( a, b ); } VECMATH_INLINE vec3_t vm_div( vec3_t a, vec3_t b ) { return vec3_div( a, b ); } VECMATH_INLINE vec3_t vm_div( vec3_t a, float b ) { return vec3_divf( a, b ); } VECMATH_INLINE vec4_t vm_div( vec4_t a, vec4_t b ) { return vec4_div( a, b ); } VECMATH_INLINE vec4_t vm_div( vec4_t a, float b ) { return vec4_divf( a, b ); } VECMATH_INLINE mat22_t vm_div( mat22_t a, mat22_t b ) { return mat22_div( a, b ); } VECMATH_INLINE mat22_t vm_div( mat22_t a, float b ) { return mat22_divf( a, b ); } VECMATH_INLINE mat23_t vm_div( mat23_t a, mat23_t b ) { return mat23_div( a, b ); } VECMATH_INLINE mat23_t vm_div( mat23_t a, float b ) { return mat23_divf( a, b ); } VECMATH_INLINE mat24_t vm_div( mat24_t a, mat24_t b ) { return mat24_div( a, b ); } VECMATH_INLINE mat24_t vm_div( mat24_t a, float b ) { return mat24_divf( a, b ); } VECMATH_INLINE mat32_t vm_div( mat32_t a, mat32_t b ) { return mat32_div( a, b ); } VECMATH_INLINE mat32_t vm_div( mat32_t a, float b ) { return mat32_divf( a, b ); } VECMATH_INLINE mat33_t vm_div( mat33_t a, mat33_t b ) { return mat33_div( a, b ); } VECMATH_INLINE mat33_t vm_div( mat33_t a, float b ) { return mat33_divf( a, b ); } VECMATH_INLINE mat34_t vm_div( mat34_t a, mat34_t b ) { return mat34_div( a, b ); } VECMATH_INLINE mat34_t vm_div( mat34_t a, float b ) { return mat34_divf( a, b ); } VECMATH_INLINE mat42_t vm_div( mat42_t a, mat42_t b ) { return mat42_div( a, b ); } VECMATH_INLINE mat42_t vm_div( mat42_t a, float b ) { return mat42_divf( a, b ); } VECMATH_INLINE mat43_t vm_div( mat43_t a, mat43_t b ) { return mat43_div( a, b ); } VECMATH_INLINE mat43_t vm_div( mat43_t a, float b ) { return mat43_divf( a, b ); } VECMATH_INLINE mat44_t vm_div( mat44_t a, mat44_t b ) { return mat44_div( a, b ); } VECMATH_INLINE mat44_t vm_div( mat44_t a, float b ) { return mat44_divf( a, b ); }
    VECMATH_INLINE float vm_abs( float a ) { return vecmath_abs( a ); } VECMATH_INLINE vec2_t vm_abs( vec2_t a ) { return vec2_abs( a ); } VECMATH_INLINE vec3_t vm_abs( vec3_t a ) { return vec3_abs( a ); } VECMATH_INLINE vec4_t vm_abs( vec4_t a ) { return vec4_abs( a ); } VECMATH_INLINE mat22_t vm_abs( mat22_t a ) { return mat22_abs( a ); } VECMATH_INLINE mat23_t vm_abs( mat23_t a ) { return mat23_abs( a ); } VECMATH_INLINE mat24_t vm_abs( mat24_t a ) { return mat24_abs( a ); } VECMATH_INLINE mat32_t vm_abs( mat32_t a ) { return mat32_abs( a ); } VECMATH_INLINE mat33_t vm_abs( mat33_t a ) { return mat33_abs( a ); } VECMATH_INLINE mat34_t vm_abs( mat34_t a ) { return mat34_abs( a ); } VECMATH_INLINE mat42_t vm_abs( mat42_t a ) { return mat42_abs( a ); } VECMATH_INLINE mat43_t vm_abs( mat43_t a ) { return mat43_abs( a ); } VECMATH_INLINE mat44_t vm_abs( mat44_t a ) { return mat44_abs( a ); }
    VECMATH_INLINE float vm_acos( float a ) { return vecmath_acos( a ); } VECMATH_INLINE vec2_t vm_acos( vec2_t a ) { return vec2_acos( a ); } VECMATH_INLINE vec3_t vm_acos( vec3_t a ) { return vec3_acos( a ); } VECMATH_INLINE vec4_t vm_acos( vec4_t a ) { return vec4_acos( a ); } VECMATH_INLINE mat22_t vm_acos( mat22_t a ) { return mat22_acos( a ); } VECMATH_INLINE mat23_t vm_acos( mat23_t a ) { return mat23_acos( a ); } VECMATH_INLINE mat24_t vm_acos( mat24_t a ) { return mat24_acos( a ); } VECMATH_INLINE mat32_t vm_acos( mat32_t a ) { return mat32_acos( a ); } VECMATH_INLINE mat33_t vm_acos( mat33_t a ) { return mat33_acos( a ); } VECMATH_INLINE mat34_t vm_acos( mat34_t a ) { return mat34_acos( a ); } VECMATH_INLINE mat42_t vm_acos( mat42_t a ) { return mat42_acos( a ); } VECMATH_INLINE mat43_t vm_acos( mat43_t a ) { return mat43_acos( a ); } VECMATH_INLINE mat44_t vm_acos( mat44_t a ) { return mat44_acos( a ); }
    VECMATH_INLINE int vm_all( vec2_t a ) { return vec2_all( a ); } VECMATH_INLINE int vm_all( vec3_t a ) { return vec3_all( a ); } VECMATH_INLINE int vm_all( vec4_t a ) { return vec4_all( a ); } VECMATH_INLINE int vm_all( mat22_t a ) { return mat22_all( a ); } VECMATH_INLINE int vm_all( mat23_t a ) { return mat23_all( a ); } VECMATH_INLINE int vm_all( mat24_t a ) { return mat24_all( a ); } VECMATH_INLINE int vm_all( mat32_t a ) { return mat32_all( a ); } VECMATH_INLINE int vm_all( mat33_t a ) { return mat33_all( a ); } VECMATH_INLINE int vm_all( mat34_t a ) { return mat34_all( a ); } VECMATH_INLINE int vm_all( mat42_t a ) { return mat42_all( a ); } VECMATH_INLINE int vm_all( mat43_t a ) { return mat43_all( a ); } VECMATH_INLINE int vm_all( mat44_t a ) { return mat44_all( a ); }
    VECMATH_INLINE int vm_any( vec2_t a ) { return vec2_any( a ); } VECMATH_INLINE int vm_any( vec3_t a ) { return vec3_any( a ); } VECMATH_INLINE int vm_any( vec4_t a ) { return vec4_any( a ); } VECMATH_INLINE int vm_any( mat22_t a ) { return mat22_any( a ); } VECMATH_INLINE int vm_any( mat23_t a ) { return mat23_any( a ); } VECMATH_INLINE int vm_any( mat24_t a ) { return mat24_any( a ); } VECMATH_INLINE int vm_any( mat32_t a ) { return mat32_any( a ); } VECMATH_INLINE int vm_any( mat33_t a ) { return mat33_any( a ); } VECMATH_INLINE int vm_any( mat34_t a ) { return mat34_any( a ); } VECMATH_INLINE int vm_any( mat42_t a ) { return mat42_any( a ); } VECMATH_INLINE int vm_any( mat43_t a ) { return mat43_any( a ); } VECMATH_INLINE int vm_any( mat44_t a ) { return mat44_any( a ); }
    VECMATH_INLINE float vm_asin( float a ) { return vecmath_asin( a ); } VECMATH_INLINE vec2_t vm_asin( vec2_t a ) { return vec2_asin( a ); } VECMATH_INLINE vec3_t vm_asin( vec3_t a ) { return vec3_asin( a ); } VECMATH_INLINE vec4_t vm_asin( vec4_t a ) { return vec4_asin( a ); } VECMATH_INLINE mat22_t vm_asin( mat22_t a ) { return mat22_asin( a ); } VECMATH_INLINE mat23_t vm_asin( mat23_t a ) { return mat23_asin( a ); } VECMATH_INLINE mat24_t vm_asin( mat24_t a ) { return mat24_asin( a ); } VECMATH_INLINE mat32_t vm_asin( mat32_t a ) { return mat32_asin( a ); } VECMATH_INLINE mat33_t vm_asin( mat33_t a ) { return mat33_asin( a ); } VECMATH_INLINE mat34_t vm_asin( mat34_t a ) { return mat34_asin( a ); } VECMATH_INLINE mat42_t vm_asin( mat42_t a ) { return mat42_asin( a ); } VECMATH_INLINE mat43_t vm_asin( mat43_t a ) { return mat43_asin( a ); } VECMATH_INLINE mat44_t vm_asin( mat44_t a ) { return mat44_asin( a ); }
    VECMATH_INLINE float vm_atan( float a ) { return vecmath_atan( a ); } VECMATH_INLINE vec2_t vm_atan( vec2_t a ) { return vec2_atan( a ); } VECMATH_INLINE vec3_t vm_atan( vec3_t a ) { return vec3_atan( a ); } VECMATH_INLINE vec4_t vm_atan( vec4_t a ) { return vec4_atan( a ); } VECMATH_INLINE mat22_t vm_atan( mat22_t a ) { return mat22_atan( a ); } VECMATH_INLINE mat23_t vm_atan( mat23_t a ) { return mat23_atan( a ); } VECMATH_INLINE mat24_t vm_atan( mat24_t a ) { return mat24_atan( a ); } VECMATH_INLINE mat32_t vm_atan( mat32_t a ) { return mat32_atan( a ); } VECMATH_INLINE mat33_t vm_atan( mat33_t a ) { return mat33_atan( a ); } VECMATH_INLINE mat34_t vm_atan( mat34_t a ) { return mat34_atan( a ); } VECMATH_INLINE mat42_t vm_atan( mat42_t a ) { return mat42_atan( a ); } VECMATH_INLINE mat43_t vm_atan( mat43_t a ) { return mat43_atan( a ); } VECMATH_INLINE mat44_t vm_atan( mat44_t a ) { return mat44_atan( a ); }
    VECMATH_INLINE float vm_atan2( float a, float b ) { return vecmath_atan2( a, b ); } VECMATH_INLINE vec2_t vm_atan2( vec2_t a, vec2_t b ) { return vec2_atan2( a, b ); } VECMATH_INLINE vec3_t vm_atan2( vec3_t a, vec3_t b ) { return vec3_atan2( a, b ); } VECMATH_INLINE vec4_t vm_atan2( vec4_t a, vec4_t b ) { return vec4_atan2( a, b ); } VECMATH_INLINE mat22_t vm_atan2( mat22_t a, mat22_t b ) { return mat22_atan2( a, b ); } VECMATH_INLINE mat23_t vm_atan2( mat23_t a, mat23_t b ) { return mat23_atan2( a, b ); } VECMATH_INLINE mat24_t vm_atan2( mat24_t a, mat24_t b ) { return mat24_atan2( a, b ); } VECMATH_INLINE mat32_t vm_atan2( mat32_t a, mat32_t b ) { return mat32_atan2( a, b ); } VECMATH_INLINE mat33_t vm_atan2( mat33_t a, mat33_t b ) { return mat33_atan2( a, b ); } VECMATH_INLINE mat34_t vm_atan2( mat34_t a, mat34_t b ) { return mat34_atan2( a, b ); } VECMATH_INLINE mat42_t vm_atan2( mat42_t a, mat42_t b ) { return mat42_atan2( a, b ); } VECMATH_INLINE mat43_t vm_atan2( mat43_t a, mat43_t b ) { return mat43_atan2( a, b ); } VECMATH_INLINE mat44_t vm_atan2( mat44_t a, mat44_t b ) { return mat44_atan2( a, b ); }
    VECMATH_INLINE float vm_ceil( float a ) { return vecmath_ceil( a ); } VECMATH_INLINE vec2_t vm_ceil( vec2_t a ) { return vec2_ceil( a ); } VECMATH_INLINE vec3_t vm_ceil( vec3_t a ) { return vec3_ceil( a ); } VECMATH_INLINE vec4_t vm_ceil( vec4_t a ) { return vec4_ceil( a ); } VECMATH_INLINE mat22_t vm_ceil( mat22_t a ) { return mat22_ceil( a ); } VECMATH_INLINE mat23_t vm_ceil( mat23_t a ) { return mat23_ceil( a ); } VECMATH_INLINE mat24_t vm_ceil( mat24_t a ) { return mat24_ceil( a ); } VECMATH_INLINE mat32_t vm_ceil( mat32_t a ) { return mat32_ceil( a ); } VECMATH_INLINE mat33_t vm_ceil( mat33_t a ) { return mat33_ceil( a ); } VECMATH_INLINE mat34_t vm_ceil( mat34_t a ) { return mat34_ceil( a ); } VECMATH_INLINE mat42_t vm_ceil( mat42_t a ) { return mat42_ceil( a ); } VECMATH_INLINE mat43_t vm_ceil( mat43_t a ) { return mat43_ceil( a ); } VECMATH_INLINE mat44_t vm_ceil( mat44_t a ) { return mat44_ceil( a ); }
    VECMATH_INLINE float vm_clamp( float a, float minv, float maxv ) { return vecmath_clamp( a, minv, maxv ); } VECMATH_INLINE vec2_t vm_clamp( vec2_t a, vec2_t minv, vec2_t maxv ) { return vec2_clamp( a, minv, maxv ); } VECMATH_INLINE vec3_t vm_clamp( vec3_t a, vec3_t minv, vec3_t maxv ) { return vec3_clamp( a, minv, maxv ); } VECMATH_INLINE vec4_t vm_clamp( vec4_t a, vec4_t minv, vec4_t maxv ) { return vec4_clamp( a, minv, maxv ); } VECMATH_INLINE mat22_t vm_clamp( mat22_t a, mat22_t minv, mat22_t maxv ) { return mat22_clamp( a, minv, maxv ); } VECMATH_INLINE mat23_t vm_clamp( mat23_t a, mat23_t minv, mat23_t maxv ) { return mat23_clamp( a, minv, maxv ); } VECMATH_INLINE mat24_t vm_clamp( mat24_t a, mat24_t minv, mat24_t maxv ) { return mat24_clamp( a, minv, maxv ); } VECMATH_INLINE mat32_t vm_clamp( mat32_t a, mat32_t minv, mat32_t maxv ) { return mat32_clamp( a, minv, maxv ); } VECMATH_INLINE mat33_t vm_clamp( mat33_t a, mat33_t minv, mat33_t maxv ) { return mat33_clamp( a, minv, maxv ); } VECMATH_INLINE mat34_t vm_clamp( mat34_t a, mat34_t minv, mat34_t maxv ) { return mat34_clamp( a, minv, maxv ); } VECMATH_INLINE mat42_t vm_clamp( mat42_t a, mat42_t minv, mat42_t maxv ) { return mat42_clamp( a, minv, maxv ); } VECMATH_INLINE mat43_t vm_clamp( mat43_t a, mat43_t minv, mat43_t maxv ) { return mat43_clamp( a, minv, maxv ); } VECMATH_INLINE mat44_t vm_clamp( mat44_t a, mat44_t minv, mat44_t maxv ) { return mat44_clamp( a, minv, maxv ); }
    VECMATH_INLINE float vm_cos( float a ) { return vecmath_cos( a ); } VECMATH_INLINE vec2_t vm_cos( vec2_t a ) { return vec2_cos( a ); } VECMATH_INLINE vec3_t vm_cos( vec3_t a ) { return vec3_cos( a ); } VECMATH_INLINE vec4_t vm_cos( vec4_t a ) { return vec4_cos( a ); } VECMATH_INLINE mat22_t vm_cos( mat22_t a ) { return mat22_cos( a ); } VECMATH_INLINE mat23_t vm_cos( mat23_t a ) { return mat23_cos( a ); } VECMATH_INLINE mat24_t vm_cos( mat24_t a ) { return mat24_cos( a ); } VECMATH_INLINE mat32_t vm_cos( mat32_t a ) { return mat32_cos( a ); } VECMATH_INLINE mat33_t vm_cos( mat33_t a ) { return mat33_cos( a ); } VECMATH_INLINE mat34_t vm_cos( mat34_t a ) { return mat34_cos( a ); } VECMATH_INLINE mat42_t vm_cos( mat42_t a ) { return mat42_cos( a ); } VECMATH_INLINE mat43_t vm_cos( mat43_t a ) { return mat43_cos( a ); } VECMATH_INLINE mat44_t vm_cos( mat44_t a ) { return mat44_cos( a ); }
    VECMATH_INLINE float vm_cosh( float a ) { return vecmath_cosh( a ); } VECMATH_INLINE vec2_t vm_cosh( vec2_t a ) { return vec2_cosh( a ); } VECMATH_INLINE vec3_t vm_cosh( vec3_t a ) { return vec3_cosh( a ); } VECMATH_INLINE vec4_t vm_cosh( vec4_t a ) { return vec4_cosh( a ); } VECMATH_INLINE mat22_t vm_cosh( mat22_t a ) { return mat22_cosh( a ); } VECMATH_INLINE mat23_t vm_cosh( mat23_t a ) { return mat23_cosh( a ); } VECMATH_INLINE mat24_t vm_cosh( mat24_t a ) { return mat24_cosh( a ); } VECMATH_INLINE mat32_t vm_cosh( mat32_t a ) { return mat32_cosh( a ); } VECMATH_INLINE mat33_t vm_cosh( mat33_t a ) { return mat33_cosh( a ); } VECMATH_INLINE mat34_t vm_cosh( mat34_t a ) { return mat34_cosh( a ); } VECMATH_INLINE mat42_t vm_cosh( mat42_t a ) { return mat42_cosh( a ); } VECMATH_INLINE mat43_t vm_cosh( mat43_t a ) { return mat43_cosh( a ); } VECMATH_INLINE mat44_t vm_cosh( mat44_t a ) { return mat44_cosh( a ); }
    VECMATH_INLINE float vm_cross( vec2_t a, vec2_t b ) { return vec2_cross( a, b ); } VECMATH_INLINE vec3_t vm_cross( vec3_t a, vec3_t b ) { return vec3_cross( a, b ); }
    VECMATH_INLINE float vm_degrees( float a ) { return vecmath_degrees( a ); } VECMATH_INLINE vec2_t vm_degrees( vec2_t a ) { return vec2_degrees( a ); } VECMATH_INLINE vec3_t vm_degrees( vec3_t a ) { return vec3_degrees( a ); } VECMATH_INLINE vec4_t vm_degrees( vec4_t a ) { return vec4_degrees( a ); } VECMATH_INLINE mat22_t vm_degrees( mat22_t a ) { return mat22_degrees( a ); } VECMATH_INLINE mat23_t vm_degrees( mat23_t a ) { return mat23_degrees( a ); } VECMATH_INLINE mat24_t vm_degrees( mat24_t a ) { return mat24_degrees( a ); } VECMATH_INLINE mat32_t vm_degrees( mat32_t a ) { return mat32_degrees( a ); } VECMATH_INLINE mat33_t vm_degrees( mat33_t a ) { return mat33_degrees( a ); } VECMATH_INLINE mat34_t vm_degrees( mat34_t a ) { return mat34_degrees( a ); } VECMATH_INLINE mat42_t vm_degrees( mat42_t a ) { return mat42_degrees( a ); } VECMATH_INLINE mat43_t vm_degrees( mat43_t a ) { return mat43_degrees( a ); } VECMATH_INLINE mat44_t vm_degrees( mat44_t a ) { return mat44_degrees( a ); }
    VECMATH_INLINE float vm_distancesq( float a, float b ) { return vecmath_distancesq( a, b ); } VECMATH_INLINE float vm_distancesq( vec2_t a, vec2_t b ) { return vec2_distancesq( a, b ); } VECMATH_INLINE float vm_distancesq( vec3_t a, vec3_t b ) { return vec3_distancesq( a, b ); } VECMATH_INLINE float vm_distancesq( vec4_t a, vec4_t b ) { return vec4_distancesq( a, b ); }
    VECMATH_INLINE float vm_distance( float a, float b ) { return vecmath_distance( a, b ); } VECMATH_INLINE float vm_distance( vec2_t a, vec2_t b ) { return vec2_distance( a, b ); } VECMATH_INLINE float vm_distance( vec3_t a, vec3_t b ) { return vec3_distance( a, b ); } VECMATH_INLINE float vm_distance( vec4_t a, vec4_t b ) { return vec4_distance( a, b ); }
    VECMATH_INLINE float vm_dot( float a, float b ) { return vecmath_dot( a, b ); } VECMATH_INLINE float vm_dot( vec2_t a, vec2_t b ) { return vec2_dot( a, b ); } VECMATH_INLINE float vm_dot( vec3_t a, vec3_t b ) { return vec3_dot( a, b ); } VECMATH_INLINE float vm_dot( vec4_t a, vec4_t b ) { return vec4_dot( a, b ); }
    VECMATH_INLINE float vm_exp( float a ) { return vecmath_exp( a ); } VECMATH_INLINE vec2_t vm_exp( vec2_t a ) { return vec2_exp( a ); } VECMATH_INLINE vec3_t vm_exp( vec3_t a ) { return vec3_exp( a ); } VECMATH_INLINE vec4_t vm_exp( vec4_t a ) { return vec4_exp( a ); } VECMATH_INLINE mat22_t vm_exp( mat22_t a ) { return mat22_exp( a ); } VECMATH_INLINE mat23_t vm_exp( mat23_t a ) { return mat23_exp( a ); } VECMATH_INLINE mat24_t vm_exp( mat24_t a ) { return mat24_exp( a ); } VECMATH_INLINE mat32_t vm_exp( mat32_t a ) { return mat32_exp( a ); } VECMATH_INLINE mat33_t vm_exp( mat33_t a ) { return mat33_exp( a ); } VECMATH_INLINE mat34_t vm_exp( mat34_t a ) { return mat34_exp( a ); } VECMATH_INLINE mat42_t vm_exp( mat42_t a ) { return mat42_exp( a ); } VECMATH_INLINE mat43_t vm_exp( mat43_t a ) { return mat43_exp( a ); } VECMATH_INLINE mat44_t vm_exp( mat44_t a ) { return mat44_exp( a ); }
    VECMATH_INLINE float vm_exp2( float a ) { return vecmath_exp2( a ); } VECMATH_INLINE vec2_t vm_exp2( vec2_t a ) { return vec2_exp2( a ); } VECMATH_INLINE vec3_t vm_exp2( vec3_t a ) { return vec3_exp2( a ); } VECMATH_INLINE vec4_t vm_exp2( vec4_t a ) { return vec4_exp2( a ); } VECMATH_INLINE mat22_t vm_exp2( mat22_t a ) { return mat22_exp2( a ); } VECMATH_INLINE mat23_t vm_exp2( mat23_t a ) { return mat23_exp2( a ); } VECMATH_INLINE mat24_t vm_exp2( mat24_t a ) { return mat24_exp2( a ); } VECMATH_INLINE mat32_t vm_exp2( mat32_t a ) { return mat32_exp2( a ); } VECMATH_INLINE mat33_t vm_exp2( mat33_t a ) { return mat33_exp2( a ); } VECMATH_INLINE mat34_t vm_exp2( mat34_t a ) { return mat34_exp2( a ); } VECMATH_INLINE mat42_t vm_exp2( mat42_t a ) { return mat42_exp2( a ); } VECMATH_INLINE mat43_t vm_exp2( mat43_t a ) { return mat43_exp2( a ); } VECMATH_INLINE mat44_t vm_exp2( mat44_t a ) { return mat44_exp2( a ); }
    VECMATH_INLINE float vm_floor( float a ) { return vecmath_floor( a ); } VECMATH_INLINE vec2_t vm_floor( vec2_t a ) { return vec2_floor( a ); } VECMATH_INLINE vec3_t vm_floor( vec3_t a ) { return vec3_floor( a ); } VECMATH_INLINE vec4_t vm_floor( vec4_t a ) { return vec4_floor( a ); } VECMATH_INLINE mat22_t vm_floor( mat22_t a ) { return mat22_floor( a ); } VECMATH_INLINE mat23_t vm_floor( mat23_t a ) { return mat23_floor( a ); } VECMATH_INLINE mat24_t vm_floor( mat24_t a ) { return mat24_floor( a ); } VECMATH_INLINE mat32_t vm_floor( mat32_t a ) { return mat32_floor( a ); } VECMATH_INLINE mat33_t vm_floor( mat33_t a ) { return mat33_floor( a ); } VECMATH_INLINE mat34_t vm_floor( mat34_t a ) { return mat34_floor( a ); } VECMATH_INLINE mat42_t vm_floor( mat42_t a ) { return mat42_floor( a ); } VECMATH_INLINE mat43_t vm_floor( mat43_t a ) { return mat43_floor( a ); } VECMATH_INLINE mat44_t vm_floor( mat44_t a ) { return mat44_floor( a ); }
    VECMATH_INLINE float vm_fmod( float a, float b ) { return vecmath_fmod( a, b ); } VECMATH_INLINE vec2_t vm_fmod( vec2_t a, vec2_t b ) { return vec2_fmod( a, b ); } VECMATH_INLINE vec3_t vm_fmod( vec3_t a, vec3_t b ) { return vec3_fmod( a, b ); } VECMATH_INLINE vec4_t vm_fmod( vec4_t a, vec4_t b ) { return vec4_fmod( a, b ); } VECMATH_INLINE mat22_t vm_fmod( mat22_t a, mat22_t b ) { return mat22_fmod( a, b ); } VECMATH_INLINE mat23_t vm_fmod( mat23_t a, mat23_t b ) { return mat23_fmod( a, b ); } VECMATH_INLINE mat24_t vm_fmod( mat24_t a, mat24_t b ) { return mat24_fmod( a, b ); } VECMATH_INLINE mat32_t vm_fmod( mat32_t a, mat32_t b ) { return mat32_fmod( a, b ); } VECMATH_INLINE mat33_t vm_fmod( mat33_t a, mat33_t b ) { return mat33_fmod( a, b ); } VECMATH_INLINE mat34_t vm_fmod( mat34_t a, mat34_t b ) { return mat34_fmod( a, b ); } VECMATH_INLINE mat42_t vm_fmod( mat42_t a, mat42_t b ) { return mat42_fmod( a, b ); } VECMATH_INLINE mat43_t vm_fmod( mat43_t a, mat43_t b ) { return mat43_fmod( a, b ); } VECMATH_INLINE mat44_t vm_fmod( mat44_t a, mat44_t b ) { return mat44_fmod( a, b ); }
    VECMATH_INLINE float vm_frac( float a ) { return vecmath_frac( a ); } VECMATH_INLINE vec2_t vm_frac( vec2_t a ) { return vec2_frac( a ); } VECMATH_INLINE vec3_t vm_frac( vec3_t a ) { return vec3_frac( a ); } VECMATH_INLINE vec4_t vm_frac( vec4_t a ) { return vec4_frac( a ); } VECMATH_INLINE mat22_t vm_frac( mat22_t a ) { return mat22_frac( a ); } VECMATH_INLINE mat23_t vm_frac( mat23_t a ) { return mat23_frac( a ); } VECMATH_INLINE mat24_t vm_frac( mat24_t a ) { return mat24_frac( a ); } VECMATH_INLINE mat32_t vm_frac( mat32_t a ) { return mat32_frac( a ); } VECMATH_INLINE mat33_t vm_frac( mat33_t a ) { return mat33_frac( a ); } VECMATH_INLINE mat34_t vm_frac( mat34_t a ) { return mat34_frac( a ); } VECMATH_INLINE mat42_t vm_frac( mat42_t a ) { return mat42_frac( a ); } VECMATH_INLINE mat43_t vm_frac( mat43_t a ) { return mat43_frac( a ); } VECMATH_INLINE mat44_t vm_frac( mat44_t a ) { return mat44_frac( a ); }
    VECMATH_INLINE float vm_lengthsq( float a ) { return vecmath_lengthsq( a ); } VECMATH_INLINE float vm_lengthsq( vec2_t a ) { return vec2_lengthsq( a ); } VECMATH_INLINE float vm_lengthsq( vec3_t a ) { return vec3_lengthsq( a ); } VECMATH_INLINE float vm_lengthsq( vec4_t a ) { return vec4_lengthsq( a ); }
    VECMATH_INLINE float vm_length( float a ) { return vecmath_length( a ); } VECMATH_INLINE float vm_length( vec2_t a ) { return vec2_length( a ); } VECMATH_INLINE float vm_length( vec3_t a ) { return vec3_length( a ); } VECMATH_INLINE float vm_length( vec4_t a ) { return vec4_length( a ); }
    VECMATH_INLINE float vm_lerp( float a, float b, float t ) { return vecmath_lerp( a, b, t ); } VECMATH_INLINE vec2_t vm_lerp( vec2_t a, vec2_t b, float t ) { return vec2_lerp( a, b, t ); } VECMATH_INLINE vec3_t vm_lerp( vec3_t a, vec3_t b, float t ) { return vec3_lerp( a, b, t ); } VECMATH_INLINE vec4_t vm_lerp( vec4_t a, vec4_t b, float t ) { return vec4_lerp( a, b, t ); } VECMATH_INLINE mat22_t vm_lerp( mat22_t a, mat22_t b, float t ) { return mat22_lerp( a, b, t ); } VECMATH_INLINE mat23_t vm_lerp( mat23_t a, mat23_t b, float t ) { return mat23_lerp( a, b, t ); } VECMATH_INLINE mat24_t vm_lerp( mat24_t a, mat24_t b, float t ) { return mat24_lerp( a, b, t ); } VECMATH_INLINE mat32_t vm_lerp( mat32_t a, mat32_t b, float t ) { return mat32_lerp( a, b, t ); } VECMATH_INLINE mat33_t vm_lerp( mat33_t a, mat33_t b, float t ) { return mat33_lerp( a, b, t ); } VECMATH_INLINE mat34_t vm_lerp( mat34_t a, mat34_t b, float t ) { return mat34_lerp( a, b, t ); } VECMATH_INLINE mat42_t vm_lerp( mat42_t a, mat42_t b, float t ) { return mat42_lerp( a, b, t ); } VECMATH_INLINE mat43_t vm_lerp( mat43_t a, mat43_t b, float t ) { return mat43_lerp( a, b, t ); } VECMATH_INLINE mat44_t vm_lerp( mat44_t a, mat44_t b, float t ) { return mat44_lerp( a, b, t ); }
    VECMATH_INLINE float vm_log( float a ) { return vecmath_log( a ); } VECMATH_INLINE vec2_t vm_log( vec2_t a ) { return vec2_log( a ); } VECMATH_INLINE vec3_t vm_log( vec3_t a ) { return vec3_log( a ); } VECMATH_INLINE vec4_t vm_log( vec4_t a ) { return vec4_log( a ); } VECMATH_INLINE mat22_t vm_log( mat22_t a ) { return mat22_log( a ); } VECMATH_INLINE mat23_t vm_log( mat23_t a ) { return mat23_log( a ); } VECMATH_INLINE mat24_t vm_log( mat24_t a ) { return mat24_log( a ); } VECMATH_INLINE mat32_t vm_log( mat32_t a ) { return mat32_log( a ); } VECMATH_INLINE mat33_t vm_log( mat33_t a ) { return mat33_log( a ); } VECMATH_INLINE mat34_t vm_log( mat34_t a ) { return mat34_log( a ); } VECMATH_INLINE mat42_t vm_log( mat42_t a ) { return mat42_log( a ); } VECMATH_INLINE mat43_t vm_log( mat43_t a ) { return mat43_log( a ); } VECMATH_INLINE mat44_t vm_log( mat44_t a ) { return mat44_log( a ); }
    VECMATH_INLINE float vm_log2( float a ) { return vecmath_log2( a ); } VECMATH_INLINE vec2_t vm_log2( vec2_t a ) { return vec2_log2( a ); } VECMATH_INLINE vec3_t vm_log2( vec3_t a ) { return vec3_log2( a ); } VECMATH_INLINE vec4_t vm_log2( vec4_t a ) { return vec4_log2( a ); } VECMATH_INLINE mat22_t vm_log2( mat22_t a ) { return mat22_log2( a ); } VECMATH_INLINE mat23_t vm_log2( mat23_t a ) { return mat23_log2( a ); } VECMATH_INLINE mat24_t vm_log2( mat24_t a ) { return mat24_log2( a ); } VECMATH_INLINE mat32_t vm_log2( mat32_t a ) { return mat32_log2( a ); } VECMATH_INLINE mat33_t vm_log2( mat33_t a ) { return mat33_log2( a ); } VECMATH_INLINE mat34_t vm_log2( mat34_t a ) { return mat34_log2( a ); } VECMATH_INLINE mat42_t vm_log2( mat42_t a ) { return mat42_log2( a ); } VECMATH_INLINE mat43_t vm_log2( mat43_t a ) { return mat43_log2( a ); } VECMATH_INLINE mat44_t vm_log2( mat44_t a ) { return mat44_log2( a ); }
    VECMATH_INLINE float vm_log10( float a ) { return vecmath_log10( a ); } VECMATH_INLINE vec2_t vm_log10( vec2_t a ) { return vec2_log10( a ); } VECMATH_INLINE vec3_t vm_log10( vec3_t a ) { return vec3_log10( a ); } VECMATH_INLINE vec4_t vm_log10( vec4_t a ) { return vec4_log10( a ); } VECMATH_INLINE mat22_t vm_log10( mat22_t a ) { return mat22_log10( a ); } VECMATH_INLINE mat23_t vm_log10( mat23_t a ) { return mat23_log10( a ); } VECMATH_INLINE mat24_t vm_log10( mat24_t a ) { return mat24_log10( a ); } VECMATH_INLINE mat32_t vm_log10( mat32_t a ) { return mat32_log10( a ); } VECMATH_INLINE mat33_t vm_log10( mat33_t a ) { return mat33_log10( a ); } VECMATH_INLINE mat34_t vm_log10( mat34_t a ) { return mat34_log10( a ); } VECMATH_INLINE mat42_t vm_log10( mat42_t a ) { return mat42_log10( a ); } VECMATH_INLINE mat43_t vm_log10( mat43_t a ) { return mat43_log10( a ); } VECMATH_INLINE mat44_t vm_log10( mat44_t a ) { return mat44_log10( a ); }
    VECMATH_INLINE float vm_max( float a, float b ) { return vecmath_max( a, b ); } VECMATH_INLINE vec2_t vm_max( vec2_t a, vec2_t b ) { return vec2_max( a, b ); } VECMATH_INLINE vec3_t vm_max( vec3_t a, vec3_t b ) { return vec3_max( a, b ); } VECMATH_INLINE vec4_t vm_max( vec4_t a, vec4_t b ) { return vec4_max( a, b ); } VECMATH_INLINE mat22_t vm_max( mat22_t a, mat22_t b ) { return mat22_max( a, b ); } VECMATH_INLINE mat23_t vm_max( mat23_t a, mat23_t b ) { return mat23_max( a, b ); } VECMATH_INLINE mat24_t vm_max( mat24_t a, mat24_t b ) { return mat24_max( a, b ); } VECMATH_INLINE mat32_t vm_max( mat32_t a, mat32_t b ) { return mat32_max( a, b ); } VECMATH_INLINE mat33_t vm_max( mat33_t a, mat33_t b ) { return mat33_max( a, b ); } VECMATH_INLINE mat34_t vm_max( mat34_t a, mat34_t b ) { return mat34_max( a, b ); } VECMATH_INLINE mat42_t vm_max( mat42_t a, mat42_t b ) { return mat42_max( a, b ); } VECMATH_INLINE mat43_t vm_max( mat43_t a, mat43_t b ) { return mat43_max( a, b ); } VECMATH_INLINE mat44_t vm_max( mat44_t a, mat44_t b ) { return mat44_max( a, b ); }
    VECMATH_INLINE float vm_min( float a, float b ) { return vecmath_min( a, b ); } VECMATH_INLINE vec2_t vm_min( vec2_t a, vec2_t b ) { return vec2_min( a, b ); } VECMATH_INLINE vec3_t vm_min( vec3_t a, vec3_t b ) { return vec3_min( a, b ); } VECMATH_INLINE vec4_t vm_min( vec4_t a, vec4_t b ) { return vec4_min( a, b ); } VECMATH_INLINE mat22_t vm_min( mat22_t a, mat22_t b ) { return mat22_min( a, b ); } VECMATH_INLINE mat23_t vm_min( mat23_t a, mat23_t b ) { return mat23_min( a, b ); } VECMATH_INLINE mat24_t vm_min( mat24_t a, mat24_t b ) { return mat24_min( a, b ); } VECMATH_INLINE mat32_t vm_min( mat32_t a, mat32_t b ) { return mat32_min( a, b ); } VECMATH_INLINE mat33_t vm_min( mat33_t a, mat33_t b ) { return mat33_min( a, b ); } VECMATH_INLINE mat34_t vm_min( mat34_t a, mat34_t b ) { return mat34_min( a, b ); } VECMATH_INLINE mat42_t vm_min( mat42_t a, mat42_t b ) { return mat42_min( a, b ); } VECMATH_INLINE mat43_t vm_min( mat43_t a, mat43_t b ) { return mat43_min( a, b ); } VECMATH_INLINE mat44_t vm_min( mat44_t a, mat44_t b ) { return mat44_min( a, b ); }
    VECMATH_INLINE float vm_normalize( float a ) { return vecmath_normalize( a ); } VECMATH_INLINE vec2_t vm_normalize( vec2_t a ) { return vec2_normalize( a ); } VECMATH_INLINE vec3_t vm_normalize( vec3_t a ) { return vec3_normalize( a ); } VECMATH_INLINE vec4_t vm_normalize( vec4_t a ) { return vec4_normalize( a ); }
    VECMATH_INLINE float vm_pow( float a, float b ) { return vecmath_pow( a, b ); } VECMATH_INLINE vec2_t vm_pow( vec2_t a, vec2_t b ) { return vec2_pow( a, b ); } VECMATH_INLINE vec3_t vm_pow( vec3_t a, vec3_t b ) { return vec3_pow( a, b ); } VECMATH_INLINE vec4_t vm_pow( vec4_t a, vec4_t b ) { return vec4_pow( a, b ); } VECMATH_INLINE mat22_t vm_pow( mat22_t a, mat22_t b ) { return mat22_pow( a, b ); } VECMATH_INLINE mat23_t vm_pow( mat23_t a, mat23_t b ) { return mat23_pow( a, b ); } VECMATH_INLINE mat24_t vm_pow( mat24_t a, mat24_t b ) { return mat24_pow( a, b ); } VECMATH_INLINE mat32_t vm_pow( mat32_t a, mat32_t b ) { return mat32_pow( a, b ); } VECMATH_INLINE mat33_t vm_pow( mat33_t a, mat33_t b ) { return mat33_pow( a, b ); } VECMATH_INLINE mat34_t vm_pow( mat34_t a, mat34_t b ) { return mat34_pow( a, b ); } VECMATH_INLINE mat42_t vm_pow( mat42_t a, mat42_t b ) { return mat42_pow( a, b ); } VECMATH_INLINE mat43_t vm_pow( mat43_t a, mat43_t b ) { return mat43_pow( a, b ); } VECMATH_INLINE mat44_t vm_pow( mat44_t a, mat44_t b ) { return mat44_pow( a, b ); }
    VECMATH_INLINE float vm_radians( float a ) { return vecmath_radians( a ); } VECMATH_INLINE vec2_t vm_radians( vec2_t a ) { return vec2_radians( a ); } VECMATH_INLINE vec3_t vm_radians( vec3_t a ) { return vec3_radians( a ); } VECMATH_INLINE vec4_t vm_radians( vec4_t a ) { return vec4_radians( a ); } VECMATH_INLINE mat22_t vm_radians( mat22_t a ) { return mat22_radians( a ); } VECMATH_INLINE mat23_t vm_radians( mat23_t a ) { return mat23_radians( a ); } VECMATH_INLINE mat24_t vm_radians( mat24_t a ) { return mat24_radians( a ); } VECMATH_INLINE mat32_t vm_radians( mat32_t a ) { return mat32_radians( a ); } VECMATH_INLINE mat33_t vm_radians( mat33_t a ) { return mat33_radians( a ); } VECMATH_INLINE mat34_t vm_radians( mat34_t a ) { return mat34_radians( a ); } VECMATH_INLINE mat42_t vm_radians( mat42_t a ) { return mat42_radians( a ); } VECMATH_INLINE mat43_t vm_radians( mat43_t a ) { return mat43_radians( a ); } VECMATH_INLINE mat44_t vm_radians( mat44_t a ) { return mat44_radians( a ); }
    VECMATH_INLINE float vm_rcp( float a ) { return vecmath_rcp( a ); } VECMATH_INLINE vec2_t vm_rcp( vec2_t a ) { return vec2_rcp( a ); } VECMATH_INLINE vec3_t vm_rcp( vec3_t a ) { return vec3_rcp( a ); } VECMATH_INLINE vec4_t vm_rcp( vec4_t a ) { return vec4_rcp( a ); } VECMATH_INLINE mat22_t vm_rcp( mat22_t a ) { return mat22_rcp( a ); } VECMATH_INLINE mat23_t vm_rcp( mat23_t a ) { return mat23_rcp( a ); } VECMATH_INLINE mat24_t vm_rcp( mat24_t a ) { return mat24_rcp( a ); } VECMATH_INLINE mat32_t vm_rcp( mat32_t a ) { return mat32_rcp( a ); } VECMATH_INLINE mat33_t vm_rcp( mat33_t a ) { return mat33_rcp( a ); } VECMATH_INLINE mat34_t vm_rcp( mat34_t a ) { return mat34_rcp( a ); } VECMATH_INLINE mat42_t vm_rcp( mat42_t a ) { return mat42_rcp( a ); } VECMATH_INLINE mat43_t vm_rcp( mat43_t a ) { return mat43_rcp( a ); } VECMATH_INLINE mat44_t vm_rcp( mat44_t a ) { return mat44_rcp( a ); }
    VECMATH_INLINE float vm_reflect( float i, float n ) { return vecmath_reflect( i, n ); } VECMATH_INLINE vec2_t vm_reflect( vec2_t i, vec2_t n ) { return vec2_reflect( i, n ); } VECMATH_INLINE vec3_t vm_reflect( vec3_t i, vec3_t n ) { return vec3_reflect( i, n ); } VECMATH_INLINE vec4_t vm_reflect( vec4_t i, vec4_t n ) { return vec4_reflect( i, n ); }
    VECMATH_INLINE float vm_refract( float i, float n, float r ) { return vecmath_refract( i, n, r ); } VECMATH_INLINE vec2_t vm_refract( vec2_t i, vec2_t n, float r ) { return vec2_refract( i, n, r ); } VECMATH_INLINE vec3_t vm_refract( vec3_t i, vec3_t n, float r ) { return vec3_refract( i, n, r ); } VECMATH_INLINE vec4_t vm_refract( vec4_t i, vec4_t n, float r ) { return vec4_refract( i, n, r ); }
    VECMATH_INLINE float vm_round( float a ) { return vecmath_round( a ); } VECMATH_INLINE vec2_t vm_round( vec2_t a ) { return vec2_round( a ); } VECMATH_INLINE vec3_t vm_round( vec3_t a ) { return vec3_round( a ); } VECMATH_INLINE vec4_t vm_round( vec4_t a ) { return vec4_round( a ); } VECMATH_INLINE mat22_t vm_round( mat22_t a ) { return mat22_round( a ); } VECMATH_INLINE mat23_t vm_round( mat23_t a ) { return mat23_round( a ); } VECMATH_INLINE mat24_t vm_round( mat24_t a ) { return mat24_round( a ); } VECMATH_INLINE mat32_t vm_round( mat32_t a ) { return mat32_round( a ); } VECMATH_INLINE mat33_t vm_round( mat33_t a ) { return mat33_round( a ); } VECMATH_INLINE mat34_t vm_round( mat34_t a ) { return mat34_round( a ); } VECMATH_INLINE mat42_t vm_round( mat42_t a ) { return mat42_round( a ); } VECMATH_INLINE mat43_t vm_round( mat43_t a ) { return mat43_round( a ); } VECMATH_INLINE mat44_t vm_round( mat44_t a ) { return mat44_round( a ); }
    VECMATH_INLINE float vm_rsqrt( float a ) { return vecmath_rsqrt( a ); } VECMATH_INLINE vec2_t vm_rsqrt( vec2_t a ) { return vec2_rsqrt( a ); } VECMATH_INLINE vec3_t vm_rsqrt( vec3_t a ) { return vec3_rsqrt( a ); } VECMATH_INLINE vec4_t vm_rsqrt( vec4_t a ) { return vec4_rsqrt( a ); } VECMATH_INLINE mat22_t vm_rsqrt( mat22_t a ) { return mat22_rsqrt( a ); } VECMATH_INLINE mat23_t vm_rsqrt( mat23_t a ) { return mat23_rsqrt( a ); } VECMATH_INLINE mat24_t vm_rsqrt( mat24_t a ) { return mat24_rsqrt( a ); } VECMATH_INLINE mat32_t vm_rsqrt( mat32_t a ) { return mat32_rsqrt( a ); } VECMATH_INLINE mat33_t vm_rsqrt( mat33_t a ) { return mat33_rsqrt( a ); } VECMATH_INLINE mat34_t vm_rsqrt( mat34_t a ) { return mat34_rsqrt( a ); } VECMATH_INLINE mat42_t vm_rsqrt( mat42_t a ) { return mat42_rsqrt( a ); } VECMATH_INLINE mat43_t vm_rsqrt( mat43_t a ) { return mat43_rsqrt( a ); } VECMATH_INLINE mat44_t vm_rsqrt( mat44_t a ) { return mat44_rsqrt( a ); }
    VECMATH_INLINE float vm_saturate( float a ) { return vecmath_saturate( a ); } VECMATH_INLINE vec2_t vm_saturate( vec2_t a ) { return vec2_saturate( a ); } VECMATH_INLINE vec3_t vm_saturate( vec3_t a ) { return vec3_saturate( a ); } VECMATH_INLINE vec4_t vm_saturate( vec4_t a ) { return vec4_saturate( a ); } VECMATH_INLINE mat22_t vm_saturate( mat22_t a ) { return mat22_saturate( a ); } VECMATH_INLINE mat23_t vm_saturate( mat23_t a ) { return mat23_saturate( a ); } VECMATH_INLINE mat24_t vm_saturate( mat24_t a ) { return mat24_saturate( a ); } VECMATH_INLINE mat32_t vm_saturate( mat32_t a ) { return mat32_saturate( a ); } VECMATH_INLINE mat33_t vm_saturate( mat33_t a ) { return mat33_saturate( a ); } VECMATH_INLINE mat34_t vm_saturate( mat34_t a ) { return mat34_saturate( a ); } VECMATH_INLINE mat42_t vm_saturate( mat42_t a ) { return mat42_saturate( a ); } VECMATH_INLINE mat43_t vm_saturate( mat43_t a ) { return mat43_saturate( a ); } VECMATH_INLINE mat44_t vm_saturate( mat44_t a ) { return mat44_saturate( a ); }
    VECMATH_INLINE float vm_sign( float a ) { return vecmath_sign( a ); } VECMATH_INLINE vec2_t vm_sign( vec2_t a ) { return vec2_sign( a ); } VECMATH_INLINE vec3_t vm_sign( vec3_t a ) { return vec3_sign( a ); } VECMATH_INLINE vec4_t vm_sign( vec4_t a ) { return vec4_sign( a ); } VECMATH_INLINE mat22_t vm_sign( mat22_t a ) { return mat22_sign( a ); } VECMATH_INLINE mat23_t vm_sign( mat23_t a ) { return mat23_sign( a ); } VECMATH_INLINE mat24_t vm_sign( mat24_t a ) { return mat24_sign( a ); } VECMATH_INLINE mat32_t vm_sign( mat32_t a ) { return mat32_sign( a ); } VECMATH_INLINE mat33_t vm_sign( mat33_t a ) { return mat33_sign( a ); } VECMATH_INLINE mat34_t vm_sign( mat34_t a ) { return mat34_sign( a ); } VECMATH_INLINE mat42_t vm_sign( mat42_t a ) { return mat42_sign( a ); } VECMATH_INLINE mat43_t vm_sign( mat43_t a ) { return mat43_sign( a ); } VECMATH_INLINE mat44_t vm_sign( mat44_t a ) { return mat44_sign( a ); }
    VECMATH_INLINE float vm_sin( float a ) { return vecmath_sin( a ); } VECMATH_INLINE vec2_t vm_sin( vec2_t a ) { return vec2_sin( a ); } VECMATH_INLINE vec3_t vm_sin( vec3_t a ) { return vec3_sin( a ); } VECMATH_INLINE vec4_t vm_sin( vec4_t a ) { return vec4_sin( a ); } VECMATH_INLINE mat22_t vm_sin( mat22_t a ) { return mat22_sin( a ); } VECMATH_INLINE mat23_t vm_sin( mat23_t a ) { return mat23_sin( a ); } VECMATH_INLINE mat24_t vm_sin( mat24_t a ) { return mat24_sin( a ); } VECMATH_INLINE mat32_t vm_sin( mat32_t a ) { return mat32_sin( a ); } VECMATH_INLINE mat33_t vm_sin( mat33_t a ) { return mat33_sin( a ); } VECMATH_INLINE mat34_t vm_sin( mat34_t a ) { return mat34_sin( a ); } VECMATH_INLINE mat42_t vm_sin( mat42_t a ) { return mat42_sin( a ); } VECMATH_INLINE mat43_t vm_sin( mat43_t a ) { return mat43_sin( a ); } VECMATH_INLINE mat44_t vm_sin( mat44_t a ) { return mat44_sin( a ); }
    VECMATH_INLINE float vm_sinh( float a ) { return vecmath_sinh( a ); } VECMATH_INLINE vec2_t vm_sinh( vec2_t a ) { return vec2_sinh( a ); } VECMATH_INLINE vec3_t vm_sinh( vec3_t a ) { return vec3_sinh( a ); } VECMATH_INLINE vec4_t vm_sinh( vec4_t a ) { return vec4_sinh( a ); } VECMATH_INLINE mat22_t vm_sinh( mat22_t a ) { return mat22_sinh( a ); } VECMATH_INLINE mat23_t vm_sinh( mat23_t a ) { return mat23_sinh( a ); } VECMATH_INLINE mat24_t vm_sinh( mat24_t a ) { return mat24_sinh( a ); } VECMATH_INLINE mat32_t vm_sinh( mat32_t a ) { return mat32_sinh( a ); } VECMATH_INLINE mat33_t vm_sinh( mat33_t a ) { return mat33_sinh( a ); } VECMATH_INLINE mat34_t vm_sinh( mat34_t a ) { return mat34_sinh( a ); } VECMATH_INLINE mat42_t vm_sinh( mat42_t a ) { return mat42_sinh( a ); } VECMATH_INLINE mat43_t vm_sinh( mat43_t a ) { return mat43_sinh( a ); } VECMATH_INLINE mat44_t vm_sinh( mat44_t a ) { return mat44_sinh( a ); }
    VECMATH_INLINE float vm_smoothstep( float min, float max, float a ) { return vecmath_smoothstep( min, max, a ); } VECMATH_INLINE vec2_t vm_smoothstep( vec2_t min, vec2_t max, vec2_t a ) { return vec2_smoothstep( min, max, a ); } VECMATH_INLINE vec3_t vm_smoothstep( vec3_t min, vec3_t max, vec3_t a ) { return vec3_smoothstep( min, max, a ); } VECMATH_INLINE vec4_t vm_smoothstep( vec4_t min, vec4_t max, vec4_t a ) { return vec4_smoothstep( min, max, a ); } VECMATH_INLINE mat22_t vm_smoothstep( mat22_t min, mat22_t max, mat22_t a ) { return mat22_smoothstep( min, max, a ); } VECMATH_INLINE mat23_t vm_smoothstep( mat23_t min, mat23_t max, mat23_t a ) { return mat23_smoothstep( min, max, a ); } VECMATH_INLINE mat24_t vm_smoothstep( mat24_t min, mat24_t max, mat24_t a ) { return mat24_smoothstep( min, max, a ); } VECMATH_INLINE mat32_t vm_smoothstep( mat32_t min, mat32_t max, mat32_t a ) { return mat32_smoothstep( min, max, a ); } VECMATH_INLINE mat33_t vm_smoothstep( mat33_t min, mat33_t max, mat33_t a ) { return mat33_smoothstep( min, max, a ); } VECMATH_INLINE mat34_t vm_smoothstep( mat34_t min, mat34_t max, mat34_t a ) { return mat34_smoothstep( min, max, a ); } VECMATH_INLINE mat42_t vm_smoothstep( mat42_t min, mat42_t max, mat42_t a ) { return mat42_smoothstep( min, max, a ); } VECMATH_INLINE mat43_t vm_smoothstep( mat43_t min, mat43_t max, mat43_t a ) { return mat43_smoothstep( min, max, a ); } VECMATH_INLINE mat44_t vm_smoothstep( mat44_t min, mat44_t max, mat44_t a ) { return mat44_smoothstep( min, max, a ); }
    VECMATH_INLINE float vm_smootherstep( float min, float max, float a ) { return vecmath_smootherstep( min, max, a ); } VECMATH_INLINE vec2_t vm_smootherstep( vec2_t min, vec2_t max, vec2_t a ) { return vec2_smootherstep( min, max, a ); } VECMATH_INLINE vec3_t vm_smootherstep( vec3_t min, vec3_t max, vec3_t a ) { return vec3_smootherstep( min, max, a ); } VECMATH_INLINE vec4_t vm_smootherstep( vec4_t min, vec4_t max, vec4_t a ) { return vec4_smootherstep( min, max, a ); } VECMATH_INLINE mat22_t vm_smootherstep( mat22_t min, mat22_t max, mat22_t a ) { return mat22_smootherstep( min, max, a ); } VECMATH_INLINE mat23_t vm_smootherstep( mat23_t min, mat23_t max, mat23_t a ) { return mat23_smootherstep( min, max, a ); } VECMATH_INLINE mat24_t vm_smootherstep( mat24_t min, mat24_t max, mat24_t a ) { return mat24_smootherstep( min, max, a ); } VECMATH_INLINE mat32_t vm_smootherstep( mat32_t min, mat32_t max, mat32_t a ) { return mat32_smootherstep( min, max, a ); } VECMATH_INLINE mat33_t vm_smootherstep( mat33_t min, mat33_t max, mat33_t a ) { return mat33_smootherstep( min, max, a ); } VECMATH_INLINE mat34_t vm_smootherstep( mat34_t min, mat34_t max, mat34_t a ) { return mat34_smootherstep( min, max, a ); } VECMATH_INLINE mat42_t vm_smootherstep( mat42_t min, mat42_t max, mat42_t a ) { return mat42_smootherstep( min, max, a ); } VECMATH_INLINE mat43_t vm_smootherstep( mat43_t min, mat43_t max, mat43_t a ) { return mat43_smootherstep( min, max, a ); } VECMATH_INLINE mat44_t vm_smootherstep( mat44_t min, mat44_t max, mat44_t a ) { return mat44_smootherstep( min, max, a ); }
    VECMATH_INLINE float vm_sqrt( float a ) { return vecmath_sqrt( a ); } VECMATH_INLINE vec2_t vm_sqrt( vec2_t a ) { return vec2_sqrt( a ); } VECMATH_INLINE vec3_t vm_sqrt( vec3_t a ) { return vec3_sqrt( a ); } VECMATH_INLINE vec4_t vm_sqrt( vec4_t a ) { return vec4_sqrt( a ); } VECMATH_INLINE mat22_t vm_sqrt( mat22_t a ) { return mat22_sqrt( a ); } VECMATH_INLINE mat23_t vm_sqrt( mat23_t a ) { return mat23_sqrt( a ); } VECMATH_INLINE mat24_t vm_sqrt( mat24_t a ) { return mat24_sqrt( a ); } VECMATH_INLINE mat32_t vm_sqrt( mat32_t a ) { return mat32_sqrt( a ); } VECMATH_INLINE mat33_t vm_sqrt( mat33_t a ) { return mat33_sqrt( a ); } VECMATH_INLINE mat34_t vm_sqrt( mat34_t a ) { return mat34_sqrt( a ); } VECMATH_INLINE mat42_t vm_sqrt( mat42_t a ) { return mat42_sqrt( a ); } VECMATH_INLINE mat43_t vm_sqrt( mat43_t a ) { return mat43_sqrt( a ); } VECMATH_INLINE mat44_t vm_sqrt( mat44_t a ) { return mat44_sqrt( a ); }
    VECMATH_INLINE float vm_step( float a, float b ) { return vecmath_step( a, b ); } VECMATH_INLINE vec2_t vm_step( vec2_t a, vec2_t b ) { return vec2_step( a, b ); } VECMATH_INLINE vec3_t vm_step( vec3_t a, vec3_t b ) { return vec3_step( a, b ); } VECMATH_INLINE vec4_t vm_step( vec4_t a, vec4_t b ) { return vec4_step( a, b ); } VECMATH_INLINE mat22_t vm_step( mat22_t a, mat22_t b ) { return mat22_step( a, b ); } VECMATH_INLINE mat23_t vm_step( mat23_t a, mat23_t b ) { return mat23_step( a, b ); } VECMATH_INLINE mat24_t vm_step( mat24_t a, mat24_t b ) { return mat24_step( a, b ); } VECMATH_INLINE mat32_t vm_step( mat32_t a, mat32_t b ) { return mat32_step( a, b ); } VECMATH_INLINE mat33_t vm_step( mat33_t a, mat33_t b ) { return mat33_step( a, b ); } VECMATH_INLINE mat34_t vm_step( mat34_t a, mat34_t b ) { return mat34_step( a, b ); } VECMATH_INLINE mat42_t vm_step( mat42_t a, mat42_t b ) { return mat42_step( a, b ); } VECMATH_INLINE mat43_t vm_step( mat43_t a, mat43_t b ) { return mat43_step( a, b ); } VECMATH_INLINE mat44_t vm_step( mat44_t a, mat44_t b ) { return mat44_step( a, b ); }
    VECMATH_INLINE float vm_tan( float a ) { return vecmath_tan( a ); } VECMATH_INLINE vec2_t vm_tan( vec2_t a ) { return vec2_tan( a ); } VECMATH_INLINE vec3_t vm_tan( vec3_t a ) { return vec3_tan( a ); } VECMATH_INLINE vec4_t vm_tan( vec4_t a ) { return vec4_tan( a ); } VECMATH_INLINE mat22_t vm_tan( mat22_t a ) { return mat22_tan( a ); } VECMATH_INLINE mat23_t vm_tan( mat23_t a ) { return mat23_tan( a ); } VECMATH_INLINE mat24_t vm_tan( mat24_t a ) { return mat24_tan( a ); } VECMATH_INLINE mat32_t vm_tan( mat32_t a ) { return mat32_tan( a ); } VECMATH_INLINE mat33_t vm_tan( mat33_t a ) { return mat33_tan( a ); } VECMATH_INLINE mat34_t vm_tan( mat34_t a ) { return mat34_tan( a ); } VECMATH_INLINE mat42_t vm_tan( mat42_t a ) { return mat42_tan( a ); } VECMATH_INLINE mat43_t vm_tan( mat43_t a ) { return mat43_tan( a ); } VECMATH_INLINE mat44_t vm_tan( mat44_t a ) { return mat44_tan( a ); }
    VECMATH_INLINE float vm_tanh( float a ) { return vecmath_tanh( a ); } VECMATH_INLINE vec2_t vm_tanh( vec2_t a ) { return vec2_tanh( a ); } VECMATH_INLINE vec3_t vm_tanh( vec3_t a ) { return vec3_tanh( a ); } VECMATH_INLINE vec4_t vm_tanh( vec4_t a ) { return vec4_tanh( a ); } VECMATH_INLINE mat22_t vm_tanh( mat22_t a ) { return mat22_tanh( a ); } VECMATH_INLINE mat23_t vm_tanh( mat23_t a ) { return mat23_tanh( a ); } VECMATH_INLINE mat24_t vm_tanh( mat24_t a ) { return mat24_tanh( a ); } VECMATH_INLINE mat32_t vm_tanh( mat32_t a ) { return mat32_tanh( a ); } VECMATH_INLINE mat33_t vm_tanh( mat33_t a ) { return mat33_tanh( a ); } VECMATH_INLINE mat34_t vm_tanh( mat34_t a ) { return mat34_tanh( a ); } VECMATH_INLINE mat42_t vm_tanh( mat42_t a ) { return mat42_tanh( a ); } VECMATH_INLINE mat43_t vm_tanh( mat43_t a ) { return mat43_tanh( a ); } VECMATH_INLINE mat44_t vm_tanh( mat44_t a ) { return mat44_tanh( a ); }
    VECMATH_INLINE float vm_trunc( float a ) { return vecmath_trunc( a ); } VECMATH_INLINE vec2_t vm_trunc( vec2_t a ) { return vec2_trunc( a ); } VECMATH_INLINE vec3_t vm_trunc( vec3_t a ) { return vec3_trunc( a ); } VECMATH_INLINE vec4_t vm_trunc( vec4_t a ) { return vec4_trunc( a ); } VECMATH_INLINE mat22_t vm_trunc( mat22_t a ) { return mat22_trunc( a ); } VECMATH_INLINE mat23_t vm_trunc( mat23_t a ) { return mat23_trunc( a ); } VECMATH_INLINE mat24_t vm_trunc( mat24_t a ) { return mat24_trunc( a ); } VECMATH_INLINE mat32_t vm_trunc( mat32_t a ) { return mat32_trunc( a ); } VECMATH_INLINE mat33_t vm_trunc( mat33_t a ) { return mat33_trunc( a ); } VECMATH_INLINE mat34_t vm_trunc( mat34_t a ) { return mat34_trunc( a ); } VECMATH_INLINE mat42_t vm_trunc( mat42_t a ) { return mat42_trunc( a ); } VECMATH_INLINE mat43_t vm_trunc( mat43_t a ) { return mat43_trunc( a ); } VECMATH_INLINE mat44_t vm_trunc( mat44_t a ) { return mat44_trunc( a ); }
    VECMATH_INLINE mat22_t vm_transpose( mat22_t a ) { return mat22_transpose( a ); } VECMATH_INLINE mat32_t vm_transpose( mat23_t a ) { return mat23_transpose( a ); } VECMATH_INLINE mat42_t vm_transpose( mat24_t a ) { return mat24_transpose( a ); } VECMATH_INLINE mat23_t vm_transpose( mat32_t a ) { return mat32_transpose( a ); } VECMATH_INLINE mat33_t vm_transpose( mat33_t a ) { return mat33_transpose( a ); } VECMATH_INLINE mat43_t vm_transpose( mat34_t a ) { return mat34_transpose( a ); } VECMATH_INLINE mat24_t vm_transpose( mat42_t a ) { return mat42_transpose( a ); } VECMATH_INLINE mat34_t vm_transpose( mat43_t a ) { return mat43_transpose( a ); } VECMATH_INLINE mat44_t vm_transpose( mat44_t a ) { return mat44_transpose( a ); }
    VECMATH_INLINE float vm_determinant( mat22_t a ) { return mat22_determinant( a ); } VECMATH_INLINE float vm_determinant( mat33_t a ) { return mat33_determinant( a ); } VECMATH_INLINE float vm_determinant( mat44_t a ) { return mat44_determinant( a ); }
#endif /* VECMATH_GENERICS */

#ifdef __cplusplus
    } // namespace vecmath
#endif

#endif /* vecmath_h */


#if defined( VECMATH_GENERICS ) && ( ( defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L ) || defined(__TINYC__) )
    #ifdef VECMATH_GENERICS_NO_PREFIX

        #undef neg 
        #undef eq 
        #undef mul 
        #undef add 
        #undef sub 
        #undef div 
        #undef abs 
        #undef acos 
        #undef all 
        #undef any 
        #undef asin 
        #undef atan 
        #undef atan2 
        #undef ceil 
        #undef clamp 
        #undef cos 
        #undef cosh 
        #undef cross 
        #undef degrees 
        #undef distancesq 
        #undef distance 
        #undef dot 
        #undef exp 
        #undef exp2 
        #undef floor 
        #undef fmod 
        #undef frac 
        #undef lengthsq 
        #undef length 
        #undef lerp 
        #undef log 
        #undef log2 
        #undef log10 
        #undef max 
        #undef min 
        #undef normalize 
        #undef pow 
        #undef radians 
        #undef rcp 
        #undef reflect 
        #undef refract 
        #undef round 
        #undef rsqrt 
        #undef saturate 
        #undef sign 
        #undef sin 
        #undef sinh 
        #undef smoothstep 
        #undef smootherste 
        #undef sqrt 
        #undef step 
        #undef tan 
        #undef tanh 
        #undef trunc 
        #undef transpose 
        #undef determinant 
        #undef inverse 
 
        #define neg vm_neg
        #define eq vm_eq
        #define mul vm_mul
        #define add vm_add
        #define sub vm_sub
        #define div vm_div
        #define abs vm_abs
        #define acos vm_acos
        #define all vm_all
        #define any vm_any
        #define asin vm_asin
        #define atan vm_atan
        #define atan2 vm_atan2
        #define ceil vm_ceil
        #define clamp vm_clamp
        #define cos vm_cos
        #define cosh vm_cosh
        #define cross vm_cross
        #define degrees vm_degrees
        #define distancesq vm_distancesq
        #define distance vm_distance
        #define dot vm_dot
        #define exp vm_exp
        #define exp2 vm_exp2
        #define floor vm_floor
        #define fmod vm_fmod
        #define frac vm_frac
        #define lengthsq vm_lengthsq
        #define length vm_length
        #define lerp vm_lerp
        #define log vm_log
        #define log2 vm_log2
        #define log10 vm_log10
        #define max vm_max
        #define min vm_min
        #define normalize vm_normalize
        #define pow vm_pow
        #define radians vm_radians
        #define rcp vm_rcp
        #define reflect vm_reflect
        #define refract vm_refract
        #define round vm_round
        #define rsqrt vm_rsqrt
        #define saturate vm_saturate
        #define sign vm_sign
        #define sin vm_sin
        #define sinh vm_sinh
        #define smoothstep vm_smoothstep
        #define smootherste vm_smootherstep
        #define sqrt vm_sqrt
        #define step vm_step
        #define tan vm_tan
        #define tanh vm_tanh
        #define trunc vm_trunc
        #define transpose vm_transpose
        #define determinant vm_determinant
 
    #endif /* VECMATH_GENERICS_NO_PREFIX */
#endif /* VECMATH_GENERICS */


/*
-------------
 TESTS
-------------

To build and run the test suite, compile it like this:
    
    cl /Tc vecmath.h /DVECMATH_RUN_TESTS

and then simply run this from the commandline: 

    vecmath.exe

For more extensive tests, like memory leaks of access violations, you can use the 
testfw.h test framework by placing it in the same directory as vecmath.h, and 
defining the VECMATH_USE_EXTERNAL_TESTFW when building

    cl /Tc vecmath.h /DVECMATH_RUN_TESTS /D VECMATH_USE_EXTERNAL_TESTFW /MTd

Note that to get correct memory leak reporting, you must specify /MTd to use the
debug memory allocation system in MSVC.

You can find testfw.h here:

    https://github.com/mattiasgustavsson/libs/blob/main/testfw.h

*/


#ifdef VECMATH_RUN_TESTS

#ifdef VECMATH_USE_EXTERNAL_TESTFW
    #include "testfw.h"
#else
    #pragma warning( push )
    #pragma warning( disable: 4710 ) // function not inlined
    #include <stdio.h>
    #pragma warning( pop )

    char const* g_testfw_desc = NULL; int g_testfw_line = 0, g_testfw_current_test_failed = 0, g_testfw_tests_count = 0, g_testfw_asserts_count = 0, g_testfw_tests_failed = 0, g_testfw_asserts_failed = 0;
    #define TESTFW_INIT() g_testfw_desc = NULL; g_testfw_line = 0; g_testfw_current_test_failed = 0; g_testfw_tests_count = 0; g_testfw_asserts_count = 0; g_testfw_tests_failed = 0; g_testfw_asserts_failed = 0;
    #define TESTFW_SUMMARY() \
        ( ( g_testfw_tests_failed == 0 ) ? printf( "\n===============================================================================\nAll tests passed (%d assertions in %d test cases)\n", g_testfw_asserts_count, g_testfw_tests_count ) : \
        ( printf( "\n===============================================================================\ntest cases: %4d | %4d passed | %4d failed\n",  g_testfw_tests_count, g_testfw_tests_count - g_testfw_tests_failed, g_testfw_tests_failed ),\
        printf( "assertions: %4d | %4d passed | %4d failed\n",  g_testfw_asserts_count, g_testfw_asserts_count - g_testfw_asserts_failed, g_testfw_asserts_failed ) ), g_testfw_tests_failed != 0 )
    #define TESTFW_TEST_BEGIN( desc ) { ++g_testfw_tests_count; g_testfw_desc = (desc); g_testfw_line = __LINE__; g_testfw_current_test_failed = 0;
    #define TESTFW_TEST_END() if( g_testfw_current_test_failed ) { ++g_testfw_tests_failed; } } g_testfw_desc = NULL; g_testfw_line = 0;
    #define TESTFW_EXPECTED( expression ) \
        ++g_testfw_asserts_count; if( !(expression) ) { ++g_testfw_asserts_failed; g_testfw_current_test_failed = 1; if( g_testfw_desc )  {  printf( "\n-------------------------------------------------------------------------------\n" ); \
        printf( "%s\n", g_testfw_desc );  printf( "-------------------------------------------------------------------------------\n" ); printf( "%s(%d): %s\n", __FILE__, g_testfw_line, __func__ ); \
        printf( "...............................................................................\n" ); g_testfw_desc = NULL; }  printf( "\n%s(%d): FAILED:\n", __FILE__, __LINE__ );  printf( "\n  TESTFW_EXPECTED( %s )\n", #expression ); }  
#endif

#include <float.h>
#include <math.h>

#ifdef __cplusplus
    using namespace vecmath;
#endif


int test_cmp( float a, float b ) { return a > b - 0.00001f && a < b + 0.00001f; }

int test_identity_mat22( mat22_t m ) {
    return
        test_cmp( m.x.x, 1.0f ) && test_cmp( m.x.y, 0.0f ) &&
        test_cmp( m.y.x, 0.0f ) && test_cmp( m.y.y, 1.0f );
}

int test_identity_mat33( mat33_t m ) {
    return
        test_cmp( m.x.x, 1.0f ) && test_cmp( m.x.y, 0.0f ) && test_cmp( m.x.z, 0.0f ) &&
        test_cmp( m.y.x, 0.0f ) && test_cmp( m.y.y, 1.0f ) && test_cmp( m.y.z, 0.0f ) &&
        test_cmp( m.z.x, 0.0f ) && test_cmp( m.z.y, 0.0f ) && test_cmp( m.z.z, 1.0f );
}

int test_identity_mat44( mat44_t m ) {
    return
        ( m.x.x > 1.0f - 0.0001f && m.x.x < 1.0f + 0.0001f ) && ( m.x.y > -0.0001f && m.x.y < 0.0001f ) && ( m.x.z > -0.0001f && m.x.z < 0.0001f ) && ( m.x.w > -0.0001f && m.x.w < 0.0001f ) &&
        ( m.y.x > -0.0001f && m.y.x < 0.0001f ) && ( m.y.y > 1.0f - 0.0001f && m.y.y < 1.0f + 0.0001f ) && ( m.y.z > -0.0001f && m.y.z < 0.0001f ) && ( m.y.w > -0.0001f && m.y.w < 0.0001f ) &&
        ( m.z.x > -0.0001f && m.z.x < 0.0001f ) && ( m.z.y > -0.0001f && m.z.y < 0.0001f ) && ( m.z.z > 1.0f - 0.0001f && m.z.z < 1.0f + 0.0001f ) && ( m.z.w > -0.0001f && m.z.w < 0.0001f ) &&
        ( m.w.x > -0.0001f && m.w.x < 0.0001f ) && ( m.w.y > -0.0001f && m.w.y < 0.0001f ) && ( m.w.z > -0.0001f && m.w.z < 0.0001f ) && ( m.w.w > 1.0f - 0.0001f && m.w.w < 1.0f + 0.0001f );
}


void test_scalar_math( void ) {
    // vecmath_abs
    TESTFW_TEST_BEGIN( "vecmath_abs returns input unchanged for non-negative values" )
        TESTFW_EXPECTED( vecmath_abs( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_abs( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_abs( 123.456f ) == 123.456f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_abs returns negated value for negative input" )
        TESTFW_EXPECTED( vecmath_abs( -1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_abs( -123.456f ) == 123.456f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_abs returns positive zero for negative zero" )
        TESTFW_EXPECTED( 1.0f / vecmath_abs( -0.0f ) == INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_abs preserves infinity" )
        TESTFW_EXPECTED( vecmath_abs( INFINITY ) == INFINITY );
        TESTFW_EXPECTED( vecmath_abs( -INFINITY ) == INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_abs propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_abs( NAN ) ) );
    TESTFW_TEST_END();
    
    // vecmath_acos
    TESTFW_TEST_BEGIN( "vecmath_acos returns correct values for canonical inputs" )
        TESTFW_EXPECTED( vecmath_acos( 1.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_acos( 0.0f ) == 1.57079633f );
        TESTFW_EXPECTED( test_cmp( vecmath_acos( -1.0f ), 3.14159265f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_acos returns values in [0, pi] for valid domain" )
        TESTFW_EXPECTED( vecmath_acos( 0.5f ) > 0.0f );
        TESTFW_EXPECTED( vecmath_acos( 0.5f ) < 3.14159265f );
        TESTFW_EXPECTED( vecmath_acos( -0.5f ) > 0.0f );
        TESTFW_EXPECTED( vecmath_acos( -0.5f ) < 3.14159265f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_acos returns NaN for inputs outside [-1, 1]" )
        TESTFW_EXPECTED( isnan( vecmath_acos( 1.0001f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_acos( -1.0001f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_acos( 2.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_acos( -2.0f ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_acos propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_acos( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_all
    TESTFW_TEST_BEGIN( "vecmath_all" )
        TESTFW_EXPECTED( vecmath_all( 0.0f ) == 0 );
        TESTFW_EXPECTED( vecmath_all( -0.0f ) == 0 );
        TESTFW_EXPECTED( vecmath_all( 1e-30f ) != 0 );
        TESTFW_EXPECTED( vecmath_all( -1e-30f ) != 0 );
        TESTFW_EXPECTED( vecmath_all( 1.0f ) != 0 );
        TESTFW_EXPECTED( vecmath_all( -1.0f ) != 0 );
    
        TESTFW_EXPECTED( vecmath_all( NAN ) != 0 );
        TESTFW_EXPECTED( vecmath_all( INFINITY ) != 0 );
        TESTFW_EXPECTED( vecmath_all( -INFINITY ) != 0 );
    TESTFW_TEST_END();

    // vecmath_any
    TESTFW_TEST_BEGIN( "vecmath_any" )
        TESTFW_EXPECTED( vecmath_any( 0.0f ) == 0 );
        TESTFW_EXPECTED( vecmath_any( -0.0f ) == 0 );
        TESTFW_EXPECTED( vecmath_any( 1e-30f ) != 0 );
        TESTFW_EXPECTED( vecmath_any( -1e-30f ) != 0 );
        TESTFW_EXPECTED( vecmath_any( 1.0f ) != 0 );
        TESTFW_EXPECTED( vecmath_any( -1.0f ) != 0 );
        
        TESTFW_EXPECTED( vecmath_any( NAN ) != 0 );
        TESTFW_EXPECTED( vecmath_any( INFINITY ) != 0 );
        TESTFW_EXPECTED( vecmath_any( -INFINITY ) != 0 );
    TESTFW_TEST_END();

    // vecmath_asin
    TESTFW_TEST_BEGIN( "vecmath_asin returns correct values for canonical inputs" )
        TESTFW_EXPECTED( vecmath_asin( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( test_cmp( vecmath_asin( 1.0f ), 1.57079633f ) );
        TESTFW_EXPECTED( test_cmp( vecmath_asin( -1.0f ), -1.57079633f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_asin returns values in [-pi/2, pi/2] for valid domain" )
        TESTFW_EXPECTED( vecmath_asin( 0.5f ) > 0.0f );
        TESTFW_EXPECTED( vecmath_asin( 0.5f ) < 1.57079633f );
        TESTFW_EXPECTED( vecmath_asin( -0.5f ) < 0.0f );
        TESTFW_EXPECTED( vecmath_asin( -0.5f ) > -1.57079633f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_asin returns NaN for inputs outside [-1, 1]" )
        TESTFW_EXPECTED( isnan( vecmath_asin( 1.0001f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_asin( -1.0001f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_asin( 2.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_asin( -2.0f ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_asin propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_asin( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_atan
    TESTFW_TEST_BEGIN( "vecmath_atan returns zero for zero input" )
        TESTFW_EXPECTED( vecmath_atan( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_atan( -0.0f ) == -0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_atan returns expected values for canonical inputs" )
        TESTFW_EXPECTED( vecmath_atan( 1.0f ) == 0.78539816f );
        TESTFW_EXPECTED( vecmath_atan( -1.0f ) == -0.78539816f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_atan returns values in (-pi/2, pi/2) for finite inputs" )
        TESTFW_EXPECTED( vecmath_atan( 10.0f ) > 1.0f );
        TESTFW_EXPECTED( vecmath_atan( -10.0f ) < -1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_atan propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_atan( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_atan2
    TESTFW_TEST_BEGIN( "vecmath_atan2 returns expected values for axes-aligned vectors" )
        TESTFW_EXPECTED( test_cmp( vecmath_atan2( 0.0f, 1.0f ), 0.0f ) );
        TESTFW_EXPECTED( test_cmp( vecmath_atan2( 1.0f, 0.0f ), 1.57079633f ) );
        TESTFW_EXPECTED( test_cmp( vecmath_atan2( 0.0f, -1.0f ), 3.14159265f ) );
        TESTFW_EXPECTED( test_cmp( vecmath_atan2( -1.0f, 0.0f ), -1.57079633f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_atan2 returns expected values in all quadrants" )
        TESTFW_EXPECTED( vecmath_atan2( 1.0f, 1.0f ) == 0.78539816f );
        TESTFW_EXPECTED( vecmath_atan2( 1.0f, -1.0f ) == 2.35619449f );
        TESTFW_EXPECTED( vecmath_atan2( -1.0f, -1.0f ) == -2.35619449f );
        TESTFW_EXPECTED( vecmath_atan2( -1.0f, 1.0f ) == -0.78539816f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_atan2 handles zero numerator and denominator" )
        TESTFW_EXPECTED( vecmath_atan2( 0.0f, 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_atan2( -0.0f, 0.0f ) == -0.0f );
        TESTFW_EXPECTED( test_cmp( vecmath_atan2( 0.0f, -0.0f ), 3.14159265f ) );
        TESTFW_EXPECTED( test_cmp( vecmath_atan2( -0.0f, -0.0f ), -3.14159265f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_atan2 handles infinities" )
        TESTFW_EXPECTED( test_cmp( vecmath_atan2( INFINITY, 1.0f ), 1.57079633f ) );
        #ifndef __TINYC__ /* For some reason, tcc does not handle this infinity case properly */
        TESTFW_EXPECTED( test_cmp( vecmath_atan2( -INFINITY, 1.0f ), -1.57079633f ) );
        #endif
        TESTFW_EXPECTED( vecmath_atan2( 1.0f, INFINITY ) == 0.0f );
        TESTFW_EXPECTED( test_cmp( vecmath_atan2( 1.0f, -INFINITY ), 3.14159265f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_atan2 propagates NaN when any input is NaN" )
        TESTFW_EXPECTED( isnan( vecmath_atan2( NAN, 1.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_atan2( 1.0f, NAN ) ) );
        TESTFW_EXPECTED( isnan( vecmath_atan2( NAN, NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_ceil
    TESTFW_TEST_BEGIN( "vecmath_ceil returns input unchanged for exact integers" )
        TESTFW_EXPECTED( vecmath_ceil( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_ceil( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_ceil( -1.0f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_ceil( 42.0f ) == 42.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_ceil rounds up positive values with fractional part" )
        TESTFW_EXPECTED( vecmath_ceil( 0.1f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_ceil( 0.5f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_ceil( 0.9f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_ceil( 1.1f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_ceil( 1.9f ) == 2.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_ceil rounds toward zero for negative values with fractional part" )
        TESTFW_EXPECTED( vecmath_ceil( -0.1f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_ceil( -0.5f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_ceil( -0.9f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_ceil( -1.1f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_ceil( -1.9f ) == -1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_ceil returns input unchanged for infinity" )
        TESTFW_EXPECTED( vecmath_ceil( INFINITY ) == INFINITY );
        TESTFW_EXPECTED( vecmath_ceil( -INFINITY ) == -INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_ceil returns NaN when input is NaN" )
        TESTFW_EXPECTED( isnan( vecmath_ceil( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_clamp
    TESTFW_TEST_BEGIN( "vecmath_clamp positive range" )
        TESTFW_EXPECTED( vecmath_clamp( -1.0f, 0.0f, 1.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_clamp( 0.0f, 0.0f, 1.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_clamp( 0.5f, 0.0f, 1.0f ) == 0.5f );
        TESTFW_EXPECTED( vecmath_clamp( 1.0f, 0.0f, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_clamp( 2.0f, 0.0f, 1.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_clamp negative range" )
        TESTFW_EXPECTED( vecmath_clamp( -5.0f, -10.0f, -1.0f ) == -5.0f );
        TESTFW_EXPECTED( vecmath_clamp( -15.0f, -10.0f, -1.0f ) == -10.0f );
        TESTFW_EXPECTED( vecmath_clamp( 0.0f, -10.0f, -1.0f ) == -1.0f );
    TESTFW_TEST_END();
        
    TESTFW_TEST_BEGIN( "vecmath_clamp handles very large and very small values" )
        TESTFW_EXPECTED( vecmath_clamp( -1e30f, 0.0f, 1e30f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_clamp( 1e30f, 0.0f, 1e30f ) == 1e30f );
        TESTFW_EXPECTED( vecmath_clamp( 1e-30f, 0.0f, 1e-10f ) == 1e-30f );
        TESTFW_EXPECTED( vecmath_clamp( 1e-20f, 0.0f, 1e-30f ) == 1e-30f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_clamp returns NaN correctly" )
        TESTFW_EXPECTED( isnan( vecmath_clamp( NAN, 0.0f, 1.0f ) ) );
        TESTFW_EXPECTED( vecmath_clamp( 0.5f, NAN, 1.0f ) == 0.5f );
        TESTFW_EXPECTED( vecmath_clamp( 0.5f, 0.0f, NAN ) == 0.5f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_clamp clamps infinity values" )
        TESTFW_EXPECTED( vecmath_clamp( INFINITY, 0.0f, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_clamp( -INFINITY, 0.0f, 1.0f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_clamp preserves zero sign" )
        TESTFW_EXPECTED( 1.0f / vecmath_clamp( 0.0f, -1.0f, 1.0f ) == INFINITY );
        TESTFW_EXPECTED( 1.0f / vecmath_clamp( -0.0f, -1.0f, 1.0f ) == -INFINITY );
    TESTFW_TEST_END();

    // vecmath_cos
    TESTFW_TEST_BEGIN( "vecmath_cos returns correct values at canonical angles" )
        TESTFW_EXPECTED( vecmath_cos( 0.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_cos( 3.14159265f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_cos( 1.57079633f ) < 1e-7f );
        TESTFW_EXPECTED( vecmath_cos( -1.57079633f ) < 1e-7f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_cos is even function" )
        TESTFW_EXPECTED( vecmath_cos( 0.5f ) == vecmath_cos( -0.5f ) );
        TESTFW_EXPECTED( vecmath_cos( 2.0f ) == vecmath_cos( -2.0f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_cos returns values in [-1, 1]" )
        TESTFW_EXPECTED( vecmath_cos( 0.25f ) <= 1.0f );
        TESTFW_EXPECTED( vecmath_cos( 0.25f ) >= -1.0f );
        TESTFW_EXPECTED( vecmath_cos( 10.0f ) <= 1.0f );
        TESTFW_EXPECTED( vecmath_cos( 10.0f ) >= -1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_cos propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_cos( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_cosh
    TESTFW_TEST_BEGIN( "vecmath_cosh returns 1 for zero input" )
        TESTFW_EXPECTED( vecmath_cosh( 0.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_cosh( -0.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_cosh is even function" )
        TESTFW_EXPECTED( vecmath_cosh( 1.0f ) == vecmath_cosh( -1.0f ) );
        TESTFW_EXPECTED( vecmath_cosh( 5.0f ) == vecmath_cosh( -5.0f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_cosh returns expected values for known inputs" )
        TESTFW_EXPECTED( test_cmp( vecmath_cosh( 1.0f ), 1.54308063f ));
        TESTFW_EXPECTED( test_cmp( vecmath_cosh( -1.0f ), 1.54308063f ));
        TESTFW_EXPECTED( test_cmp( vecmath_cosh( 2.0f ), 3.76219559f ));
        TESTFW_EXPECTED( test_cmp( vecmath_cosh( -2.0f ), 3.76219559f ));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_cosh handles infinity" )
        TESTFW_EXPECTED( vecmath_cosh( INFINITY ) == INFINITY );
        TESTFW_EXPECTED( vecmath_cosh( -INFINITY ) == INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_cosh propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_cosh( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_degrees
    TESTFW_TEST_BEGIN( "vecmath_degrees zero and multiples of pi" )
        TESTFW_EXPECTED( vecmath_degrees( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_degrees( 3.14159265f ) == 180.0f );
        TESTFW_EXPECTED( vecmath_degrees( 1.57079633f ) == 90.0f );
        TESTFW_EXPECTED( vecmath_degrees( -3.14159265f ) == -180.0f );
        TESTFW_EXPECTED( vecmath_degrees( -1.57079633f ) == -90.0f );
        TESTFW_EXPECTED( vecmath_degrees( 6.28318530f ) == 360.0f );
        TESTFW_EXPECTED( vecmath_degrees( 0.78539816f ) == 45.0f );
        TESTFW_EXPECTED( vecmath_degrees( 4.71238898f ) == 270.0f );
        TESTFW_EXPECTED( vecmath_degrees( -6.28318530f ) == -360.0f );
        TESTFW_EXPECTED( vecmath_degrees( -0.78539816f ) == -45.0f );
        TESTFW_EXPECTED( vecmath_degrees( -4.71238898f ) == -270.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_degrees preservs sign for tiny values" )
        TESTFW_EXPECTED( vecmath_degrees( 1e-30f ) > 0.0f );
        TESTFW_EXPECTED( vecmath_degrees( -1e-30f ) < 0.0f );
    TESTFW_TEST_END();

    // vecmath_distancesq
    TESTFW_TEST_BEGIN( "vecmath_distancesq returns squared difference" )
        TESTFW_EXPECTED( vecmath_distancesq( 0.0f, 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_distancesq( 1.0f, 0.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_distancesq( 0.0f, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_distancesq( 2.0f, -2.0f ) == 16.0f );
        TESTFW_EXPECTED( vecmath_distancesq( -3.0f, 3.0f ) == 36.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_distancesq handles very large and very small values" )
        TESTFW_EXPECTED( vecmath_distancesq( 1e-22f, 0.0f ) == 1e-44f );
        TESTFW_EXPECTED( vecmath_distancesq( 0.0f, 1e-22f ) == 1e-44f );
        TESTFW_EXPECTED( vecmath_distancesq( -1e-22f, 0.0f ) == 1e-44f );
        TESTFW_EXPECTED( vecmath_distancesq( 0.0f, -1e-22f ) == 1e-44f );
        TESTFW_EXPECTED( vecmath_distancesq( 1e19f, 0.0f ) == 1e38f );
        TESTFW_EXPECTED( vecmath_distancesq( 0.0f, 1e19f ) == 1e38f );
        TESTFW_EXPECTED( vecmath_distancesq( -1e19f, 0.0f ) == 1e38f );
        TESTFW_EXPECTED( vecmath_distancesq( 0.0f, -1e19f ) == 1e38f );
    TESTFW_TEST_END();

    // vecmath_distance 
    TESTFW_TEST_BEGIN( "vecmath_distance returns absolute difference" )
        TESTFW_EXPECTED( vecmath_distance( 0.0f, 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_distance( 1.0f, 0.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_distance( 0.0f, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_distance( 2.0f, -2.0f ) == 4.0f );
        TESTFW_EXPECTED( vecmath_distance( -3.0f, 3.0f ) == 6.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_distance handles very large and very small values" )
        TESTFW_EXPECTED( vecmath_distance( 1e-19f, 0.0f ) == 1e-19f );
        TESTFW_EXPECTED( vecmath_distance( 0.0f, 1e-19f ) == 1e-19f );
        TESTFW_EXPECTED( vecmath_distance( -1e-19f, 0.0f ) == 1e-19f );
        TESTFW_EXPECTED( vecmath_distance( 0.0f, -1e-19f ) == 1e-19f );
        TESTFW_EXPECTED( vecmath_distance( 1e19f, 0.0f ) == 1e19f );
        TESTFW_EXPECTED( vecmath_distance( 0.0f, 1e19f ) == 1e19f );
        TESTFW_EXPECTED( vecmath_distance( -1e19f, 0.0f ) == 1e19f );
        TESTFW_EXPECTED( vecmath_distance( 0.0f, -1e19f ) == 1e19f );
    TESTFW_TEST_END();

    // vecmath_dot
    TESTFW_TEST_BEGIN( "vecmath_dot returns product of inputs" )
        TESTFW_EXPECTED( vecmath_dot( 0.0f, 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_dot( 1.0f, 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_dot( 0.0f, 1.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_dot( 2.0f, 3.0f ) == 6.0f );
        TESTFW_EXPECTED( vecmath_dot( -2.0f, 3.0f ) == -6.0f );
        TESTFW_EXPECTED( vecmath_dot( -2.0f, -3.0f ) == 6.0f );
    TESTFW_TEST_END();

    // vecmath_exp
    TESTFW_TEST_BEGIN( "vecmath_exp returns 1 at zero" )
        TESTFW_EXPECTED( vecmath_exp( 0.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_exp( -0.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_exp returns e^x for positive inputs" )
        TESTFW_EXPECTED( vecmath_exp( 1.0f ) > 2.71f );
        TESTFW_EXPECTED( vecmath_exp( 1.0f ) < 2.72f );
        TESTFW_EXPECTED( vecmath_exp( 2.0f ) > 7.38f );
        TESTFW_EXPECTED( vecmath_exp( 2.0f ) < 7.39f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_exp returns value in (0, 1) for negative inputs" )
        TESTFW_EXPECTED( vecmath_exp( -1.0f ) > 0.36f );
        TESTFW_EXPECTED( vecmath_exp( -1.0f ) < 0.37f );
        TESTFW_EXPECTED( vecmath_exp( -2.0f ) > 0.13f );
        TESTFW_EXPECTED( vecmath_exp( -2.0f ) < 0.14f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_exp returns infinity for +infinity input" )
        TESTFW_EXPECTED( vecmath_exp( INFINITY ) == INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_exp returns zero for -infinity input" )
        TESTFW_EXPECTED( vecmath_exp( -INFINITY ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_exp propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_exp( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_exp2
    TESTFW_TEST_BEGIN( "vecmath_exp2 returns powers of two for integer inputs" )
        TESTFW_EXPECTED( vecmath_exp2( 0.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_exp2( 1.0f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_exp2( 2.0f ) == 4.0f );
        TESTFW_EXPECTED( vecmath_exp2( -1.0f ) == 0.5f );
        TESTFW_EXPECTED( vecmath_exp2( -2.0f ) == 0.25f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_exp2 returns 2^x for fractional inputs" )
        TESTFW_EXPECTED( vecmath_exp2( 0.5f ) > 1.4142f );
        TESTFW_EXPECTED( vecmath_exp2( 0.5f ) < 1.4143f );
        TESTFW_EXPECTED( vecmath_exp2( -0.5f ) > 0.7071f );
        TESTFW_EXPECTED( vecmath_exp2( -0.5f ) < 0.7072f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_exp2 returns infinity for +infinity input" )
        TESTFW_EXPECTED( vecmath_exp2( INFINITY ) == INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_exp2 returns zero for -infinity input" )
        TESTFW_EXPECTED( vecmath_exp2( -INFINITY ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_exp2 propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_exp2( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_floor
    TESTFW_TEST_BEGIN( "vecmath_floor returns input unchanged for exact integers" )
        TESTFW_EXPECTED( vecmath_floor( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_floor( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_floor( -1.0f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_floor( 42.0f ) == 42.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_floor rounds down positive values with fractional part" )
        TESTFW_EXPECTED( vecmath_floor( 0.1f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_floor( 0.5f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_floor( 0.9f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_floor( 1.1f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_floor( 1.9f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_floor rounds away from zero for negative values with fractional part" )
        TESTFW_EXPECTED( vecmath_floor( -0.1f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_floor( -0.5f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_floor( -0.9f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_floor( -1.1f ) == -2.0f );
        TESTFW_EXPECTED( vecmath_floor( -1.9f ) == -2.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_floor returns input unchanged for infinity" )
        TESTFW_EXPECTED( vecmath_floor( INFINITY ) == INFINITY );
        TESTFW_EXPECTED( vecmath_floor( -INFINITY ) == -INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_floor returns NaN when input is NaN" )
        TESTFW_EXPECTED( isnan( vecmath_floor( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_fmod
    TESTFW_TEST_BEGIN( "vecmath_fmod returns remainder of division for positive values" )
        TESTFW_EXPECTED( vecmath_fmod( 5.25f, 2.0f ) == 1.25f );
        TESTFW_EXPECTED( vecmath_fmod( 9.5f, 4.5f ) == 0.5f );
        TESTFW_EXPECTED( vecmath_fmod( 7.5f, 3.75f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_fmod returns remainder with correct sign for negative numerators" )
        TESTFW_EXPECTED( vecmath_fmod( -5.25f, 2.0f ) == -1.25f );
        TESTFW_EXPECTED( vecmath_fmod( -9.5f, 4.5f ) == -0.5f );
        TESTFW_EXPECTED( vecmath_fmod( -7.5f, 3.75f ) == -0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_fmod returns remainder with sign of numerator when denominator is negative" )
        TESTFW_EXPECTED( vecmath_fmod( 5.25f, -2.0f ) == 1.25f );
        TESTFW_EXPECTED( vecmath_fmod( -5.25f, -2.0f ) == -1.25f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_fmod returns zero when numerator is zero" )
        TESTFW_EXPECTED( vecmath_fmod( 0.0f, 3.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_fmod( -0.0f, 3.0f ) == -0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_fmod returns NaN when denominator is zero" )
        TESTFW_EXPECTED( isnan( vecmath_fmod( 1.0f, 0.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_fmod( -1.0f, 0.0f ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_fmod propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_fmod( NAN, 1.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_fmod( 1.0f, NAN ) ) );
        TESTFW_EXPECTED( isnan( vecmath_fmod( NAN, NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_frac
    TESTFW_TEST_BEGIN( "vecmath_frac returns positive fractional part in [0,1)" )
        TESTFW_EXPECTED( vecmath_frac( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_frac( 1.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_frac( 2.75f ) == 0.75f );
        TESTFW_EXPECTED( vecmath_frac( 1234.5678f ) > 0.0f );
        TESTFW_EXPECTED( vecmath_frac( 1234.5678f ) < 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_frac strips sign of fractional part" )
        TESTFW_EXPECTED( vecmath_frac( -1.5f ) == 0.5f );
        TESTFW_EXPECTED( vecmath_frac( -1.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_frac( -1234.5678f ) > 0.0f );
        TESTFW_EXPECTED( vecmath_frac( -1234.5678f ) < 1.0f );
    TESTFW_TEST_END();

    // vecmath_lengthsq
    TESTFW_TEST_BEGIN( "vecmath_lengthsq returns squared value" )
        TESTFW_EXPECTED( vecmath_lengthsq( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_lengthsq( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_lengthsq( 2.0f ) == 4.0f );
        TESTFW_EXPECTED( vecmath_lengthsq( -2.0f ) == 4.0f );
        TESTFW_EXPECTED( vecmath_lengthsq( 0.5f ) == 0.25f );
        TESTFW_EXPECTED( vecmath_lengthsq( -0.5f ) == 0.25f );
    TESTFW_TEST_END();

    // vecmath_length
    TESTFW_TEST_BEGIN( "vecmath_length returns absolute value" )
        TESTFW_EXPECTED( vecmath_length( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_length( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_length( 2.0f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_length( -2.0f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_length( 0.5f ) == 0.5f );
        TESTFW_EXPECTED( vecmath_length( -0.5f ) == 0.5f );
    TESTFW_TEST_END();

    // vecmath_lerp
    TESTFW_TEST_BEGIN( "vecmath_lerp returns a at t = 0" )
        TESTFW_EXPECTED( vecmath_lerp( 1.0f, 3.0f, 0.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_lerp( -5.0f, 5.0f, 0.0f ) == -5.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_lerp returns b at t = 1" )
        TESTFW_EXPECTED( vecmath_lerp( 1.0f, 3.0f, 1.0f ) == 3.0f );
        TESTFW_EXPECTED( vecmath_lerp( -5.0f, 5.0f, 1.0f ) == 5.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_lerp returns midpoint at t = 0.5" )
        TESTFW_EXPECTED( vecmath_lerp( 1.0f, 3.0f, 0.5f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_lerp( -5.0f, 5.0f, 0.5f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_lerp( -2.0f, -6.0f, 0.5f ) == -4.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_lerp handles t < 0 and t > 1" )
        TESTFW_EXPECTED( vecmath_lerp( 1.0f, 3.0f, -1.0f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_lerp( 1.0f, 3.0f, 2.0f ) == 5.0f );
    TESTFW_TEST_END();

    // vecmath_log
    TESTFW_TEST_BEGIN( "vecmath_log returns 0 for input 1" )
        TESTFW_EXPECTED( vecmath_log( 1.0f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log returns ln(x) for valid inputs" )
        TESTFW_EXPECTED( vecmath_log( 2.71828183f ) > 0.999f );
        TESTFW_EXPECTED( vecmath_log( 2.71828183f ) < 1.001f );
        TESTFW_EXPECTED( vecmath_log( 7.38905610f ) > 1.999f );
        TESTFW_EXPECTED( vecmath_log( 7.38905610f ) < 2.001f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log returns negative for values in (0,1)" )
        TESTFW_EXPECTED( vecmath_log( 0.5f ) < 0.0f );
        TESTFW_EXPECTED( vecmath_log( 0.5f ) > -1.0f );
        TESTFW_EXPECTED( vecmath_log( 0.1f ) < -2.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log returns -infinity for zero input" )
        #ifndef __wasm__ /* For some reason, wasm does not handle this infinity case properly */
        TESTFW_EXPECTED( vecmath_log( 0.0f ) == -INFINITY );
        #endif
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log returns NaN for negative input" )
        #ifndef __wasm__ /* For some reason, wasm does not handle these cases properly */
        TESTFW_EXPECTED( isnan( vecmath_log( -1.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_log( -INFINITY ) ) );
        #endif
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log propagates NaN" )
        #ifndef __wasm__ /* For some reason, wasm does not handle this case properly */
        TESTFW_EXPECTED( isnan( vecmath_log( NAN ) ) );
        #endif
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log returns infinity for +infinity input" )
        #ifndef __wasm__ /* For some reason, wasm does not handle this infinity case properly */
        TESTFW_EXPECTED( vecmath_log( INFINITY ) == INFINITY );
        #endif
    TESTFW_TEST_END();

    // vecmath_log2
    TESTFW_TEST_BEGIN( "vecmath_log2 returns 0 for input 1" )
        TESTFW_EXPECTED( vecmath_log2( 1.0f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log2 returns log base 2 for powers of two" )
        TESTFW_EXPECTED( vecmath_log2( 2.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_log2( 4.0f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_log2( 8.0f ) == 3.0f );
        TESTFW_EXPECTED( vecmath_log2( 16.0f ) == 4.0f );
        TESTFW_EXPECTED( vecmath_log2( 0.5f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_log2( 0.25f ) == -2.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log2 returns -infinity for zero input" )
        TESTFW_EXPECTED( vecmath_log2( 0.0f ) == -INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log2 returns NaN for negative input" )
        TESTFW_EXPECTED( isnan( vecmath_log2( -1.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_log2( -INFINITY ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log2 propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_log2( NAN ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log2 returns infinity for +infinity input" )
        TESTFW_EXPECTED( vecmath_log2( INFINITY ) == INFINITY );
    TESTFW_TEST_END();

    // vecmath_log10
    TESTFW_TEST_BEGIN( "vecmath_log10 returns 0 for input 1" )
        TESTFW_EXPECTED( vecmath_log10( 1.0f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log10 returns log base 10 for valid inputs" )
        TESTFW_EXPECTED( vecmath_log10( 10.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_log10( 100.0f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_log10( 0.1f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_log10( 0.01f ) == -2.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log10 returns -infinity for zero input" )
        TESTFW_EXPECTED( vecmath_log10( 0.0f ) == -INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log10 returns NaN for negative input" )
        TESTFW_EXPECTED( isnan( vecmath_log10( -1.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_log10( -INFINITY ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log10 propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_log10( NAN ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_log10 returns infinity for +infinity input" )
        TESTFW_EXPECTED( vecmath_log10( INFINITY ) == INFINITY );
    TESTFW_TEST_END();

    // vecmath_max
    TESTFW_TEST_BEGIN( "vecmath_max returns greater of two values" )
        TESTFW_EXPECTED( vecmath_max( 1.0f, 2.0f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_max( 2.0f, 1.0f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_max( -2.0f, -3.0f ) == -2.0f );
        TESTFW_EXPECTED( vecmath_max( -3.0f, -2.0f ) == -2.0f );
        TESTFW_EXPECTED( vecmath_max( 5.0f, 5.0f ) == 5.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_max handles very large and very small values" )
        TESTFW_EXPECTED( vecmath_max( 1e30f, 1e20f ) == 1e30f );
        TESTFW_EXPECTED( vecmath_max( 1e-30f, 1e-20f ) == 1e-20f );
        TESTFW_EXPECTED( vecmath_max( -1e-30f, -1e-20f ) == -1e-30f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_max suppresses NaN if other value is valid" )
        TESTFW_EXPECTED( vecmath_max( NAN, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_max( 1.0f, NAN ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_max preserves NaN if both inputs are NaN" )
        TESTFW_EXPECTED( isnan( vecmath_max( NAN, NAN ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_max handles infinity values" )
        TESTFW_EXPECTED( vecmath_max( INFINITY, 1.0f ) == INFINITY );
        TESTFW_EXPECTED( vecmath_max( -INFINITY, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_max( 1.0f, INFINITY ) == INFINITY );
        TESTFW_EXPECTED( vecmath_max( 1.0f, -INFINITY ) == 1.0f );
    TESTFW_TEST_END();
    
    // vecmath_min
    TESTFW_TEST_BEGIN( "vecmath_min returns lesser of two values" )
        TESTFW_EXPECTED( vecmath_min( 1.0f, 2.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_min( 2.0f, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_min( -2.0f, -3.0f ) == -3.0f );
        TESTFW_EXPECTED( vecmath_min( -3.0f, -2.0f ) == -3.0f );
        TESTFW_EXPECTED( vecmath_min( 5.0f, 5.0f ) == 5.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_min handles very large and very small values" )
        TESTFW_EXPECTED( vecmath_min( 1e30f, 1e20f ) == 1e20f );
        TESTFW_EXPECTED( vecmath_min( 1e-30f, 1e-20f ) == 1e-30f );
        TESTFW_EXPECTED( vecmath_min( -1e-30f, -1e-20f ) == -1e-20f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_min suppresses NaN if other value is valid" )
        TESTFW_EXPECTED( vecmath_min( NAN, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_min( 1.0f, NAN ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_min preserves NaN if both inputs are NaN" )
        TESTFW_EXPECTED( isnan( vecmath_min( NAN, NAN ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_min handles infinity values" )
        TESTFW_EXPECTED( vecmath_min( 1.0f, INFINITY ) == 1.0f );
        TESTFW_EXPECTED( vecmath_min( 1.0f, -INFINITY ) == -INFINITY );
        TESTFW_EXPECTED( vecmath_min( INFINITY, 1.0f ) == 1.0f );
        #ifndef __TINYC__ /* For some reason, tcc does not handle this infinity case properly */
        TESTFW_EXPECTED( vecmath_min( -INFINITY, 1.0f ) == -INFINITY );
        #endif
    TESTFW_TEST_END();

    // vecmath_normalize
    TESTFW_TEST_BEGIN( "vecmath_normalize returns sign for nonzero input" )
        TESTFW_EXPECTED( vecmath_normalize( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_normalize( -1.0f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_normalize( 123.456f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_normalize( -987.654f ) == -1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_normalize returns zero for zero input" )
        TESTFW_EXPECTED( vecmath_normalize( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_normalize( -0.0f ) == 0.0f );
    TESTFW_TEST_END();

    // vecmath_pow
    TESTFW_TEST_BEGIN( "vecmath_pow returns 1 for any value to the power 0" )
        TESTFW_EXPECTED( vecmath_pow( 2.0f, 0.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_pow( -3.5f, 0.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_pow( 0.0f, 0.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_pow returns base for exponent 1" )
        TESTFW_EXPECTED( vecmath_pow( 2.0f, 1.0f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_pow( -3.0f, 1.0f ) == -3.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_pow returns power for integer exponents" )
        TESTFW_EXPECTED( vecmath_pow( 2.0f, 2.0f ) == 4.0f );
        TESTFW_EXPECTED( vecmath_pow( 3.0f, 3.0f ) == 27.0f );
        TESTFW_EXPECTED( vecmath_pow( 2.0f, -1.0f ) == 0.5f );
        TESTFW_EXPECTED( vecmath_pow( 4.0f, -2.0f ) == 0.0625f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_pow returns expected values for fractional exponents" )
        TESTFW_EXPECTED( vecmath_pow( 4.0f, 0.5f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_pow( 9.0f, 0.5f ) == 3.0f );
        TESTFW_EXPECTED( vecmath_pow( 27.0f, 1.0f / 3.0f ) > 2.999f );
        TESTFW_EXPECTED( vecmath_pow( 27.0f, 1.0f / 3.0f ) < 3.001f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_pow returns NaN for negative base and fractional exponent" )
        TESTFW_EXPECTED( isnan( vecmath_pow( -2.0f, 0.5f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_pow( -8.0f, 1.0f / 3.0f ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_pow handles zero base" )
        TESTFW_EXPECTED( vecmath_pow( 0.0f, 2.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_pow( 0.0f, -1.0f ) == INFINITY );
        TESTFW_EXPECTED( vecmath_pow( -0.0f, -1.0f ) == -INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_pow handles infinity base" )
        TESTFW_EXPECTED( vecmath_pow( INFINITY, 1.0f ) == INFINITY );
        TESTFW_EXPECTED( vecmath_pow( INFINITY, -1.0f ) == 0.0f );
        #ifndef __TINYC__ /* For some reason, tcc does not handle this infinity case properly */
        TESTFW_EXPECTED( vecmath_pow( -INFINITY, 2.0f ) == INFINITY );
        TESTFW_EXPECTED( vecmath_pow( -INFINITY, 3.0f ) == -INFINITY );
        #endif
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_pow propagates NaN when applicable" )
        TESTFW_EXPECTED( isnan( vecmath_pow( NAN, 2.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_pow( 2.0f, NAN ) ) );
        TESTFW_EXPECTED( isnan( vecmath_pow( NAN, NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_radians 
    TESTFW_TEST_BEGIN( "vecmath_radians zero and multiples of pi" )
        TESTFW_EXPECTED( vecmath_radians( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_radians( 180.0f ) == 3.14159265f );
        TESTFW_EXPECTED( vecmath_radians( 90.0f ) == 1.57079633f );
        TESTFW_EXPECTED( vecmath_radians( -180.0f ) == -3.14159265f );
        TESTFW_EXPECTED( vecmath_radians( -90.0f ) == -1.57079633f );
        TESTFW_EXPECTED( vecmath_radians( 360.0f ) == 6.28318530f );
        TESTFW_EXPECTED( vecmath_radians( 45.0f ) == 0.78539816f );
        TESTFW_EXPECTED( vecmath_radians( 270.0f ) == 4.71238898f );
        TESTFW_EXPECTED( vecmath_radians( -360.0f ) == -6.28318530f );
        TESTFW_EXPECTED( vecmath_radians( -45.0f ) == -0.78539816f );
        TESTFW_EXPECTED( vecmath_radians( -270.0f ) == -4.71238898f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_radians preserves sign for tiny values" )
        TESTFW_EXPECTED( vecmath_radians( 1e-30f ) > 0.0f );
        TESTFW_EXPECTED( vecmath_radians( -1e-30f ) < 0.0f );
    TESTFW_TEST_END();

    // vecmath_rcp
    TESTFW_TEST_BEGIN( "vecmath_rcp returns reciprocal of input" )
        TESTFW_EXPECTED( vecmath_rcp( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_rcp( 2.0f ) == 0.5f );
        TESTFW_EXPECTED( vecmath_rcp( 0.5f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_rcp( -4.0f ) == -0.25f );
        TESTFW_EXPECTED( vecmath_rcp( -0.25f ) == -4.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_rcp handles zero and infinity correctly" )
        TESTFW_EXPECTED( vecmath_rcp( 0.0f ) == INFINITY );
        TESTFW_EXPECTED( vecmath_rcp( -0.0f ) == -INFINITY );
        TESTFW_EXPECTED( 1.0f / vecmath_rcp( INFINITY ) == INFINITY );
        TESTFW_EXPECTED( 1.0f / vecmath_rcp( -INFINITY ) == -INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_rcp propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_rcp( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_reflect
    TESTFW_TEST_BEGIN( "vecmath_reflect returns input unchanged when normal is zero" )
        TESTFW_EXPECTED( vecmath_reflect( 1.0f, 0.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_reflect( -2.0f, 0.0f ) == -2.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_reflect inverts direction when normal is aligned with input" )
        TESTFW_EXPECTED( vecmath_reflect( 1.0f, 1.0f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_reflect( -1.0f, -1.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_reflect returns expected value for input opposite normal" )
        TESTFW_EXPECTED( vecmath_reflect( -1.0f, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_reflect( 2.0f, -1.0f ) == -2.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_reflect returns expected value for 45-degree incidence" )
        TESTFW_EXPECTED( vecmath_reflect( 1.0f, -1.0f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_reflect( -1.0f, 1.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_reflect propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_reflect( NAN, 1.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_reflect( 1.0f, NAN ) ) );
        TESTFW_EXPECTED( isnan( vecmath_reflect( NAN, NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_refract
    TESTFW_TEST_BEGIN( "vecmath_refract returns zero when angle is too great for given refraction index" )
        float i = -0.5f;
        float n = 1.0f;
        TESTFW_EXPECTED( vecmath_refract( i, n, 1.5f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_refract returns unchanged value when normal is orthogonal and refraction index is 1.0" )
        float i = 1.0f;
        float n = 0.0f;
        TESTFW_EXPECTED( vecmath_refract( i, n, 1.0f ) == i );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_refract returns value in same general direction as input" )
        float i = -1.0f;
        float n = 1.0f;
        float r = vecmath_refract( i, n, 0.8f );
        TESTFW_EXPECTED( i * r > 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_refract of zero is zero" )
        TESTFW_EXPECTED( vecmath_refract( 0.0f, 1.0f, 1.5f ) == 0.0f );
    TESTFW_TEST_END();

    // vecmath_round
    TESTFW_TEST_BEGIN( "vecmath_round returns input unchanged for exact integers" )
        TESTFW_EXPECTED( vecmath_round( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_round( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_round( -1.0f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_round( 42.0f ) == 42.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_round rounds positive values to nearest integer" )
        TESTFW_EXPECTED( vecmath_round( 0.1f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_round( 0.49f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_round( 0.5f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_round( 0.9f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_round( 1.5f ) == 2.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_round rounds negative values to nearest integer" )
        TESTFW_EXPECTED( vecmath_round( -0.1f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_round( -0.49f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_round( -0.5f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_round( -0.9f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_round( -1.5f ) == -2.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_round returns input unchanged for infinity" )
        TESTFW_EXPECTED( vecmath_round( INFINITY ) == INFINITY );
        TESTFW_EXPECTED( vecmath_round( -INFINITY ) == -INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_round returns NaN when input is NaN" )
        TESTFW_EXPECTED( isnan( vecmath_round( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_rsqrt
    TESTFW_TEST_BEGIN( "vecmath_rsqrt returns exact reciprocal square root for positive perfect squares" )
        TESTFW_EXPECTED( vecmath_rsqrt( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_rsqrt( 4.0f ) == 0.5f );
        TESTFW_EXPECTED( vecmath_rsqrt( 9.0f ) == 1.0f / 3.0f );
        TESTFW_EXPECTED( vecmath_rsqrt( 0.25f ) == 2.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_rsqrt returns infinity for zero input" )
        TESTFW_EXPECTED( vecmath_rsqrt( 0.0f ) == INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_rsqrt returns zero for infinite input" )
        TESTFW_EXPECTED( vecmath_rsqrt( INFINITY ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_rsqrt returns NaN for negative input" )
        TESTFW_EXPECTED( isnan( vecmath_rsqrt( -1.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_rsqrt( -INFINITY ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_rsqrt returns NaN when input is NaN" )
        TESTFW_EXPECTED( isnan( vecmath_rsqrt( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_saturate
    TESTFW_TEST_BEGIN( "vecmath_saturate returns input unchanged for values in [0, 1]" )
        TESTFW_EXPECTED( vecmath_saturate( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_saturate( 0.5f ) == 0.5f );
        TESTFW_EXPECTED( vecmath_saturate( 1.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_saturate clamps values below zero" )
        TESTFW_EXPECTED( vecmath_saturate( -0.1f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_saturate( -1.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_saturate( -FLT_MAX ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_saturate clamps values above one" )
        TESTFW_EXPECTED( vecmath_saturate( 1.1f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_saturate( 2.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_saturate( FLT_MAX ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_saturate returns NaN when input is NaN" )
        TESTFW_EXPECTED( isnan( vecmath_saturate( NAN ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_saturate clamps infinity values" )
        TESTFW_EXPECTED( vecmath_saturate( INFINITY ) == 1.0f );
        TESTFW_EXPECTED( vecmath_saturate( -INFINITY ) == 0.0f );
    TESTFW_TEST_END();

    // vecmath_sign
    TESTFW_TEST_BEGIN( "vecmath_sign returns 1 for positive input" )
        TESTFW_EXPECTED( vecmath_sign( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_sign( 123.456f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_sign( 1e-30f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sign returns -1 for negative input" )
        TESTFW_EXPECTED( vecmath_sign( -1.0f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_sign( -123.456f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_sign( -1e-30f ) == -1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sign returns 0 for zero input" )
        TESTFW_EXPECTED( vecmath_sign( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_sign( -0.0f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sign preserves sign of infinity" )
        TESTFW_EXPECTED( vecmath_sign( INFINITY ) == 1.0f );
        TESTFW_EXPECTED( vecmath_sign( -INFINITY ) == -1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sign does not propagate NaN" )
        TESTFW_EXPECTED( vecmath_sign( NAN ) == 0.0f );
    TESTFW_TEST_END();

    // vecmath_sin
    TESTFW_TEST_BEGIN( "vecmath_sin returns correct values at canonical angles" )
        TESTFW_EXPECTED( vecmath_sin( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_sin( 3.14159265f ) < 1e-6f );
        TESTFW_EXPECTED( vecmath_sin( 3.14159265f ) > -1e-6f );
        TESTFW_EXPECTED( vecmath_sin( 1.57079633f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_sin( -1.57079633f ) == -1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sin is odd function" )
        TESTFW_EXPECTED( vecmath_sin( 0.5f ) == -vecmath_sin( -0.5f ) );
        TESTFW_EXPECTED( vecmath_sin( 2.0f ) == -vecmath_sin( -2.0f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sin returns values in [-1, 1]" )
        TESTFW_EXPECTED( vecmath_sin( 0.25f ) <= 1.0f );
        TESTFW_EXPECTED( vecmath_sin( 0.25f ) >= -1.0f );
        TESTFW_EXPECTED( vecmath_sin( 10.0f ) <= 1.0f );
        TESTFW_EXPECTED( vecmath_sin( 10.0f ) >= -1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sin propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_sin( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_sinh
    TESTFW_TEST_BEGIN( "vecmath_sinh returns 0 for zero input" )
        TESTFW_EXPECTED( vecmath_sinh( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_sinh( -0.0f ) == -0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sinh is odd function" )
        TESTFW_EXPECTED( vecmath_sinh( 1.0f ) == -vecmath_sinh( -1.0f ) );
        TESTFW_EXPECTED( vecmath_sinh( 2.0f ) == -vecmath_sinh( -2.0f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sinh returns expected values for known inputs" )
        TESTFW_EXPECTED( vecmath_sinh( 1.0f ) > 1.17f );
        TESTFW_EXPECTED( vecmath_sinh( 1.0f ) < 1.18f );
        TESTFW_EXPECTED( vecmath_sinh( -1.0f ) > -1.18f );
        TESTFW_EXPECTED( vecmath_sinh( -1.0f ) < -1.17f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sinh handles infinity" )
        TESTFW_EXPECTED( vecmath_sinh( INFINITY ) == INFINITY );
        TESTFW_EXPECTED( vecmath_sinh( -INFINITY ) == -INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sinh propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_sinh( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_smoothstep
    TESTFW_TEST_BEGIN( "vecmath_smoothstep returns 0 for inputs below min" )
        TESTFW_EXPECTED( vecmath_smoothstep( 0.0f, 1.0f, -0.1f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_smoothstep( 0.0f, 1.0f, 0.0f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_smoothstep returns 1 for inputs above max" )
        TESTFW_EXPECTED( vecmath_smoothstep( 0.0f, 1.0f, 1.1f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_smoothstep( 0.0f, 1.0f, 2.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_smoothstep returns smooth interpolation for inputs between min and max" )
        TESTFW_EXPECTED( vecmath_smoothstep( 0.0f, 1.0f, 0.5f ) > 0.4f );
        TESTFW_EXPECTED( vecmath_smoothstep( 0.0f, 1.0f, 0.5f ) < 0.6f );
        TESTFW_EXPECTED( vecmath_smoothstep( 1.0f, 2.0f, 1.5f ) > 0.4f );
        TESTFW_EXPECTED( vecmath_smoothstep( 1.0f, 2.0f, 1.5f ) < 0.6f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_smoothstep returns 0 for inputs below min when min == max" )
        TESTFW_EXPECTED( vecmath_smoothstep( 1.0f, 1.0f, 0.5f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_smoothstep returns 1 for inputs at or above min when min == max" )
        TESTFW_EXPECTED( vecmath_smoothstep( 1.0f, 1.0f, 1.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_smoothstep propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_smoothstep( NAN, 1.0f, 0.5f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_smoothstep( 0.0f, NAN, 0.5f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_smoothstep( 0.0f, 1.0f, NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_smootherstep
    TESTFW_TEST_BEGIN( "vecmath_smootherstep returns 0 for inputs below min" )
        TESTFW_EXPECTED( vecmath_smootherstep( 0.0f, 1.0f, -0.1f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_smootherstep( 0.0f, 1.0f, 0.0f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_smootherstep returns 1 for inputs above max" )
        TESTFW_EXPECTED( vecmath_smootherstep( 0.0f, 1.0f, 1.1f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_smootherstep( 0.0f, 1.0f, 2.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_smootherstep returns smooth interpolation for inputs between min and max" )
        float val = vecmath_smootherstep( 0.0f, 1.0f, 0.5f );
        TESTFW_EXPECTED( val > 0.45f );
        TESTFW_EXPECTED( val < 0.55f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_smootherstep returns 0 for inputs below min when min == max" )
        TESTFW_EXPECTED( vecmath_smootherstep( 1.0f, 1.0f, 0.5f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_smootherstep returns 1 for inputs at or above min when min == max" )
        TESTFW_EXPECTED( vecmath_smootherstep( 1.0f, 1.0f, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_smootherstep( 1.0f, 1.0f, 1.1f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_smootherstep propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_smootherstep( NAN, 1.0f, 0.5f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_smootherstep( 0.0f, NAN, 0.5f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_smootherstep( 0.0f, 1.0f, NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_sqrt
    TESTFW_TEST_BEGIN( "vecmath_sqrt returns correct values for perfect squares" )
        TESTFW_EXPECTED( vecmath_sqrt( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_sqrt( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_sqrt( 4.0f ) == 2.0f );
        TESTFW_EXPECTED( vecmath_sqrt( 9.0f ) == 3.0f );
        TESTFW_EXPECTED( vecmath_sqrt( 0.25f ) == 0.5f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sqrt returns NaN for negative input" )
        TESTFW_EXPECTED( isnan( vecmath_sqrt( -1.0f ) ) );
        TESTFW_EXPECTED( isnan( vecmath_sqrt( -INFINITY ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sqrt returns infinity for +infinity input" )
        TESTFW_EXPECTED( vecmath_sqrt( INFINITY ) == INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_sqrt propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_sqrt( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_step
    TESTFW_TEST_BEGIN( "vecmath_step returns 0 when input is less than edge" )
        TESTFW_EXPECTED( vecmath_step( 1.0f, 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_step( 5.0f, 4.999f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_step( 0.0f, -1.0f ) == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_step returns 1 when input is equal or greater than edge" )
        TESTFW_EXPECTED( vecmath_step( 1.0f, 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_step( 1.0f, 2.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_step( -1.0f, 0.0f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_step returns 0 for any NaN inputs" )
        TESTFW_EXPECTED( vecmath_step( NAN, 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_step( 0.0f, NAN ) == 0.0f );
        TESTFW_EXPECTED( vecmath_step( NAN, NAN ) == 0.0f );
    TESTFW_TEST_END();

    // vecmath_tan
    TESTFW_TEST_BEGIN( "vecmath_tan returns near-zero values at multiples of pi" )
        TESTFW_EXPECTED( vecmath_tan( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_tan( 3.14159265f ) < 1e-6f );
        TESTFW_EXPECTED( vecmath_tan( 3.14159265f ) > -1e-6f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_tan returns large magnitude near +-pi/2" )
        TESTFW_EXPECTED( vecmath_abs(vecmath_tan( 1.57079633f )) > 1e2f );
        TESTFW_EXPECTED( vecmath_abs(vecmath_tan( -1.57079633f )) > 1e2f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_tan does not necessarily return NaN near discontinuities" )
        TESTFW_EXPECTED( !isnan( vecmath_tan( 1.57079633f + 1e-8f ) ) );
        TESTFW_EXPECTED( !isnan( vecmath_tan( -1.57079633f - 1e-8f ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_tan is odd function" )
        TESTFW_EXPECTED( vecmath_tan( 0.5f ) == -vecmath_tan( -0.5f ) );
        TESTFW_EXPECTED( vecmath_tan( 2.0f ) == -vecmath_tan( -2.0f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_tan propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_tan( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_tanh
    TESTFW_TEST_BEGIN( "vecmath_tanh returns 0 for zero input" )
        TESTFW_EXPECTED( vecmath_tanh( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_tanh( -0.0f ) == -0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_tanh is odd function" )
        TESTFW_EXPECTED( vecmath_tanh( 1.0f ) == -vecmath_tanh( -1.0f ) );
        TESTFW_EXPECTED( vecmath_tanh( 2.0f ) == -vecmath_tanh( -2.0f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_tanh returns values in (-1, 1)" )
        TESTFW_EXPECTED( vecmath_tanh( 0.5f ) > 0.0f );
        TESTFW_EXPECTED( vecmath_tanh( 0.5f ) < 1.0f );
        TESTFW_EXPECTED( vecmath_tanh( -0.5f ) < 0.0f );
        TESTFW_EXPECTED( vecmath_tanh( -0.5f ) > -1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_tanh approaches +-1 for large magnitude inputs" )
        TESTFW_EXPECTED( vecmath_tanh( 10.0f ) > 0.9999f );
        TESTFW_EXPECTED( vecmath_tanh( -10.0f ) < -0.9999f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_tanh propagates NaN" )
        TESTFW_EXPECTED( isnan( vecmath_tanh( NAN ) ) );
    TESTFW_TEST_END();

    // vecmath_trunc
    TESTFW_TEST_BEGIN( "vecmath_trunc returns input unchanged for exact integers" )
        TESTFW_EXPECTED( vecmath_trunc( 0.0f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_trunc( 1.0f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_trunc( -1.0f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_trunc( 42.0f ) == 42.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_trunc removes fractional part of positive values" )
        TESTFW_EXPECTED( vecmath_trunc( 0.1f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_trunc( 0.5f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_trunc( 0.9f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_trunc( 1.5f ) == 1.0f );
        TESTFW_EXPECTED( vecmath_trunc( 1.9f ) == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_trunc removes fractional part of negative values" )
        TESTFW_EXPECTED( vecmath_trunc( -0.1f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_trunc( -0.5f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_trunc( -0.9f ) == 0.0f );
        TESTFW_EXPECTED( vecmath_trunc( -1.5f ) == -1.0f );
        TESTFW_EXPECTED( vecmath_trunc( -1.9f ) == -1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_trunc returns input unchanged for infinity" )
        TESTFW_EXPECTED( vecmath_trunc( INFINITY ) == INFINITY );
        TESTFW_EXPECTED( vecmath_trunc( -INFINITY ) == -INFINITY );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vecmath_trunc returns NaN when input is NaN" )
        TESTFW_EXPECTED( isnan( vecmath_trunc( NAN ) ) );
    TESTFW_TEST_END();
}


void test_vec2( void ) {
    // vec2
    TESTFW_TEST_BEGIN( "vec2 constructs vector from distinct x and y components" )
        vec2_t v = vec2( 1.0f, 2.0f );
        TESTFW_EXPECTED( v.x == 1.0f );
        TESTFW_EXPECTED( v.y == 2.0f );
    TESTFW_TEST_END();

    // vec2f
    TESTFW_TEST_BEGIN( "vec2f constructs a vector with both components equal to input" )
        vec2_t v = vec2f( 3.5f );
        TESTFW_EXPECTED( v.x == 3.5f );
        TESTFW_EXPECTED( v.y == 3.5f );
    TESTFW_TEST_END();

    // vec2_get
    TESTFW_TEST_BEGIN( "vec2_get returns x and y by index" )
        vec2_t v = vec2( 1.5f, -2.5f );
        TESTFW_EXPECTED( vec2_get( v, 0 ) == 1.5f );
        TESTFW_EXPECTED( vec2_get( v, 1 ) == -2.5f );
    TESTFW_TEST_END();

    // vec2_set
    TESTFW_TEST_BEGIN( "vec2_set modifies only the indexed component" )
        vec2_t v = vec2( 1.0f, 2.0f );
        vec2_set( &v, 0, 9.0f );
        TESTFW_EXPECTED( v.x == 9.0f );
        TESTFW_EXPECTED( v.y == 2.0f );

        v = vec2( 3.0f, 4.0f );
        vec2_set( &v, 1, -7.0f );
        TESTFW_EXPECTED( v.x == 3.0f );
        TESTFW_EXPECTED( v.y == -7.0f );
    TESTFW_TEST_END();

    // vec2_neg
    TESTFW_TEST_BEGIN( "vec2_neg negates each component of the input vector" )
        vec2_t v = vec2( 1.0f, -2.5f );
        vec2_t r = vec2_neg( v );
        TESTFW_EXPECTED( r.x == -1.0f );
        TESTFW_EXPECTED( r.y == 2.5f );
    TESTFW_TEST_END();

    // vec2_eq
    TESTFW_TEST_BEGIN( "vec2_eq returns nonzero if both components are equal" )
        vec2_t a = vec2( 1.0f, 2.0f );
        vec2_t b = vec2( 1.0f, 2.0f );
        TESTFW_EXPECTED( vec2_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_eq returns zero if any component differs" )
        vec2_t a = vec2( 1.0f, 2.0f );
        vec2_t b = vec2( 1.0f, 3.0f );
        TESTFW_EXPECTED( vec2_eq( a, b ) == 0 );

        b = vec2( 4.0f, 2.0f );
        TESTFW_EXPECTED( vec2_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // vec2_add
    TESTFW_TEST_BEGIN( "vec2_add adds corresponding components of two vectors" )
        vec2_t a = vec2( 1.0f, 6.0f );
        vec2_t b = vec2( 4.0f, 9.0f );
        vec2_t r = vec2_add( a, b );
        TESTFW_EXPECTED( r.x == 5.0f ); 
        TESTFW_EXPECTED( r.y == 15.0f );
    TESTFW_TEST_END();

    // vec2_sub
    TESTFW_TEST_BEGIN( "vec2_sub subtracts corresponding components of two vectors" )
        vec2_t a = vec2( 8.0f, 15.0f );
        vec2_t b = vec2( 3.0f, 4.0f );
        vec2_t r = vec2_sub( a, b );
        TESTFW_EXPECTED( r.x == 5.0f ); 
        TESTFW_EXPECTED( r.y == 11.0f );
    TESTFW_TEST_END();

    // vec2_mul
    TESTFW_TEST_BEGIN( "vec2_mul multiplies corresponding components of two vectors" )
        vec2_t a = vec2( 2.0f, 5.0f );
        vec2_t b = vec2( 3.0f, 4.0f );
        vec2_t r = vec2_mul( a, b );
        TESTFW_EXPECTED( r.x == 6.0f ); 
        TESTFW_EXPECTED( r.y == 20.0f ); 
    TESTFW_TEST_END();

    // vec2_div
    TESTFW_TEST_BEGIN( "vec2_div divides corresponding components of two vectors" )
        vec2_t a = vec2( 10.0f, 18.0f );
        vec2_t b = vec2( 2.0f, 3.0f );
        vec2_t r = vec2_div( a, b );
        TESTFW_EXPECTED( r.x == 5.0f ); 
        TESTFW_EXPECTED( r.y == 6.0f ); 
    TESTFW_TEST_END();

    // vec2_addf
    TESTFW_TEST_BEGIN( "vec2_addf adds scalar to both components of vector" )
        vec2_t a = vec2( 2.0f, 5.0f );
        vec2_t r = vec2_addf( a, 3.0f );
        TESTFW_EXPECTED( r.x == 5.0f ); 
        TESTFW_EXPECTED( r.y == 8.0f ); 
    TESTFW_TEST_END();

    // vec2_subf
    TESTFW_TEST_BEGIN( "vec2_subf subtracts scalar from both components of vector" )
        vec2_t a = vec2( 10.0f, 6.0f );
        vec2_t r = vec2_subf( a, 4.0f );
        TESTFW_EXPECTED( r.x == 6.0f ); 
        TESTFW_EXPECTED( r.y == 2.0f ); 
    TESTFW_TEST_END();

    // vec2_mulf
    TESTFW_TEST_BEGIN( "vec2_mulf multiplies both components of vector by scalar" )
        vec2_t a = vec2( 2.0f, 5.0f );
        vec2_t r = vec2_mulf( a, 3.0f );
        TESTFW_EXPECTED( r.x == 6.0f ); 
        TESTFW_EXPECTED( r.y == 15.0f ); 
    TESTFW_TEST_END();

    // vec2_divf
    TESTFW_TEST_BEGIN( "vec2_divf divides both components of vector by scalar" )
        vec2_t a = vec2( 12.0f, 18.0f );
        vec2_t r = vec2_divf( a, 3.0f );
        TESTFW_EXPECTED( r.x == 4.0f ); 
        TESTFW_EXPECTED( r.y == 6.0f ); 
    TESTFW_TEST_END();

    // vec2_abs
    TESTFW_TEST_BEGIN( "vec2_abs applies absolute value to each component" )
        vec2_t a = vec2( -3.0f, -4.0f );
        vec2_t r = vec2_abs( a );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == 4.0f );
    TESTFW_TEST_END();

    // vec2_acos
    TESTFW_TEST_BEGIN( "vec2_acos applies acos to each component" )
        vec2_t a = vec2( 0.5f, -1.0f );
        vec2_t r = vec2_acos( a );
        TESTFW_EXPECTED( test_cmp( r.x, 1.04719758f ) ); 
        TESTFW_EXPECTED( test_cmp( r.y, 3.14159265f ) ); 
    TESTFW_TEST_END();

    // vec2_all
    TESTFW_TEST_BEGIN( "vec2_all returns nonzero only if both components are nonzero" )
        TESTFW_EXPECTED( vec2_all( vec2( 1.0f, 1.0f ) ) != 0 );
        TESTFW_EXPECTED( vec2_all( vec2( 1.0f, 0.0f ) ) == 0 );
        TESTFW_EXPECTED( vec2_all( vec2( 0.0f, 1.0f ) ) == 0 );
        TESTFW_EXPECTED( vec2_all( vec2( 0.0f, 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // vec2_any
    TESTFW_TEST_BEGIN( "vec2_any returns nonzero if either component is nonzero" )
        TESTFW_EXPECTED( vec2_any( vec2( 1.0f, 1.0f ) ) != 0 );
        TESTFW_EXPECTED( vec2_any( vec2( 1.0f, 0.0f ) ) != 0 );
        TESTFW_EXPECTED( vec2_any( vec2( 0.0f, 1.0f ) ) != 0 );
        TESTFW_EXPECTED( vec2_any( vec2( 0.0f, 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // vec2_asin
    TESTFW_TEST_BEGIN( "vec2_asin applies asin to each component" )
        vec2_t a = vec2( 0.5f, -1.0f );
        vec2_t r = vec2_asin( a );
        TESTFW_EXPECTED( test_cmp( r.x, 0.52359878f )); 
        TESTFW_EXPECTED( test_cmp( r.y, -1.57079633f )); 
    TESTFW_TEST_END();

    // vec2_atan
    TESTFW_TEST_BEGIN( "vec2_atan applies atan to each component" )
        vec2_t a = vec2( 0.5f, -2.0f );
        vec2_t r = vec2_atan( a );
        TESTFW_EXPECTED( r.x == 0.46364761f ); 
        TESTFW_EXPECTED( r.y == -1.10714872f ); 
    TESTFW_TEST_END();

    // vec2_atan2
    TESTFW_TEST_BEGIN( "vec2_atan2 applies atan2 to each pair of components" )
        vec2_t y = vec2( 2.0f, -3.0f );
        vec2_t x = vec2( 1.0f, -4.0f );
        vec2_t r = vec2_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x, 1.10714872f )); 
        TESTFW_EXPECTED( test_cmp( r.y, -2.49809154f )); 
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_atan2 handles distinct signs and quadrants" )
        vec2_t y = vec2( 3.0f, -2.0f );
        vec2_t x = vec2( -2.0f, 5.0f );
        vec2_t r = vec2_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x, 2.15879893f )); 
        TESTFW_EXPECTED( test_cmp( r.y, -0.38050638f )); 
    TESTFW_TEST_END();

    // vec2_ceil
    TESTFW_TEST_BEGIN( "vec2_ceil applies ceil to each component" )
        vec2_t v = vec2( 1.2f, -3.7f );
        vec2_t r = vec2_ceil( v );
        TESTFW_EXPECTED( r.x == 2.0f ); 
        TESTFW_EXPECTED( r.y == -3.0f ); 
    TESTFW_TEST_END();

    // vec2_clamp
    TESTFW_TEST_BEGIN( "vec2_clamp clamps each component using corresponding min and max" )
        vec2_t v = vec2( 5.0f, -10.0f );
        vec2_t min = vec2( 0.0f, -8.0f );
        vec2_t max = vec2( 4.0f, -7.0f );
        vec2_t r = vec2_clamp( v, min, max );
        TESTFW_EXPECTED( r.x == 4.0f ); 
        TESTFW_EXPECTED( r.y == -8.0f ); 
    TESTFW_TEST_END();

    // vec2_cos
    TESTFW_TEST_BEGIN( "vec2_cos applies cos to each component" )
        vec2_t a = vec2( 0.5f, 2.0f );
        vec2_t r = vec2_cos( a );
        TESTFW_EXPECTED( r.x == 0.87758256f ); 
        TESTFW_EXPECTED( r.y == -0.41614684f ); 
    TESTFW_TEST_END();

    // vec2_cosh
    TESTFW_TEST_BEGIN( "vec2_cosh applies cosh to each component" )
        vec2_t a = vec2( 0.5f, 2.0f );
        vec2_t r = vec2_cosh( a );
        TESTFW_EXPECTED( test_cmp( r.x, 1.12762597f )); 
        TESTFW_EXPECTED( test_cmp( r.y, 3.76219569f )); 
    TESTFW_TEST_END();

    // vec2_cross
    TESTFW_TEST_BEGIN( "vec2_cross returns signed area (a.x * b.y - a.y * b.x)" )
        vec2_t a = vec2( 3.0f, 2.0f );
        vec2_t b = vec2( 5.0f, 7.0f );
        float r = vec2_cross( a, b );
        TESTFW_EXPECTED( r == 11.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_cross returns zero for parallel vectors" )
        vec2_t a = vec2( 2.0f, 4.0f );
        vec2_t b = vec2( 4.0f, 8.0f );
        float r = vec2_cross( a, b );
        TESTFW_EXPECTED( r == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_cross returns negative when orientation is flipped" )
        vec2_t a = vec2( 3.0f, 2.0f );
        vec2_t b = vec2( -5.0f, -7.0f );
        float r = vec2_cross( a, b );
        TESTFW_EXPECTED( r == -11.0f );
    TESTFW_TEST_END();

    // vec2_degrees
    TESTFW_TEST_BEGIN( "vec2_degrees converts radians to degrees component-wise" )
        vec2_t a = vec2( 0.5f, -2.0f );
        vec2_t r = vec2_degrees( a );
        TESTFW_EXPECTED( r.x == 28.6478898f );
        TESTFW_EXPECTED( r.y == -114.591559f );
    TESTFW_TEST_END();

    // vec2_distancesq
    TESTFW_TEST_BEGIN( "vec2_distancesq returns squared distance between components" )
        vec2_t a = vec2( 1.0f, 4.0f );
        vec2_t b = vec2( -2.0f, 6.0f );
        float r = vec2_distancesq( a, b );
        TESTFW_EXPECTED( r == 13.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_distancesq is zero when vectors are equal" )
        vec2_t a = vec2( 3.0f, 7.0f );
        float r = vec2_distancesq( a, a );
        TESTFW_EXPECTED( r == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_distancesq is symmetric in its arguments" )
        vec2_t a = vec2( -1.0f, 2.0f );
        vec2_t b = vec2( 4.0f, -3.0f );
        float d1 = vec2_distancesq( a, b );
        float d2 = vec2_distancesq( b, a );
        TESTFW_EXPECTED( d1 == d2 );
    TESTFW_TEST_END();

    // vec2_distance
    TESTFW_TEST_BEGIN( "vec2_distance returns Euclidean distance between components" )
        vec2_t a = vec2( 1.0f, 4.0f );
        vec2_t b = vec2( -2.0f, 6.0f );
        float r = vec2_distance( a, b );
        TESTFW_EXPECTED( r == 3.60555128f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_distance is zero when vectors are equal" )
        vec2_t a = vec2( 3.0f, 7.0f );
        float r = vec2_distance( a, a );
        TESTFW_EXPECTED( r == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_distance is symmetric in its arguments" )
        vec2_t a = vec2( -1.0f, 2.0f );
        vec2_t b = vec2( 4.0f, -3.0f );
        float d1 = vec2_distance( a, b );
        float d2 = vec2_distance( b, a );
        TESTFW_EXPECTED( d1 == d2 );
    TESTFW_TEST_END();

    // vec2_dot
    TESTFW_TEST_BEGIN( "vec2_dot returns sum of products of corresponding components" )
        vec2_t a = vec2( 2.0f, 3.0f );
        vec2_t b = vec2( 4.0f, -1.0f );
        float r = vec2_dot( a, b );
        TESTFW_EXPECTED( r == 5.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_dot is symmetric in its arguments" )
        vec2_t a = vec2( -1.0f, 5.0f );
        vec2_t b = vec2( 7.0f, 2.0f );
        float d1 = vec2_dot( a, b );
        float d2 = vec2_dot( b, a );
        TESTFW_EXPECTED( d1 == d2 );
    TESTFW_TEST_END();

    // vec2_exp
    TESTFW_TEST_BEGIN( "vec2_exp applies exp to each component" )
        vec2_t a = vec2( 0.5f, -2.0f );
        vec2_t r = vec2_exp( a );
        TESTFW_EXPECTED( r.x == 1.64872127f );
        TESTFW_EXPECTED( r.y == 0.13533528f );
    TESTFW_TEST_END();

    // vec2_exp2
    TESTFW_TEST_BEGIN( "vec2_exp2 applies exp2 to each component" )
        vec2_t a = vec2( 3.0f, -2.0f );
        vec2_t r = vec2_exp2( a );
        TESTFW_EXPECTED( r.x == 8.0f ); 
        TESTFW_EXPECTED( r.y == 0.25f );
    TESTFW_TEST_END();

    // vec2_floor
    TESTFW_TEST_BEGIN( "vec2_floor applies floor to each component" )
        vec2_t a = vec2( 2.7f, -3.2f );
        vec2_t r = vec2_floor( a );
        TESTFW_EXPECTED( r.x == 2.0f );
        TESTFW_EXPECTED( r.y == -4.0f );
    TESTFW_TEST_END();

    // vec2_fmod
    TESTFW_TEST_BEGIN( "vec2_fmod applies fmod to each pair of components" )
        vec2_t a = vec2( 6.5f, -5.0f );
        vec2_t b = vec2( 2.0f, 3.0f );
        vec2_t r = vec2_fmod( a, b );
        TESTFW_EXPECTED( r.x == 0.5f ); 
        TESTFW_EXPECTED( r.y == -2.0f ); 
    TESTFW_TEST_END();

    // vec2_frac
    TESTFW_TEST_BEGIN( "vec2_frac returns fractional part of each component" )
        vec2_t a = vec2( 3.75f, -2.25f );
        vec2_t r = vec2_frac( a );
        TESTFW_EXPECTED( r.x == 0.75f );
        TESTFW_EXPECTED( r.y == 0.25f );
    TESTFW_TEST_END();

    // vec2_lengthsq
    TESTFW_TEST_BEGIN( "vec2_lengthsq returns sum of squared components" )
        vec2_t a = vec2( 3.0f, -4.0f );
        float r = vec2_lengthsq( a );
        TESTFW_EXPECTED( r == 25.0f );
    TESTFW_TEST_END();

    // vec2_length
    TESTFW_TEST_BEGIN( "vec2_length returns Euclidean length of vector" )
        vec2_t a = vec2( 3.0f, -4.0f );
        float r = vec2_length( a );
        TESTFW_EXPECTED( r == 5.0f );
    TESTFW_TEST_END();

    // vec2_lerp
    TESTFW_TEST_BEGIN( "vec2_lerp linearly interpolates between vectors component-wise" )
        vec2_t a = vec2( 2.0f, -4.0f );
        vec2_t b = vec2( 6.0f, 8.0f );
        vec2_t r = vec2_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == -1.0f );
    TESTFW_TEST_END();

    // vec2_log
    TESTFW_TEST_BEGIN( "vec2_log applies natural log to each component" )
        vec2_t a = vec2( 7.38905610f, 54.5981500f );
        vec2_t r = vec2_log( a );
        TESTFW_EXPECTED( r.x == 2.0f );
        TESTFW_EXPECTED( r.y == 4.0f );
    TESTFW_TEST_END();

    // vec2_log2
    TESTFW_TEST_BEGIN( "vec2_log2 applies base-2 logarithm to each component" )
        vec2_t a = vec2( 16.0f, 0.25f );
        vec2_t r = vec2_log2( a );
        TESTFW_EXPECTED( r.x == 4.0f );
        TESTFW_EXPECTED( r.y == -2.0f );
    TESTFW_TEST_END();

    // vec2_log10
    TESTFW_TEST_BEGIN( "vec2_log10 applies base-10 logarithm to each component" )
        vec2_t a = vec2( 100.0f, 0.001f );
        vec2_t r = vec2_log10( a );
        TESTFW_EXPECTED( r.x == 2.0f );
        TESTFW_EXPECTED( r.y == -3.0f );
    TESTFW_TEST_END();

    // vec2_max
    TESTFW_TEST_BEGIN( "vec2_max returns component-wise maximum of two vectors" )
        vec2_t a = vec2( 3.0f, -5.0f );
        vec2_t b = vec2( 2.0f, -4.0f );
        vec2_t r = vec2_max( a, b );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == -4.0f );
    TESTFW_TEST_END();

    // vec2_min
    TESTFW_TEST_BEGIN( "vec2_min returns component-wise minimum of two vectors" )
        vec2_t a = vec2( 3.0f, -5.0f );
        vec2_t b = vec2( 2.0f, -4.0f );
        vec2_t r = vec2_min( a, b );
        TESTFW_EXPECTED( r.x == 2.0f );
        TESTFW_EXPECTED( r.y == -5.0f );
    TESTFW_TEST_END();

    // vec2_normalize
    TESTFW_TEST_BEGIN( "vec2_normalize returns vector of unit length in same direction" )
        vec2_t a = vec2( 3.0f, 4.0f );
        vec2_t r = vec2_normalize( a );
        TESTFW_EXPECTED( r.x == 0.6f );
        TESTFW_EXPECTED( r.y == 0.8f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_normalize returns zero vector when input is zero" )
        vec2_t a = vec2( 0.0f, 0.0f );
        vec2_t r = vec2_normalize( a );
        TESTFW_EXPECTED( r.x == 0.0f );
        TESTFW_EXPECTED( r.y == 0.0f );
    TESTFW_TEST_END();

    // vec2_pow
    TESTFW_TEST_BEGIN( "vec2_pow applies pow to each pair of components" )
        vec2_t a = vec2( 4.0f, 9.0f );
        vec2_t b = vec2( 0.5f, 0.5f );
        vec2_t r = vec2_pow( a, b );
        TESTFW_EXPECTED( r.x == 2.0f );
        TESTFW_EXPECTED( r.y == 3.0f );
    TESTFW_TEST_END();

    // vec2_radians
    TESTFW_TEST_BEGIN( "vec2_radians converts degrees to radians component-wise" )
        vec2_t a = vec2( 90.0f, -45.0f );
        vec2_t r = vec2_radians( a );
        TESTFW_EXPECTED( r.x == 1.57079633f );
        TESTFW_EXPECTED( r.y == -0.78539816f );
    TESTFW_TEST_END();

    // vec2_rcp
    TESTFW_TEST_BEGIN( "vec2_rcp returns per-component reciprocal" )
        vec2_t a = vec2( 4.0f, -0.5f );
        vec2_t r = vec2_rcp( a );
        TESTFW_EXPECTED( r.x == 0.25f );
        TESTFW_EXPECTED( r.y == -2.0f );
    TESTFW_TEST_END();

    // vec2_reflect
    TESTFW_TEST_BEGIN( "vec2_reflect preserves length for normalized normal" )
        vec2_t i = vec2( 3.0f, 4.0f );
        vec2_t n = vec2_normalize( vec2( 0.0f, 1.0f ) );
        TESTFW_EXPECTED( vec2_length( i ) == vec2_length( vec2_reflect( i, n ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_reflect is identity when reflected twice" )
        vec2_t i = vec2( 2.0f, -5.0f );
        vec2_t n = vec2_normalize( vec2( 0.0f, 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( i, vec2_reflect( vec2_reflect( i, n ), n ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_reflect negates vector when incident equals normal" )
        vec2_t n = vec2_normalize( vec2( 0.8f, 0.6f ) );
        TESTFW_EXPECTED( vec2_eq( vec2_reflect( n, n ), vec2_neg( n ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_reflect leaves vector unchanged when perpendicular to normal" )
        vec2_t i = vec2( 1.0f, 0.0f );
        vec2_t n = vec2( 0.0f, 1.0f );
        TESTFW_EXPECTED( vec2_eq( vec2_reflect( i, n ), i ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_reflect result is invariant under normal direction" )
        vec2_t i = vec2( 3.0f, 4.0f );
        vec2_t n = vec2_normalize( vec2( 0.0f, 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vec2_reflect( i, n ), vec2_reflect( i, vec2_neg( n ) ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_reflect of zero vector is zero" )
        vec2_t n = vec2_normalize( vec2( 0.0f, 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vec2_reflect( vec2f( 0.0f ), n ), vec2f( 0.0f ) ) );
    TESTFW_TEST_END();

    // vec2_refract
    TESTFW_TEST_BEGIN( "vec2_refract returns zero when angle is too great for given refraction index" )
        vec2_t i = vec2_normalize( vec2( 1.0f, -0.5f ) );
        vec2_t n = vec2( 0.0f, 1.0f );
        TESTFW_EXPECTED( vec2_eq( vec2_refract( i, n, 1.5f ), vec2f( 0.0f ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_refract returns unchanged vector when normal is perpendicular and refraction index 1.0" )
        vec2_t i = vec2( 1.0f, 0.0f );
        vec2_t n = vec2( 0.0f, 1.0f );
        TESTFW_EXPECTED( vec2_eq( vec2_refract( i, n, 1.0f ), i ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_refract bends toward normal when entering denser medium" )
        vec2_t i = vec2_normalize( vec2( 1.0f, -1.0f ) );
        vec2_t n = vec2( 0.0f, 1.0f );
        TESTFW_EXPECTED( vec2_refract( i, n, 2.0f ).y > i.y );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_refract bends away from normal when entering rarer medium" )
        vec2_t i = vec2_normalize( vec2( 1.0f, -1.0f ) );
        vec2_t n = vec2( 0.0f, 1.0f );
        TESTFW_EXPECTED( vec2_refract( i, n, 0.5f ).y < i.y );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_refract result lies in same general direction as input" )
        vec2_t i = vec2_normalize( vec2( 1.0f, -1.0f ) );
        vec2_t n = vec2( 0.0f, 1.0f );
        TESTFW_EXPECTED( vec2_dot( i, vec2_refract( i, n, 1.2f ) ) > 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_refract of zero vector is zero" )
        vec2_t n = vec2( 0.0f, 1.0f );
        TESTFW_EXPECTED( vec2_eq( vec2_refract( vec2f( 0.0f ), n, 1.5f ), vec2f( 0.0f ) ) );
    TESTFW_TEST_END();

    // vec2_round
    TESTFW_TEST_BEGIN( "vec2_round rounds each component to nearest integer" )
        vec2_t a = vec2( 2.6f, -3.4f );
        vec2_t r = vec2_round( a );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == -3.0f );
    TESTFW_TEST_END();

    // vec2_rsqrt
    TESTFW_TEST_BEGIN( "vec2_rsqrt returns reciprocal square root of each component" )
        vec2_t a = vec2( 4.0f, 0.25f );
        vec2_t r = vec2_rsqrt( a );
        TESTFW_EXPECTED( r.x == 0.5f );
        TESTFW_EXPECTED( r.y == 2.0f );
    TESTFW_TEST_END();

    // vec2_saturate
    TESTFW_TEST_BEGIN( "vec2_saturate clamps each component to the [0, 1] range" )
        vec2_t a = vec2( -2.0f, 1.5f );
        vec2_t r = vec2_saturate( a );
        TESTFW_EXPECTED( r.x == 0.0f );
        TESTFW_EXPECTED( r.y == 1.0f );
    TESTFW_TEST_END();

    // vec2_sign
    TESTFW_TEST_BEGIN( "vec2_sign returns sign of each component" )
        vec2_t a = vec2( 3.5f, -2.0f );
        vec2_t r = vec2_sign( a );
        TESTFW_EXPECTED( r.x == 1.0f );
        TESTFW_EXPECTED( r.y == -1.0f );
    TESTFW_TEST_END();

    // vec2_sin
    TESTFW_TEST_BEGIN( "vec2_sin applies sin to each component" )
        vec2_t a = vec2( 0.5f, -2.0f );
        vec2_t r = vec2_sin( a );
        TESTFW_EXPECTED( r.x == 0.47942554f );
        TESTFW_EXPECTED( r.y == -0.90929743f );
    TESTFW_TEST_END();

    // vec2_sinh
    TESTFW_TEST_BEGIN( "vec2_sinh applies sinh to each component" )
        vec2_t a = vec2( 1.0f, -2.0f );
        vec2_t r = vec2_sinh( a );
        TESTFW_EXPECTED( r.x == 1.17520119f );
        TESTFW_EXPECTED( r.y == -3.62686041f );
    TESTFW_TEST_END();

    // vec2_smoothstep
    TESTFW_TEST_BEGIN( "vec2_smoothstep performs Hermite interpolation between a and b" )
        vec2_t a = vec2( 2.0f, 10.0f );
        vec2_t b = vec2( 6.0f, 14.0f );
        vec2_t t = vec2( 3.0f, 12.0f );
        vec2_t r = vec2_smoothstep( a, b, t );
        TESTFW_EXPECTED( r.x == 0.15625f );
        TESTFW_EXPECTED( r.y == 0.5f );
    TESTFW_TEST_END();

    // vec2_smootherstep
    TESTFW_TEST_BEGIN( "vec2_smootherstep performs quintic Hermite interpolation between a and b" )
        vec2_t a = vec2( 0.0f, 4.0f );
        vec2_t b = vec2( 8.0f, 12.0f );
        vec2_t t = vec2( 4.0f, 10.0f );
        vec2_t r = vec2_smootherstep( a, b, t );
        TESTFW_EXPECTED( r.x == 0.5f );
        TESTFW_EXPECTED( r.y == 0.89648438f );
    TESTFW_TEST_END();

    // vec2_sqrt
    TESTFW_TEST_BEGIN( "vec2_sqrt returns square root of each component" )
        vec2_t a = vec2( 16.0f, 0.25f );
        vec2_t r = vec2_sqrt( a );
        TESTFW_EXPECTED( r.x == 4.0f );
        TESTFW_EXPECTED( r.y == 0.5f );
    TESTFW_TEST_END();

    // vec2_step
    TESTFW_TEST_BEGIN( "vec2_step returns 0.0 or 1.0 per component based on threshold" )
        vec2_t a = vec2( 2.5f, 6.0f );
        vec2_t b = vec2( 3.0f, 5.0f );
        vec2_t r = vec2_step( a, b );
        TESTFW_EXPECTED( r.x == 1.0f );
        TESTFW_EXPECTED( r.y == 0.0f );
    TESTFW_TEST_END();

    // vec2_tan
    TESTFW_TEST_BEGIN( "vec2_tan applies tan to each component" )
        vec2_t a = vec2( 0.5f, -1.0f );
        vec2_t r = vec2_tan( a );
        TESTFW_EXPECTED( r.x == 0.54630249f );
        TESTFW_EXPECTED( r.y == -1.55740772f );
    TESTFW_TEST_END();

    // vec2_tanh
    TESTFW_TEST_BEGIN( "vec2_tanh applies tanh to each component" )
        vec2_t a = vec2( 1.0f, -2.0f );
        vec2_t r = vec2_tanh( a );
        TESTFW_EXPECTED( r.x == 0.76159416f );
        TESTFW_EXPECTED( r.y == -0.96402758f );
    TESTFW_TEST_END();

    // vec2_trunc
    TESTFW_TEST_BEGIN( "vec2_trunc removes fractional part of each component" )
        vec2_t a = vec2( 3.7f, -2.9f );
        vec2_t r = vec2_trunc( a );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == -2.0f );
    TESTFW_TEST_END();
}


void test_vec3( void ) {
    // vec3
    TESTFW_TEST_BEGIN( "vec3 constructs vector from distinct x, y, and z components" )
        vec3_t v = vec3( 1.0f, 2.0f, 3.0f );
        TESTFW_EXPECTED( v.x == 1.0f );
        TESTFW_EXPECTED( v.y == 2.0f );
        TESTFW_EXPECTED( v.z == 3.0f );
    TESTFW_TEST_END();

    // vec3f
    TESTFW_TEST_BEGIN( "vec3f constructs a vector with all components equal to input" )
        vec3_t v = vec3f( 3.5f );
        TESTFW_EXPECTED( v.x == 3.5f );
        TESTFW_EXPECTED( v.y == 3.5f );
        TESTFW_EXPECTED( v.z == 3.5f );
    TESTFW_TEST_END();

    // vec3v2f
    TESTFW_TEST_BEGIN("vec3v2f constructs a vector from vec2 and float")
        vec3_t v = vec3v2f( vec2( 1.5f, 2.5f ), 3.5f );
        TESTFW_EXPECTED( v.x == 1.5f );
        TESTFW_EXPECTED( v.y == 2.5f );
        TESTFW_EXPECTED( v.z == 3.5f );
    TESTFW_TEST_END();

    // vec3fv2
    TESTFW_TEST_BEGIN("vec3fv2 constructs a vector from float and vec2")
        vec3_t v = vec3fv2( 1.5f, vec2( 2.5f, 3.5f ) );
        TESTFW_EXPECTED( v.x == 1.5f );
        TESTFW_EXPECTED( v.y == 2.5f );
        TESTFW_EXPECTED( v.z == 3.5f );
    TESTFW_TEST_END();

    // vec3_get
    TESTFW_TEST_BEGIN( "vec3_get returns x, y, and z by index" )
        vec3_t v = vec3( 1.5f, -2.5f, 4.5f );
        TESTFW_EXPECTED( vec3_get( v, 0 ) == 1.5f );
        TESTFW_EXPECTED( vec3_get( v, 1 ) == -2.5f );
        TESTFW_EXPECTED( vec3_get( v, 2 ) == 4.5f );
    TESTFW_TEST_END();

    // vec3_set
    TESTFW_TEST_BEGIN( "vec3_set modifies only the indexed component" )
        vec3_t v = vec3( 1.0f, 2.0f, 3.0f );
        vec3_set( &v, 0, 9.0f );
        TESTFW_EXPECTED( v.x == 9.0f );
        TESTFW_EXPECTED( v.y == 2.0f );
        TESTFW_EXPECTED( v.z == 3.0f );

        v = vec3( 3.0f, 4.0f, 5.0f );
        vec3_set( &v, 1, -7.0f );
        TESTFW_EXPECTED( v.x == 3.0f );
        TESTFW_EXPECTED( v.y == -7.0f );
        TESTFW_EXPECTED( v.z == 5.0f );

        v = vec3( 6.0f, 7.0f, 8.0f );
        vec3_set( &v, 2, 0.0f );
        TESTFW_EXPECTED( v.x == 6.0f );
        TESTFW_EXPECTED( v.y == 7.0f );
        TESTFW_EXPECTED( v.z == 0.0f );
    TESTFW_TEST_END();

    // vec3_neg
    TESTFW_TEST_BEGIN( "vec3_neg negates each component of the input vector" )
        vec3_t v = vec3( 1.0f, -2.5f, 4.0f );
        vec3_t r = vec3_neg( v );
        TESTFW_EXPECTED( r.x == -1.0f );
        TESTFW_EXPECTED( r.y == 2.5f );
        TESTFW_EXPECTED( r.z == -4.0f );
    TESTFW_TEST_END();

    // vec3_eq
    TESTFW_TEST_BEGIN( "vec3_eq returns nonzero if all components are equal" )
        vec3_t a = vec3( 1.0f, 2.0f, 3.0f );
        vec3_t b = vec3( 1.0f, 2.0f, 3.0f );
        TESTFW_EXPECTED( vec3_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_eq returns zero if any component differs" )
        vec3_t a = vec3( 1.0f, 2.0f, 3.0f );
        vec3_t b = vec3( 1.0f, 2.0f, 4.0f );
        TESTFW_EXPECTED( vec3_eq( a, b ) == 0 );

        b = vec3( 1.0f, 4.0f, 3.0f );
        TESTFW_EXPECTED( vec3_eq( a, b ) == 0 );

        b = vec3( 5.0f, 2.0f, 3.0f );
        TESTFW_EXPECTED( vec3_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // vec3_add
    TESTFW_TEST_BEGIN( "vec3_add adds corresponding components of two vectors" )
        vec3_t a = vec3( 1.0f, 6.0f, -1.0f );
        vec3_t b = vec3( 4.0f, 9.0f, 2.0f );
        vec3_t r = vec3_add( a, b );
        TESTFW_EXPECTED( r.x == 5.0f ); 
        TESTFW_EXPECTED( r.y == 15.0f );
        TESTFW_EXPECTED( r.z == 1.0f ); 
    TESTFW_TEST_END();

    // vec3_sub
    TESTFW_TEST_BEGIN( "vec3_sub subtracts corresponding components of two vectors" )
        vec3_t a = vec3( 8.0f, 15.0f, 5.0f );
        vec3_t b = vec3( 3.0f, 4.0f, -2.0f );
        vec3_t r = vec3_sub( a, b );
        TESTFW_EXPECTED( r.x == 5.0f ); 
        TESTFW_EXPECTED( r.y == 11.0f );
        TESTFW_EXPECTED( r.z == 7.0f ); 
    TESTFW_TEST_END();

    // vec3_mul
    TESTFW_TEST_BEGIN( "vec3_mul multiplies corresponding components of two vectors" )
        vec3_t a = vec3( 2.0f, 5.0f, -3.0f );
        vec3_t b = vec3( 3.0f, 4.0f, 2.0f );
        vec3_t r = vec3_mul( a, b );
        TESTFW_EXPECTED( r.x == 6.0f ); 
        TESTFW_EXPECTED( r.y == 20.0f );
        TESTFW_EXPECTED( r.z == -6.0f );
    TESTFW_TEST_END();

    // vec3_div
    TESTFW_TEST_BEGIN( "vec3_div divides corresponding components of two vectors" )
        vec3_t a = vec3( 10.0f, 18.0f, -6.0f );
        vec3_t b = vec3( 2.0f, 3.0f, 2.0f );
        vec3_t r = vec3_div( a, b );
        TESTFW_EXPECTED( r.x == 5.0f ); 
        TESTFW_EXPECTED( r.y == 6.0f ); 
        TESTFW_EXPECTED( r.z == -3.0f );
    TESTFW_TEST_END();

    // vec3_addf
    TESTFW_TEST_BEGIN( "vec3_addf adds scalar to all components of vector" )
        vec3_t a = vec3( 2.0f, 5.0f, -1.0f );
        vec3_t r = vec3_addf( a, 3.0f );
        TESTFW_EXPECTED( r.x == 5.0f ); 
        TESTFW_EXPECTED( r.y == 8.0f ); 
        TESTFW_EXPECTED( r.z == 2.0f ); 
    TESTFW_TEST_END();

    // vec3_subf
    TESTFW_TEST_BEGIN( "vec3_subf subtracts scalar from all components of vector" )
        vec3_t a = vec3( 10.0f, 6.0f, 0.0f );
        vec3_t r = vec3_subf( a, 4.0f );
        TESTFW_EXPECTED( r.x == 6.0f ); 
        TESTFW_EXPECTED( r.y == 2.0f ); 
        TESTFW_EXPECTED( r.z == -4.0f );
    TESTFW_TEST_END();

    // vec3_mulf
    TESTFW_TEST_BEGIN( "vec3_mulf multiplies all components of vector by scalar" )
        vec3_t a = vec3( 2.0f, 5.0f, -3.0f );
        vec3_t r = vec3_mulf( a, 3.0f );
        TESTFW_EXPECTED( r.x == 6.0f ); 
        TESTFW_EXPECTED( r.y == 15.0f );
        TESTFW_EXPECTED( r.z == -9.0f );
    TESTFW_TEST_END();

    // vec3_divf
    TESTFW_TEST_BEGIN( "vec3_divf divides all components of vector by scalar" )
        vec3_t a = vec3( 12.0f, 18.0f, -6.0f );
        vec3_t r = vec3_divf( a, 3.0f );
        TESTFW_EXPECTED( r.x == 4.0f ); 
        TESTFW_EXPECTED( r.y == 6.0f ); 
        TESTFW_EXPECTED( r.z == -2.0f );
    TESTFW_TEST_END();

    // vec3_abs
    TESTFW_TEST_BEGIN( "vec3_abs applies absolute value to each component" )
        vec3_t a = vec3( -3.0f, -4.0f, 5.0f );
        vec3_t r = vec3_abs( a );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == 4.0f );
        TESTFW_EXPECTED( r.z == 5.0f );
    TESTFW_TEST_END();

    // vec3_acos
    TESTFW_TEST_BEGIN( "vec3_acos applies acos to each component" )
        vec3_t a = vec3( 0.5f, -1.0f, 1.0f );
        vec3_t r = vec3_acos( a );
        TESTFW_EXPECTED( test_cmp( r.x, 1.04719758f ) );
        TESTFW_EXPECTED( test_cmp( r.y, 3.14159265f ) );
        TESTFW_EXPECTED( test_cmp( r.z, 0.00000000f ) );
    TESTFW_TEST_END();

    // vec3_all
    TESTFW_TEST_BEGIN( "vec3_all returns nonzero only if all components are nonzero" )
        TESTFW_EXPECTED( vec3_all( vec3( 1.0f, 1.0f, 1.0f ) ) != 0 );
        TESTFW_EXPECTED( vec3_all( vec3( 1.0f, 0.0f, 1.0f ) ) == 0 );
        TESTFW_EXPECTED( vec3_all( vec3( 0.0f, 1.0f, 1.0f ) ) == 0 );
        TESTFW_EXPECTED( vec3_all( vec3( 1.0f, 1.0f, 0.0f ) ) == 0 );
        TESTFW_EXPECTED( vec3_all( vec3( 0.0f, 0.0f, 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // vec3_any
    TESTFW_TEST_BEGIN( "vec3_any returns nonzero if any component is nonzero" )
        TESTFW_EXPECTED( vec3_any( vec3( 1.0f, 1.0f, 1.0f ) ) != 0 );
        TESTFW_EXPECTED( vec3_any( vec3( 1.0f, 0.0f, 0.0f ) ) != 0 );
        TESTFW_EXPECTED( vec3_any( vec3( 0.0f, 1.0f, 0.0f ) ) != 0 );
        TESTFW_EXPECTED( vec3_any( vec3( 0.0f, 0.0f, 1.0f ) ) != 0 );
        TESTFW_EXPECTED( vec3_any( vec3( 0.0f, 0.0f, 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // vec3_asin
    TESTFW_TEST_BEGIN( "vec3_asin applies asin to each component" )
        vec3_t a = vec3( 0.5f, -1.0f, 1.0f );
        vec3_t r = vec3_asin( a );
        TESTFW_EXPECTED( test_cmp( r.x, 0.52359878f ));
        TESTFW_EXPECTED( test_cmp( r.y, -1.57079633f ));
        TESTFW_EXPECTED( test_cmp( r.z, 1.57079633f ));
    TESTFW_TEST_END();

    // vec3_atan
    TESTFW_TEST_BEGIN( "vec3_atan applies atan to each component" )
        vec3_t a = vec3( 0.5f, -2.0f, 1.0f );
        vec3_t r = vec3_atan( a );
        TESTFW_EXPECTED( r.x == 0.46364761f );
        TESTFW_EXPECTED( r.y == -1.10714872f );
        TESTFW_EXPECTED( r.z == 0.78539816f );
    TESTFW_TEST_END();

    // vec3_atan2
    TESTFW_TEST_BEGIN( "vec3_atan2 applies atan2 to each pair of components" )
        vec3_t y = vec3( 2.0f, -3.0f, 1.0f );
        vec3_t x = vec3( 1.0f, -4.0f, 4.0f );
        vec3_t r = vec3_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x, 1.10714872f ));
        TESTFW_EXPECTED( test_cmp( r.y, -2.49809154f ));
        TESTFW_EXPECTED( test_cmp( r.z, 0.24497866f )); 
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_atan2 handles distinct signs and quadrants" )
        vec3_t y = vec3( 3.0f, -2.0f, 0.0f );
        vec3_t x = vec3( -2.0f, 5.0f, -1.0f );
        vec3_t r = vec3_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x, 2.15879893f )); 
        TESTFW_EXPECTED( test_cmp( r.y, -0.38050638f ));
        TESTFW_EXPECTED( test_cmp( r.z, 3.14159265f )); 
    TESTFW_TEST_END();

    // vec3_ceil
    TESTFW_TEST_BEGIN( "vec3_ceil applies ceil to each component" )
        vec3_t v = vec3( 1.2f, -3.7f, 0.0f );
        vec3_t r = vec3_ceil( v );
        TESTFW_EXPECTED( r.x == 2.0f ); 
        TESTFW_EXPECTED( r.y == -3.0f );
        TESTFW_EXPECTED( r.z == 0.0f ); 
    TESTFW_TEST_END();

    // vec3_clamp
    TESTFW_TEST_BEGIN( "vec3_clamp clamps each component using corresponding min and max" )
        vec3_t v = vec3( 5.0f, -10.0f, 2.5f );
        vec3_t min = vec3( 0.0f, -8.0f, -1.0f );
        vec3_t max = vec3( 4.0f, -7.0f, 1.0f );
        vec3_t r = vec3_clamp( v, min, max );
        TESTFW_EXPECTED( r.x == 4.0f ); 
        TESTFW_EXPECTED( r.y == -8.0f );
        TESTFW_EXPECTED( r.z == 1.0f );
    TESTFW_TEST_END();

    // vec3_cos
    TESTFW_TEST_BEGIN( "vec3_cos applies cos to each component" )
        vec3_t a = vec3( 0.5f, 2.0f, 3.14159265f );
        vec3_t r = vec3_cos( a );
        TESTFW_EXPECTED( r.x == 0.87758256f ); 
        TESTFW_EXPECTED( r.y == -0.41614684f );
        TESTFW_EXPECTED( r.z == -1.00000000f );
    TESTFW_TEST_END();

    // vec3_cosh
    TESTFW_TEST_BEGIN( "vec3_cosh applies cosh to each component" )
        vec3_t a = vec3( 0.5f, 2.0f, 1.0f );
        vec3_t r = vec3_cosh( a );
        TESTFW_EXPECTED( test_cmp( r.x, 1.12762597f )); 
        TESTFW_EXPECTED( test_cmp( r.y, 3.76219569f )); 
        TESTFW_EXPECTED( test_cmp( r.z, 1.54308063f )); 
    TESTFW_TEST_END();

    // vec3_cross
    TESTFW_TEST_BEGIN( "vec3_cross computes the 3D cross product correctly" )
        vec3_t a = vec3( 1.0f, 0.0f, 0.0f );
        vec3_t b = vec3( 0.0f, 1.0f, 0.0f );
        vec3_t r = vec3_cross( a, b );
        TESTFW_EXPECTED( r.x == 0.0f );
        TESTFW_EXPECTED( r.y == 0.0f );
        TESTFW_EXPECTED( r.z == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_cross returns zero vector for parallel inputs" )
        vec3_t a = vec3( 2.0f, 4.0f, 6.0f );
        vec3_t b = vec3( 4.0f, 8.0f, 12.0f );
        vec3_t r = vec3_cross( a, b );
        TESTFW_EXPECTED( r.x == 0.0f );
        TESTFW_EXPECTED( r.y == 0.0f );
        TESTFW_EXPECTED( r.z == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_cross handles orientation and sign" )
        vec3_t a = vec3( 0.0f, 1.0f, 0.0f );
        vec3_t b = vec3( 0.0f, 0.0f, 1.0f );
        vec3_t r = vec3_cross( a, b );
        TESTFW_EXPECTED( r.x == 1.0f ); 
        TESTFW_EXPECTED( r.y == 0.0f );
        TESTFW_EXPECTED( r.z == 0.0f );
    TESTFW_TEST_END();

    // vec3_degrees
    TESTFW_TEST_BEGIN( "vec3_degrees converts radians to degrees component-wise" )
        vec3_t a = vec3( 0.5f, -2.0f, 1.0f );
        vec3_t r = vec3_degrees( a );
        TESTFW_EXPECTED( r.x == 28.6478898f ); 
        TESTFW_EXPECTED( r.y == -114.591559f );
        TESTFW_EXPECTED( r.z == 57.2957795f ); 
    TESTFW_TEST_END();

    // vec3_distancesq
    TESTFW_TEST_BEGIN( "vec3_distancesq returns squared distance between vectors" )
        vec3_t a = vec3( 3.0f, 4.0f, 0.0f );
        vec3_t b = vec3f( 0.0f );
        float r = vec3_distancesq( a, b );
        TESTFW_EXPECTED( r == 25.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_distancesq is zero when vectors are equal" )
        vec3_t a = vec3( 3.0f, 7.0f, 0.0f );
        float r = vec3_distancesq( a, a );
        TESTFW_EXPECTED( r == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_distancesq is symmetric in its arguments" )
        vec3_t a = vec3( -1.0f, 2.0f, 3.0f );
        vec3_t b = vec3( 4.0f, -3.0f, 0.0f );
        float d1 = vec3_distancesq( a, b );
        float d2 = vec3_distancesq( b, a );
        TESTFW_EXPECTED( d1 == d2 );
    TESTFW_TEST_END();

    // vec3_distance
    TESTFW_TEST_BEGIN( "vec3_distance returns Euclidean distance between vectors" )
        vec3_t a = vec3( 3.0f, 4.0f, 0.0f );
        vec3_t b = vec3f( 0.0f );
        float r = vec3_distance( a, b );
        TESTFW_EXPECTED( r == 5.0f ); 
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_distance is zero when vectors are equal" )
        vec3_t a = vec3( 3.0f, 7.0f, 5.0f );
        float r = vec3_distance( a, a );
        TESTFW_EXPECTED( r == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_distance is symmetric in its arguments" )
        vec3_t a = vec3( -1.0f, 2.0f, 3.0f );
        vec3_t b = vec3( 4.0f, -3.0f, 0.0f );
        float d1 = vec3_distance( a, b );
        float d2 = vec3_distance( b, a );
        TESTFW_EXPECTED( d1 == d2 );
    TESTFW_TEST_END();

    // vec3_dot
    TESTFW_TEST_BEGIN( "vec3_dot returns sum of products of corresponding components" )
        vec3_t a = vec3( 1.0f, 1.0f, 2.0f );
        vec3_t b = vec3( 1.0f, 1.0f, 1.0f );
        float r = vec3_dot( a, b );
        TESTFW_EXPECTED( r == 4.0f ); 
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_dot is symmetric in its arguments" )
        vec3_t a = vec3( -1.0f, 5.0f, 2.0f );
        vec3_t b = vec3( 7.0f, 2.0f, -3.0f );
        float d1 = vec3_dot( a, b );
        float d2 = vec3_dot( b, a );
        TESTFW_EXPECTED( d1 == d2 );
    TESTFW_TEST_END();

    // vec3_exp
    TESTFW_TEST_BEGIN( "vec3_exp applies exp to each component" )
        vec3_t a = vec3( 0.5f, -2.0f, 1.0f );
        vec3_t r = vec3_exp( a );
        TESTFW_EXPECTED( r.x == 1.64872127f );
        TESTFW_EXPECTED( r.y == 0.13533528f );
        TESTFW_EXPECTED( r.z == 2.71828183f );
    TESTFW_TEST_END();

    // vec3_exp2
    TESTFW_TEST_BEGIN( "vec3_exp2 applies exp2 to each component" )
        vec3_t a = vec3( 3.0f, -2.0f, 1.0f );
        vec3_t r = vec3_exp2( a );
        TESTFW_EXPECTED( r.x == 8.0f );
        TESTFW_EXPECTED( r.y == 0.25f );
        TESTFW_EXPECTED( r.z == 2.0f );
    TESTFW_TEST_END();

    // vec3_floor
    TESTFW_TEST_BEGIN( "vec3_floor applies floor to each component" )
        vec3_t a = vec3( 2.7f, -3.2f, 0.0f );
        vec3_t r = vec3_floor( a );
        TESTFW_EXPECTED( r.x == 2.0f );
        TESTFW_EXPECTED( r.y == -4.0f );
        TESTFW_EXPECTED( r.z == 0.0f ); 
    TESTFW_TEST_END();

    // vec3_fmod
    TESTFW_TEST_BEGIN( "vec3_fmod applies fmod to each pair of components" )
        vec3_t a = vec3( 6.5f, -5.0f, 7.75f );
        vec3_t b = vec3( 2.0f, 3.0f, 2.5f );
        vec3_t r = vec3_fmod( a, b );
        TESTFW_EXPECTED( r.x == 0.5f );
        TESTFW_EXPECTED( r.y == -2.0f );
        TESTFW_EXPECTED( r.z == 0.25f );
    TESTFW_TEST_END();

    // vec3_frac
    TESTFW_TEST_BEGIN( "vec3_frac returns fractional part of each component" )
        vec3_t a = vec3( 3.75f, -2.25f, 1.5f );
        vec3_t r = vec3_frac( a );
        TESTFW_EXPECTED( r.x == 0.75f );
        TESTFW_EXPECTED( r.y == 0.25f );
        TESTFW_EXPECTED( r.z == 0.5f ); 
    TESTFW_TEST_END();

    // vec3_lengthsq
    TESTFW_TEST_BEGIN( "vec3_lengthsq returns sum of squared components" )
        vec3_t a = vec3( 3.0f, -4.0f, 12.0f );
        float r = vec3_lengthsq( a );
        TESTFW_EXPECTED( r == 169.0f ); 
    TESTFW_TEST_END();

    // vec3_length
    TESTFW_TEST_BEGIN( "vec3_length returns Euclidean length of vector" )
        vec3_t a = vec3( 3.0f, -4.0f, 12.0f );
        float r = vec3_length( a );
        TESTFW_EXPECTED( r == 13.0f ); 
    TESTFW_TEST_END();

    // vec3_lerp
    TESTFW_TEST_BEGIN( "vec3_lerp linearly interpolates between vectors component-wise" )
        vec3_t a = vec3( 2.0f, -4.0f, 0.0f );
        vec3_t b = vec3( 6.0f, 8.0f, 4.0f );
        vec3_t r = vec3_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x == 3.0f ); 
        TESTFW_EXPECTED( r.y == -1.0f );
        TESTFW_EXPECTED( r.z == 1.0f ); 
    TESTFW_TEST_END();

    // vec3_log
    TESTFW_TEST_BEGIN( "vec3_log applies natural log to each component" )
        vec3_t a = vec3( 7.38905610f, 54.5981500f, 20.085537f );
        vec3_t r = vec3_log( a );
        TESTFW_EXPECTED( r.x == 2.0f ); 
        TESTFW_EXPECTED( r.y == 4.0f ); 
        TESTFW_EXPECTED( r.z == 3.0f ); 
    TESTFW_TEST_END();

    // vec3_log2
    TESTFW_TEST_BEGIN( "vec3_log2 applies base-2 logarithm to each component" )
        vec3_t a = vec3( 16.0f, 0.25f, 2.0f );
        vec3_t r = vec3_log2( a );
        TESTFW_EXPECTED( r.x == 4.0f ); 
        TESTFW_EXPECTED( r.y == -2.0f );
        TESTFW_EXPECTED( r.z == 1.0f ); 
    TESTFW_TEST_END();

    // vec3_log10
    TESTFW_TEST_BEGIN( "vec3_log10 applies base-10 logarithm to each component" )
        vec3_t a = vec3( 100.0f, 0.001f, 10.0f );
        vec3_t r = vec3_log10( a );
        TESTFW_EXPECTED( r.x == 2.0f ); 
        TESTFW_EXPECTED( r.y == -3.0f );
        TESTFW_EXPECTED( r.z == 1.0f ); 
    TESTFW_TEST_END();

    // vec3_max
    TESTFW_TEST_BEGIN( "vec3_max returns component-wise maximum of two vectors" )
        vec3_t a = vec3( 3.0f, -5.0f, 7.0f );
        vec3_t b = vec3( 2.0f, -4.0f, 8.0f );
        vec3_t r = vec3_max( a, b );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == -4.0f );
        TESTFW_EXPECTED( r.z == 8.0f );
    TESTFW_TEST_END();

    // vec3_min
    TESTFW_TEST_BEGIN( "vec3_min returns component-wise minimum of two vectors" )
        vec3_t a = vec3( 3.0f, -5.0f, 7.0f );
        vec3_t b = vec3( 2.0f, -4.0f, 8.0f );
        vec3_t r = vec3_min( a, b );
        TESTFW_EXPECTED( r.x == 2.0f );
        TESTFW_EXPECTED( r.y == -5.0f );
        TESTFW_EXPECTED( r.z == 7.0f );
    TESTFW_TEST_END();

    // vec3_normalize
    TESTFW_TEST_BEGIN( "vec3_normalize returns vector of unit length in same direction" )
        vec3_t a = vec3( 3.0f, 4.0f, 12.0f );
        vec3_t r = vec3_normalize( a );
        TESTFW_EXPECTED( r.x == 0.23076923f );
        TESTFW_EXPECTED( r.y == 0.30769231f );
        TESTFW_EXPECTED( r.z == 0.92307692f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_normalize returns zero vector when input is zero" )
        vec3_t a = vec3f( 0.0f );
        vec3_t r = vec3_normalize( a );
        TESTFW_EXPECTED( r.x == 0.0f );
        TESTFW_EXPECTED( r.y == 0.0f );
        TESTFW_EXPECTED( r.z == 0.0f );
    TESTFW_TEST_END();

    // vec3_pow
    TESTFW_TEST_BEGIN( "vec3_pow applies pow to each pair of components" )
        vec3_t a = vec3( 4.0f, 9.0f, 16.0f );
        vec3_t b = vec3( 0.5f, 0.5f, 0.5f );
        vec3_t r = vec3_pow( a, b );
        TESTFW_EXPECTED( r.x == 2.0f );
        TESTFW_EXPECTED( r.y == 3.0f );
        TESTFW_EXPECTED( r.z == 4.0f );
    TESTFW_TEST_END();

    // vec3_radians
    TESTFW_TEST_BEGIN( "vec3_radians converts degrees to radians component-wise" )
        vec3_t a = vec3( 90.0f, -45.0f, 180.0f );
        vec3_t r = vec3_radians( a );
        TESTFW_EXPECTED( r.x == 1.57079633f );
        TESTFW_EXPECTED( r.y == -0.78539816f );
        TESTFW_EXPECTED( r.z == 3.14159265f );
    TESTFW_TEST_END();

    // vec3_rcp
    TESTFW_TEST_BEGIN( "vec3_rcp returns per-component reciprocal" )
        vec3_t a = vec3( 4.0f, -0.5f, 2.0f );
        vec3_t r = vec3_rcp( a );
        TESTFW_EXPECTED( r.x == 0.25f );
        TESTFW_EXPECTED( r.y == -2.0f );
        TESTFW_EXPECTED( r.z == 0.5f );
    TESTFW_TEST_END();

    // vec3_reflect
    TESTFW_TEST_BEGIN( "vec3_reflect preserves length for normalized normal" )
        vec3_t i = vec3( 3.0f, 4.0f, 0.0f );
        vec3_t n = vec3_normalize( vec3( 0.0f, 1.0f, 1.0f ) );
        TESTFW_EXPECTED( vec3_length( i ) == vec3_length( vec3_reflect( i, n ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_reflect is identity when reflected twice" )
        vec3_t i = vec3( 2.0f, -5.0f, 1.0f );
        vec3_t n = vec3_normalize( vec3( 0.0f, 1.0f, 0.0f ) );
        TESTFW_EXPECTED( vec3_eq( i, vec3_reflect( vec3_reflect( i, n ), n ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_reflect negates vector when incident equals normal" )
        vec3_t n = vec3_normalize( vec3( 0.8f, 0.6f, 0.0f ) );
        TESTFW_EXPECTED( vec3_eq( vec3_reflect( n, n ), vec3_neg( n ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_reflect leaves vector unchanged when perpendicular to normal" )
        vec3_t i = vec3( 1.0f, 0.0f, 0.0f );
        vec3_t n = vec3( 0.0f, 1.0f, 0.0f );
        TESTFW_EXPECTED( vec3_eq( vec3_reflect( i, n ), i ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_reflect result is invariant under normal direction" )
        vec3_t i = vec3( 3.0f, 4.0f, 5.0f );
        vec3_t n = vec3_normalize( vec3( 0.0f, 1.0f, 0.0f ) );
        TESTFW_EXPECTED( vec3_eq( vec3_reflect( i, n ), vec3_reflect( i, vec3_neg( n ) ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_reflect of zero vector is zero" )
        vec3_t n = vec3_normalize( vec3( 0.0f, 1.0f, 0.0f ) );
        TESTFW_EXPECTED( vec3_eq( vec3_reflect( vec3f( 0.0f ), n ), vec3f( 0.0f ) ) );
    TESTFW_TEST_END();

    // vec3_refract
    TESTFW_TEST_BEGIN( "vec3_refract returns zero when angle is too great for given refraction index" )
        vec3_t i = vec3_normalize( vec3( 1.0f, -0.5f, 0.5f ) );
        vec3_t n = vec3( 0.0f, 1.0f, 0.0f );
        TESTFW_EXPECTED( vec3_eq( vec3_refract( i, n, 1.5f ), vec3f( 0.0f ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_refract returns unchanged vector when normal is perpendicular and refraction index 1.0" )
        vec3_t i = vec3( 1.0f, 0.0f, 0.0f );
        vec3_t n = vec3( 0.0f, 1.0f, 0.0f );
        TESTFW_EXPECTED( vec3_eq( vec3_refract( i, n, 1.0f ), i ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_refract bends toward normal when entering denser medium" )
        vec3_t i = vec3_normalize( vec3( 1.0f, -1.0f, 0.0f ) );
        vec3_t n = vec3( 0.0f, 1.0f, 0.0f );
        TESTFW_EXPECTED( vec3_refract( i, n, 2.0f ).y > i.y );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_refract bends away from normal when entering rarer medium" )
        vec3_t i = vec3_normalize( vec3( 1.0f, -1.0f, 0.0f ) );
        vec3_t n = vec3( 0.0f, 1.0f, 0.0f );
        TESTFW_EXPECTED( vec3_refract( i, n, 0.5f ).y < i.y );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_refract result lies in same general direction as input" )
        vec3_t i = vec3_normalize( vec3( 1.0f, -1.0f, 1.0f ) );
        vec3_t n = vec3( 0.0f, 1.0f, 0.0f );
        TESTFW_EXPECTED( vec3_dot( i, vec3_refract( i, n, 1.2f ) ) > 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_refract of zero vector is zero" )
        vec3_t n = vec3( 0.0f, 1.0f, 0.0f );
        TESTFW_EXPECTED( vec3_eq( vec3_refract( vec3f( 0.0f ), n, 1.5f ), vec3f( 0.0f ) ) );
    TESTFW_TEST_END();

    // vec3_round
    TESTFW_TEST_BEGIN( "vec3_round rounds each component to nearest integer" )
        vec3_t a = vec3( 2.6f, -3.4f, 0.0f );
        vec3_t r = vec3_round( a );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == -3.0f );
        TESTFW_EXPECTED( r.z == 0.0f );
    TESTFW_TEST_END();

    // vec3_rsqrt
    TESTFW_TEST_BEGIN( "vec3_rsqrt returns reciprocal square root of each component" )
        vec3_t a = vec3( 4.0f, 0.25f, 1.0f );
        vec3_t r = vec3_rsqrt( a );
        TESTFW_EXPECTED( r.x == 0.5f );
        TESTFW_EXPECTED( r.y == 2.0f );
        TESTFW_EXPECTED( r.z == 1.0f );
    TESTFW_TEST_END();

    // vec3_saturate
    TESTFW_TEST_BEGIN( "vec3_saturate clamps each component to the [0, 1] range" )
        vec3_t a = vec3( -2.0f, 1.5f, 0.5f );
        vec3_t r = vec3_saturate( a );
        TESTFW_EXPECTED( r.x == 0.0f );
        TESTFW_EXPECTED( r.y == 1.0f );
        TESTFW_EXPECTED( r.z == 0.5f );
    TESTFW_TEST_END();

    // vec3_sign
    TESTFW_TEST_BEGIN( "vec3_sign returns sign of each component" )
        vec3_t a = vec3( 3.5f, -2.0f, 0.0f );
        vec3_t r = vec3_sign( a );
        TESTFW_EXPECTED( r.x == 1.0f );
        TESTFW_EXPECTED( r.y == -1.0f );
        TESTFW_EXPECTED( r.z == 0.0f );
    TESTFW_TEST_END();

    // vec3_sin
    TESTFW_TEST_BEGIN( "vec3_sin applies sin to each component" )
        vec3_t a = vec3( 0.5f, -2.0f, 1.57079633f );
        vec3_t r = vec3_sin( a );
        TESTFW_EXPECTED( r.x == 0.47942554f );
        TESTFW_EXPECTED( r.y == -0.90929743f );
        TESTFW_EXPECTED( r.z == 1.00000000f ); 
    TESTFW_TEST_END();

    // vec3_sinh
    TESTFW_TEST_BEGIN( "vec3_sinh applies sinh to each component" )
        vec3_t a = vec3( 1.0f, -2.0f, 0.0f );
        vec3_t r = vec3_sinh( a );
        TESTFW_EXPECTED( r.x == 1.17520119f ); 
        TESTFW_EXPECTED( r.y == -3.62686041f );
        TESTFW_EXPECTED( r.z == 0.00000000f ); 
    TESTFW_TEST_END();

    // vec3_smoothstep
    TESTFW_TEST_BEGIN( "vec3_smoothstep performs Hermite interpolation between a and b" )
        vec3_t a = vec3( 0.0f, 0.0f, 0.0f );
        vec3_t b = vec3( 4.0f, 4.0f, 4.0f );
        vec3_t t = vec3( 1.0f, 2.0f, 3.0f );
        vec3_t r = vec3_smoothstep( a, b, t );
        TESTFW_EXPECTED( r.x == 0.15625f );
        TESTFW_EXPECTED( r.y == 0.50000f );
        TESTFW_EXPECTED( r.z == 0.84375f );
    TESTFW_TEST_END();

    // vec3_smootherstep
    TESTFW_TEST_BEGIN( "vec3_smootherstep performs quintic Hermite interpolation between a and b" )
        vec3_t a = vec3( 0.0f, 0.0f, 0.0f );
        vec3_t b = vec3( 5.0f, 5.0f, 5.0f );
        vec3_t t = vec3( 1.0f, 2.5f, 4.0f );
        vec3_t r = vec3_smootherstep( a, b, t );
        TESTFW_EXPECTED( test_cmp( r.x, 0.05792000f ));
        TESTFW_EXPECTED( test_cmp( r.y, 0.50000000f ));
        TESTFW_EXPECTED( test_cmp( r.z, 0.94208014f ));
    TESTFW_TEST_END();

    // vec3_sqrt
    TESTFW_TEST_BEGIN( "vec3_sqrt returns square root of each component" )
        vec3_t a = vec3( 16.0f, 0.25f, 9.0f );
        vec3_t r = vec3_sqrt( a );
        TESTFW_EXPECTED( r.x == 4.0f );
        TESTFW_EXPECTED( r.y == 0.5f );
        TESTFW_EXPECTED( r.z == 3.0f );
    TESTFW_TEST_END();

    // vec3_step
    TESTFW_TEST_BEGIN( "vec3_step returns 0.0 or 1.0 per component based on threshold" )
        vec3_t edge = vec3( 2.5f, 6.0f, 4.0f );
        vec3_t x = vec3( 3.0f, 5.0f, 4.0f );
        vec3_t r = vec3_step( edge, x );
        TESTFW_EXPECTED( r.x == 1.0f ); 
        TESTFW_EXPECTED( r.y == 0.0f ); 
        TESTFW_EXPECTED( r.z == 1.0f ); 
    TESTFW_TEST_END();

    // vec3_tan
    TESTFW_TEST_BEGIN( "vec3_tan applies tan to each component" )
        vec3_t a = vec3( 0.5f, -1.0f, 1.0f );
        vec3_t r = vec3_tan( a );
        TESTFW_EXPECTED( r.x == 0.54630249f ); 
        TESTFW_EXPECTED( r.y == -1.55740772f );
        TESTFW_EXPECTED( r.z == 1.55740772f ); 
    TESTFW_TEST_END();

    // vec3_tanh
    TESTFW_TEST_BEGIN( "vec3_tanh applies tanh to each component" )
        vec3_t a = vec3( 1.0f, -2.0f, 0.0f );
        vec3_t r = vec3_tanh( a );
        TESTFW_EXPECTED( r.x == 0.76159416f ); 
        TESTFW_EXPECTED( r.y == -0.96402758f );
        TESTFW_EXPECTED( r.z == 0.00000000f );
    TESTFW_TEST_END();

    // vec3_trunc
    TESTFW_TEST_BEGIN( "vec3_trunc removes fractional part of each component" )
        vec3_t a = vec3( 3.7f, -2.9f, 0.5f );
        vec3_t r = vec3_trunc( a );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == -2.0f );
        TESTFW_EXPECTED( r.z == 0.0f );
    TESTFW_TEST_END();
}


void test_vec4( void ) {
    // vec4
    TESTFW_TEST_BEGIN( "vec4 constructs vector from distinct x, y, z, and w components" )
        vec4_t v = vec4( 1.0f, 2.0f, 3.0f, 4.0f );
        TESTFW_EXPECTED( v.x == 1.0f );
        TESTFW_EXPECTED( v.y == 2.0f );
        TESTFW_EXPECTED( v.z == 3.0f );
        TESTFW_EXPECTED( v.w == 4.0f );
    TESTFW_TEST_END();

    // vec4f
    TESTFW_TEST_BEGIN( "vec4f constructs a vector with all components equal to input" )
        vec4_t v = vec4f( 3.5f );
        TESTFW_EXPECTED( v.x == 3.5f );
        TESTFW_EXPECTED( v.y == 3.5f );
        TESTFW_EXPECTED( v.z == 3.5f );
        TESTFW_EXPECTED( v.w == 3.5f );
    TESTFW_TEST_END();

    // vec4v2
    TESTFW_TEST_BEGIN( "vec4v2 constructs a vector from two vec2" )
        vec4_t v = vec4v2( vec2( 1.5f, 2.5f ), vec2( 3.5f, 4.5f ) );
        TESTFW_EXPECTED( v.x == 1.5f );
        TESTFW_EXPECTED( v.y == 2.5f );
        TESTFW_EXPECTED( v.z == 3.5f );
        TESTFW_EXPECTED( v.w == 4.5f );
    TESTFW_TEST_END();

    // vec4v3f
    TESTFW_TEST_BEGIN( "vec4v3f constructs a vector from vec3 and float" )
        vec4_t v = vec4v3f( vec3( 1.5f, 2.5f, 3.5f ), 4.5f );
        TESTFW_EXPECTED( v.x == 1.5f );
        TESTFW_EXPECTED( v.y == 2.5f );
        TESTFW_EXPECTED( v.z == 3.5f );
        TESTFW_EXPECTED( v.w == 4.5f );
    TESTFW_TEST_END();

    // vec4fv3
    TESTFW_TEST_BEGIN( "vec4fv3 constructs a vector from float and vec3" )
        vec4_t v = vec4fv3( 1.5f, vec3( 2.5f, 3.5f, 4.5f ) );
        TESTFW_EXPECTED( v.x == 1.5f );
        TESTFW_EXPECTED( v.y == 2.5f );
        TESTFW_EXPECTED( v.z == 3.5f );
        TESTFW_EXPECTED( v.w == 4.5f );
    TESTFW_TEST_END();

    // vec4_get
    TESTFW_TEST_BEGIN( "vec4_get returns x, y, z, and w by index" )
        vec4_t v = vec4( 1.5f, -2.5f, 4.5f, -6.5f );
        TESTFW_EXPECTED( vec4_get( v, 0 ) == 1.5f );
        TESTFW_EXPECTED( vec4_get( v, 1 ) == -2.5f );
        TESTFW_EXPECTED( vec4_get( v, 2 ) == 4.5f );
        TESTFW_EXPECTED( vec4_get( v, 3 ) == -6.5f );
    TESTFW_TEST_END();

    // vec4_set
    TESTFW_TEST_BEGIN( "vec4_set modifies only the indexed component" )
        vec4_t v = vec4( 1.0f, 2.0f, 3.0f, 4.0f );
        vec4_set( &v, 0, 9.0f );
        TESTFW_EXPECTED( v.x == 9.0f ); TESTFW_EXPECTED( v.y == 2.0f ); TESTFW_EXPECTED( v.z == 3.0f ); TESTFW_EXPECTED( v.w == 4.0f );

        v = vec4( 3.0f, 4.0f, 5.0f, 6.0f );
        vec4_set( &v, 1, -7.0f );
        TESTFW_EXPECTED( v.x == 3.0f ); TESTFW_EXPECTED( v.y == -7.0f ); TESTFW_EXPECTED( v.z == 5.0f ); TESTFW_EXPECTED( v.w == 6.0f );

        v = vec4( 6.0f, 7.0f, 8.0f, 9.0f );
        vec4_set( &v, 2, 0.0f );
        TESTFW_EXPECTED( v.x == 6.0f ); TESTFW_EXPECTED( v.y == 7.0f ); TESTFW_EXPECTED( v.z == 0.0f ); TESTFW_EXPECTED( v.w == 9.0f );

        v = vec4( 1.0f, 2.0f, 3.0f, 4.0f );
        vec4_set( &v, 3, 5.5f );
        TESTFW_EXPECTED( v.x == 1.0f ); TESTFW_EXPECTED( v.y == 2.0f ); TESTFW_EXPECTED( v.z == 3.0f ); TESTFW_EXPECTED( v.w == 5.5f );
    TESTFW_TEST_END();

    // vec4_neg
    TESTFW_TEST_BEGIN( "vec4_neg negates each component of the input vector" )
        vec4_t v = vec4( 1.0f, -2.5f, 4.0f, -8.0f );
        vec4_t r = vec4_neg( v );
        TESTFW_EXPECTED( r.x == -1.0f ); TESTFW_EXPECTED( r.y == 2.5f ); TESTFW_EXPECTED( r.z == -4.0f ); TESTFW_EXPECTED( r.w == 8.0f );
    TESTFW_TEST_END();

    // vec4_eq
    TESTFW_TEST_BEGIN( "vec4_eq returns nonzero if all components are equal" )
        vec4_t a = vec4( 1.0f, 2.0f, 3.0f, 4.0f );
        vec4_t b = vec4( 1.0f, 2.0f, 3.0f, 4.0f );
        TESTFW_EXPECTED( vec4_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_eq returns zero if any component differs" )
        vec4_t a = vec4( 1.0f, 2.0f, 3.0f, 4.0f );
        vec4_t b = vec4( 1.0f, 2.0f, 3.0f, 5.0f );
        TESTFW_EXPECTED( vec4_eq( a, b ) == 0 );
        b = vec4( 1.0f, 2.0f, 4.0f, 4.0f );
        TESTFW_EXPECTED( vec4_eq( a, b ) == 0 );
        b = vec4( 1.0f, 3.0f, 3.0f, 4.0f );
        TESTFW_EXPECTED( vec4_eq( a, b ) == 0 );
        b = vec4( 5.0f, 2.0f, 3.0f, 4.0f );
        TESTFW_EXPECTED( vec4_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // vec4_add
    TESTFW_TEST_BEGIN( "vec4_add adds corresponding components of two vectors" )
        vec4_t a = vec4( 1.0f, 6.0f, -1.0f, 2.0f );
        vec4_t b = vec4( 4.0f, 9.0f, 2.0f, 3.0f );
        vec4_t r = vec4_add( a, b );
        TESTFW_EXPECTED( r.x == 5.0f ); TESTFW_EXPECTED( r.y == 15.0f ); TESTFW_EXPECTED( r.z == 1.0f ); TESTFW_EXPECTED( r.w == 5.0f );
    TESTFW_TEST_END();

    // vec4_sub
    TESTFW_TEST_BEGIN( "vec4_sub subtracts corresponding components of two vectors" )
        vec4_t a = vec4( 8.0f, 15.0f, 5.0f, 6.0f );
        vec4_t b = vec4( 3.0f, 4.0f, -2.0f, 1.0f );
        vec4_t r = vec4_sub( a, b );
        TESTFW_EXPECTED( r.x == 5.0f ); TESTFW_EXPECTED( r.y == 11.0f ); TESTFW_EXPECTED( r.z == 7.0f ); TESTFW_EXPECTED( r.w == 5.0f );
    TESTFW_TEST_END();

    // vec4_mul
    TESTFW_TEST_BEGIN( "vec4_mul multiplies corresponding components of two vectors" )
        vec4_t a = vec4( 2.0f, 5.0f, -3.0f, 4.0f );
        vec4_t b = vec4( 3.0f, 4.0f, 2.0f, 0.5f );
        vec4_t r = vec4_mul( a, b );
        TESTFW_EXPECTED( r.x == 6.0f ); TESTFW_EXPECTED( r.y == 20.0f ); TESTFW_EXPECTED( r.z == -6.0f ); TESTFW_EXPECTED( r.w == 2.0f );
    TESTFW_TEST_END();

    // vec4_div
    TESTFW_TEST_BEGIN( "vec4_div divides corresponding components of two vectors" )
        vec4_t a = vec4( 10.0f, 18.0f, -6.0f, 4.0f );
        vec4_t b = vec4( 2.0f, 3.0f, 2.0f, 2.0f );
        vec4_t r = vec4_div( a, b );
        TESTFW_EXPECTED( r.x == 5.0f ); TESTFW_EXPECTED( r.y == 6.0f ); TESTFW_EXPECTED( r.z == -3.0f ); TESTFW_EXPECTED( r.w == 2.0f );
    TESTFW_TEST_END();

    // vec4_addf
    TESTFW_TEST_BEGIN( "vec4_addf adds scalar to all components of vector" )
        vec4_t a = vec4( 2.0f, 5.0f, -1.0f, 3.0f );
        vec4_t r = vec4_addf( a, 3.0f );
        TESTFW_EXPECTED( r.x == 5.0f ); TESTFW_EXPECTED( r.y == 8.0f ); TESTFW_EXPECTED( r.z == 2.0f ); TESTFW_EXPECTED( r.w == 6.0f );
    TESTFW_TEST_END();

    // vec4_subf
    TESTFW_TEST_BEGIN( "vec4_subf subtracts scalar from all components of vector" )
        vec4_t a = vec4( 10.0f, 6.0f, 0.0f, 4.0f );
        vec4_t r = vec4_subf( a, 4.0f );
        TESTFW_EXPECTED( r.x == 6.0f ); TESTFW_EXPECTED( r.y == 2.0f ); TESTFW_EXPECTED( r.z == -4.0f ); TESTFW_EXPECTED( r.w == 0.0f );
    TESTFW_TEST_END();

    // vec4_mulf
    TESTFW_TEST_BEGIN( "vec4_mulf multiplies all components of vector by scalar" )
        vec4_t a = vec4( 2.0f, 5.0f, -3.0f, 4.0f );
        vec4_t r = vec4_mulf( a, 3.0f );
        TESTFW_EXPECTED( r.x == 6.0f ); TESTFW_EXPECTED( r.y == 15.0f ); TESTFW_EXPECTED( r.z == -9.0f ); TESTFW_EXPECTED( r.w == 12.0f );
    TESTFW_TEST_END();

    // vec4_divf
    TESTFW_TEST_BEGIN( "vec4_divf divides all components of vector by scalar" )
        vec4_t a = vec4( 12.0f, 18.0f, -6.0f, 8.0f );
        vec4_t r = vec4_divf( a, 3.0f );
        TESTFW_EXPECTED( r.x == 4.0f ); TESTFW_EXPECTED( r.y == 6.0f ); TESTFW_EXPECTED( r.z == -2.0f ); TESTFW_EXPECTED( r.w == 2.66666667f );
    TESTFW_TEST_END();

    // vec4_abs
    TESTFW_TEST_BEGIN( "vec4_abs applies absolute value to each component" )
        vec4_t a = vec4( -3.0f, -4.0f, 5.0f, -6.0f );
        vec4_t r = vec4_abs( a );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == 4.0f );
        TESTFW_EXPECTED( r.z == 5.0f );
        TESTFW_EXPECTED( r.w == 6.0f );
    TESTFW_TEST_END();

    // vec4_acos
    TESTFW_TEST_BEGIN( "vec4_acos applies acos to each component" )
        vec4_t a = vec4( 0.5f, -1.0f, 1.0f, 0.0f );
        vec4_t r = vec4_acos( a );
        TESTFW_EXPECTED( test_cmp( r.x, 1.04719758f ) );
        TESTFW_EXPECTED( test_cmp( r.y, 3.14159265f ) );
        TESTFW_EXPECTED( test_cmp( r.z, 0.00000000f ) );
        TESTFW_EXPECTED( test_cmp( r.w, 1.57079633f ) );
    TESTFW_TEST_END();

    // vec4_all
    TESTFW_TEST_BEGIN( "vec4_all returns nonzero only if all components are nonzero" )
        TESTFW_EXPECTED( vec4_all( vec4( 1, 1, 1, 1 ) ) != 0 );
        TESTFW_EXPECTED( vec4_all( vec4( 1, 0, 1, 1 ) ) == 0 );
        TESTFW_EXPECTED( vec4_all( vec4( 1, 1, 0, 1 ) ) == 0 );
        TESTFW_EXPECTED( vec4_all( vec4( 1, 1, 1, 0 ) ) == 0 );
        TESTFW_EXPECTED( vec4_all( vec4( 0, 0, 0, 0 ) ) == 0 );
    TESTFW_TEST_END();

    // vec4_any
    TESTFW_TEST_BEGIN( "vec4_any returns nonzero if any component is nonzero" )
        TESTFW_EXPECTED( vec4_any( vec4( 1, 0, 0, 0 ) ) != 0 );
        TESTFW_EXPECTED( vec4_any( vec4( 0, 1, 0, 0 ) ) != 0 );
        TESTFW_EXPECTED( vec4_any( vec4( 0, 0, 1, 0 ) ) != 0 );
        TESTFW_EXPECTED( vec4_any( vec4( 0, 0, 0, 1 ) ) != 0 );
        TESTFW_EXPECTED( vec4_any( vec4( 0, 0, 0, 0 ) ) == 0 );
    TESTFW_TEST_END();

    // vec4_asin
    TESTFW_TEST_BEGIN( "vec4_asin applies asin to each component" )
        vec4_t a = vec4( 0.5f, -1.0f, 1.0f, 0.0f );
        vec4_t r = vec4_asin( a );
        TESTFW_EXPECTED( test_cmp( r.x, 0.52359878f ));
        TESTFW_EXPECTED( test_cmp( r.y, -1.57079633f ));
        TESTFW_EXPECTED( test_cmp( r.z, 1.57079633f ));
        TESTFW_EXPECTED( test_cmp( r.w, 0.00000000f ));
    TESTFW_TEST_END();

    // vec4_atan
    TESTFW_TEST_BEGIN( "vec4_atan applies atan to each component" )
        vec4_t a = vec4( 0.5f, -2.0f, 1.0f, -1.0f );
        vec4_t r = vec4_atan( a );
        TESTFW_EXPECTED( r.x == 0.46364761f ); 
        TESTFW_EXPECTED( r.y == -1.10714872f ); 
        TESTFW_EXPECTED( r.z == 0.78539816f ); 
        TESTFW_EXPECTED( r.w == -0.78539816f );
    TESTFW_TEST_END();

    // vec4_atan2
    TESTFW_TEST_BEGIN( "vec4_atan2 applies atan2 to each pair of components" )
        vec4_t y = vec4( 2.0f, -3.0f, 1.0f, -1.0f );
        vec4_t x = vec4( 1.0f, -4.0f, 4.0f, 1.0f );
        vec4_t r = vec4_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x, 1.10714872f )); 
        TESTFW_EXPECTED( test_cmp( r.y, -2.49809154f ));
        TESTFW_EXPECTED( test_cmp( r.z, 0.24497866f )); 
        TESTFW_EXPECTED( test_cmp( r.w, -0.78539816f ));
    TESTFW_TEST_END();

    // vec4_ceil
    TESTFW_TEST_BEGIN( "vec4_ceil applies ceil to each component" )
        vec4_t v = vec4( 1.2f, -3.7f, 0.0f, 2.3f );
        vec4_t r = vec4_ceil( v );
        TESTFW_EXPECTED( r.x == 2.0f ); 
        TESTFW_EXPECTED( r.y == -3.0f );
        TESTFW_EXPECTED( r.z == 0.0f ); 
        TESTFW_EXPECTED( r.w == 3.0f ); 
    TESTFW_TEST_END();

    // vec4_clamp
    TESTFW_TEST_BEGIN( "vec4_clamp clamps each component using corresponding min and max" )
        vec4_t v = vec4( 5.0f, -10.0f, 2.5f, 8.0f );
        vec4_t min = vec4( 0.0f, -8.0f, -1.0f, 5.0f );
        vec4_t max = vec4( 4.0f, -7.0f, 1.0f, 7.0f );
        vec4_t r = vec4_clamp( v, min, max );
        TESTFW_EXPECTED( r.x == 4.0f );
        TESTFW_EXPECTED( r.y == -8.0f );
        TESTFW_EXPECTED( r.z == 1.0f );
        TESTFW_EXPECTED( r.w == 7.0f );
    TESTFW_TEST_END();

    // vec4_cos
    TESTFW_TEST_BEGIN( "vec4_cos applies cos to each component" )
        vec4_t a = vec4( 0.5f, 2.0f, 3.14159265f, 0.0f );
        vec4_t r = vec4_cos( a );
        TESTFW_EXPECTED( r.x == 0.87758256f );
        TESTFW_EXPECTED( r.y == -0.41614684f );
        TESTFW_EXPECTED( r.z == -1.00000000f );
        TESTFW_EXPECTED( r.w == 1.00000000f );
    TESTFW_TEST_END();

    // vec4_cosh
    TESTFW_TEST_BEGIN( "vec4_cosh applies cosh to each component" )
        vec4_t a = vec4( 0.5f, 2.0f, 1.0f, 0.0f );
        vec4_t r = vec4_cosh( a );
        TESTFW_EXPECTED( test_cmp( r.x, 1.12762597f ));
        TESTFW_EXPECTED( test_cmp( r.y, 3.76219569f ));
        TESTFW_EXPECTED( test_cmp( r.z, 1.54308063f ));
        TESTFW_EXPECTED( test_cmp( r.w, 1.00000000f ));
    TESTFW_TEST_END();

    // vec4_degrees
    TESTFW_TEST_BEGIN( "vec4_degrees converts radians to degrees component-wise" )
        vec4_t a = vec4( 0.5f, -2.0f, 1.0f, 0.0f );
        vec4_t r = vec4_degrees( a );
        TESTFW_EXPECTED( r.x == 28.6478898f );
        TESTFW_EXPECTED( r.y == -114.591559f );
        TESTFW_EXPECTED( r.z == 57.2957795f );
        TESTFW_EXPECTED( r.w == 0.0000000f );
    TESTFW_TEST_END();

    // vec4_distancesq
    TESTFW_TEST_BEGIN( "vec4_distancesq returns squared distance between vectors" )
        vec4_t a = vec4( 3.0f, 4.0f, 0.0f, 12.0f );
        vec4_t b = vec4f( 0.0f );
        float r = vec4_distancesq( a, b );
        TESTFW_EXPECTED( r == 169.0f ); 
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_distance returns Euclidean distance between vectors" )
        vec4_t a = vec4( 3.0f, 4.0f, 0.0f, 12.0f );
        vec4_t b = vec4f( 0.0f );
        float r = vec4_distance( a, b );
        TESTFW_EXPECTED( r == 13.0f ); 
    TESTFW_TEST_END();

    // vec4_dot
    TESTFW_TEST_BEGIN( "vec4_dot returns sum of products of corresponding components" )
        vec4_t a = vec4( 1.0f, 1.0f, 2.0f, 2.0f );
        vec4_t b = vec4( 1.0f, 1.0f, 1.0f, 1.0f );
        float r = vec4_dot( a, b );
        TESTFW_EXPECTED( r == 6.0f ); 
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_dot is symmetric in its arguments" )
        vec4_t a = vec4( -1.0f, 5.0f, 2.0f, 3.0f );
        vec4_t b = vec4( 7.0f, 2.0f, -3.0f, 1.0f );
        float d1 = vec4_dot( a, b );
        float d2 = vec4_dot( b, a );
        TESTFW_EXPECTED( d1 == d2 );
    TESTFW_TEST_END();

    // vec4_exp
    TESTFW_TEST_BEGIN( "vec4_exp applies exp to each component" )
        vec4_t a = vec4( 0.5f, -2.0f, 1.0f, 0.0f );
        vec4_t r = vec4_exp( a );
        TESTFW_EXPECTED( r.x == 1.64872127f ); 
        TESTFW_EXPECTED( r.y == 0.13533528f ); 
        TESTFW_EXPECTED( r.z == 2.71828183f ); 
        TESTFW_EXPECTED( r.w == 1.00000000f ); 
    TESTFW_TEST_END();

    // vec4_exp2
    TESTFW_TEST_BEGIN( "vec4_exp2 applies exp2 to each component" )
        vec4_t a = vec4( 3.0f, -2.0f, 1.0f, 0.0f );
        vec4_t r = vec4_exp2( a );
        TESTFW_EXPECTED( r.x == 8.0f ); 
        TESTFW_EXPECTED( r.y == 0.25f );
        TESTFW_EXPECTED( r.z == 2.0f );
        TESTFW_EXPECTED( r.w == 1.0f );
    TESTFW_TEST_END();

    // vec4_floor
    TESTFW_TEST_BEGIN( "vec4_floor applies floor to each component" )
        vec4_t a = vec4( 2.7f, -3.2f, 0.0f, -1.5f );
        vec4_t r = vec4_floor( a );
        TESTFW_EXPECTED( r.x == 2.0f ); 
        TESTFW_EXPECTED( r.y == -4.0f );
        TESTFW_EXPECTED( r.z == 0.0f ); 
        TESTFW_EXPECTED( r.w == -2.0f );
    TESTFW_TEST_END();

    // vec4_fmod
    TESTFW_TEST_BEGIN( "vec4_fmod applies fmod to each pair of components" )
        vec4_t a = vec4( 6.5f, -5.0f, 7.75f, 5.5f );
        vec4_t b = vec4( 2.0f, 3.0f, 2.5f, 4.0f );
        vec4_t r = vec4_fmod( a, b );
        TESTFW_EXPECTED( r.x == 0.5f ); 
        TESTFW_EXPECTED( r.y == -2.0f );
        TESTFW_EXPECTED( r.z == 0.25f );
        TESTFW_EXPECTED( r.w == 1.5f );
    TESTFW_TEST_END();

    // vec4_frac
    TESTFW_TEST_BEGIN( "vec4_frac returns fractional part of each component" )
        vec4_t a = vec4( 3.75f, -2.25f, 1.5f, -3.125f );
        vec4_t r = vec4_frac( a );
        TESTFW_EXPECTED( r.x == 0.75f );
        TESTFW_EXPECTED( r.y == 0.25f );
        TESTFW_EXPECTED( r.z == 0.50f );
        TESTFW_EXPECTED( r.w == 0.125f );
    TESTFW_TEST_END();

    // vec4_lengthsq
    TESTFW_TEST_BEGIN( "vec4_lengthsq returns sum of squared components" )
        vec4_t a = vec4( 0.0f, 3.0f, 4.0f, 0.0f );
        float r = vec4_lengthsq( a );
        TESTFW_EXPECTED( r == 25.0f );
    TESTFW_TEST_END();

    // vec4_length
    TESTFW_TEST_BEGIN( "vec4_length returns Euclidean length of vector" )
        vec4_t a = vec4( 0.0f, 3.0f, 4.0f, 0.0f );
        float r = vec4_length( a );
        TESTFW_EXPECTED( r == 5.0f );
    TESTFW_TEST_END();

    // vec4_lerp
    TESTFW_TEST_BEGIN( "vec4_lerp linearly interpolates between vectors component-wise" )
        vec4_t a = vec4( 0.0f, 0.0f, 0.0f, 0.0f );
        vec4_t b = vec4( 4.0f, 8.0f, 12.0f, 16.0f );
        vec4_t r = vec4_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x == 1.0f ); 
        TESTFW_EXPECTED( r.y == 2.0f ); 
        TESTFW_EXPECTED( r.z == 3.0f ); 
        TESTFW_EXPECTED( r.w == 4.0f ); 
    TESTFW_TEST_END();

    // vec4_log
    TESTFW_TEST_BEGIN( "vec4_log applies natural log to each component" )
        vec4_t a = vec4( 1.0f, 7.38905610f, 20.0855370f, 54.5981500f );
        vec4_t r = vec4_log( a );
        TESTFW_EXPECTED( r.x == 0.0f ); 
        TESTFW_EXPECTED( r.y == 2.0f ); 
        TESTFW_EXPECTED( r.z == 3.0f ); 
        TESTFW_EXPECTED( r.w == 4.0f ); 
    TESTFW_TEST_END();

    // vec4_log2
    TESTFW_TEST_BEGIN( "vec4_log2 applies base-2 logarithm to each component" )
        vec4_t a = vec4( 16.0f, 0.25f, 2.0f, 1.0f );
        vec4_t r = vec4_log2( a );
        TESTFW_EXPECTED( r.x == 4.0f ); 
        TESTFW_EXPECTED( r.y == -2.0f );
        TESTFW_EXPECTED( r.z == 1.0f ); 
        TESTFW_EXPECTED( r.w == 0.0f ); 
    TESTFW_TEST_END();

    // vec4_log10
    TESTFW_TEST_BEGIN( "vec4_log10 applies base-10 logarithm to each component" )
        vec4_t a = vec4( 100.0f, 0.001f, 10.0f, 1.0f );
        vec4_t r = vec4_log10( a );
        TESTFW_EXPECTED( r.x == 2.0f ); 
        TESTFW_EXPECTED( r.y == -3.0f ); 
        TESTFW_EXPECTED( r.z == 1.0f ); 
        TESTFW_EXPECTED( r.w == 0.0f );
    TESTFW_TEST_END();

    // vec4_max
    TESTFW_TEST_BEGIN( "vec4_max returns component-wise maximum of two vectors" )
        vec4_t a = vec4( 3.0f, -5.0f, 7.0f, 2.0f );
        vec4_t b = vec4( 2.0f, -4.0f, 8.0f, 5.0f );
        vec4_t r = vec4_max( a, b );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == -4.0f );
        TESTFW_EXPECTED( r.z == 8.0f );
        TESTFW_EXPECTED( r.w == 5.0f );
    TESTFW_TEST_END();

    // vec4_min
    TESTFW_TEST_BEGIN( "vec4_min returns component-wise minimum of two vectors" )
        vec4_t a = vec4( 3.0f, -5.0f, 7.0f, 2.0f );
        vec4_t b = vec4( 2.0f, -4.0f, 8.0f, 5.0f );
        vec4_t r = vec4_min( a, b );
        TESTFW_EXPECTED( r.x == 2.0f );
        TESTFW_EXPECTED( r.y == -5.0f );
        TESTFW_EXPECTED( r.z == 7.0f );
        TESTFW_EXPECTED( r.w == 2.0f );
    TESTFW_TEST_END();

    // vec4_normalize
    TESTFW_TEST_BEGIN( "vec4_normalize returns vector of unit length in same direction" )
        vec4_t a = vec4( 0.0f, 3.0f, 4.0f, 0.0f );
        vec4_t r = vec4_normalize( a );
        TESTFW_EXPECTED( r.x == 0.00000000f ); 
        TESTFW_EXPECTED( r.y == 0.60000000f ); 
        TESTFW_EXPECTED( r.z == 0.80000000f ); 
        TESTFW_EXPECTED( r.w == 0.00000000f ); 
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_normalize returns zero vector when input is zero" )
        vec4_t a = vec4f( 0.0f );
        vec4_t r = vec4_normalize( a );
        TESTFW_EXPECTED( r.x == 0.0f );
        TESTFW_EXPECTED( r.y == 0.0f );
        TESTFW_EXPECTED( r.z == 0.0f );
        TESTFW_EXPECTED( r.w == 0.0f );
    TESTFW_TEST_END();

    // vec4_pow
    TESTFW_TEST_BEGIN( "vec4_pow applies pow to each pair of components" )
        vec4_t a = vec4( 4.0f, 9.0f, 16.0f, 25.0f );
        vec4_t b = vec4( 0.5f, 0.5f, 0.5f, 0.5f );
        vec4_t r = vec4_pow( a, b );
        TESTFW_EXPECTED( r.x == 2.0f ); 
        TESTFW_EXPECTED( r.y == 3.0f ); 
        TESTFW_EXPECTED( r.w == 5.0f ); 
    TESTFW_TEST_END();

    // vec4_radians
    TESTFW_TEST_BEGIN( "vec4_radians converts degrees to radians component-wise" )
        vec4_t a = vec4( 90.0f, -45.0f, 180.0f, 360.0f );
        vec4_t r = vec4_radians( a );
        TESTFW_EXPECTED( r.x == 1.57079633f );
        TESTFW_EXPECTED( r.y == -0.78539816f );
        TESTFW_EXPECTED( r.z == 3.14159265f );
        TESTFW_EXPECTED( r.w == 6.28318531f );
    TESTFW_TEST_END();

    // vec4_rcp
    TESTFW_TEST_BEGIN( "vec4_rcp returns per-component reciprocal" )
        vec4_t a = vec4( 4.0f, -0.5f, 2.0f, 1.0f );
        vec4_t r = vec4_rcp( a );
        TESTFW_EXPECTED( r.x == 0.25f );
        TESTFW_EXPECTED( r.y == -2.0f );
        TESTFW_EXPECTED( r.z == 0.5f );
        TESTFW_EXPECTED( r.w == 1.0f );
    TESTFW_TEST_END();

    // vec4_reflect
    TESTFW_TEST_BEGIN( "vec4_reflect preserves length for normalized normal" )
        vec4_t i = vec4( 3.0f, 4.0f, 0.0f, 0.0f );
        vec4_t n = vec4_normalize( vec4( 0.0f, 1.0f, 1.0f, 0.0f ) );
        TESTFW_EXPECTED( vec4_length( i ) == vec4_length( vec4_reflect( i, n ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_reflect is identity when reflected twice" )
        vec4_t i = vec4( 2.0f, -5.0f, 1.0f, 0.0f );
        vec4_t n = vec4_normalize( vec4( 0.0f, 1.0f, 0.0f, 0.0f ) );
        TESTFW_EXPECTED( vec4_eq( i, vec4_reflect( vec4_reflect( i, n ), n ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_reflect negates vector when incident equals normal" )
        vec4_t n = vec4_normalize( vec4( 0.8f, 0.6f, 0.0f, 0.0f ) );
        TESTFW_EXPECTED( vec4_eq( vec4_reflect( n, n ), vec4_neg( n ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_reflect leaves vector unchanged when perpendicular to normal" )
        vec4_t i = vec4( 1.0f, 0.0f, 0.0f, 0.0f );
        vec4_t n = vec4( 0.0f, 1.0f, 0.0f, 0.0f );
        TESTFW_EXPECTED( vec4_eq( vec4_reflect( i, n ), i ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_reflect result is invariant under normal direction" )
        vec4_t i = vec4( 3.0f, 4.0f, 5.0f, 0.0f );
        vec4_t n = vec4_normalize( vec4( 0.0f, 1.0f, 0.0f, 0.0f ) );
        TESTFW_EXPECTED( vec4_eq( vec4_reflect( i, n ), vec4_reflect( i, vec4_neg( n ) ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_reflect of zero vector is zero" )
        vec4_t n = vec4_normalize( vec4( 0.0f, 1.0f, 0.0f, 0.0f ) );
        TESTFW_EXPECTED( vec4_eq( vec4_reflect( vec4f( 0.0f ), n ), vec4f( 0.0f ) ) );
    TESTFW_TEST_END();

    // vec4_refract
    TESTFW_TEST_BEGIN( "vec4_refract returns zero when angle is too great for given refraction index" )
        vec4_t i = vec4_normalize( vec4( 1.0f, -0.5f, 0.5f, 0.0f ) );
        vec4_t n = vec4( 0.0f, 1.0f, 0.0f, 0.0f );
        TESTFW_EXPECTED( vec4_eq( vec4_refract( i, n, 1.5f ), vec4f( 0.0f ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_refract returns unchanged vector when normal is perpendicular and refraction index 1.0" )
        vec4_t i = vec4( 1.0f, 0.0f, 0.0f, 0.0f );
        vec4_t n = vec4( 0.0f, 1.0f, 0.0f, 0.0f );
        TESTFW_EXPECTED( vec4_eq( vec4_refract( i, n, 1.0f ), i ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_refract bends toward normal when entering denser medium" )
        vec4_t i = vec4_normalize( vec4( 1.0f, -1.0f, 0.0f, 0.0f ) );
        vec4_t n = vec4( 0.0f, 1.0f, 0.0f, 0.0f );
        TESTFW_EXPECTED( vec4_refract( i, n, 2.0f ).y > i.y );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_refract bends away from normal when entering rarer medium" )
        vec4_t i = vec4_normalize( vec4( 1.0f, -1.0f, 0.0f, 0.0f ) );
        vec4_t n = vec4( 0.0f, 1.0f, 0.0f, 0.0f );
        TESTFW_EXPECTED( vec4_refract( i, n, 0.5f ).y < i.y );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_refract result lies in same general direction as input" )
        vec4_t i = vec4_normalize( vec4( 1.0f, -1.0f, 1.0f, 0.0f ) );
        vec4_t n = vec4( 0.0f, 1.0f, 0.0f, 0.0f );
        TESTFW_EXPECTED( vec4_dot( i, vec4_refract( i, n, 1.2f ) ) > 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_refract of zero vector is zero" )
        vec4_t n = vec4( 0.0f, 1.0f, 0.0f, 0.0f );
        TESTFW_EXPECTED( vec4_eq( vec4_refract( vec4f( 0.0f ), n, 1.5f ), vec4f( 0.0f ) ) );
    TESTFW_TEST_END();

    // vec4_round
    TESTFW_TEST_BEGIN( "vec4_round rounds each component to nearest integer" )
        vec4_t a = vec4( 2.6f, -3.4f, 0.0f, 1.5f );
        vec4_t r = vec4_round( a );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == -3.0f );
        TESTFW_EXPECTED( r.z == 0.0f );
        TESTFW_EXPECTED( r.w == 2.0f );
    TESTFW_TEST_END();

    // vec4_rsqrt
    TESTFW_TEST_BEGIN( "vec4_rsqrt returns reciprocal square root of each component" )
        vec4_t a = vec4( 4.0f, 0.25f, 1.0f, 16.0f );
        vec4_t r = vec4_rsqrt( a );
        TESTFW_EXPECTED( r.x == 0.5f );
        TESTFW_EXPECTED( r.y == 2.0f );
        TESTFW_EXPECTED( r.z == 1.0f );
        TESTFW_EXPECTED( r.w == 0.25f );
    TESTFW_TEST_END();

    // vec4_saturate
    TESTFW_TEST_BEGIN( "vec4_saturate clamps each component to the [0, 1] range" )
        vec4_t a = vec4( -2.0f, 1.5f, 0.5f, 2.0f );
        vec4_t r = vec4_saturate( a );
        TESTFW_EXPECTED( r.x == 0.0f );
        TESTFW_EXPECTED( r.y == 1.0f );
        TESTFW_EXPECTED( r.z == 0.5f );
        TESTFW_EXPECTED( r.w == 1.0f );
    TESTFW_TEST_END();

    // vec4_sign
    TESTFW_TEST_BEGIN( "vec4_sign returns sign of each component" )
        vec4_t a = vec4( 3.5f, -2.0f, 0.0f, -4.0f );
        vec4_t r = vec4_sign( a );
        TESTFW_EXPECTED( r.x == 1.0f );
        TESTFW_EXPECTED( r.y == -1.0f );
        TESTFW_EXPECTED( r.z == 0.0f );
        TESTFW_EXPECTED( r.w == -1.0f );
    TESTFW_TEST_END();

    // vec4_sin
    TESTFW_TEST_BEGIN( "vec4_sin applies sin to each component" )
        vec4_t a = vec4( 0.5f, -2.0f, 1.57079633f, -0.5f );
        vec4_t r = vec4_sin( a );
        TESTFW_EXPECTED( r.x == 0.47942554f );
        TESTFW_EXPECTED( r.y == -0.90929743f );
        TESTFW_EXPECTED( r.z == 1.00000000f );
        TESTFW_EXPECTED( r.w == -0.47942554f );
    TESTFW_TEST_END();

    // vec4_sinh
    TESTFW_TEST_BEGIN( "vec4_sinh applies sinh to each component" )
        vec4_t a = vec4( -1.0f, 0.0f, 1.0f, 2.0f );
        vec4_t r = vec4_sinh( a );
        TESTFW_EXPECTED( r.x == -1.17520119f ); 
        TESTFW_EXPECTED( r.y == 0.00000000f ); 
        TESTFW_EXPECTED( r.z == 1.17520119f ); 
        TESTFW_EXPECTED( r.w == 3.62686041f ); 
    TESTFW_TEST_END();

    // vec4_smoothstep
    TESTFW_TEST_BEGIN( "vec4_smoothstep performs Hermite interpolation between a and b" )
        vec4_t a = vec4( 0.0f, 0.0f, 0.0f, 0.0f );
        vec4_t b = vec4( 4.0f, 4.0f, 4.0f, 4.0f );
        vec4_t t = vec4( 1.0f, 2.0f, 3.0f, 4.0f );
        vec4_t r = vec4_smoothstep( a, b, t );
        TESTFW_EXPECTED( r.x == 0.15625f );
        TESTFW_EXPECTED( r.y == 0.50000f );
        TESTFW_EXPECTED( r.z == 0.84375f );
        TESTFW_EXPECTED( r.w == 1.00000f );
    TESTFW_TEST_END();

    // vec4_smootherstep
    TESTFW_TEST_BEGIN( "vec4_smootherstep performs quintic Hermite interpolation between a and b" )
        vec4_t a = vec4f( 0.0f );
        vec4_t b = vec4f( 4.0f );
        vec4_t t = vec4( 0.0f, 2.0f, 3.0f, 4.0f );
        vec4_t r = vec4_smootherstep( a, b, t );
        TESTFW_EXPECTED( r.x == 0.00000000f ); 
        TESTFW_EXPECTED( r.y == 0.50000000f ); 
        TESTFW_EXPECTED( r.z == 0.89648438f ); 
        TESTFW_EXPECTED( r.w == 1.00000000f ); 
    TESTFW_TEST_END();

    // vec4_sqrt
    TESTFW_TEST_BEGIN( "vec4_sqrt returns square root of each component" )
        vec4_t a = vec4( 16.0f, 0.25f, 9.0f, 1.0f );
        vec4_t r = vec4_sqrt( a );
        TESTFW_EXPECTED( r.x == 4.0f );
        TESTFW_EXPECTED( r.y == 0.5f );
        TESTFW_EXPECTED( r.z == 3.0f );
        TESTFW_EXPECTED( r.w == 1.0f );
    TESTFW_TEST_END();

    // vec4_step
    TESTFW_TEST_BEGIN( "vec4_step returns 0.0 or 1.0 per component based on threshold" )
        vec4_t edge = vec4( 2.5f, 6.0f, 4.0f, 1.0f );
        vec4_t x = vec4( 3.0f, 5.0f, 4.0f, 0.5f );
        vec4_t r = vec4_step( edge, x );
        TESTFW_EXPECTED( r.x == 1.0f );
        TESTFW_EXPECTED( r.y == 0.0f );
        TESTFW_EXPECTED( r.z == 1.0f );
        TESTFW_EXPECTED( r.w == 0.0f );
    TESTFW_TEST_END();

    // vec4_tan
    TESTFW_TEST_BEGIN( "vec4_tan applies tan to each component" )
        vec4_t a = vec4( 0.5f, -1.0f, 1.0f, -0.5f );
        vec4_t r = vec4_tan( a );
        TESTFW_EXPECTED( r.x == 0.54630249f );
        TESTFW_EXPECTED( r.y == -1.55740772f );
        TESTFW_EXPECTED( r.z == 1.55740772f );
        TESTFW_EXPECTED( r.w == -0.54630249f );
    TESTFW_TEST_END();

    // vec4_tanh
    TESTFW_TEST_BEGIN( "vec4_tanh applies tanh to each component" )
        vec4_t a = vec4( 1.0f, -2.0f, 0.0f, 0.5f );
        vec4_t r = vec4_tanh( a );
        TESTFW_EXPECTED( r.x == 0.76159416f );
        TESTFW_EXPECTED( r.y == -0.96402758f );
        TESTFW_EXPECTED( r.z == 0.00000000f );
        TESTFW_EXPECTED( r.w == 0.46211716f );
    TESTFW_TEST_END();

    // vec4_trunc
    TESTFW_TEST_BEGIN( "vec4_trunc removes fractional part of each component" )
        vec4_t a = vec4( 3.7f, -2.9f, 0.5f, -0.5f );
        vec4_t r = vec4_trunc( a );
        TESTFW_EXPECTED( r.x == 3.0f );
        TESTFW_EXPECTED( r.y == -2.0f );
        TESTFW_EXPECTED( r.z == 0.0f );
        TESTFW_EXPECTED( r.w == 0.0f );
    TESTFW_TEST_END();
}


void test_mat22( void ) {
    // mat22
    TESTFW_TEST_BEGIN( "mat22 constructs matrix from two distinct row vectors" )
        mat22_t m = mat22( vec2(1.0f, 2.0f), vec2(3.0f, 4.0f) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 2.0f );
        TESTFW_EXPECTED( m.y.x == 3.0f );
        TESTFW_EXPECTED( m.y.y == 4.0f );
    TESTFW_TEST_END();

    // mat22f
    TESTFW_TEST_BEGIN( "mat22f constructs a matrix with all elements equal to input" )
        mat22_t m = mat22f( 5.5f );
        TESTFW_EXPECTED( m.x.x == 5.5f );
        TESTFW_EXPECTED( m.x.y == 5.5f );
        TESTFW_EXPECTED( m.y.x == 5.5f );
        TESTFW_EXPECTED( m.y.y == 5.5f );
    TESTFW_TEST_END();

    // mat22_get
    TESTFW_TEST_BEGIN( "mat22_get returns each row by index" )
        mat22_t m = mat22( vec2( 1.0f, -1.0f ), vec2( 2.0f, -2.0f ) );
        vec2_t r0 = mat22_get( m, 0 );
        vec2_t r1 = mat22_get( m, 1 );
        TESTFW_EXPECTED( r0.x == 1.0f );
        TESTFW_EXPECTED( r0.y == -1.0f );
        TESTFW_EXPECTED( r1.x == 2.0f );
        TESTFW_EXPECTED( r1.y == -2.0f );
    TESTFW_TEST_END();

    // mat22_set
    TESTFW_TEST_BEGIN( "mat22_set modifies only the specified row" )
        mat22_t m = mat22( vec2(1,2), vec2(3,4) );
        mat22_set( &m, 0, vec2(9,9) );
        TESTFW_EXPECTED( m.x.x == 9.0f );
        TESTFW_EXPECTED( m.x.y == 9.0f );
        TESTFW_EXPECTED( m.y.x == 3.0f );
        TESTFW_EXPECTED( m.y.y == 4.0f );

        m = mat22( vec2(1,2), vec2(3,4) );
        mat22_set( &m, 1, vec2(-7,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 2.0f );
        TESTFW_EXPECTED( m.y.x == -7.0f );
        TESTFW_EXPECTED( m.y.y == 0.0f );
    TESTFW_TEST_END();

    // mat22_neg
    TESTFW_TEST_BEGIN( "mat22_neg negates each element of the matrix" )
        mat22_t m = mat22( vec2(1,-2), vec2(-3,4) );
        mat22_t r = mat22_neg( m );
        TESTFW_EXPECTED( r.x.x == -1.0f );
        TESTFW_EXPECTED( r.x.y == 2.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.y.y == -4.0f );
    TESTFW_TEST_END();

    // mat22_eq
    TESTFW_TEST_BEGIN( "mat22_eq returns nonzero if all corresponding rows are equal" )
        mat22_t a = mat22( vec2(1,2), vec2(3,4) );
        mat22_t b = mat22( vec2(1,2), vec2(3,4) );
        TESTFW_EXPECTED( mat22_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat22_eq returns zero if any element differs" )
        mat22_t a = mat22( vec2(1,2), vec2(3,4) );
        mat22_t b = mat22( vec2(1,2), vec2(3,5) );
        TESTFW_EXPECTED( mat22_eq( a, b ) == 0 );

        b = mat22( vec2(0,2), vec2(3,4) );
        TESTFW_EXPECTED( mat22_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // mat22_eq
    TESTFW_TEST_BEGIN( "mat22_eq returns nonzero if both rows are equal" )
        mat22_t a = mat22( vec2(1.0f, 2.0f), vec2(3.0f, 4.0f) );
        mat22_t b = mat22( vec2(1.0f, 2.0f), vec2(3.0f, 4.0f) );
        TESTFW_EXPECTED( mat22_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat22_eq returns zero if any element differs" )
        mat22_t a = mat22( vec2(1.0f, 2.0f), vec2(3.0f, 4.0f) );
        mat22_t b = mat22( vec2(1.0f, 2.0f), vec2(3.0f, 5.0f) );
        TESTFW_EXPECTED( mat22_eq( a, b ) == 0 );

        b = mat22( vec2(0.0f, 2.0f), vec2(3.0f, 4.0f) );
        TESTFW_EXPECTED( mat22_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // mat22_add
    TESTFW_TEST_BEGIN( "mat22_add adds corresponding elements of two matrices" )
        mat22_t a = mat22( vec2(1.0f, 6.0f), vec2(8.0f, 15.0f) );
        mat22_t b = mat22( vec2(4.0f, 9.0f), vec2(3.0f, 4.0f) );
        mat22_t r = mat22_add( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f ); 
        TESTFW_EXPECTED( r.x.y == 15.0f );
        TESTFW_EXPECTED( r.y.x == 11.0f );
        TESTFW_EXPECTED( r.y.y == 19.0f );
    TESTFW_TEST_END();

    // mat22_sub
    TESTFW_TEST_BEGIN( "mat22_sub subtracts corresponding elements of two matrices" )
        mat22_t a = mat22( vec2(8.0f, 15.0f), vec2(5.0f, 10.0f) );
        mat22_t b = mat22( vec2(3.0f, 4.0f), vec2(2.0f, 5.0f) );
        mat22_t r = mat22_sub( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f ); 
        TESTFW_EXPECTED( r.x.y == 11.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f ); 
        TESTFW_EXPECTED( r.y.y == 5.0f ); 
    TESTFW_TEST_END();

    // mat22_mul_elem
    TESTFW_TEST_BEGIN( "mat22_mul_elem multiplies corresponding elements of two matrices" )
        mat22_t a = mat22( vec2(2.0f, 5.0f), vec2(10.0f, 12.0f) );
        mat22_t b = mat22( vec2(3.0f, 4.0f), vec2(2.0f, 3.0f) );
        mat22_t r = mat22_mul_elem( a, b );
        TESTFW_EXPECTED( r.x.x == 6.0f ); 
        TESTFW_EXPECTED( r.x.y == 20.0f );
        TESTFW_EXPECTED( r.y.x == 20.0f );
        TESTFW_EXPECTED( r.y.y == 36.0f );
    TESTFW_TEST_END();

    // mat22_div
    TESTFW_TEST_BEGIN( "mat22_div divides corresponding elements of two matrices" )
        mat22_t a = mat22( vec2(10.0f, 18.0f), vec2(12.0f, 9.0f) );
        mat22_t b = mat22( vec2(2.0f, 3.0f), vec2(4.0f, 3.0f) );
        mat22_t r = mat22_div( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f ); 
        TESTFW_EXPECTED( r.x.y == 6.0f ); 
        TESTFW_EXPECTED( r.y.x == 3.0f ); 
        TESTFW_EXPECTED( r.y.y == 3.0f ); 
    TESTFW_TEST_END();

    // mat22_addf
    TESTFW_TEST_BEGIN( "mat22_addf adds scalar to all elements of matrix" )
        mat22_t m = mat22( vec2(2.0f, 5.0f), vec2(8.0f, -1.0f) );
        mat22_t r = mat22_addf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 5.0f ); 
        TESTFW_EXPECTED( r.x.y == 8.0f ); 
        TESTFW_EXPECTED( r.y.x == 11.0f );
        TESTFW_EXPECTED( r.y.y == 2.0f );
    TESTFW_TEST_END();

    // mat22_subf
    TESTFW_TEST_BEGIN( "mat22_subf subtracts scalar from all elements of matrix" )
        mat22_t m = mat22( vec2(10.0f, 6.0f), vec2(0.0f, 4.0f) );
        mat22_t r = mat22_subf( m, 4.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.x.y == 2.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.y.y == 0.0f );
    TESTFW_TEST_END();

    // mat22_mulf
    TESTFW_TEST_BEGIN( "mat22_mulf multiplies all elements by scalar" )
        mat22_t m = mat22( vec2(2.0f, -1.0f), vec2(3.0f, -2.0f) );
        mat22_t r = mat22_mulf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.x.y == -3.0f );
        TESTFW_EXPECTED( r.y.x == 9.0f ); 
        TESTFW_EXPECTED( r.y.y == -6.0f );
    TESTFW_TEST_END();

    // mat22_divf
    TESTFW_TEST_BEGIN( "mat22_divf divides all elements by scalar" )
        mat22_t m = mat22( vec2(4.0f, -4.0f), vec2(6.0f, -6.0f) );
        mat22_t r = mat22_divf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f ); 
        TESTFW_EXPECTED( r.x.y == -2.0f ); 
        TESTFW_EXPECTED( r.y.x == 3.0f ); 
        TESTFW_EXPECTED( r.y.y == -3.0f );
    TESTFW_TEST_END();

    // mat22_abs
    TESTFW_TEST_BEGIN( "mat22_abs applies absolute value to each element of the matrix" )
        mat22_t m = mat22( vec2( -3.0f, -4.0f ), vec2( -5.5f, 6.5f ) );
        mat22_t r = mat22_abs( m );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.x.y == 4.0f );
        TESTFW_EXPECTED( r.y.x == 5.5f );
        TESTFW_EXPECTED( r.y.y == 6.5f );
    TESTFW_TEST_END();

    // mat22_acos
    TESTFW_TEST_BEGIN( "mat22_acos applies acos to each element" )
        mat22_t m = mat22( vec2( 0.5f, -1.0f ), vec2( 1.0f, 0.0f ) );
        mat22_t r = mat22_acos( m );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.04719758f ) ); 
        TESTFW_EXPECTED( test_cmp( r.x.y, 3.14159265f ) ); 
        TESTFW_EXPECTED( test_cmp( r.y.x, 0.00000000f ) ); 
        TESTFW_EXPECTED( test_cmp( r.y.y, 1.57079633f ) ); 
    TESTFW_TEST_END();

    // mat22_all
    TESTFW_TEST_BEGIN( "mat22_all returns nonzero only if all four elements are nonzero" )
        TESTFW_EXPECTED( mat22_all( mat22( vec2(1.0f, 1.0f), vec2(1.0f, 1.0f) ) ) != 0 );
        TESTFW_EXPECTED( mat22_all( mat22( vec2(1.0f, 0.0f), vec2(1.0f, 1.0f) ) ) == 0 );
        TESTFW_EXPECTED( mat22_all( mat22( vec2(1.0f, 1.0f), vec2(0.0f, 1.0f) ) ) == 0 );
        TESTFW_EXPECTED( mat22_all( mat22( vec2(0.0f, 0.0f), vec2(0.0f, 0.0f) ) ) == 0 );
    TESTFW_TEST_END();

    // mat22_any
    TESTFW_TEST_BEGIN( "mat22_any returns nonzero if any element is nonzero" )
        TESTFW_EXPECTED( mat22_any( mat22( vec2(1.0f, 0.0f), vec2(0.0f, 0.0f) ) ) != 0 );
        TESTFW_EXPECTED( mat22_any( mat22( vec2(0.0f, 1.0f), vec2(0.0f, 0.0f) ) ) != 0 );
        TESTFW_EXPECTED( mat22_any( mat22( vec2(0.0f, 0.0f), vec2(1.0f, 0.0f) ) ) != 0 );
        TESTFW_EXPECTED( mat22_any( mat22( vec2(0.0f, 0.0f), vec2(0.0f, 1.0f) ) ) != 0 );
        TESTFW_EXPECTED( mat22_any( mat22( vec2(0.0f, 0.0f), vec2(0.0f, 0.0f) ) ) == 0 );
    TESTFW_TEST_END();

    // mat22_asin
    TESTFW_TEST_BEGIN( "mat22_asin applies asin to each element" )
        mat22_t m = mat22( vec2( 0.5f, -1.0f ), vec2( 1.0f, 0.0f ) );
        mat22_t r = mat22_asin( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 0.52359878f )); 
        TESTFW_EXPECTED( test_cmp(r.x.y, -1.57079633f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, 1.57079633f )); 
        TESTFW_EXPECTED( test_cmp(r.y.y, 0.00000000f )); 
    TESTFW_TEST_END();

    // mat22_atan
    TESTFW_TEST_BEGIN( "mat22_atan applies atan to each element" )
        mat22_t m = mat22( vec2( 0.5f, -2.0f ), vec2( 1.0f, -1.0f ) );
        mat22_t r = mat22_atan( m );
        TESTFW_EXPECTED( r.x.x == 0.46364761f ); 
        TESTFW_EXPECTED( r.x.y == -1.10714872f );
        TESTFW_EXPECTED( r.y.x == 0.78539816f ); 
        TESTFW_EXPECTED( r.y.y == -0.78539816f );
    TESTFW_TEST_END();

    // mat22_atan2
    TESTFW_TEST_BEGIN( "mat22_atan2 applies atan2 to each pair of elements" )
        mat22_t y = mat22( vec2( 2.0f, -3.0f ), vec2( 1.0f, 3.0f ) );
        mat22_t x = mat22( vec2( 1.0f, -4.0f ), vec2( -1.0f, 1.0f ) );
        mat22_t r = mat22_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.10714872f )); 
        TESTFW_EXPECTED( test_cmp( r.x.y, -2.49809154f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, 2.35619449f )); 
        TESTFW_EXPECTED( test_cmp( r.y.y, 1.24904577f )); 
    TESTFW_TEST_END();

    // mat22_ceil
    TESTFW_TEST_BEGIN( "mat22_ceil applies ceil to each element" )
        mat22_t m = mat22( vec2( 1.2f, -3.7f ), vec2( -0.1f, 2.9f ) );
        mat22_t r = mat22_ceil( m );
        TESTFW_EXPECTED( r.x.x == 2.0f ); 
        TESTFW_EXPECTED( r.x.y == -3.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f ); 
        TESTFW_EXPECTED( r.y.y == 3.0f ); 
    TESTFW_TEST_END();

    // mat22_clamp
    TESTFW_TEST_BEGIN( "mat22_clamp clamps each element using corresponding min and max matrices" )
        mat22_t v = mat22( vec2( 5.0f, -10.0f ), vec2( 0.5f, 3.0f ) );
        mat22_t mn = mat22( vec2( 0.0f, -8.0f ), vec2( -1.0f, 0.0f ) );
        mat22_t mx = mat22( vec2( 4.0f, -7.0f ), vec2( 2.0f, 1.0f ) );
        mat22_t r = mat22_clamp( v, mn, mx );
        TESTFW_EXPECTED( r.x.x == 4.0f ); 
        TESTFW_EXPECTED( r.x.y == -8.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f ); 
        TESTFW_EXPECTED( r.y.y == 1.0f ); 
    TESTFW_TEST_END();

    // mat22_cos
    TESTFW_TEST_BEGIN( "mat22_cos applies cos to each element" )
        mat22_t m = mat22( vec2( 0.5f, 2.0f ), vec2( 3.14159265f, 0.0f ) );
        mat22_t r = mat22_cos( m );
        TESTFW_EXPECTED( r.x.x == 0.87758256f ); 
        TESTFW_EXPECTED( r.x.y == -0.41614684f ); 
        TESTFW_EXPECTED( r.y.x == -1.00000000f ); 
        TESTFW_EXPECTED( r.y.y == 1.00000000f ); 
    TESTFW_TEST_END();

    // mat22_cosh
    TESTFW_TEST_BEGIN( "mat22_cosh applies cosh to each element" )
        mat22_t m = mat22( vec2( 0.5f, 2.0f ), vec2( 1.0f, 0.0f ) );
        mat22_t r = mat22_cosh( m );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.12762597f )); 
        TESTFW_EXPECTED( test_cmp( r.x.y, 3.76219569f )); 
        TESTFW_EXPECTED( test_cmp( r.y.x, 1.54308063f )); 
        TESTFW_EXPECTED( test_cmp( r.y.y, 1.00000000f )); 
    TESTFW_TEST_END();


    // mat22_degrees
    TESTFW_TEST_BEGIN( "mat22_degrees converts radians to degrees element-wise" )
        mat22_t m = mat22( vec2( 0.5f, -1.0f ), vec2( 3.14159265f, 0.0f ) );
        mat22_t r = mat22_degrees( m );
        TESTFW_EXPECTED( r.x.x == 28.6478898f ); 
        TESTFW_EXPECTED( r.x.y == -57.2957795f );
        TESTFW_EXPECTED( r.y.x == 180.0f ); 
        TESTFW_EXPECTED( r.y.y == 0.0f ); 
    TESTFW_TEST_END();

    // mat22_exp
    TESTFW_TEST_BEGIN( "mat22_exp applies exp to each element" )
        mat22_t m = mat22( vec2( 0.5f, -2.0f ), vec2( 1.0f, 0.0f ) );
        mat22_t r = mat22_exp( m );
        TESTFW_EXPECTED( r.x.x == 1.64872127f ); 
        TESTFW_EXPECTED( r.x.y == 0.13533528f ); 
        TESTFW_EXPECTED( r.y.x == 2.71828183f ); 
        TESTFW_EXPECTED( r.y.y == 1.00000000f ); 
    TESTFW_TEST_END();

    // mat22_exp2
    TESTFW_TEST_BEGIN( "mat22_exp2 applies exp2 to each element" )
        mat22_t m = mat22( vec2( 3.0f, -2.0f ), vec2( 1.0f, 0.0f ) );
        mat22_t r = mat22_exp2( m );
        TESTFW_EXPECTED( r.x.x == 8.0f ); 
        TESTFW_EXPECTED( r.x.y == 0.25f ); 
        TESTFW_EXPECTED( r.y.x == 2.0f ); 
        TESTFW_EXPECTED( r.y.y == 1.0f ); 
    TESTFW_TEST_END();

    // mat22_floor
    TESTFW_TEST_BEGIN( "mat22_floor applies floor to each element" )
        mat22_t m = mat22( vec2( 2.7f, -3.2f ), vec2( 0.0f, -1.5f ) );
        mat22_t r = mat22_floor( m );
        TESTFW_EXPECTED( r.x.x == 2.0f ); 
        TESTFW_EXPECTED( r.x.y == -4.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f ); 
        TESTFW_EXPECTED( r.y.y == -2.0f );
    TESTFW_TEST_END();

    // mat22_fmod
    TESTFW_TEST_BEGIN( "mat22_fmod applies fmod to each pair of elements" )
        mat22_t a = mat22( vec2( 6.5f, -5.0f ), vec2( 7.75f, 5.5f ) );
        mat22_t b = mat22( vec2( 2.0f, 3.0f ), vec2( 2.5f, 4.0f ) );
        mat22_t r = mat22_fmod( a, b );
        TESTFW_EXPECTED( r.x.x == 0.5f ); 
        TESTFW_EXPECTED( r.x.y == -2.0f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.y.y == 1.5f ); 
    TESTFW_TEST_END();

    // mat22_frac
    TESTFW_TEST_BEGIN( "mat22_frac returns fractional part of each element" )
        mat22_t m = mat22( vec2( 3.75f, -2.25f ), vec2( 1.5f, -3.125f ) );
        mat22_t r = mat22_frac( m );
        TESTFW_EXPECTED( r.x.x == 0.75f );
        TESTFW_EXPECTED( r.x.y == 0.25f );
        TESTFW_EXPECTED( r.y.x == 0.50f );
        TESTFW_EXPECTED( r.y.y == 0.125f );
    TESTFW_TEST_END();

    // mat22_lerp
    TESTFW_TEST_BEGIN( "mat22_lerp linearly interpolates between matrices element-wise" )
        mat22_t a = mat22(vec2(2.0f, -4.0f), vec2(0.0f, 0.0f));
        mat22_t b = mat22(vec2(6.0f, 8.0f), vec2(4.0f, 12.0f));
        mat22_t r = mat22_lerp(a, b, 0.25f);
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.x.y == -1.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 3.0f );
    TESTFW_TEST_END();


    // mat22_log
    TESTFW_TEST_BEGIN( "mat22_log applies natural log to each element" )
        mat22_t m = mat22(vec2(1.0f, 2.718282f), vec2(7.38905610f, 20.08553700f));
        mat22_t r = mat22_log(m);
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.x.y == 1.0f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.y.y == 3.0f );
    TESTFW_TEST_END();


    // mat22_log2
    TESTFW_TEST_BEGIN( "mat22_log2 applies base-2 logarithm to each element" )
        mat22_t m = mat22( vec2( 16.0f, 0.25f ), vec2( 2.0f, 1.0f ) );
        mat22_t r = mat22_log2( m );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.x.y == -2.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 0.0f );
    TESTFW_TEST_END();

    // mat22_log10
    TESTFW_TEST_BEGIN( "mat22_log10 applies base-10 logarithm to each element" )
        mat22_t m = mat22( vec2( 100.0f, 0.001f ), vec2( 10.0f, 1.0f ) );
        mat22_t r = mat22_log10( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.x.y == -3.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 0.0f );
    TESTFW_TEST_END();

    // mat22_max
    TESTFW_TEST_BEGIN( "mat22_max returns element-wise maximum of two matrices" )
        mat22_t a = mat22( vec2( 3.0f, -5.0f ), vec2( 7.0f, 2.0f ) );
        mat22_t b = mat22( vec2( 2.0f, -4.0f ), vec2( 8.0f, 1.0f ) );
        mat22_t r = mat22_max( a, b );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.x.y == -4.0f );
        TESTFW_EXPECTED( r.y.x == 8.0f );
        TESTFW_EXPECTED( r.y.y == 2.0f );
    TESTFW_TEST_END();

    // mat22_min
    TESTFW_TEST_BEGIN( "mat22_min returns element-wise minimum of two matrices" )
        mat22_t a = mat22( vec2( 3.0f, -5.0f ), vec2( 7.0f, 2.0f ) );
        mat22_t b = mat22( vec2( 2.0f, -4.0f ), vec2( 8.0f, 1.0f ) );
        mat22_t r = mat22_min( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.x.y == -5.0f );
        TESTFW_EXPECTED( r.y.x == 7.0f );
        TESTFW_EXPECTED( r.y.y == 1.0f );
    TESTFW_TEST_END();

    // mat22_pow
    TESTFW_TEST_BEGIN( "mat22_pow applies pow to each element-pair" )
        mat22_t a = mat22( vec2( 4.0f, 9.0f ), vec2( 16.0f, 25.0f ) );
        mat22_t b = mat22( vec2( 0.5f, 0.5f ), vec2( 0.5f, 0.5f ) );
        mat22_t r = mat22_pow( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.x.y == 3.0f );
        TESTFW_EXPECTED( r.y.x == 4.0f );
        TESTFW_EXPECTED( r.y.y == 5.0f );
    TESTFW_TEST_END();

    // mat22_radians
    TESTFW_TEST_BEGIN( "mat22_radians converts degrees to radians element-wise" )
        mat22_t m = mat22( vec2( 90.0f, -45.0f ), vec2( 180.0f, 360.0f ) );
        mat22_t r = mat22_radians( m );
        TESTFW_EXPECTED( r.x.x == 1.57079633f );
        TESTFW_EXPECTED( r.x.y == -0.78539816f );
        TESTFW_EXPECTED( r.y.x == 3.14159265f );
        TESTFW_EXPECTED( r.y.y == 6.28318531f );
    TESTFW_TEST_END();

    // mat22_rcp
    TESTFW_TEST_BEGIN( "mat22_rcp returns element-wise reciprocal" )
        mat22_t m = mat22( vec2( 4.0f, -0.5f ), vec2( 2.0f, 1.0f ) );
        mat22_t r = mat22_rcp( m );
        TESTFW_EXPECTED( r.x.x == 0.25f );
        TESTFW_EXPECTED( r.x.y == -2.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.y.y == 1.0f );
    TESTFW_TEST_END();

    // mat22_round
    TESTFW_TEST_BEGIN( "mat22_round rounds each element to nearest integer" )
        mat22_t m = mat22(vec2(2.6f, -3.4f), vec2(-1.7f, 4.3f));
        mat22_t r = mat22_round(m);
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.x.y == -3.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.y.y == 4.0f );
    TESTFW_TEST_END();

    // mat22_rsqrt
    TESTFW_TEST_BEGIN( "mat22_rsqrt returns reciprocal square root of each element" )
        mat22_t m = mat22(vec2(4.0f, 0.25f), vec2(16.0f, 1.0f));
        mat22_t r = mat22_rsqrt(m);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.x.y == 2.0f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.y.y == 1.0f );
    TESTFW_TEST_END();

    // mat22_saturate
    TESTFW_TEST_BEGIN( "mat22_saturate clamps each element to the [0, 1] range" )
        mat22_t m = mat22(vec2(-2.0f, 1.5f), vec2(0.5f, 2.0f));
        mat22_t r = mat22_saturate(m);
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.x.y == 1.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.y.y == 1.0f );
    TESTFW_TEST_END();

    // mat22_sign
    TESTFW_TEST_BEGIN( "mat22_sign returns sign of each element" )
        mat22_t m = mat22(vec2(3.5f, -2.0f), vec2(0.0f, -4.7f));
        mat22_t r = mat22_sign(m);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.x.y == -1.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f );
        TESTFW_EXPECTED( r.y.y == -1.0f );
    TESTFW_TEST_END();

    // mat22_sin
    TESTFW_TEST_BEGIN( "mat22_sin applies sin to each element" )
        mat22_t m = mat22(vec2(0.5f, -2.0f), vec2(1.0f, -1.0f));
        mat22_t r = mat22_sin(m);
        TESTFW_EXPECTED( r.x.x == 0.47942554f );
        TESTFW_EXPECTED( r.x.y == -0.90929743f );
        TESTFW_EXPECTED( r.y.x == 0.84147098f );
        TESTFW_EXPECTED( r.y.y == -0.84147098f );
    TESTFW_TEST_END();

    // mat22_sinh
    TESTFW_TEST_BEGIN( "mat22_sinh applies sinh to each element" )
        mat22_t m = mat22(vec2(-1.0f, 0.0f), vec2(1.0f, 0.5f));
        mat22_t r = mat22_sinh(m);
        TESTFW_EXPECTED( r.x.x == -1.17520119f );
        TESTFW_EXPECTED( r.x.y == 0.00000000f );
        TESTFW_EXPECTED( r.y.x == 1.17520119f );
        TESTFW_EXPECTED( r.y.y == 0.521095276f );
    TESTFW_TEST_END();

    // mat22_smoothstep
    TESTFW_TEST_BEGIN( "mat22_smoothstep performs Hermite interpolation element-wise" )
        mat22_t a = mat22(vec2(2.0f, 10.0f), vec2(0.0f, 5.0f));
        mat22_t b = mat22(vec2(6.0f, 14.0f), vec2(4.0f, 15.0f));
        mat22_t t = mat22(vec2(3.0f, 12.0f), vec2(1.0f, 10.0f));
        mat22_t r = mat22_smoothstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.15625f );
        TESTFW_EXPECTED( r.x.y == 0.50000f );
        TESTFW_EXPECTED( r.y.x == 0.15625f );
        TESTFW_EXPECTED( r.y.y == 0.50000f );
    TESTFW_TEST_END();

    // mat22_smootherstep
    TESTFW_TEST_BEGIN( "mat22_smootherstep performs quintic Hermite interpolation element-wise" )
        mat22_t a = mat22(vec2(0.0f, 4.0f), vec2(0.0f, 0.0f));
        mat22_t b = mat22(vec2(8.0f, 12.0f), vec2(8.0f, 8.0f));
        mat22_t t = mat22(vec2(4.0f, 10.0f), vec2(2.0f, 4.0f));
        mat22_t r = mat22_smootherstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.50000000f );
        TESTFW_EXPECTED( r.x.y == 0.89648438f );
        TESTFW_EXPECTED( r.y.x == 0.103515625f );
        TESTFW_EXPECTED( r.y.y == 0.50000000f );
    TESTFW_TEST_END();

    // mat22_sqrt
    TESTFW_TEST_BEGIN( "mat22_sqrt returns square root of each element" )
        mat22_t m = mat22(vec2(16.0f, 0.25f), vec2(9.0f, 1.0f));
        mat22_t r = mat22_sqrt(m);
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.x.y == 0.5f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.y.y == 1.0f );
    TESTFW_TEST_END();

    // mat22_step
    TESTFW_TEST_BEGIN( "mat22_step returns 0.0 or 1.0 per element based on threshold" )
        mat22_t a = mat22(vec2(2.5f, 6.0f), vec2(4.0f, 1.0f));
        mat22_t b = mat22(vec2(3.0f, 5.0f), vec2(4.0f, 0.5f));
        mat22_t r = mat22_step(a, b);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.x.y == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 0.0f );
    TESTFW_TEST_END();

    // mat22_tan
    TESTFW_TEST_BEGIN( "mat22_tan applies tan to each element" )
        mat22_t m = mat22(vec2(0.5f, -1.0f), vec2(1.0f, -0.5f));
        mat22_t r = mat22_tan(m);
        TESTFW_EXPECTED( r.x.x == 0.54630249f );
        TESTFW_EXPECTED( r.x.y == -1.55740772f );
        TESTFW_EXPECTED( r.y.x == 1.55740772f );
        TESTFW_EXPECTED( r.y.y == -0.54630249f );
    TESTFW_TEST_END();

    // mat22_tanh
    TESTFW_TEST_BEGIN( "mat22_tanh applies tanh to each element" )
        mat22_t m = mat22(vec2(1.0f, -2.0f), vec2(0.0f, 0.5f));
        mat22_t r = mat22_tanh(m);
        TESTFW_EXPECTED( r.x.x == 0.76159416f );
        TESTFW_EXPECTED( r.x.y == -0.96402758f );
        TESTFW_EXPECTED( r.y.x == 0.00000000f );
        TESTFW_EXPECTED( r.y.y == 0.46211716f );
    TESTFW_TEST_END();

    // mat22_trunc
    TESTFW_TEST_BEGIN( "mat22_trunc removes fractional part of each element" )
        mat22_t m = mat22(vec2(3.7f, -2.9f), vec2(0.5f, -0.5f));
        mat22_t r = mat22_trunc(m);
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.x.y == -2.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f );
        TESTFW_EXPECTED( r.y.y == 0.0f );
    TESTFW_TEST_END();
}


void test_mat23( void ) {
    // mat23
    TESTFW_TEST_BEGIN( "mat23 constructs matrix from two distinct row vectors" )
        mat23_t m = mat23(
            vec3( 1.0f, 2.0f, 3.0f ),
            vec3( 5.0f, 6.0f, 7.0f )
        );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 2.0f );
        TESTFW_EXPECTED( m.x.z == 3.0f );
        TESTFW_EXPECTED( m.y.x == 5.0f );
        TESTFW_EXPECTED( m.y.y == 6.0f );
        TESTFW_EXPECTED( m.y.z == 7.0f );
    TESTFW_TEST_END();

    // mat23f
    TESTFW_TEST_BEGIN( "mat23f constructs a matrix with all elements equal to input" )
        mat23_t m = mat23f( -3.5f );
        TESTFW_EXPECTED( m.x.x == -3.5f );
        TESTFW_EXPECTED( m.x.y == -3.5f );
        TESTFW_EXPECTED( m.x.z == -3.5f );
        TESTFW_EXPECTED( m.y.x == -3.5f );
        TESTFW_EXPECTED( m.y.y == -3.5f );
        TESTFW_EXPECTED( m.y.z == -3.5f );
    TESTFW_TEST_END();

    // mat23_get
    TESTFW_TEST_BEGIN( "mat23_get returns each row by index" )
        mat23_t m = mat23(
            vec3( 10, 0, 0 ),
            vec3( 20, 0, 0 )
        );
        vec3_t r0 = mat23_get( m, 0 );
        vec3_t r1 = mat23_get( m, 1 );
        TESTFW_EXPECTED( r0.x == 10.0f );
        TESTFW_EXPECTED( r1.x == 20.0f );
    TESTFW_TEST_END();

    // mat23_set
    TESTFW_TEST_BEGIN( "mat23_set modifies only the specified row" )
        mat23_t m = mat23(
            vec3(1,0,0), vec3(2,0,0)
        );
        mat23_set( &m, 0, vec3(9,0,0) );
        TESTFW_EXPECTED( m.x.x == 9.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );

        m = mat23(
            vec3(1,0,0), vec3(2,0,0)
        );
        mat23_set( &m, 1, vec3(9,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 9.0f );
    TESTFW_TEST_END();

    // mat23_neg
    TESTFW_TEST_BEGIN( "mat23_neg negates each element of the matrix" )
        mat23_t m = mat23(
            vec3( 1, -2, 0 ),
            vec3( -3, 4, 0 )
        );
        mat23_t r = mat23_neg( m );
        TESTFW_EXPECTED( r.x.x == -1.0f );
        TESTFW_EXPECTED( r.x.y == 2.0f );
        TESTFW_EXPECTED( r.x.z == -0.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.y.y == -4.0f );
        TESTFW_EXPECTED( r.y.z == -0.0f );
    TESTFW_TEST_END();

    // mat23_eq
    TESTFW_TEST_BEGIN( "mat23_eq returns nonzero if all corresponding rows are equal" )
        mat23_t a = mat23(
            vec3(1,2,3),
            vec3(4,5,6)
        );
        mat23_t b = a;
        TESTFW_EXPECTED( mat23_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat23_eq returns zero if any element differs" )
        mat23_t a = mat23(
            vec3(1,2,3),
            vec3(4,5,6)
        );
        mat23_t b = a;
        b.y.z = 99.0f;
        TESTFW_EXPECTED( mat23_eq( a, b ) == 0 );

        b = a;
        b.x.x = 0.0f;
        TESTFW_EXPECTED( mat23_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // mat23_add
    TESTFW_TEST_BEGIN( "mat23_add adds corresponding elements of two matrices" )
        mat23_t a = mat23(
            vec3(1,2,3),
            vec3(4,5,6)
        );
        mat23_t b = mat23(
            vec3(6,5,4),
            vec3(3,2,1)
        );
        mat23_t r = mat23_add( a, b );
        TESTFW_EXPECTED( r.x.x == 7.0f );
        TESTFW_EXPECTED( r.x.y == 7.0f );
        TESTFW_EXPECTED( r.x.z == 7.0f );
        TESTFW_EXPECTED( r.y.x == 7.0f );
        TESTFW_EXPECTED( r.y.y == 7.0f );
        TESTFW_EXPECTED( r.y.z == 7.0f );
    TESTFW_TEST_END();

    // mat23_sub
    TESTFW_TEST_BEGIN( "mat23_sub subtracts corresponding elements of two matrices" )
        mat23_t a = mat23(
            vec3(8,7,6),
            vec3(5,4,3)
        );
        mat23_t b = mat23(
            vec3(1,2,3),
            vec3(4,3,2)
        );
        mat23_t r = mat23_sub( a, b );
        TESTFW_EXPECTED( r.x.x == 7.0f );
        TESTFW_EXPECTED( r.x.y == 5.0f );
        TESTFW_EXPECTED( r.x.z == 3.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 1.0f );
        TESTFW_EXPECTED( r.y.z == 1.0f );
    TESTFW_TEST_END();

    // mat23_mul_elem
    TESTFW_TEST_BEGIN( "mat23_mul_elem multiplies corresponding elements of two matrices" )
        mat23_t a = mat23(
            vec3(1,2,3),
            vec3(4,5,6)
        );
        mat23_t b = mat23(
            vec3(6,5,4),
            vec3(3,2,1)
        );
        mat23_t r = mat23_mul_elem( a, b );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.x.y == 10.0f );
        TESTFW_EXPECTED( r.x.z == 12.0f );
        TESTFW_EXPECTED( r.y.x == 12.0f );
        TESTFW_EXPECTED( r.y.y == 10.0f );
        TESTFW_EXPECTED( r.y.z == 6.0f );
    TESTFW_TEST_END();

    // mat23_div
    TESTFW_TEST_BEGIN( "mat23_div divides corresponding elements of two matrices" )
        mat23_t a = mat23(
            vec3(10,20,30),
            vec3(40,50,60)
        );
        mat23_t b = mat23(
            vec3(2,4,5),
            vec3(8,10,12)
        );
        mat23_t r = mat23_div( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.x.y == 5.0f );
        TESTFW_EXPECTED( r.x.z == 6.0f );
        TESTFW_EXPECTED( r.y.x == 5.0f );
        TESTFW_EXPECTED( r.y.y == 5.0f );
        TESTFW_EXPECTED( r.y.z == 5.0f );
    TESTFW_TEST_END();

    // mat23_addf
    TESTFW_TEST_BEGIN( "mat23_addf adds scalar to all elements of matrix" )
        mat23_t m = mat23(
            vec3(1,2,3),
            vec3(4,5,6)
        );
        mat23_t r = mat23_addf( m, 1.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.x.y == 3.0f );
        TESTFW_EXPECTED( r.x.z == 4.0f );
        TESTFW_EXPECTED( r.y.x == 5.0f );
        TESTFW_EXPECTED( r.y.y == 6.0f );
        TESTFW_EXPECTED( r.y.z == 7.0f );
    TESTFW_TEST_END();

    // mat23_subf
    TESTFW_TEST_BEGIN( "mat23_subf subtracts scalar from all elements of matrix" )
        mat23_t m = mat23(
            vec3(10,9,8),
            vec3(7,6,5)
        );
        mat23_t r = mat23_subf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 8.0f );
        TESTFW_EXPECTED( r.x.y == 7.0f );
        TESTFW_EXPECTED( r.x.z == 6.0f );
        TESTFW_EXPECTED( r.y.x == 5.0f );
        TESTFW_EXPECTED( r.y.y == 4.0f );
        TESTFW_EXPECTED( r.y.z == 3.0f );
    TESTFW_TEST_END();

    // mat23_mulf
    TESTFW_TEST_BEGIN( "mat23_mulf multiplies all elements by scalar" )
        mat23_t m = mat23(
            vec3(1,2,3),
            vec3(4,5,6)
        );
        mat23_t r = mat23_mulf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.x.y == 4.0f );
        TESTFW_EXPECTED( r.x.z == 6.0f );
        TESTFW_EXPECTED( r.y.x == 8.0f );
        TESTFW_EXPECTED( r.y.y == 10.0f );
        TESTFW_EXPECTED( r.y.z == 12.0f );
    TESTFW_TEST_END();

    // mat23_divf
    TESTFW_TEST_BEGIN( "mat23_divf divides all elements by scalar" )
        mat23_t m = mat23(
            vec3(4,6,8),
            vec3(10,12,14)
        );
        mat23_t r = mat23_divf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.x.y == 3.0f );
        TESTFW_EXPECTED( r.x.z == 4.0f );
        TESTFW_EXPECTED( r.y.x == 5.0f );
        TESTFW_EXPECTED( r.y.y == 6.0f );
        TESTFW_EXPECTED( r.y.z == 7.0f );
    TESTFW_TEST_END();

    // mat23_abs
    TESTFW_TEST_BEGIN( "mat23_abs applies absolute value to each element of the matrix" )
        mat23_t m = mat23(
            vec3( -1.0f, 0.0f, 0.0f ),
            vec3( 0.0f, -2.0f, 0.0f )
        );
        mat23_t r = mat23_abs( m );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 2.0f );
    TESTFW_TEST_END();

    // mat23_acos
    TESTFW_TEST_BEGIN( "mat23_acos applies acos to each element" )
        mat23_t m = mat23(
            vec3( 0.5f, 0, 0 ),
            vec3( -1.0f, 0, 0 )
        );
        mat23_t r = mat23_acos( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 1.04719758f ) );
        TESTFW_EXPECTED( test_cmp(r.y.x, 3.14159265f ) );
    TESTFW_TEST_END();

    // mat23_all
    TESTFW_TEST_BEGIN( "mat23_all returns nonzero only if all six elements are nonzero" )
        TESTFW_EXPECTED( mat23_all( mat23(
            vec3(1,1,1), vec3(1,1,1)
        ) ) != 0 );

        TESTFW_EXPECTED( mat23_all( mat23(
            vec3(0,1,1), vec3(1,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat23_all( mat23(
            vec3(1,1,1), vec3(0,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat23_all( mat23f( 1.0f ) ) != 0 );
    TESTFW_TEST_END();

    // mat23_any
    TESTFW_TEST_BEGIN( "mat23_any returns nonzero if any element is nonzero" )
        TESTFW_EXPECTED( mat23_any( mat23(
            vec3(0,1,0), vec3(0,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat23_any( mat23(
            vec3(0,0,0), vec3(0,1,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat23_any( mat23f( 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // mat23_asin
    TESTFW_TEST_BEGIN( "mat23_asin applies asin to each element" )
        mat23_t m = mat23(
            vec3( 0.5f, 0, 0 ),
            vec3( -1.0f, 0, 0 )
        );
        mat23_t r = mat23_asin( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 0.52359878f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, -1.57079633f ));
    TESTFW_TEST_END();

    // mat23_atan
    TESTFW_TEST_BEGIN( "mat23_atan applies atan to each element" )
        mat23_t m = mat23(
            vec3( 0.5f, 0, 0 ),
            vec3( -2.0f, 0, 0 )
        );
        mat23_t r = mat23_atan( m );
        TESTFW_EXPECTED( r.x.x == 0.46364761f );
        TESTFW_EXPECTED( r.y.x == -1.10714872f );
    TESTFW_TEST_END();

    // mat23_atan2
    TESTFW_TEST_BEGIN( "mat23_atan2 applies atan2 to each element" )
        mat23_t y = mat23(
            vec3( 2.0f, 0, 0 ),
            vec3( -3.0f, 0, 0 )
        );
        mat23_t x = mat23(
            vec3( 1.0f, 0, 0 ),
            vec3( -4.0f, 0, 0 )
        );
        mat23_t r = mat23_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.10714872f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, -2.49809154f ));
    TESTFW_TEST_END();

    // mat23_ceil
    TESTFW_TEST_BEGIN( "mat23_ceil applies ceil to each element" )
        mat23_t m = mat23(
            vec3( 1.2f, 0, 0 ),
            vec3( -3.7f, 0, 0 )
        );
        mat23_t r = mat23_ceil( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
    TESTFW_TEST_END();

    // mat23_clamp
    TESTFW_TEST_BEGIN( "mat23_clamp clamps each element using corresponding min and max matrices" )
        mat23_t v = mat23(
            vec3( 5.0f, 0, 0 ),
            vec3(-10.0f, 0, 0 )
        );
        mat23_t mn = mat23(
            vec3( 0.0f, 0, 0 ),
            vec3( -8.0f, 0, 0 )
        );
        mat23_t mx = mat23(
            vec3( 4.0f, 0, 0 ),
            vec3( -7.0f, 0, 0 )
        );
        mat23_t r = mat23_clamp( v, mn, mx );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -8.0f );
    TESTFW_TEST_END();

    // mat23_cos
    TESTFW_TEST_BEGIN( "mat23_cos applies cos to each element" )
        mat23_t m = mat23(
            vec3( 0.5f, 0, 0 ),
            vec3( 2.0f, 0, 0 )
        );
        mat23_t r = mat23_cos( m );
        TESTFW_EXPECTED( r.x.x == 0.87758256f );
        TESTFW_EXPECTED( r.y.x == -0.41614684f );
    TESTFW_TEST_END();

    // mat23_cosh
    TESTFW_TEST_BEGIN( "mat23_cosh applies cosh to each element" )
        mat23_t m = mat23(
            vec3( 0.5f, 0, 0 ),
            vec3( 2.0f, 0, 0 )
        );
        mat23_t r = mat23_cosh( m );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.12762597f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, 3.76219569f ));
    TESTFW_TEST_END();

    // mat23_degrees
    TESTFW_TEST_BEGIN( "mat23_degrees converts radians to degrees element-wise" )
        mat23_t m = mat23(
            vec3( 0.5f, 0, 0 ),
            vec3( -1.0f, 0, 0 )
        );
        mat23_t r = mat23_degrees( m );
        TESTFW_EXPECTED( r.x.x == 28.6478898f );
        TESTFW_EXPECTED( r.y.x == -57.2957795f );
    TESTFW_TEST_END();

    // mat23_exp
    TESTFW_TEST_BEGIN( "mat23_exp applies exp to each element" )
        mat23_t m = mat23(
            vec3( 0.5f, 0, 0 ),
            vec3( -2.0f, 0, 0 )
        );
        mat23_t r = mat23_exp( m );
        TESTFW_EXPECTED( r.x.x == 1.64872127f );
        TESTFW_EXPECTED( r.y.x == 0.13533528f );
    TESTFW_TEST_END();

    // mat23_exp2
    TESTFW_TEST_BEGIN( "mat23_exp2 applies exp2 to each element" )
        mat23_t m = mat23(
            vec3( 3.0f, 0, 0 ),
            vec3( -2.0f, 0, 0 )
        );
        mat23_t r = mat23_exp2( m );
        TESTFW_EXPECTED( r.x.x == 8.0f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
    TESTFW_TEST_END();

    // mat23_floor
    TESTFW_TEST_BEGIN( "mat23_floor applies floor to each element" )
        mat23_t m = mat23(
            vec3( 2.7f, 0, 0 ),
            vec3( -3.2f, 0, 0 )
        );
        mat23_t r = mat23_floor( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
    TESTFW_TEST_END();

    // mat23_fmod
    TESTFW_TEST_BEGIN( "mat23_fmod applies fmod to each element" )
        mat23_t a = mat23(
            vec3( 6.5f, 0, 0 ),
            vec3(-5.0f, 0, 0 )
        );
        mat23_t b = mat23(
            vec3( 2.0f, 0, 0 ),
            vec3( 3.0f, 0, 0 )
        );
        mat23_t r = mat23_fmod( a, b );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
    TESTFW_TEST_END();

    // mat23_frac
    TESTFW_TEST_BEGIN( "mat23_frac returns fractional part of each element" )
        mat23_t m = mat23(
            vec3( 3.75f, 0, 0 ),
            vec3( -2.25f, 0, 0 )
        );
        mat23_t r = mat23_frac( m );
        TESTFW_EXPECTED( r.x.x == 0.75f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
    TESTFW_TEST_END();

    // mat23_lerp
    TESTFW_TEST_BEGIN( "mat23_lerp linearly interpolates between matrices element-wise" )
        mat23_t a = mat23(
            vec3( 2.0f, 0, 0 ),
            vec3(-4.0f, 0, 0 )
        );
        mat23_t b = mat23(
            vec3( 6.0f, 0, 0 ),
            vec3( 8.0f, 0, 0 )
        );
        mat23_t r = mat23_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
    TESTFW_TEST_END();

    // mat23_log
    TESTFW_TEST_BEGIN( "mat23_log applies natural log to each element" )
        mat23_t m = mat23(
            vec3( 1.0f, 0, 0 ),
            vec3( 2.718282f, 0, 0 )
        );
        mat23_t r = mat23_log( m );
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
    TESTFW_TEST_END();

    // mat23_log2
    TESTFW_TEST_BEGIN( "mat23_log2 applies base-2 logarithm to each element" )
        mat23_t m = mat23(
            vec3( 16.0f, 0, 0 ),
            vec3( 0.25f, 0, 0 )
        );
        mat23_t r = mat23_log2( m );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
    TESTFW_TEST_END();

    // mat23_log10
    TESTFW_TEST_BEGIN( "mat23_log10 applies base-10 logarithm to each element" )
        mat23_t m = mat23(
            vec3( 100.0f, 0, 0 ),
            vec3( 0.001f, 0, 0 )
        );
        mat23_t r = mat23_log10( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
    TESTFW_TEST_END();

    // mat23_max
    TESTFW_TEST_BEGIN( "mat23_max returns element-wise maximum of two matrices" )
        mat23_t a = mat23(
            vec3( 3.0f, 0, 0 ),
            vec3( -5.0f, 0, 0 )
        );
        mat23_t b = mat23(
            vec3( 2.0f, 0, 0 ),
            vec3( -4.0f, 0, 0 )
        );
        mat23_t r = mat23_max( a, b );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
    TESTFW_TEST_END();

    // mat23_min
    TESTFW_TEST_BEGIN( "mat23_min returns element-wise minimum of two matrices" )
        mat23_t a = mat23(
            vec3( 3.0f, 0, 0 ),
            vec3( -5.0f, 0, 0 )
        );
        mat23_t b = mat23(
            vec3( 2.0f, 0, 0 ),
            vec3( -4.0f, 0, 0 )
        );
        mat23_t r = mat23_min( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -5.0f );
    TESTFW_TEST_END();

    // mat23_pow
    TESTFW_TEST_BEGIN( "mat23_pow applies pow to each element" )
        mat23_t a = mat23(
            vec3( 4.0f, 0, 0 ),
            vec3( 9.0f, 0, 0 )
        );
        mat23_t b = mat23f( 0.5f );
        mat23_t r = mat23_pow( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
    TESTFW_TEST_END();

    // mat23_radians
    TESTFW_TEST_BEGIN( "mat23_radians converts degrees to radians element-wise" )
        mat23_t m = mat23(
            vec3( 90.0f, 0, 0 ),
            vec3( -45.0f, 0, 0 )
        );
        mat23_t r = mat23_radians( m );
        TESTFW_EXPECTED( r.x.x == 1.57079633f );
        TESTFW_EXPECTED( r.y.x == -0.78539816f );
    TESTFW_TEST_END();

    // mat23_rcp
    TESTFW_TEST_BEGIN( "mat23_rcp returns element-wise reciprocal" )
        mat23_t m = mat23(
            vec3( 4.0f, 0, 0 ),
            vec3( -0.5f, 0, 0 )
        );
        mat23_t r = mat23_rcp( m );
        TESTFW_EXPECTED( r.x.x == 0.25f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
    TESTFW_TEST_END();

    // mat23_round
    TESTFW_TEST_BEGIN( "mat23_round rounds each element to nearest integer" )
        mat23_t m = mat23(
            vec3( 2.6f, 0, 0 ),
            vec3( -3.4f, 0, 0 )
        );
        mat23_t r = mat23_round( m );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
    TESTFW_TEST_END();

    // mat23_rsqrt
    TESTFW_TEST_BEGIN( "mat23_rsqrt returns reciprocal square root of each element" )
        mat23_t m = mat23(
            vec3( 4.0f, 0, 0 ),
            vec3( 0.25f, 0, 0 )
        );
        mat23_t r = mat23_rsqrt( m );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
    TESTFW_TEST_END();

    // mat23_saturate
    TESTFW_TEST_BEGIN( "mat23_saturate clamps each element to the [0, 1] range" )
        mat23_t m = mat23(
            vec3(-2.0f, 0, 0 ),
            vec3( 1.5f, 0, 0 )
        );
        mat23_t r = mat23_saturate( m );
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
    TESTFW_TEST_END();

    // mat23_sign
    TESTFW_TEST_BEGIN( "mat23_sign returns sign of each element" )
        mat23_t m = mat23(
            vec3( 3.5f, 0, 0 ),
            vec3(-2.0f, 0, 0 )
        );
        mat23_t r = mat23_sign( m );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
    TESTFW_TEST_END();

    // mat23_sin
    TESTFW_TEST_BEGIN( "mat23_sin applies sin to each element" )
        mat23_t m = mat23(
            vec3( 0.5f, 0, 0 ),
            vec3(-2.0f, 0, 0 )
        );
        mat23_t r = mat23_sin( m );
        TESTFW_EXPECTED( r.x.x == 0.47942554f );
        TESTFW_EXPECTED( r.y.x == -0.90929743f );
    TESTFW_TEST_END();

    // mat23_sinh
    TESTFW_TEST_BEGIN( "mat23_sinh applies sinh to each element" )
        mat23_t m = mat23(
            vec3(-1.0f, 0, 0),
            vec3( 0.0f, 0, 0)
        );
        mat23_t r = mat23_sinh(m);
        TESTFW_EXPECTED( r.x.x == -1.17520119f );
        TESTFW_EXPECTED( r.y.x == 0.00000000f );
    TESTFW_TEST_END();

    // mat23_smoothstep
    TESTFW_TEST_BEGIN( "mat23_smoothstep performs Hermite interpolation element-wise" )
        mat23_t a = mat23(
            vec3( 2.0f, 0, 0),
            vec3(10.0f, 0, 0)
        );
        mat23_t b = mat23(
            vec3( 6.0f, 0, 0),
            vec3(14.0f, 0, 0)
        );
        mat23_t t = mat23(
            vec3( 3.0f, 0, 0),
            vec3(12.0f, 0, 0)
        );
        mat23_t r = mat23_smoothstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.15625f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
    TESTFW_TEST_END();

    // mat23_smootherstep
    TESTFW_TEST_BEGIN( "mat23_smootherstep performs quintic Hermite interpolation element-wise" )
        mat23_t a = mat23(
            vec3( 0.0f, 0, 0),
            vec3( 4.0f, 0, 0)
        );
        mat23_t b = mat23(
            vec3( 8.0f, 0, 0),
            vec3(12.0f, 0, 0)
        );
        mat23_t t = mat23(
            vec3( 4.0f, 0, 0),
            vec3(10.0f, 0, 0)
        );
        mat23_t r = mat23_smootherstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 0.89648438f );
    TESTFW_TEST_END();

    // mat23_sqrt
    TESTFW_TEST_BEGIN( "mat23_sqrt returns square root of each element" )
        mat23_t m = mat23(
            vec3(16.0f, 0, 0),
            vec3( 0.25f, 0, 0)
        );
        mat23_t r = mat23_sqrt(m);
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
    TESTFW_TEST_END();

    // mat23_step
    TESTFW_TEST_BEGIN( "mat23_step returns 0.0 or 1.0 per element based on threshold" )
        mat23_t a = mat23(
            vec3(2.5f, 0, 0),
            vec3(6.0f, 0, 0)
        );
        mat23_t b = mat23(
            vec3(3.0f, 0, 0),
            vec3(5.0f, 0, 0)
        );
        mat23_t r = mat23_step(a, b);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f );
    TESTFW_TEST_END();

    // mat23_tan
    TESTFW_TEST_BEGIN( "mat23_tan applies tan to each element" )
        mat23_t m = mat23(
            vec3( 0.5f, 0, 0),
            vec3(-1.0f, 0, 0)
        );
        mat23_t r = mat23_tan(m);
        TESTFW_EXPECTED( r.x.x == 0.54630249f );
        TESTFW_EXPECTED( r.y.x == -1.55740772f );
    TESTFW_TEST_END();

    // mat23_tanh
    TESTFW_TEST_BEGIN( "mat23_tanh applies tanh to each element" )
        mat23_t m = mat23(
            vec3( 1.0f, 0, 0),
            vec3(-2.0f, 0, 0)
        );
        mat23_t r = mat23_tanh(m);
        TESTFW_EXPECTED( r.x.x == 0.76159416f );
        TESTFW_EXPECTED( r.y.x == -0.96402758f );
    TESTFW_TEST_END();

    // mat23_trunc
    TESTFW_TEST_BEGIN( "mat23_trunc removes fractional part of each element" )
        mat23_t m = mat23(
            vec3( 3.7f, 0, 0),
            vec3(-2.9f, 0, 0)
        );
        mat23_t r = mat23_trunc(m);
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
    TESTFW_TEST_END();
}


void test_mat32( void ) {
    // mat32
    TESTFW_TEST_BEGIN( "mat32 constructs matrix from three distinct row vectors" )
        mat32_t m = mat32(
            vec2( 1.0f, 2.0f ),
            vec2( 5.0f, 6.0f ),
            vec2( 9.0f, 10.0f )
        );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 2.0f );
        TESTFW_EXPECTED( m.y.x == 5.0f );
        TESTFW_EXPECTED( m.y.y == 6.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
        TESTFW_EXPECTED( m.z.y == 10.0f );
    TESTFW_TEST_END();

    // mat32f
    TESTFW_TEST_BEGIN( "mat32f constructs a matrix with all elements equal to input" )
        mat32_t m = mat32f( -3.5f );
        TESTFW_EXPECTED( m.x.x == -3.5f );
        TESTFW_EXPECTED( m.x.y == -3.5f );
        TESTFW_EXPECTED( m.y.x == -3.5f );
        TESTFW_EXPECTED( m.y.y == -3.5f );
        TESTFW_EXPECTED( m.z.x == -3.5f );
        TESTFW_EXPECTED( m.z.y == -3.5f );
    TESTFW_TEST_END();

    // mat32_get
    TESTFW_TEST_BEGIN( "mat32_get returns each row by index" )
        mat32_t m = mat32(
            vec2( 10, 0 ),
            vec2( 20, 0 ),
            vec2( 30, 0 )
        );
        vec2_t r0 = mat32_get( m, 0 );
        vec2_t r1 = mat32_get( m, 1 );
        vec2_t r2 = mat32_get( m, 2 );
        TESTFW_EXPECTED( r0.x == 10.0f );
        TESTFW_EXPECTED( r1.x == 20.0f );
        TESTFW_EXPECTED( r2.x == 30.0f );
    TESTFW_TEST_END();

    // mat32_set
    TESTFW_TEST_BEGIN( "mat32_set modifies only the specified row" )
        mat32_t m = mat32(
            vec2(1,0), vec2(2,0), vec2(3,0)
        );
        mat32_set( &m, 0, vec2(9,0) );
        TESTFW_EXPECTED( m.x.x == 9.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );

        m = mat32(
            vec2(1,0), vec2(2,0), vec2(3,0)
        );
        mat32_set( &m, 1, vec2(9,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 9.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );

        m = mat32(
            vec2(1,0), vec2(2,0), vec2(3,0)
        );
        mat32_set( &m, 2, vec2(9,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
    TESTFW_TEST_END();

    // mat32_neg
    TESTFW_TEST_BEGIN( "mat32_neg negates each element of the matrix" )
        mat32_t m = mat32(
            vec2( 1, -2 ),
            vec2( -3, 4 ),
            vec2( 5, -6 )
        );
        mat32_t r = mat32_neg( m );
        TESTFW_EXPECTED( r.x.x == -1.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == -5.0f );
    TESTFW_TEST_END();

    // mat32_eq
    TESTFW_TEST_BEGIN( "mat32_eq returns nonzero if all corresponding rows are equal" )
        mat32_t a = mat32(
            vec2(1,2),
            vec2(3,4),
            vec2(5,6)
        );
        mat32_t b = a;
        TESTFW_EXPECTED( mat32_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat32_eq returns zero if any element differs" )
        mat32_t a = mat32(
            vec2(1,2),
            vec2(3,4),
            vec2(5,6)
        );
        mat32_t b = a;
        b.z.y = 99.0f;
        TESTFW_EXPECTED( mat32_eq( a, b ) == 0 );

        b = a;
        b.x.x = 0.0f;
        TESTFW_EXPECTED( mat32_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // mat32_add
    TESTFW_TEST_BEGIN( "mat32_add adds corresponding elements of two matrices" )
        mat32_t a = mat32(
            vec2( 1, 0 ),
            vec2( 6, 0 ),
            vec2( 8, 0 )
        );
        mat32_t b = mat32(
            vec2( 4, 0 ),
            vec2( 9, 0 ),
            vec2( 3, 0 )
        );
        mat32_t r = mat32_add( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 15.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
    TESTFW_TEST_END();

    // mat32_sub
    TESTFW_TEST_BEGIN( "mat32_sub subtracts corresponding elements of two matrices" )
        mat32_t a = mat32(
            vec2( 8, 0 ),
            vec2(15, 0 ),
            vec2( 5, 0 )
        );
        mat32_t b = mat32(
            vec2( 3, 0 ),
            vec2( 4, 0 ),
            vec2( 2, 0 )
        );
        mat32_t r = mat32_sub( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 11.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat32_mul_elem
    TESTFW_TEST_BEGIN( "mat32_mul_elem multiplies corresponding elements of two matrices" )
        mat32_t a = mat32(
            vec2( 2, 0 ),
            vec2( 5, 0 ),
            vec2(10, 0 )
        );
        mat32_t b = mat32(
            vec2( 3, 0 ),
            vec2( 4, 0 ),
            vec2( 2, 0 )
        );
        mat32_t r = mat32_mul_elem( a, b );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 20.0f );
        TESTFW_EXPECTED( r.z.x == 20.0f );
    TESTFW_TEST_END();

    // mat32_div
    TESTFW_TEST_BEGIN( "mat32_div divides corresponding elements of two matrices" )
        mat32_t a = mat32(
            vec2(10, 0 ),
            vec2(18, 0 ),
            vec2(12, 0 )
        );
        mat32_t b = mat32(
            vec2( 2, 0 ),
            vec2( 3, 0 ),
            vec2( 4, 0 )
        );
        mat32_t r = mat32_div( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 6.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat32_addf
    TESTFW_TEST_BEGIN( "mat32_addf adds scalar to all elements of matrix" )
        mat32_t m = mat32(
            vec2( 2.0f, 0 ),
            vec2( 5.0f, 0 ),
            vec2( 8.0f, 0 )
        );
        mat32_t r = mat32_addf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 8.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
    TESTFW_TEST_END();

    // mat32_subf
    TESTFW_TEST_BEGIN( "mat32_subf subtracts scalar from all elements of matrix" )
        mat32_t m = mat32(
            vec2(10.0f, 0 ),
            vec2( 6.0f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat32_t r = mat32_subf( m, 4.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == -4.0f );
    TESTFW_TEST_END();

    // mat32_mulf
    TESTFW_TEST_BEGIN( "mat32_mulf multiplies all elements by scalar" )
        mat32_t m = mat32(
            vec2( 2.0f, 0 ),
            vec2(-1.0f, 0 ),
            vec2( 3.0f, 0 )
        );
        mat32_t r = mat32_mulf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 9.0f );
    TESTFW_TEST_END();

    // mat32_divf
    TESTFW_TEST_BEGIN( "mat32_divf divides all elements by scalar" )
        mat32_t m = mat32(
            vec2( 4.0f, 0 ),
            vec2(-4.0f, 0 ),
            vec2( 6.0f, 0 )
        );
        mat32_t r = mat32_divf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat32_abs
    TESTFW_TEST_BEGIN( "mat32_abs applies absolute value to each element of the matrix" )
        mat32_t m = mat32(
            vec2( -1.0f, 0.0f ),
            vec2( 0.0f, -2.0f ),
            vec2( 0.0f, 0.0f )
        );
        mat32_t r = mat32_abs( m );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 2.0f );
    TESTFW_TEST_END();

    // mat32_acos
    TESTFW_TEST_BEGIN( "mat32_acos applies acos to each element" )
        mat32_t m = mat32(
            vec2( 0.5f, 0 ),
            vec2( -1.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t r = mat32_acos( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 1.04719758f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, 3.14159265f ));
        TESTFW_EXPECTED( test_cmp(r.z.x, 0.00000000f ));
    TESTFW_TEST_END();

    // mat32_all
    TESTFW_TEST_BEGIN( "mat32_all returns nonzero only if all six elements are nonzero" )
        TESTFW_EXPECTED( mat32_all( mat32(
            vec2(1,1), vec2(1,1), vec2(1,1)
        ) ) != 0 );

        TESTFW_EXPECTED( mat32_all( mat32(
            vec2(0,1), vec2(1,1), vec2(1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat32_all( mat32(
            vec2(1,1), vec2(1,0), vec2(1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat32_all( mat32(
            vec2(1,1), vec2(1,1), vec2(1,0)
        ) ) == 0 );

        TESTFW_EXPECTED( mat32_all( mat32f( 1.0f ) ) != 0 );
    TESTFW_TEST_END();

    // mat32_any
    TESTFW_TEST_BEGIN( "mat32_any returns nonzero if any element is nonzero" )
        TESTFW_EXPECTED( mat32_any( mat32(
            vec2(0,1), vec2(0,0), vec2(0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat32_any( mat32(
            vec2(0,0), vec2(1,0), vec2(0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat32_any( mat32(
            vec2(0,0), vec2(0,0), vec2(0,1)
        ) ) != 0 );

        TESTFW_EXPECTED( mat32_any( mat32f( 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // mat32_asin
    TESTFW_TEST_BEGIN( "mat32_asin applies asin to each element" )
        mat32_t m = mat32(
            vec2( 0.5f, 0 ),
            vec2( -1.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t r = mat32_asin( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 0.52359878f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, -1.57079633f ));
        TESTFW_EXPECTED( test_cmp(r.z.x, 1.57079633f ));
    TESTFW_TEST_END();

    // mat32_atan
    TESTFW_TEST_BEGIN( "mat32_atan applies atan to each element" )
        mat32_t m = mat32(
            vec2( 0.5f, 0 ),
            vec2( -2.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t r = mat32_atan( m );
        TESTFW_EXPECTED( r.x.x == 0.46364761f );
        TESTFW_EXPECTED( r.y.x == -1.10714872f );
        TESTFW_EXPECTED( r.z.x == 0.78539816f );
    TESTFW_TEST_END();

    // mat32_atan2
    TESTFW_TEST_BEGIN( "mat32_atan2 applies atan2 to each element" )
        mat32_t y = mat32(
            vec2( 2.0f, 0 ),
            vec2( -3.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t x = mat32(
            vec2( 1.0f, 0 ),
            vec2( -4.0f, 0 ),
            vec2( -1.0f, 0 )
        );
        mat32_t r = mat32_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.10714872f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, -2.49809154f ));
        TESTFW_EXPECTED( test_cmp( r.z.x, 2.35619449f ));
    TESTFW_TEST_END();

    // mat32_ceil
    TESTFW_TEST_BEGIN( "mat32_ceil applies ceil to each element" )
        mat32_t m = mat32(
            vec2( 1.2f, 0 ),
            vec2( -3.7f, 0 ),
            vec2( -0.1f, 0 )
        );
        mat32_t r = mat32_ceil( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat32_clamp
    TESTFW_TEST_BEGIN( "mat32_clamp clamps each element using corresponding min and max matrices" )
        mat32_t v = mat32(
            vec2( 5.0f, 0 ),
            vec2(-10.0f, 0 ),
            vec2( 0.5f, 0 )
        );
        mat32_t mn = mat32(
            vec2( 0.0f, 0 ),
            vec2( -8.0f, 0 ),
            vec2( -1.0f, 0 )
        );
        mat32_t mx = mat32(
            vec2( 4.0f, 0 ),
            vec2( -7.0f, 0 ),
            vec2( 2.0f, 0 )
        );
        mat32_t r = mat32_clamp( v, mn, mx );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -8.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
    TESTFW_TEST_END();

    // mat32_cos
    TESTFW_TEST_BEGIN( "mat32_cos applies cos to each element" )
        mat32_t m = mat32(
            vec2( 0.5f, 0 ),
            vec2( 2.0f, 0 ),
            vec2( 3.14159265f, 0 )
        );
        mat32_t r = mat32_cos( m );
        TESTFW_EXPECTED( r.x.x == 0.87758256f );
        TESTFW_EXPECTED( r.y.x == -0.41614684f );
        TESTFW_EXPECTED( r.z.x == -1.00000000f );
    TESTFW_TEST_END();

    // mat32_cosh
    TESTFW_TEST_BEGIN( "mat32_cosh applies cosh to each element" )
        mat32_t m = mat32(
            vec2( 0.5f, 0 ),
            vec2( 2.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t r = mat32_cosh( m );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.12762597f ) );
        TESTFW_EXPECTED( test_cmp( r.y.x, 3.76219569f ) );
        TESTFW_EXPECTED( test_cmp( r.z.x, 1.54308063f ) );
    TESTFW_TEST_END();

    // mat32_degrees
    TESTFW_TEST_BEGIN( "mat32_degrees converts radians to degrees element-wise" )
        mat32_t m = mat32(
            vec2( 0.5f, 0 ),
            vec2( -1.0f, 0 ),
            vec2( 3.14159265f, 0 )
        );
        mat32_t r = mat32_degrees( m );
        TESTFW_EXPECTED( r.x.x == 28.6478898f );
        TESTFW_EXPECTED( r.y.x == -57.2957795f );
        TESTFW_EXPECTED( r.z.x == 180.0f );
    TESTFW_TEST_END();

    // mat32_exp
    TESTFW_TEST_BEGIN( "mat32_exp applies exp to each element" )
        mat32_t m = mat32(
            vec2( 0.5f, 0 ),
            vec2( -2.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t r = mat32_exp( m );
        TESTFW_EXPECTED( r.x.x == 1.64872127f );
        TESTFW_EXPECTED( r.y.x == 0.13533528f );
        TESTFW_EXPECTED( r.z.x == 2.71828183f );
    TESTFW_TEST_END();

    // mat32_exp2
    TESTFW_TEST_BEGIN( "mat32_exp2 applies exp2 to each element" )
        mat32_t m = mat32(
            vec2( 3.0f, 0 ),
            vec2( -2.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t r = mat32_exp2( m );
        TESTFW_EXPECTED( r.x.x == 8.0f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
    TESTFW_TEST_END();

    // mat32_floor
    TESTFW_TEST_BEGIN( "mat32_floor applies floor to each element" )
        mat32_t m = mat32(
            vec2( 2.7f, 0 ),
            vec2( -3.2f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat32_t r = mat32_floor( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat32_fmod
    TESTFW_TEST_BEGIN( "mat32_fmod applies fmod to each element" )
        mat32_t a = mat32(
            vec2( 6.5f, 0 ),
            vec2(-5.0f, 0 ),
            vec2( 7.75f, 0 )
        );
        mat32_t b = mat32(
            vec2( 2.0f, 0 ),
            vec2( 3.0f, 0 ),
            vec2( 2.5f, 0 )
        );
        mat32_t r = mat32_fmod( a, b );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
    TESTFW_TEST_END();

    // mat32_frac
    TESTFW_TEST_BEGIN( "mat32_frac returns fractional part of each element" )
        mat32_t m = mat32(
            vec2( 3.75f, 0 ),
            vec2( -2.25f, 0 ),
            vec2( 1.5f, 0 )
        );
        mat32_t r = mat32_frac( m );
        TESTFW_EXPECTED( r.x.x == 0.75f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 0.50f );
    TESTFW_TEST_END();

    // mat32_lerp
    TESTFW_TEST_BEGIN( "mat32_lerp linearly interpolates between matrices element-wise" )
        mat32_t a = mat32(
            vec2( 2.0f, 0 ),
            vec2(-4.0f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat32_t b = mat32(
            vec2( 6.0f, 0 ),
            vec2( 8.0f, 0 ),
            vec2( 4.0f, 0 )
        );
        mat32_t r = mat32_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat32_log
    TESTFW_TEST_BEGIN( "mat32_log applies natural log to each element" )
        mat32_t m = mat32(
            vec2( 1.0f, 0 ),
            vec2( 2.718282f, 0 ),
            vec2( 7.3890561f,0 )
        );
        mat32_t r = mat32_log( m );
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
    TESTFW_TEST_END();

    // mat32_log2
    TESTFW_TEST_BEGIN( "mat32_log2 applies base-2 logarithm to each element" )
        mat32_t m = mat32(
            vec2( 16.0f, 0 ),
            vec2( 0.25f, 0 ),
            vec2( 2.0f, 0 )
        );
        mat32_t r = mat32_log2( m );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat32_log10
    TESTFW_TEST_BEGIN( "mat32_log10 applies base-10 logarithm to each element" )
        mat32_t m = mat32(
            vec2( 100.0f, 0 ),
            vec2( 0.001f, 0 ),
            vec2( 10.0f, 0 )
        );
        mat32_t r = mat32_log10( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat32_max
    TESTFW_TEST_BEGIN( "mat32_max returns element-wise maximum of two matrices" )
        mat32_t a = mat32(
            vec2( 3.0f, 0 ),
            vec2( -5.0f, 0 ),
            vec2( 7.0f, 0 )
        );
        mat32_t b = mat32(
            vec2( 2.0f, 0 ),
            vec2( -4.0f, 0 ),
            vec2( 8.0f, 0 )
        );
        mat32_t r = mat32_max( a, b );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 8.0f );
    TESTFW_TEST_END();

    // mat32_min
    TESTFW_TEST_BEGIN( "mat32_min returns element-wise minimum of two matrices" )
        mat32_t a = mat32(
            vec2( 3.0f, 0 ),
            vec2( -5.0f, 0 ),
            vec2( 7.0f, 0 )
        );
        mat32_t b = mat32(
            vec2( 2.0f, 0 ),
            vec2( -4.0f, 0 ),
            vec2( 8.0f, 0 )
        );
        mat32_t r = mat32_min( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -5.0f );
        TESTFW_EXPECTED( r.z.x == 7.0f );
    TESTFW_TEST_END();

    // mat32_pow
    TESTFW_TEST_BEGIN( "mat32_pow applies pow to each element" )
        mat32_t a = mat32(
            vec2( 4.0f, 0 ),
            vec2( 9.0f, 0 ),
            vec2( 16.0f, 0 )
        );
        mat32_t b = mat32f( 0.5f );
        mat32_t r = mat32_pow( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == 4.0f );
    TESTFW_TEST_END();

    // mat32_radians
    TESTFW_TEST_BEGIN( "mat32_radians converts degrees to radians element-wise" )
        mat32_t m = mat32(
            vec2( 90.0f, 0 ),
            vec2( -45.0f, 0 ),
            vec2( 180.0f, 0 )
        );
        mat32_t r = mat32_radians( m );
        TESTFW_EXPECTED( r.x.x == 1.57079633f );
        TESTFW_EXPECTED( r.y.x == -0.78539816f );
        TESTFW_EXPECTED( r.z.x == 3.14159265f );
    TESTFW_TEST_END();

    // mat32_rcp
    TESTFW_TEST_BEGIN( "mat32_rcp returns element-wise reciprocal" )
        mat32_t m = mat32(
            vec2( 4.0f, 0 ),
            vec2( -0.5f, 0 ),
            vec2( 2.0f, 0 )
        );
        mat32_t r = mat32_rcp( m );
        TESTFW_EXPECTED( r.x.x == 0.25f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
    TESTFW_TEST_END();

    // mat32_round
    TESTFW_TEST_BEGIN( "mat32_round rounds each element to nearest integer" )
        mat32_t m = mat32(
            vec2( 2.6f, 0 ),
            vec2( -3.4f, 0 ),
            vec2( -1.7f, 0 )
        );
        mat32_t r = mat32_round( m );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == -2.0f );
    TESTFW_TEST_END();

    // mat32_rsqrt
    TESTFW_TEST_BEGIN( "mat32_rsqrt returns reciprocal square root of each element" )
        mat32_t m = mat32(
            vec2( 4.0f, 0 ),
            vec2( 0.25f, 0 ),
            vec2( 16.0f, 0 )
        );
        mat32_t r = mat32_rsqrt(m);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
    TESTFW_TEST_END();

    // mat32_saturate
    TESTFW_TEST_BEGIN( "mat32_saturate clamps each element to the [0, 1] range" )
        mat32_t m = mat32(
            vec2(-2.0f, 0 ),
            vec2( 1.5f, 0 ),
            vec2( 0.5f, 0 )
        );
        mat32_t r = mat32_saturate(m);
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
    TESTFW_TEST_END();

    // mat32_sign
    TESTFW_TEST_BEGIN( "mat32_sign returns sign of each element" )
        mat32_t m = mat32(
            vec2( 3.5f, 0 ),
            vec2(-2.0f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat32_t r = mat32_sign(m);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat32_sin
    TESTFW_TEST_BEGIN( "mat32_sin applies sin to each element" )
        mat32_t m = mat32(
            vec2( 0.5f, 0 ),
            vec2(-2.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t r = mat32_sin(m);
        TESTFW_EXPECTED( r.x.x == 0.47942554f );
        TESTFW_EXPECTED( r.y.x == -0.90929743f );
        TESTFW_EXPECTED( r.z.x == 0.84147098f );
    TESTFW_TEST_END();

    // mat32_sinh
    TESTFW_TEST_BEGIN( "mat32_sinh applies sinh to each element" )
        mat32_t m = mat32(
            vec2(-1.0f, 0 ),
            vec2( 0.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t r = mat32_sinh(m);
        TESTFW_EXPECTED( r.x.x == -1.17520119f );
        TESTFW_EXPECTED( r.y.x == 0.00000000f );
        TESTFW_EXPECTED( r.z.x == 1.17520119f );
    TESTFW_TEST_END();

    // mat32_smoothstep
    TESTFW_TEST_BEGIN( "mat32_smoothstep performs Hermite interpolation element-wise" )
        mat32_t a = mat32(
            vec2( 2.0f, 0 ),
            vec2(10.0f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat32_t b = mat32(
            vec2( 6.0f, 0 ),
            vec2(14.0f, 0 ),
            vec2( 4.0f, 0 )
        );
        mat32_t t = mat32(
            vec2( 3.0f, 0 ),
            vec2(12.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t r = mat32_smoothstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.15625f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 0.15625f );
    TESTFW_TEST_END();

    // mat32_smootherstep
    TESTFW_TEST_BEGIN( "mat32_smootherstep performs quintic Hermite interpolation element-wise" )
        mat32_t a = mat32(
            vec2( 0.0f, 0 ),
            vec2( 4.0f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat32_t b = mat32(
            vec2( 8.0f, 0 ),
            vec2(12.0f, 0 ),
            vec2( 8.0f, 0 )
        );
        mat32_t t = mat32(
            vec2( 4.0f, 0 ),
            vec2(10.0f, 0 ),
            vec2( 2.0f, 0 )
        );
        mat32_t r = mat32_smootherstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 0.89648438f );
        TESTFW_EXPECTED( r.z.x == 0.103515625f );
    TESTFW_TEST_END();

    // mat32_sqrt
    TESTFW_TEST_BEGIN( "mat32_sqrt returns square root of each element" )
        mat32_t m = mat32(
            vec2(16.0f, 0 ),
            vec2( 0.25f, 0 ),
            vec2( 9.0f, 0 )
        );
        mat32_t r = mat32_sqrt(m);
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat32_step
    TESTFW_TEST_BEGIN( "mat32_step returns 0.0 or 1.0 per element based on threshold" )
        mat32_t a = mat32(
            vec2(2.5f, 0 ),
            vec2(6.0f, 0 ),
            vec2(4.0f, 0 )
        );
        mat32_t b = mat32(
            vec2(3.0f, 0 ),
            vec2(5.0f, 0 ),
            vec2(4.0f, 0 )
        );
        mat32_t r = mat32_step(a, b);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat32_tan
    TESTFW_TEST_BEGIN( "mat32_tan applies tan to each element" )
        mat32_t m = mat32(
            vec2( 0.5f, 0 ),
            vec2(-1.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat32_t r = mat32_tan(m);
        TESTFW_EXPECTED( r.x.x == 0.54630249f );
        TESTFW_EXPECTED( r.y.x == -1.55740772f );
        TESTFW_EXPECTED( r.z.x == 1.55740772f );
    TESTFW_TEST_END();

    // mat32_tanh
    TESTFW_TEST_BEGIN( "mat32_tanh applies tanh to each element" )
        mat32_t m = mat32(
            vec2( 1.0f, 0 ),
            vec2(-2.0f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat32_t r = mat32_tanh(m);
        TESTFW_EXPECTED( r.x.x == 0.76159416f );
        TESTFW_EXPECTED( r.y.x == -0.96402758f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat32_trunc
    TESTFW_TEST_BEGIN( "mat32_trunc removes fractional part of each element" )
        mat32_t m = mat32(
            vec2( 3.7f, 0 ),
            vec2(-2.9f, 0 ),
            vec2( 0.5f, 0 )
        );
        mat32_t r = mat32_trunc(m);
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();
}


void test_mat33( void ) {
    // mat33
    TESTFW_TEST_BEGIN( "mat33 constructs matrix from three distinct row vectors" )
        mat33_t m = mat33(
            vec3( 1.0f, 2.0f, 3.0f ),
            vec3( 5.0f, 6.0f, 7.0f ),
            vec3( 9.0f, 10.0f, 11.0f )
        );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 2.0f );
        TESTFW_EXPECTED( m.x.z == 3.0f );
        TESTFW_EXPECTED( m.y.x == 5.0f );
        TESTFW_EXPECTED( m.y.y == 6.0f );
        TESTFW_EXPECTED( m.y.z == 7.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
        TESTFW_EXPECTED( m.z.y == 10.0f );
        TESTFW_EXPECTED( m.z.z == 11.0f );
    TESTFW_TEST_END();

    // mat33f
    TESTFW_TEST_BEGIN( "mat33f constructs a matrix with all elements equal to input" )
        mat33_t m = mat33f( -3.5f );
        TESTFW_EXPECTED( m.x.x == -3.5f );
        TESTFW_EXPECTED( m.x.y == -3.5f );
        TESTFW_EXPECTED( m.x.z == -3.5f );
        TESTFW_EXPECTED( m.y.x == -3.5f );
        TESTFW_EXPECTED( m.y.y == -3.5f );
        TESTFW_EXPECTED( m.y.z == -3.5f );
        TESTFW_EXPECTED( m.z.x == -3.5f );
        TESTFW_EXPECTED( m.z.y == -3.5f );
        TESTFW_EXPECTED( m.z.z == -3.5f );
    TESTFW_TEST_END();

    // mat33_get
    TESTFW_TEST_BEGIN( "mat33_get returns each row by index" )
        mat33_t m = mat33(
            vec3( 10, 0, 0 ),
            vec3( 20, 0, 0 ),
            vec3( 30, 0, 0 )
        );
        vec3_t r0 = mat33_get( m, 0 );
        vec3_t r1 = mat33_get( m, 1 );
        vec3_t r2 = mat33_get( m, 2 );
        TESTFW_EXPECTED( r0.x == 10.0f );
        TESTFW_EXPECTED( r1.x == 20.0f );
        TESTFW_EXPECTED( r2.x == 30.0f );
    TESTFW_TEST_END();

    // mat33_set
    TESTFW_TEST_BEGIN( "mat33_set modifies only the specified row" )
        mat33_t m = mat33(
            vec3(1,0,0), vec3(2,0,0),
            vec3(3,0,0)
        );
        mat33_set( &m, 0, vec3(9,0,0) );
        TESTFW_EXPECTED( m.x.x == 9.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );

        m = mat33(
            vec3(1,0,0), vec3(2,0,0),
            vec3(3,0,0)
        );
        mat33_set( &m, 1, vec3(9,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 9.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );

        m = mat33(
            vec3(1,0,0), vec3(2,0,0),
            vec3(3,0,0)
        );
        mat33_set( &m, 2, vec3(9,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
    TESTFW_TEST_END();

    // mat33_neg
    TESTFW_TEST_BEGIN( "mat33_neg negates each element of the matrix" )
        mat33_t m = mat33(
            vec3( 1, -2, 0 ),
            vec3( -3, 4, 0 ),
            vec3( 5, -6, 0 )
        );
        mat33_t r = mat33_neg( m );
        TESTFW_EXPECTED( r.x.x == -1.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == -5.0f );
    TESTFW_TEST_END();

    // mat33_eq
    TESTFW_TEST_BEGIN( "mat33_eq returns nonzero if all corresponding rows are equal" )
        mat33_t a = mat33(
            vec3(1,2,3),
            vec3(4,5,6),
            vec3(7,8,9)
        );
        mat33_t b = a;
        TESTFW_EXPECTED( mat33_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat33_eq returns zero if any element differs" )
        mat33_t a = mat33(
            vec3(1,2,3),
            vec3(4,5,6),
            vec3(7,8,9)
        );
        mat33_t b = a;
        b.z.z = 99.0f;
        TESTFW_EXPECTED( mat33_eq( a, b ) == 0 );

        b = a;
        b.x.x = 0.0f;
        TESTFW_EXPECTED( mat33_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // mat33_add
    TESTFW_TEST_BEGIN( "mat33_add adds corresponding elements of two matrices" )
        mat33_t a = mat33(
            vec3( 1, 0, 0 ),
            vec3( 6, 0, 0 ),
            vec3( 8, 0, 0 )
        );
        mat33_t b = mat33(
            vec3( 4, 0, 0 ),
            vec3( 9, 0, 0 ),
            vec3( 3, 0, 0 )
        );
        mat33_t r = mat33_add( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 15.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
    TESTFW_TEST_END();

    // mat33_sub
    TESTFW_TEST_BEGIN( "mat33_sub subtracts corresponding elements of two matrices" )
        mat33_t a = mat33(
            vec3( 8, 0, 0 ),
            vec3(15, 0, 0 ),
            vec3( 5, 0, 0 )
        );
        mat33_t b = mat33(
            vec3( 3, 0, 0 ),
            vec3( 4, 0, 0 ),
            vec3( 2, 0, 0 )
        );
        mat33_t r = mat33_sub( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 11.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat33_mul_elem
    TESTFW_TEST_BEGIN( "mat33_mul_elem multiplies corresponding elements of two matrices" )
        mat33_t a = mat33(
            vec3( 2, 0, 0 ),
            vec3( 5, 0, 0 ),
            vec3(10, 0, 0 )
        );
        mat33_t b = mat33(
            vec3( 3, 0, 0 ),
            vec3( 4, 0, 0 ),
            vec3( 2, 0, 0 )
        );
        mat33_t r = mat33_mul_elem( a, b );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 20.0f );
        TESTFW_EXPECTED( r.z.x == 20.0f );
    TESTFW_TEST_END();

    // mat33_div
    TESTFW_TEST_BEGIN( "mat33_div divides corresponding elements of two matrices" )
        mat33_t a = mat33(
            vec3(10, 0, 0 ),
            vec3(18, 0, 0 ),
            vec3(12, 0, 0 )
        );
        mat33_t b = mat33(
            vec3( 2, 0, 0 ),
            vec3( 3, 0, 0 ),
            vec3( 4, 0, 0 )
        );
        mat33_t r = mat33_div( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 6.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat33_addf
    TESTFW_TEST_BEGIN( "mat33_addf adds scalar to all elements of matrix" )
        mat33_t m = mat33(
            vec3( 2.0f, 0, 0 ),
            vec3( 5.0f, 0, 0 ),
            vec3( 8.0f, 0, 0 )
        );
        mat33_t r = mat33_addf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 8.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
    TESTFW_TEST_END();

    // mat33_subf
    TESTFW_TEST_BEGIN( "mat33_subf subtracts scalar from all elements of matrix" )
        mat33_t m = mat33(
            vec3(10.0f, 0, 0 ),
            vec3( 6.0f, 0, 0 ),
            vec3( 0.0f, 0, 0 )
        );
        mat33_t r = mat33_subf( m, 4.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == -4.0f );
    TESTFW_TEST_END();

    // mat33_mulf
    TESTFW_TEST_BEGIN( "mat33_mulf multiplies all elements by scalar" )
        mat33_t m = mat33(
            vec3( 2.0f, 0, 0 ),
            vec3(-1.0f, 0, 0 ),
            vec3( 3.0f, 0, 0 )
        );
        mat33_t r = mat33_mulf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 9.0f );
    TESTFW_TEST_END();

    // mat33_divf
    TESTFW_TEST_BEGIN( "mat33_divf divides all elements by scalar" )
        mat33_t m = mat33(
            vec3( 4.0f, 0, 0 ),
            vec3(-4.0f, 0, 0 ),
            vec3( 6.0f, 0, 0 )
        );
        mat33_t r = mat33_divf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat33_abs
    TESTFW_TEST_BEGIN( "mat33_abs applies absolute value to each element of the matrix" )
        mat33_t m = mat33(
            vec3( -1.0f, 0.0f, 0.0f ),
            vec3( 0.0f, -2.0f, 0.0f ),
            vec3( 0.0f, 0.0f, -3.5f )
        );
        mat33_t r = mat33_abs( m );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 2.0f );
        TESTFW_EXPECTED( r.z.z == 3.5f );
    TESTFW_TEST_END();

    // mat33_acos
    TESTFW_TEST_BEGIN( "mat33_acos applies acos to each element" )
        mat33_t m = mat33(
            vec3( 0.5f, 0, 0 ),
            vec3( -1.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat33_t r = mat33_acos( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 1.04719758f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, 3.14159265f ));
        TESTFW_EXPECTED( test_cmp(r.z.x, 0.00000000f ));
    TESTFW_TEST_END();

    // mat33_all
    TESTFW_TEST_BEGIN( "mat33_all returns nonzero only if all nine elements are nonzero" )
        TESTFW_EXPECTED( mat33_all( mat33(
            vec3(1,1,1), vec3(1,1,1), vec3(1,1,1)
        ) ) != 0 );

        TESTFW_EXPECTED( mat33_all( mat33(
            vec3(0,1,1), vec3(1,1,1), vec3(1,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat33_all( mat33(
            vec3(1,1,1), vec3(1,0,1), vec3(1,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat33_all( mat33(
            vec3(1,1,1), vec3(1,1,1), vec3(0,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat33_all( mat33f( 1.0f ) ) != 0 );
    TESTFW_TEST_END();

    // mat33_any
    TESTFW_TEST_BEGIN( "mat33_any returns nonzero if any element is nonzero" )
        TESTFW_EXPECTED( mat33_any( mat33(
            vec3(0,1,0), vec3(0,0,0), vec3(0,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat33_any( mat33(
            vec3(0,0,0), vec3(0,0,1), vec3(0,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat33_any( mat33(
            vec3(0,0,0), vec3(0,0,0), vec3(0,0,1)
        ) ) != 0 );

        TESTFW_EXPECTED( mat33_any( mat33(
            vec3(0,0,0), vec3(0,0,0), vec3(1,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat33_any( mat33f( 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // mat33_asin
    TESTFW_TEST_BEGIN( "mat33_asin applies asin to each element" )
        mat33_t m = mat33(
            vec3( 0.5f, 0, 0 ),
            vec3( -1.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat33_t r = mat33_asin( m );
        TESTFW_EXPECTED( test_cmp(r.x.x,0.52359878f ));
        TESTFW_EXPECTED( test_cmp(r.y.x,-1.57079633f ));
        TESTFW_EXPECTED( test_cmp(r.z.x,1.57079633f ));
    TESTFW_TEST_END();

    // mat33_atan
    TESTFW_TEST_BEGIN( "mat33_atan applies atan to each element" )
        mat33_t m = mat33(
            vec3( 0.5f, 0, 0 ),
            vec3( -2.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat33_t r = mat33_atan( m );
        TESTFW_EXPECTED( r.x.x == 0.46364761f );
        TESTFW_EXPECTED( r.y.x == -1.10714872f );
        TESTFW_EXPECTED( r.z.x == 0.78539816f );
    TESTFW_TEST_END();

    // mat33_atan2
    TESTFW_TEST_BEGIN( "mat33_atan2 applies atan2 to each element" )
        mat33_t y = mat33(
            vec3( 2.0f, 0, 0 ),
            vec3( -3.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat33_t x = mat33(
            vec3( 1.0f, 0, 0 ),
            vec3( -4.0f, 0, 0 ),
            vec3( -1.0f, 0, 0 )
        );
        mat33_t r = mat33_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.10714872f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, -2.49809154f ));
        TESTFW_EXPECTED( test_cmp( r.z.x, 2.35619449f ));
    TESTFW_TEST_END();

    // mat33_ceil
    TESTFW_TEST_BEGIN( "mat33_ceil applies ceil to each element" )
        mat33_t m = mat33(
            vec3( 1.2f, 0, 0 ),
            vec3( -3.7f, 0, 0 ),
            vec3( -0.1f, 0, 0 )
        );
        mat33_t r = mat33_ceil( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat33_clamp
    TESTFW_TEST_BEGIN( "mat33_clamp clamps each element using corresponding min and max matrices" )
        mat33_t v = mat33(
            vec3( 5.0f, 0, 0 ),
            vec3(-10.0f, 0, 0 ),
            vec3( 0.5f, 0, 0 )
        );
        mat33_t mn = mat33(
            vec3( 0.0f, 0, 0 ),
            vec3( -8.0f, 0, 0 ),
            vec3( -1.0f, 0, 0 )
        );
        mat33_t mx = mat33(
            vec3( 4.0f, 0, 0 ),
            vec3( -7.0f, 0, 0 ),
            vec3( 2.0f, 0, 0 )
        );
        mat33_t r = mat33_clamp( v, mn, mx );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -8.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
    TESTFW_TEST_END();

    // mat33_cos
    TESTFW_TEST_BEGIN( "mat33_cos applies cos to each element" )
        mat33_t m = mat33(
            vec3( 0.5f, 0,0 ),
            vec3( 2.0f, 0,0 ),
            vec3( 3.14159265f, 0,0 )
        );
        mat33_t r = mat33_cos( m );
        TESTFW_EXPECTED( r.x.x == 0.87758256f );
        TESTFW_EXPECTED( r.y.x == -0.41614684f );
        TESTFW_EXPECTED( r.z.x == -1.00000000f );
    TESTFW_TEST_END();

    // mat33_cosh
    TESTFW_TEST_BEGIN( "mat33_cosh applies cosh to each element" )
        mat33_t m = mat33(
            vec3( 0.5f, 0,0 ),
            vec3( 2.0f, 0,0 ),
            vec3( 1.0f, 0,0 )
        );
        mat33_t r = mat33_cosh( m );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.12762597f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, 3.76219569f ));
        TESTFW_EXPECTED( test_cmp( r.z.x, 1.54308063f ));
    TESTFW_TEST_END();

    // mat33_degrees
    TESTFW_TEST_BEGIN( "mat33_degrees converts radians to degrees element-wise" )
        mat33_t m = mat33(
            vec3( 0.5f, 0,0 ),
            vec3( -1.0f, 0,0 ),
            vec3( 3.14159265f, 0,0 )
        );
        mat33_t r = mat33_degrees( m );
        TESTFW_EXPECTED( r.x.x == 28.6478898f );
        TESTFW_EXPECTED( r.y.x == -57.2957795f );
        TESTFW_EXPECTED( r.z.x == 180.0f );
    TESTFW_TEST_END();

    // mat33_exp
    TESTFW_TEST_BEGIN( "mat33_exp applies exp to each element" )
        mat33_t m = mat33(
            vec3( 0.5f, 0,0 ),
            vec3( -2.0f, 0,0 ),
            vec3( 1.0f, 0,0 )
        );
        mat33_t r = mat33_exp( m );
        TESTFW_EXPECTED( r.x.x == 1.64872127f );
        TESTFW_EXPECTED( r.y.x == 0.13533528f );
        TESTFW_EXPECTED( r.z.x == 2.71828183f );
    TESTFW_TEST_END();

    // mat33_exp2
    TESTFW_TEST_BEGIN( "mat33_exp2 applies exp2 to each element" )
        mat33_t m = mat33(
            vec3( 3.0f, 0,0 ),
            vec3( -2.0f, 0,0 ),
            vec3( 1.0f, 0,0 )
        );
        mat33_t r = mat33_exp2( m );
        TESTFW_EXPECTED( r.x.x == 8.0f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
    TESTFW_TEST_END();

    // mat33_floor
    TESTFW_TEST_BEGIN( "mat33_floor applies floor to each element" )
        mat33_t m = mat33(
            vec3( 2.7f, 0,0 ),
            vec3( -3.2f, 0,0 ),
            vec3( 0.0f, 0,0 )
        );
        mat33_t r = mat33_floor( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat33_fmod
    TESTFW_TEST_BEGIN( "mat33_fmod applies fmod to each element" )
        mat33_t a = mat33(
            vec3( 6.5f, 0,0 ),
            vec3(-5.0f, 0,0 ),
            vec3( 7.75f, 0,0 )
        );
        mat33_t b = mat33(
            vec3( 2.0f, 0,0 ),
            vec3( 3.0f, 0,0 ),
            vec3( 2.5f, 0,0 )
        );
        mat33_t r = mat33_fmod( a, b );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
    TESTFW_TEST_END();

    // mat33_frac
    TESTFW_TEST_BEGIN( "mat33_frac returns fractional part of each element" )
        mat33_t m = mat33(
            vec3( 3.75f, 0,0 ),
            vec3( -2.25f, 0,0 ),
            vec3( 1.5f, 0,0 )
        );
        mat33_t r = mat33_frac( m );
        TESTFW_EXPECTED( r.x.x == 0.75f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 0.50f );
    TESTFW_TEST_END();

    // mat33_lerp
    TESTFW_TEST_BEGIN( "mat33_lerp linearly interpolates between matrices element-wise" )
        mat33_t a = mat33(
            vec3( 2.0f, 0,0 ),
            vec3(-4.0f, 0,0 ),
            vec3( 0.0f, 0,0 )
        );
        mat33_t b = mat33(
            vec3( 6.0f, 0,0 ),
            vec3( 8.0f, 0,0 ),
            vec3( 4.0f, 0,0 )
        );
        mat33_t r = mat33_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat33_log
    TESTFW_TEST_BEGIN( "mat33_log applies natural log to each element" )
        mat33_t m = mat33(
            vec3( 1.0f, 0,0 ),
            vec3( 2.718282f, 0,0 ),
            vec3( 7.3890561f,0,0 )
        );
        mat33_t r = mat33_log( m );
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
    TESTFW_TEST_END();

    // mat33_log2
    TESTFW_TEST_BEGIN( "mat33_log2 applies base-2 logarithm to each element" )
        mat33_t m = mat33(
            vec3( 16.0f, 0,0 ),
            vec3( 0.25f, 0,0 ),
            vec3( 2.0f, 0,0 )
        );
        mat33_t r = mat33_log2( m );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat33_log10
    TESTFW_TEST_BEGIN( "mat33_log10 applies base-10 logarithm to each element" )
        mat33_t m = mat33(
            vec3( 100.0f, 0,0 ),
            vec3( 0.001f,0,0 ),
            vec3( 10.0f, 0,0 )
        );
        mat33_t r = mat33_log10( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat33_max
    TESTFW_TEST_BEGIN( "mat33_max returns element-wise maximum of two matrices" )
        mat33_t a = mat33(
            vec3( 3.0f, 0,0 ),
            vec3( -5.0f, 0,0 ),
            vec3( 7.0f, 0,0 )
        );
        mat33_t b = mat33(
            vec3( 2.0f, 0,0 ),
            vec3( -4.0f, 0,0 ),
            vec3( 8.0f, 0,0 )
        );
        mat33_t r = mat33_max( a, b );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 8.0f );
    TESTFW_TEST_END();

    // mat33_min
    TESTFW_TEST_BEGIN( "mat33_min returns element-wise minimum of two matrices" )
        mat33_t a = mat33(
            vec3( 3.0f, 0,0 ),
            vec3( -5.0f, 0,0 ),
            vec3( 7.0f, 0,0 )
        );
        mat33_t b = mat33(
            vec3( 2.0f, 0,0 ),
            vec3( -4.0f, 0,0 ),
            vec3( 8.0f, 0,0 )
        );
        mat33_t r = mat33_min( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -5.0f );
        TESTFW_EXPECTED( r.z.x == 7.0f );
    TESTFW_TEST_END();

    // mat33_pow
    TESTFW_TEST_BEGIN( "mat33_pow applies pow to each element" )
        mat33_t a = mat33(
            vec3( 4.0f, 0,0 ),
            vec3( 9.0f, 0,0 ),
            vec3( 16.0f, 0,0 )
        );
        mat33_t b = mat33f( 0.5f );
        mat33_t r = mat33_pow( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == 4.0f );
    TESTFW_TEST_END();

    // mat33_radians
    TESTFW_TEST_BEGIN( "mat33_radians converts degrees to radians element-wise" )
        mat33_t m = mat33(
            vec3( 90.0f, 0,0 ),
            vec3( -45.0f, 0,0 ),
            vec3( 180.0f, 0,0 )
        );
        mat33_t r = mat33_radians( m );
        TESTFW_EXPECTED( r.x.x == 1.57079633f );
        TESTFW_EXPECTED( r.y.x == -0.78539816f );
        TESTFW_EXPECTED( r.z.x == 3.14159265f );
    TESTFW_TEST_END();

    // mat33_rcp
    TESTFW_TEST_BEGIN( "mat33_rcp returns element-wise reciprocal" )
        mat33_t m = mat33(
            vec3( 4.0f, 0,0 ),
            vec3( -0.5f, 0,0 ),
            vec3( 2.0f, 0,0 )
        );
        mat33_t r = mat33_rcp( m );
        TESTFW_EXPECTED( r.x.x == 0.25f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
    TESTFW_TEST_END();

    // mat33_round
    TESTFW_TEST_BEGIN( "mat33_round rounds each element to nearest integer" )
        mat33_t m = mat33(
            vec3( 2.6f, 0,0 ),
            vec3( -3.4f, 0,0 ),
            vec3( -1.7f, 0,0 )
        );
        mat33_t r = mat33_round( m );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == -2.0f );
    TESTFW_TEST_END();

    // mat33_rsqrt
    TESTFW_TEST_BEGIN( "mat33_rsqrt returns reciprocal square root of each element" )
        mat33_t m = mat33(
            vec3( 4.0f, 0,0 ),
            vec3( 0.25f, 0,0 ),
            vec3( 16.0f, 0,0 )
        );
        mat33_t r = mat33_rsqrt(m);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
    TESTFW_TEST_END();

    // mat33_saturate
    TESTFW_TEST_BEGIN( "mat33_saturate clamps each element to the [0, 1] range" )
        mat33_t m = mat33(
            vec3(-2.0f, 0,0 ),
            vec3( 1.5f, 0,0 ),
            vec3( 0.5f, 0,0 )
        );
        mat33_t r = mat33_saturate(m);
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
    TESTFW_TEST_END();

    // mat33_sign
    TESTFW_TEST_BEGIN( "mat33_sign returns sign of each element" )
        mat33_t m = mat33(
            vec3( 3.5f, 0,0 ),
            vec3(-2.0f, 0,0 ),
            vec3( 0.0f, 0,0 )
        );
        mat33_t r = mat33_sign(m);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat33_sin
    TESTFW_TEST_BEGIN( "mat33_sin applies sin to each element" )
        mat33_t m = mat33(
            vec3( 0.5f, 0,0 ),
            vec3(-2.0f, 0,0 ),
            vec3( 1.0f, 0,0 )
        );
        mat33_t r = mat33_sin(m);
        TESTFW_EXPECTED( r.x.x == 0.47942554f );
        TESTFW_EXPECTED( r.y.x == -0.90929743f );
        TESTFW_EXPECTED( r.z.x == 0.84147098f );
    TESTFW_TEST_END();

    // mat33_sinh
    TESTFW_TEST_BEGIN( "mat33_sinh applies sinh to each element" )
        mat33_t m = mat33(
            vec3(-1.0f, 0,0 ),
            vec3( 0.0f, 0,0 ),
            vec3( 1.0f, 0,0 )
        );
        mat33_t r = mat33_sinh(m);
        TESTFW_EXPECTED( r.x.x == -1.17520119f );
        TESTFW_EXPECTED( r.y.x == 0.00000000f );
        TESTFW_EXPECTED( r.z.x == 1.17520119f );
    TESTFW_TEST_END();

    // mat33_smoothstep
    TESTFW_TEST_BEGIN( "mat33_smoothstep performs Hermite interpolation element-wise" )
        mat33_t a = mat33(
            vec3( 2.0f, 0,0 ),
            vec3(10.0f, 0,0 ),
            vec3( 0.0f, 0,0 )
        );
        mat33_t b = mat33(
            vec3( 6.0f, 0,0 ),
            vec3(14.0f, 0,0 ),
            vec3( 4.0f, 0,0 )
        );
        mat33_t t = mat33(
            vec3( 3.0f, 0,0 ),
            vec3(12.0f, 0,0 ),
            vec3( 1.0f, 0,0 )
        );
        mat33_t r = mat33_smoothstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.15625f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 0.15625f );
    TESTFW_TEST_END();

    // mat33_smootherstep
    TESTFW_TEST_BEGIN( "mat33_smootherstep performs quintic Hermite interpolation element-wise" )
        mat33_t a = mat33(
            vec3( 0.0f, 0,0 ),
            vec3( 4.0f, 0,0 ),
            vec3( 0.0f, 0,0 )
        );
        mat33_t b = mat33(
            vec3( 8.0f, 0,0 ),
            vec3(12.0f, 0,0 ),
            vec3( 8.0f, 0,0 )
        );
        mat33_t t = mat33(
            vec3( 4.0f, 0,0 ),
            vec3(10.0f, 0,0 ),
            vec3( 2.0f, 0,0 )
        );
        mat33_t r = mat33_smootherstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 0.89648438f );
        TESTFW_EXPECTED( r.z.x == 0.103515625f );
    TESTFW_TEST_END();

    // mat33_sqrt
    TESTFW_TEST_BEGIN( "mat33_sqrt returns square root of each element" )
        mat33_t m = mat33(
            vec3(16.0f, 0,0 ),
            vec3( 0.25f,0,0 ),
            vec3( 9.0f, 0,0 )
        );
        mat33_t r = mat33_sqrt(m);
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat33_step
    TESTFW_TEST_BEGIN( "mat33_step returns 0.0 or 1.0 per element based on threshold" )
        mat33_t a = mat33(
            vec3(2.5f, 0,0 ),
            vec3(6.0f, 0,0 ),
            vec3(4.0f, 0,0 )
        );
        mat33_t b = mat33(
            vec3(3.0f, 0,0 ),
            vec3(5.0f, 0,0 ),
            vec3(4.0f, 0,0 )
        );
        mat33_t r = mat33_step(a, b);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat33_tan
    TESTFW_TEST_BEGIN( "mat33_tan applies tan to each element" )
        mat33_t m = mat33(
            vec3( 0.5f, 0,0 ),
            vec3(-1.0f, 0,0 ),
            vec3( 1.0f, 0,0 )
        );
        mat33_t r = mat33_tan(m);
        TESTFW_EXPECTED( r.x.x == 0.54630249f );
        TESTFW_EXPECTED( r.y.x == -1.55740772f );
        TESTFW_EXPECTED( r.z.x == 1.55740772f );
    TESTFW_TEST_END();

    // mat33_tanh
    TESTFW_TEST_BEGIN( "mat33_tanh applies tanh to each element" )
        mat33_t m = mat33(
            vec3( 1.0f, 0,0 ),
            vec3(-2.0f, 0,0 ),
            vec3( 0.0f, 0,0 )
        );
        mat33_t r = mat33_tanh(m);
        TESTFW_EXPECTED( r.x.x == 0.76159416f );
        TESTFW_EXPECTED( r.y.x == -0.96402758f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat33_trunc
    TESTFW_TEST_BEGIN( "mat33_trunc removes fractional part of each element" )
        mat33_t m = mat33(
            vec3( 3.7f, 0,0 ),
            vec3(-2.9f, 0,0 ),
            vec3( 0.5f, 0,0 )
        );
        mat33_t r = mat33_trunc(m);
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

}


void test_mat24( void ) {
    // mat24
    TESTFW_TEST_BEGIN( "mat24 constructs matrix from two distinct row vectors" )
        mat24_t m = mat24(
            vec4( 1.0f, 2.0f, 3.0f, 4.0f ),
            vec4( 5.0f, 6.0f, 7.0f, 8.0f ) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 2.0f );
        TESTFW_EXPECTED( m.x.z == 3.0f );
        TESTFW_EXPECTED( m.x.w == 4.0f );
        TESTFW_EXPECTED( m.y.x == 5.0f );
        TESTFW_EXPECTED( m.y.y == 6.0f );
        TESTFW_EXPECTED( m.y.z == 7.0f );
        TESTFW_EXPECTED( m.y.w == 8.0f );
    TESTFW_TEST_END();

    // mat24f
    TESTFW_TEST_BEGIN( "mat24f constructs a matrix with all elements equal to input" )
        mat24_t m = mat24f( -3.5f );
        TESTFW_EXPECTED( m.x.x == -3.5f );
        TESTFW_EXPECTED( m.x.y == -3.5f );
        TESTFW_EXPECTED( m.x.z == -3.5f );
        TESTFW_EXPECTED( m.x.w == -3.5f );
        TESTFW_EXPECTED( m.y.x == -3.5f );
        TESTFW_EXPECTED( m.y.y == -3.5f );
        TESTFW_EXPECTED( m.y.z == -3.5f );
        TESTFW_EXPECTED( m.y.w == -3.5f );
    TESTFW_TEST_END();

    // mat24_get
    TESTFW_TEST_BEGIN( "mat24_get returns each row by index" )
        mat24_t m = mat24(
            vec4( 10, 0, 0, 0 ),
            vec4( 20, 0, 0, 0 ) );
        vec4_t r0 = mat24_get( m, 0 );
        vec4_t r1 = mat24_get( m, 1 );
        TESTFW_EXPECTED( r0.x == 10.0f );
        TESTFW_EXPECTED( r1.x == 20.0f );
    TESTFW_TEST_END();

    // mat24_set
    TESTFW_TEST_BEGIN( "mat24_set modifies only the specified row" )
        mat24_t m = mat24(
            vec4(1,0,0,0), vec4(2,0,0,0) );
        mat24_set( &m, 0, vec4(9,0,0,0) );
        TESTFW_EXPECTED( m.x.x == 9.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );

        m = mat24(
            vec4(1,0,0,0), vec4(2,0,0,0) );
        mat24_set( &m, 1, vec4(9,0,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 9.0f );
    TESTFW_TEST_END();

    // mat24_neg
    TESTFW_TEST_BEGIN( "mat24_neg negates each element of the matrix" )
        mat24_t m = mat24(
            vec4( 1, -2, 0, 0 ),
            vec4( -3, 4, 0, 0 ) );
        mat24_t r = mat24_neg( m );
        TESTFW_EXPECTED( r.x.x == -1.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
    TESTFW_TEST_END();

    // mat24_eq
    TESTFW_TEST_BEGIN( "mat24_eq returns nonzero if all corresponding rows are equal" )
        mat24_t a = mat24(
            vec4(1,2,3,4),
            vec4(5,6,7,8) );
        mat24_t b = a;
        TESTFW_EXPECTED( mat24_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat24_eq returns zero if any element differs" )
        mat24_t a = mat24(
            vec4(1,2,3,4),
            vec4(5,6,7,8) );
        mat24_t b = a;
        b.y.z = 99.0f;
        TESTFW_EXPECTED( mat24_eq( a, b ) == 0 );

        b = a;
        b.x.x = 0.0f;
        TESTFW_EXPECTED( mat24_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // mat24_add
    TESTFW_TEST_BEGIN( "mat24_add adds corresponding elements of two matrices" )
        mat24_t a = mat24(
            vec4( 1, 0,0,0 ),
            vec4( 6, 0,0,0 ) );
        mat24_t b = mat24(
            vec4( 4, 0,0,0 ),
            vec4( 9, 0,0,0 ) );
        mat24_t r = mat24_add( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 15.0f );
    TESTFW_TEST_END();

    // mat24_sub
    TESTFW_TEST_BEGIN( "mat24_sub subtracts corresponding elements of two matrices" )
        mat24_t a = mat24(
            vec4( 8, 0,0,0 ),
            vec4(15, 0,0,0 ) );
        mat24_t b = mat24(
            vec4( 3, 0,0,0 ),
            vec4( 4, 0,0,0 ) );
        mat24_t r = mat24_sub( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 11.0f );
    TESTFW_TEST_END();

    // mat24_mul_elem
    TESTFW_TEST_BEGIN( "mat24_mul_elem multiplies corresponding elements of two matrices" )
        mat24_t a = mat24(
            vec4( 2, 0,0,0 ),
            vec4( 5, 0,0,0 ) );
        mat24_t b = mat24(
            vec4( 3, 0,0,0 ),
            vec4( 4, 0,0,0 ) );
        mat24_t r = mat24_mul_elem( a, b );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 20.0f );
    TESTFW_TEST_END();

    // mat24_div
    TESTFW_TEST_BEGIN( "mat24_div divides corresponding elements of two matrices" )
        mat24_t a = mat24(
            vec4(10, 0,0,0 ),
            vec4(18, 0,0,0 ) );
        mat24_t b = mat24(
            vec4( 2, 0,0,0 ),
            vec4( 3, 0,0,0 ) );
        mat24_t r = mat24_div( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 6.0f );
    TESTFW_TEST_END();

    // mat24_addf
    TESTFW_TEST_BEGIN( "mat24_addf adds scalar to all elements of matrix" )
        mat24_t m = mat24(
            vec4( 2.0f, 0,0,0 ),
            vec4( 5.0f, 0,0,0 ) );
        mat24_t r = mat24_addf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 8.0f );
    TESTFW_TEST_END();

    // mat24_subf
    TESTFW_TEST_BEGIN( "mat24_subf subtracts scalar from all elements of matrix" )
        mat24_t m = mat24(
            vec4(10.0f, 0,0,0 ),
            vec4( 6.0f, 0,0,0 ) );
        mat24_t r = mat24_subf( m, 4.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
    TESTFW_TEST_END();

    // mat24_mulf
    TESTFW_TEST_BEGIN( "mat24_mulf multiplies all elements by scalar" )
        mat24_t m = mat24(
            vec4( 2.0f, 0,0,0 ),
            vec4(-1.0f, 0,0,0 ) );
        mat24_t r = mat24_mulf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
    TESTFW_TEST_END();

    // mat24_divf
    TESTFW_TEST_BEGIN( "mat24_divf divides all elements by scalar" )
        mat24_t m = mat24(
            vec4( 4.0f, 0,0,0 ),
            vec4(-4.0f, 0,0,0 ) );
        mat24_t r = mat24_divf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
    TESTFW_TEST_END();

    // mat24_abs
    TESTFW_TEST_BEGIN( "mat24_abs applies absolute value to each element of the matrix" )
        mat24_t m = mat24(
            vec4( -1.0f, 0.0f, 0.0f, 0.0f ),
            vec4( 0.0f, -2.0f, 0.0f, 0.0f ) );
        mat24_t r = mat24_abs( m );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 2.0f );
    TESTFW_TEST_END();

    // mat24_acos
    TESTFW_TEST_BEGIN( "mat24_acos applies acos to each element" )
        mat24_t m = mat24(
            vec4( 0.5f, 0, 0, 0 ),
            vec4( -1.0f, 0, 0, 0 ) );
        mat24_t r = mat24_acos( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 1.04719758f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, 3.14159265f ));
    TESTFW_TEST_END();

    // mat24_all
    TESTFW_TEST_BEGIN( "mat24_all returns nonzero only if all eight elements are nonzero" )
        TESTFW_EXPECTED( mat24_all( mat24(
            vec4(1,1,1,1), vec4(1,1,1,1) ) ) != 0 );

        TESTFW_EXPECTED( mat24_all( mat24(
            vec4(0,1,1,1), vec4(1,1,1,1) ) ) == 0 );

        TESTFW_EXPECTED( mat24_all( mat24(
            vec4(1,1,1,1), vec4(1,0,1,1) ) ) == 0 );

        TESTFW_EXPECTED( mat24_all( mat24(
            vec4(1,1,1,0), vec4(1,1,1,1) ) ) == 0 );

        TESTFW_EXPECTED( mat24_all( mat24(
            vec4(1,1,1,1), vec4(1,1,1,0) ) ) == 0 );

        TESTFW_EXPECTED( mat24_all( mat24f( 1.0f ) ) != 0 );
    TESTFW_TEST_END();

    // mat24_any
    TESTFW_TEST_BEGIN( "mat24_any returns nonzero if any element is nonzero" )
        TESTFW_EXPECTED( mat24_any( mat24(
            vec4(0,1,0,0), vec4(0,0,0,0) ) ) != 0 );

        TESTFW_EXPECTED( mat24_any( mat24(
            vec4(0,0,0,0), vec4(0,0,1,0) ) ) != 0 );

        TESTFW_EXPECTED( mat24_any( mat24(
            vec4(0,0,0,0), vec4(0,0,0,1) ) ) != 0 );

        TESTFW_EXPECTED( mat24_any( mat24(
            vec4(1,0,0,0), vec4(0,0,0,0) ) ) != 0 );

        TESTFW_EXPECTED( mat24_any( mat24f( 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // mat24_asin
    TESTFW_TEST_BEGIN( "mat24_asin applies asin to each element" )
        mat24_t m = mat24(
            vec4( 0.5f, 0, 0, 0 ),
            vec4( -1.0f, 0, 0, 0 ) );
        mat24_t r = mat24_asin( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 0.52359878f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, -1.57079633f ));
    TESTFW_TEST_END();

    // mat24_atan
    TESTFW_TEST_BEGIN( "mat24_atan applies atan to each element" )
        mat24_t m = mat24(
            vec4( 0.5f, 0,0,0 ),
            vec4( -2.0f, 0,0,0 ) );
        mat24_t r = mat24_atan( m );
        TESTFW_EXPECTED( r.x.x == 0.46364761f );
        TESTFW_EXPECTED( r.y.x == -1.10714872f );
    TESTFW_TEST_END();

    // mat24_atan2
    TESTFW_TEST_BEGIN( "mat24_atan2 applies atan2 to each element" )
        mat24_t y = mat24(
            vec4( 2.0f, 0,0,0 ),
            vec4( -3.0f, 0,0,0 ) );
        mat24_t x = mat24(
            vec4( 1.0f, 0,0,0 ),
            vec4( -4.0f, 0,0,0 ) );
        mat24_t r = mat24_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.10714872f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, -2.49809154f ));
    TESTFW_TEST_END();

    // mat24_ceil
    TESTFW_TEST_BEGIN( "mat24_ceil applies ceil to each element" )
        mat24_t m = mat24(
            vec4( 1.2f, 0,0,0 ),
            vec4( -3.7f, 0,0,0 ) );
        mat24_t r = mat24_ceil( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
    TESTFW_TEST_END();

    // mat24_clamp
    TESTFW_TEST_BEGIN( "mat24_clamp clamps each element using corresponding min and max matrices" )
        mat24_t v = mat24(
            vec4( 5.0f, 0,0,0 ),
            vec4(-10.0f, 0,0,0 ) );
        mat24_t mn = mat24(
            vec4( 0.0f, 0,0,0 ),
            vec4( -8.0f, 0,0,0 ) );
        mat24_t mx = mat24(
            vec4( 4.0f, 0,0,0 ),
            vec4( -7.0f, 0,0,0 ) );
        mat24_t r = mat24_clamp( v, mn, mx );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -8.0f );
    TESTFW_TEST_END();

    // mat24_cos
    TESTFW_TEST_BEGIN( "mat24_cos applies cos to each element" )
        mat24_t m = mat24(
            vec4( 0.5f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ) );
        mat24_t r = mat24_cos( m );
        TESTFW_EXPECTED( r.x.x == 0.87758256f );
        TESTFW_EXPECTED( r.y.x == -0.41614684f );
    TESTFW_TEST_END();

    // mat24_cosh
    TESTFW_TEST_BEGIN( "mat24_cosh applies cosh to each element" )
        mat24_t m = mat24(
            vec4( 0.5f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ) );
        mat24_t r = mat24_cosh( m );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.12762597f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, 3.76219569f ));
    TESTFW_TEST_END();

    // mat24_degrees
    TESTFW_TEST_BEGIN( "mat24_degrees converts radians to degrees element-wise" )
        mat24_t m = mat24(
            vec4( 0.5f, 0,0,0 ),
            vec4( -1.0f, 0,0,0 ) );
        mat24_t r = mat24_degrees( m );
        TESTFW_EXPECTED( r.x.x == 28.6478898f );
        TESTFW_EXPECTED( r.y.x == -57.2957795f );
    TESTFW_TEST_END();

    // mat24_exp
    TESTFW_TEST_BEGIN( "mat24_exp applies exp to each element" )
        mat24_t m = mat24(
            vec4( 0.5f, 0,0,0 ),
            vec4( -2.0f, 0,0,0 ) );
        mat24_t r = mat24_exp( m );
        TESTFW_EXPECTED( r.x.x == 1.64872127f );
        TESTFW_EXPECTED( r.y.x == 0.13533528f );
    TESTFW_TEST_END();

    // mat24_exp2
    TESTFW_TEST_BEGIN( "mat24_exp2 applies exp2 to each element" )
        mat24_t m = mat24(
            vec4( 3.0f, 0,0,0 ),
            vec4( -2.0f, 0,0,0 ) );
        mat24_t r = mat24_exp2( m );
        TESTFW_EXPECTED( r.x.x == 8.0f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
    TESTFW_TEST_END();

    // mat24_floor
    TESTFW_TEST_BEGIN( "mat24_floor applies floor to each element" )
        mat24_t m = mat24(
            vec4( 2.7f, 0,0,0 ),
            vec4( -3.2f, 0,0,0 ) );
        mat24_t r = mat24_floor( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
    TESTFW_TEST_END();

    // mat24_fmod
    TESTFW_TEST_BEGIN( "mat24_fmod applies fmod to each element" )
        mat24_t a = mat24(
            vec4( 6.5f, 0,0,0 ),
            vec4(-5.0f, 0,0,0 ) );
        mat24_t b = mat24(
            vec4( 2.0f, 0,0,0 ),
            vec4( 3.0f, 0,0,0 ) );
        mat24_t r = mat24_fmod( a, b );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
    TESTFW_TEST_END();

    // mat24_frac
    TESTFW_TEST_BEGIN( "mat24_frac returns fractional part of each element" )
        mat24_t m = mat24(
            vec4( 3.75f, 0,0,0 ),
            vec4( -2.25f, 0,0,0 ) );
        mat24_t r = mat24_frac( m );
        TESTFW_EXPECTED( r.x.x == 0.75f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
    TESTFW_TEST_END();

    // mat24_lerp
    TESTFW_TEST_BEGIN( "mat24_lerp linearly interpolates between matrices element-wise" )
        mat24_t a = mat24(
            vec4( 2.0f, 0,0,0 ),
            vec4(-4.0f, 0,0,0 ) );
        mat24_t b = mat24(
            vec4( 6.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ) );
        mat24_t r = mat24_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
    TESTFW_TEST_END();

    // mat24_log
    TESTFW_TEST_BEGIN( "mat24_log applies natural log to each element" )
        mat24_t m = mat24(
            vec4( 1.0f, 0,0,0 ),
            vec4( 2.718282f, 0,0,0 ) );
        mat24_t r = mat24_log( m );
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
    TESTFW_TEST_END();

    // mat24_log2
    TESTFW_TEST_BEGIN( "mat24_log2 applies base-2 logarithm to each element" )
        mat24_t m = mat24(
            vec4( 16.0f, 0,0,0 ),
            vec4( 0.25f, 0,0,0 ) );
        mat24_t r = mat24_log2( m );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
    TESTFW_TEST_END();

    // mat24_log10
    TESTFW_TEST_BEGIN( "mat24_log10 applies base-10 logarithm to each element" )
        mat24_t m = mat24(
            vec4( 100.0f, 0,0,0 ),
            vec4( 0.001f,0,0,0 ) );
        mat24_t r = mat24_log10( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
    TESTFW_TEST_END();

    // mat24_max
    TESTFW_TEST_BEGIN( "mat24_max returns element-wise maximum of two matrices" )
        mat24_t a = mat24(
            vec4( 3.0f, 0,0,0 ),
            vec4( -5.0f, 0,0,0 ) );
        mat24_t b = mat24(
            vec4( 2.0f, 0,0,0 ),
            vec4( -4.0f, 0,0,0 ) );
        mat24_t r = mat24_max( a, b );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
    TESTFW_TEST_END();

    // mat24_min
    TESTFW_TEST_BEGIN( "mat24_min returns element-wise minimum of two matrices" )
        mat24_t a = mat24(
            vec4( 3.0f, 0,0,0 ),
            vec4( -5.0f, 0,0,0 ) );
        mat24_t b = mat24(
            vec4( 2.0f, 0,0,0 ),
            vec4( -4.0f, 0,0,0 ) );
        mat24_t r = mat24_min( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -5.0f );
    TESTFW_TEST_END();

    // mat24_pow
    TESTFW_TEST_BEGIN( "mat24_pow applies pow to each element" )
        mat24_t a = mat24(
            vec4( 4.0f, 0,0,0 ),
            vec4( 9.0f, 0,0,0 ) );
        mat24_t b = mat24f( 0.5f );
        mat24_t r = mat24_pow( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
    TESTFW_TEST_END();

    // mat24_radians
    TESTFW_TEST_BEGIN( "mat24_radians converts degrees to radians element-wise" )
        mat24_t m = mat24(
            vec4( 90.0f, 0,0,0 ),
            vec4( -45.0f, 0,0,0 ) );
        mat24_t r = mat24_radians( m );
        TESTFW_EXPECTED( r.x.x == 1.57079633f );
        TESTFW_EXPECTED( r.y.x == -0.78539816f );
    TESTFW_TEST_END();

    // mat24_rcp
    TESTFW_TEST_BEGIN( "mat24_rcp returns element-wise reciprocal" )
        mat24_t m = mat24(
            vec4( 4.0f, 0,0,0 ),
            vec4( -0.5f, 0,0,0 ) );
        mat24_t r = mat24_rcp( m );
        TESTFW_EXPECTED( r.x.x == 0.25f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
    TESTFW_TEST_END();

    // mat24_round
    TESTFW_TEST_BEGIN( "mat24_round rounds each element to nearest integer" )
        mat24_t m = mat24(
            vec4( 2.6f, 0,0,0 ),
            vec4( -3.4f, 0,0,0 ) );
        mat24_t r = mat24_round( m );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
    TESTFW_TEST_END();

    // mat24_rsqrt
    TESTFW_TEST_BEGIN( "mat24_rsqrt returns reciprocal square root of each element" )
        mat24_t m = mat24(
            vec4( 4.0f, 0,0,0 ),
            vec4( 0.25f, 0,0,0 ) );
        mat24_t r = mat24_rsqrt(m);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
    TESTFW_TEST_END();

    // mat24_saturate
    TESTFW_TEST_BEGIN( "mat24_saturate clamps each element to the [0, 1] range" )
        mat24_t m = mat24(
            vec4(-2.0f, 0,0,0 ),
            vec4( 1.5f, 0,0,0 ) );
        mat24_t r = mat24_saturate(m);
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
    TESTFW_TEST_END();

    // mat24_sign
    TESTFW_TEST_BEGIN( "mat24_sign returns sign of each element" )
        mat24_t m = mat24(
            vec4( 3.5f, 0,0,0 ),
            vec4(-2.0f, 0,0,0 ) );
        mat24_t r = mat24_sign(m);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
    TESTFW_TEST_END();

    // mat24_sin
    TESTFW_TEST_BEGIN( "mat24_sin applies sin to each element" )
        mat24_t m = mat24(
            vec4( 0.5f, 0,0,0 ),
            vec4(-2.0f, 0,0,0 ) );
        mat24_t r = mat24_sin(m);
        TESTFW_EXPECTED( r.x.x == 0.47942554f );
        TESTFW_EXPECTED( r.y.x == -0.90929743f );
    TESTFW_TEST_END();

    // mat24_sinh
    TESTFW_TEST_BEGIN( "mat24_sinh applies sinh to each element" )
        mat24_t m = mat24(
            vec4(-1.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ) );
        mat24_t r = mat24_sinh(m);
        TESTFW_EXPECTED( r.x.x == -1.17520119f );
        TESTFW_EXPECTED( r.y.x == 0.00000000f );
    TESTFW_TEST_END();

    // mat24_smoothstep
    TESTFW_TEST_BEGIN( "mat24_smoothstep performs Hermite interpolation element-wise" )
        mat24_t a = mat24(
            vec4( 2.0f, 0,0,0 ),
            vec4(10.0f, 0,0,0 ) );
        mat24_t b = mat24(
            vec4( 6.0f, 0,0,0 ),
            vec4(14.0f, 0,0,0 ) );
        mat24_t t = mat24(
            vec4( 3.0f, 0,0,0 ),
            vec4(12.0f, 0,0,0 ) );
        mat24_t r = mat24_smoothstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.15625f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
    TESTFW_TEST_END();

    // mat24_smootherstep
    TESTFW_TEST_BEGIN( "mat24_smootherstep performs quintic Hermite interpolation element-wise" )
        mat24_t a = mat24(
            vec4( 0.0f, 0,0,0 ),
            vec4( 4.0f, 0,0,0 ) );
        mat24_t b = mat24(
            vec4( 8.0f, 0,0,0 ),
            vec4(12.0f, 0,0,0 ) );
        mat24_t t = mat24(
            vec4( 4.0f, 0,0,0 ),
            vec4(10.0f, 0,0,0 ) );
        mat24_t r = mat24_smootherstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 0.89648438f );
    TESTFW_TEST_END();

    // mat24_sqrt
    TESTFW_TEST_BEGIN( "mat24_sqrt returns square root of each element" )
        mat24_t m = mat24(
            vec4(16.0f, 0,0,0 ),
            vec4( 0.25f,0,0,0 ) );
        mat24_t r = mat24_sqrt(m);
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
    TESTFW_TEST_END();

    // mat24_step
    TESTFW_TEST_BEGIN( "mat24_step returns 0.0 or 1.0 per element based on threshold" )
        mat24_t a = mat24(
            vec4(2.5f, 0,0,0 ),
            vec4(6.0f, 0,0,0 ) );
        mat24_t b = mat24(
            vec4(3.0f, 0,0,0 ),
            vec4(5.0f, 0,0,0 ) );
        mat24_t r = mat24_step(a, b);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f );
    TESTFW_TEST_END();

    // mat24_tan
    TESTFW_TEST_BEGIN( "mat24_tan applies tan to each element" )
        mat24_t m = mat24(
            vec4( 0.5f, 0,0,0 ),
            vec4(-1.0f, 0,0,0 ) );
        mat24_t r = mat24_tan(m);
        TESTFW_EXPECTED( r.x.x == 0.54630249f );
        TESTFW_EXPECTED( r.y.x == -1.55740772f );
    TESTFW_TEST_END();

    // mat24_tanh
    TESTFW_TEST_BEGIN( "mat24_tanh applies tanh to each element" )
        mat24_t m = mat24(
            vec4( 1.0f, 0,0,0 ),
            vec4(-2.0f, 0,0,0 ) );
        mat24_t r = mat24_tanh(m);
        TESTFW_EXPECTED( r.x.x == 0.76159416f );
        TESTFW_EXPECTED( r.y.x == -0.96402758f );
    TESTFW_TEST_END();

    // mat24_trunc
    TESTFW_TEST_BEGIN( "mat24_trunc removes fractional part of each element" )
        mat24_t m = mat24(
            vec4( 3.7f, 0,0,0 ),
            vec4(-2.9f, 0,0,0 ) );
        mat24_t r = mat24_trunc(m);
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
    TESTFW_TEST_END();

}


void test_mat34( void ) {
    // mat34
    TESTFW_TEST_BEGIN( "mat34 constructs matrix from three distinct row vectors" )
        mat34_t m = mat34(
            vec4( 1.0f, 2.0f, 3.0f, 4.0f ),
            vec4( 5.0f, 6.0f, 7.0f, 8.0f ),
            vec4( 9.0f, 10.0f, 11.0f, 12.0f ) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 2.0f );
        TESTFW_EXPECTED( m.x.z == 3.0f );
        TESTFW_EXPECTED( m.x.w == 4.0f );
        TESTFW_EXPECTED( m.y.x == 5.0f );
        TESTFW_EXPECTED( m.y.y == 6.0f );
        TESTFW_EXPECTED( m.y.z == 7.0f );
        TESTFW_EXPECTED( m.y.w == 8.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
        TESTFW_EXPECTED( m.z.y == 10.0f );
        TESTFW_EXPECTED( m.z.z == 11.0f );
        TESTFW_EXPECTED( m.z.w == 12.0f );
    TESTFW_TEST_END();

    // mat34f
    TESTFW_TEST_BEGIN( "mat34f constructs a matrix with all elements equal to input" )
        mat34_t m = mat34f( -3.5f );
        TESTFW_EXPECTED( m.x.x == -3.5f );
        TESTFW_EXPECTED( m.x.y == -3.5f );
        TESTFW_EXPECTED( m.x.z == -3.5f );
        TESTFW_EXPECTED( m.x.w == -3.5f );
        TESTFW_EXPECTED( m.y.x == -3.5f );
        TESTFW_EXPECTED( m.y.y == -3.5f );
        TESTFW_EXPECTED( m.y.z == -3.5f );
        TESTFW_EXPECTED( m.y.w == -3.5f );
        TESTFW_EXPECTED( m.z.x == -3.5f );
        TESTFW_EXPECTED( m.z.y == -3.5f );
        TESTFW_EXPECTED( m.z.z == -3.5f );
        TESTFW_EXPECTED( m.z.w == -3.5f );
    TESTFW_TEST_END();

    // mat34_get
    TESTFW_TEST_BEGIN( "mat34_get returns each row by index" )
        mat34_t m = mat34(
            vec4( 10, 0, 0, 0 ),
            vec4( 20, 0, 0, 0 ),
            vec4( 30, 0, 0, 0 ) );
        vec4_t r0 = mat34_get( m, 0 );
        vec4_t r1 = mat34_get( m, 1 );
        vec4_t r2 = mat34_get( m, 2 );
        TESTFW_EXPECTED( r0.x == 10.0f );
        TESTFW_EXPECTED( r1.x == 20.0f );
        TESTFW_EXPECTED( r2.x == 30.0f );
    TESTFW_TEST_END();

    // mat34_set
    TESTFW_TEST_BEGIN( "mat34_set modifies only the specified row" )
        mat34_t m = mat34(
            vec4(1,0,0,0),
            vec4(2,0,0,0),
            vec4(3,0,0,0) );
        mat34_set( &m, 0, vec4(9,0,0,0) );
        TESTFW_EXPECTED( m.x.x == 9.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );

        m = mat34(
            vec4(1,0,0,0),
            vec4(2,0,0,0),
            vec4(3,0,0,0) );
        mat34_set( &m, 1, vec4(9,0,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 9.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );

        m = mat34(
            vec4(1,0,0,0),
            vec4(2,0,0,0),
            vec4(3,0,0,0) );
        mat34_set( &m, 2, vec4(9,0,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
    TESTFW_TEST_END();

    // mat34_neg
    TESTFW_TEST_BEGIN( "mat34_neg negates each element of the matrix" )
        mat34_t m = mat34(
            vec4( 1, -2, 0, 0 ),
            vec4( -3, 4, 0, 0 ),
            vec4( 5, -6, 0, 0 ) );
        mat34_t r = mat34_neg( m );
        TESTFW_EXPECTED( r.x.x == -1.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == -5.0f );
    TESTFW_TEST_END();

    // mat34_eq
    TESTFW_TEST_BEGIN( "mat34_eq returns nonzero if all corresponding rows are equal" )
        mat34_t a = mat34(
            vec4(1,2,3,4),
            vec4(5,6,7,8),
            vec4(9,10,11,12) );
        mat34_t b = a;
        TESTFW_EXPECTED( mat34_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat34_eq returns zero if any element differs" )
        mat34_t a = mat34(
            vec4(1,2,3,4),
            vec4(5,6,7,8),
            vec4(9,10,11,12) );
        mat34_t b = a;
        b.z.z = 99.0f;
        TESTFW_EXPECTED( mat34_eq( a, b ) == 0 );

        b = a;
        b.x.x = 0.0f;
        TESTFW_EXPECTED( mat34_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // mat34_add
    TESTFW_TEST_BEGIN( "mat34_add adds corresponding elements of two matrices" )
        mat34_t a = mat34(
            vec4( 1, 0,0,0 ),
            vec4( 6, 0,0,0 ),
            vec4( 8, 0,0,0 ) );
        mat34_t b = mat34(
            vec4( 4, 0,0,0 ),
            vec4( 9, 0,0,0 ),
            vec4( 3, 0,0,0 ) );
        mat34_t r = mat34_add( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 15.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
    TESTFW_TEST_END();

    // mat34_sub
    TESTFW_TEST_BEGIN( "mat34_sub subtracts corresponding elements of two matrices" )
        mat34_t a = mat34(
            vec4( 8, 0,0,0 ),
            vec4(15, 0,0,0 ),
            vec4( 5, 0,0,0 ) );
        mat34_t b = mat34(
            vec4( 3, 0,0,0 ),
            vec4( 4, 0,0,0 ),
            vec4( 2, 0,0,0 ) );
        mat34_t r = mat34_sub( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 11.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat34_mul_elem
    TESTFW_TEST_BEGIN( "mat34_mul_elem multiplies corresponding elements of two matrices" )
        mat34_t a = mat34(
            vec4( 2, 0,0,0 ),
            vec4( 5, 0,0,0 ),
            vec4(10, 0,0,0 ) );
        mat34_t b = mat34(
            vec4( 3, 0,0,0 ),
            vec4( 4, 0,0,0 ),
            vec4( 2, 0,0,0 ) );
        mat34_t r = mat34_mul_elem( a, b );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 20.0f );
        TESTFW_EXPECTED( r.z.x == 20.0f );
    TESTFW_TEST_END();

    // mat34_div
    TESTFW_TEST_BEGIN( "mat34_div divides corresponding elements of two matrices" )
        mat34_t a = mat34(
            vec4(10, 0,0,0 ),
            vec4(18, 0,0,0 ),
            vec4(12, 0,0,0 ) );
        mat34_t b = mat34(
            vec4( 2, 0,0,0 ),
            vec4( 3, 0,0,0 ),
            vec4( 4, 0,0,0 ) );
        mat34_t r = mat34_div( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 6.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat34_addf
    TESTFW_TEST_BEGIN( "mat34_addf adds scalar to all elements of matrix" )
        mat34_t m = mat34(
            vec4( 2.0f, 0,0,0 ),
            vec4( 5.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ) );
        mat34_t r = mat34_addf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 8.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
    TESTFW_TEST_END();

    // mat34_subf
    TESTFW_TEST_BEGIN( "mat34_subf subtracts scalar from all elements of matrix" )
        mat34_t m = mat34(
            vec4(10.0f, 0,0,0 ),
            vec4( 6.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ) );
        mat34_t r = mat34_subf( m, 4.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == -4.0f );
    TESTFW_TEST_END();

    // mat34_mulf
    TESTFW_TEST_BEGIN( "mat34_mulf multiplies all elements by scalar" )
        mat34_t m = mat34(
            vec4( 2.0f, 0,0,0 ),
            vec4(-1.0f, 0,0,0 ),
            vec4( 3.0f, 0,0,0 ) );
        mat34_t r = mat34_mulf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 9.0f );
    TESTFW_TEST_END();

    // mat34_divf
    TESTFW_TEST_BEGIN( "mat34_divf divides all elements by scalar" )
        mat34_t m = mat34(
            vec4( 4.0f, 0,0,0 ),
            vec4(-4.0f, 0,0,0 ),
            vec4( 6.0f, 0,0,0 ) );
        mat34_t r = mat34_divf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat34_abs
    TESTFW_TEST_BEGIN( "mat34_abs applies absolute value to each element of the matrix" )
        mat34_t m = mat34(
            vec4( -1.0f, 0.0f, 0.0f, 0.0f ),
            vec4( 0.0f, -2.0f, 0.0f, 0.0f ),
            vec4( 0.0f, 0.0f, -3.5f, 0.0f ) );
        mat34_t r = mat34_abs( m );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 2.0f );
        TESTFW_EXPECTED( r.z.z == 3.5f );
    TESTFW_TEST_END();

    // mat34_acos
    TESTFW_TEST_BEGIN( "mat34_acos applies acos to each element" )
        mat34_t m = mat34(
            vec4( 0.5f, 0, 0, 0 ),
            vec4( -1.0f, 0, 0, 0 ),
            vec4( 1.0f, 0, 0, 0 ) );
        mat34_t r = mat34_acos( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 1.04719758f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, 3.14159265f ));
        TESTFW_EXPECTED( test_cmp(r.z.x, 0.00000000f ));
    TESTFW_TEST_END();

    // mat34_all
    TESTFW_TEST_BEGIN( "mat34_all returns nonzero only if all twelve elements are nonzero" )
        TESTFW_EXPECTED( mat34_all( mat34(
            vec4(1,1,1,1),
            vec4(1,1,1,1),
            vec4(1,1,1,1) ) ) != 0 );

        TESTFW_EXPECTED( mat34_all( mat34(
            vec4(0,1,1,1),
            vec4(1,1,1,1),
            vec4(1,1,1,1) ) ) == 0 );

        TESTFW_EXPECTED( mat34_all( mat34(
            vec4(1,1,1,1),
            vec4(1,0,1,1),
            vec4(1,1,1,1) ) ) == 0 );

        TESTFW_EXPECTED( mat34_all( mat34(
            vec4(1,1,1,1),
            vec4(1,1,1,1),
            vec4(1,1,0,1) ) ) == 0 );

        TESTFW_EXPECTED( mat34_all( mat34f( 1.0f ) ) != 0 );
    TESTFW_TEST_END();

    // mat34_any
    TESTFW_TEST_BEGIN( "mat34_any returns nonzero if any element is nonzero" )
        TESTFW_EXPECTED( mat34_any( mat34(
            vec4(0,1,0,0),
            vec4(0,0,0,0),
            vec4(0,0,0,0) ) ) != 0 );

        TESTFW_EXPECTED( mat34_any( mat34(
            vec4(0,0,0,0),
            vec4(0,0,1,0),
            vec4(0,0,0,0) ) ) != 0 );

        TESTFW_EXPECTED( mat34_any( mat34(
            vec4(0,0,0,0),
            vec4(0,0,0,0),
            vec4(0,0,0,1) ) ) != 0 );

        TESTFW_EXPECTED( mat34_any( mat34f( 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // mat34_asin
    TESTFW_TEST_BEGIN( "mat34_asin applies asin to each element" )
        mat34_t m = mat34(
            vec4( 0.5f, 0, 0, 0 ),
            vec4( -1.0f, 0, 0, 0 ),
            vec4( 1.0f, 0, 0, 0 ) );
        mat34_t r = mat34_asin( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 0.52359878f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, -1.57079633f ));
        TESTFW_EXPECTED( test_cmp(r.z.x, 1.57079633f ));
    TESTFW_TEST_END();

    // mat34_atan
    TESTFW_TEST_BEGIN( "mat34_atan applies atan to each element" )
        mat34_t m = mat34(
            vec4( 0.5f, 0,0,0 ),
            vec4( -2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ) );
        mat34_t r = mat34_atan( m );
        TESTFW_EXPECTED( r.x.x == 0.46364761f );
        TESTFW_EXPECTED( r.y.x == -1.10714872f );
        TESTFW_EXPECTED( r.z.x == 0.78539816f );
    TESTFW_TEST_END();

    // mat34_atan2
    TESTFW_TEST_BEGIN( "mat34_atan2 applies atan2 to each element" )
        mat34_t y = mat34(
            vec4( 2.0f, 0,0,0 ),
            vec4( -3.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ) );
        mat34_t x = mat34(
            vec4( 1.0f, 0,0,0 ),
            vec4( -4.0f, 0,0,0 ),
            vec4( -1.0f, 0,0,0 ) );
        mat34_t r = mat34_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.10714872f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, -2.49809154f ));
        TESTFW_EXPECTED( test_cmp( r.z.x, 2.35619449f ));
    TESTFW_TEST_END();

    // mat34_ceil
    TESTFW_TEST_BEGIN( "mat34_ceil applies ceil to each element" )
        mat34_t m = mat34(
            vec4( 1.2f, 0,0,0 ),
            vec4( -3.7f, 0,0,0 ),
            vec4( -0.1f, 0,0,0 ) );
        mat34_t r = mat34_ceil( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat34_clamp
    TESTFW_TEST_BEGIN( "mat34_clamp clamps each element using corresponding min and max matrices" )
        mat34_t v = mat34(
            vec4( 5.0f, 0,0,0 ),
            vec4(-10.0f, 0,0,0 ),
            vec4( 0.5f, 0,0,0 ) );
        mat34_t mn = mat34(
            vec4( 0.0f, 0,0,0 ),
            vec4( -8.0f, 0,0,0 ),
            vec4( -1.0f, 0,0,0 ) );
        mat34_t mx = mat34(
            vec4( 4.0f, 0,0,0 ),
            vec4( -7.0f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ) );
        mat34_t r = mat34_clamp( v, mn, mx );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -8.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
    TESTFW_TEST_END();

    // mat34_cos
    TESTFW_TEST_BEGIN( "mat34_cos applies cos to each element" )
        mat34_t m = mat34(
            vec4( 0.5f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ),
            vec4( 3.14159265f, 0,0,0 ) );
        mat34_t r = mat34_cos( m );
        TESTFW_EXPECTED( r.x.x == 0.87758256f );
        TESTFW_EXPECTED( r.y.x == -0.41614684f );
        TESTFW_EXPECTED( r.z.x == -1.00000000f );
    TESTFW_TEST_END();

    // mat34_cosh
    TESTFW_TEST_BEGIN( "mat34_cosh applies cosh to each element" )
        mat34_t m = mat34(
            vec4( 0.5f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ) );
        mat34_t r = mat34_cosh( m );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.12762597f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, 3.76219569f ));
        TESTFW_EXPECTED( test_cmp( r.z.x, 1.54308063f ));
    TESTFW_TEST_END();

    // mat34_degrees
    TESTFW_TEST_BEGIN( "mat34_degrees converts radians to degrees element-wise" )
        mat34_t m = mat34(
            vec4( 0.5f, 0,0,0 ),
            vec4( -1.0f, 0,0,0 ),
            vec4( 3.14159265f, 0,0,0 ) );
        mat34_t r = mat34_degrees( m );
        TESTFW_EXPECTED( r.x.x == 28.6478898f );
        TESTFW_EXPECTED( r.y.x == -57.2957795f );
        TESTFW_EXPECTED( r.z.x == 180.0f );
    TESTFW_TEST_END();

    // mat34_exp
    TESTFW_TEST_BEGIN( "mat34_exp applies exp to each element" )
        mat34_t m = mat34(
            vec4( 0.5f, 0,0,0 ),
            vec4( -2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ) );
        mat34_t r = mat34_exp( m );
        TESTFW_EXPECTED( r.x.x == 1.64872127f );
        TESTFW_EXPECTED( r.y.x == 0.13533528f );
        TESTFW_EXPECTED( r.z.x == 2.71828183f );
    TESTFW_TEST_END();

    // mat34_exp2
    TESTFW_TEST_BEGIN( "mat34_exp2 applies exp2 to each element" )
        mat34_t m = mat34(
            vec4( 3.0f, 0,0,0 ),
            vec4( -2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ) );
        mat34_t r = mat34_exp2( m );
        TESTFW_EXPECTED( r.x.x == 8.0f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
    TESTFW_TEST_END();

    // mat34_floor
    TESTFW_TEST_BEGIN( "mat34_floor applies floor to each element" )
        mat34_t m = mat34(
            vec4( 2.7f, 0,0,0 ),
            vec4( -3.2f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ) );
        mat34_t r = mat34_floor( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat34_fmod
    TESTFW_TEST_BEGIN( "mat34_fmod applies fmod to each element" )
        mat34_t a = mat34(
            vec4( 6.5f, 0,0,0 ),
            vec4(-5.0f, 0,0,0 ),
            vec4( 7.75f, 0,0,0 ) );
        mat34_t b = mat34(
            vec4( 2.0f, 0,0,0 ),
            vec4( 3.0f, 0,0,0 ),
            vec4( 2.5f, 0,0,0 ) );
        mat34_t r = mat34_fmod( a, b );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
    TESTFW_TEST_END();

    // mat34_frac
    TESTFW_TEST_BEGIN( "mat34_frac returns fractional part of each element" )
        mat34_t m = mat34(
            vec4( 3.75f, 0,0,0 ),
            vec4( -2.25f, 0,0,0 ),
            vec4( 1.5f, 0,0,0 ) );
        mat34_t r = mat34_frac( m );
        TESTFW_EXPECTED( r.x.x == 0.75f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 0.50f );
    TESTFW_TEST_END();

    // mat34_lerp
    TESTFW_TEST_BEGIN( "mat34_lerp linearly interpolates between matrices element-wise" )
        mat34_t a = mat34(
            vec4( 2.0f, 0,0,0 ),
            vec4(-4.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ) );
        mat34_t b = mat34(
            vec4( 6.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ),
            vec4( 4.0f, 0,0,0 ) );
        mat34_t r = mat34_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat34_log
    TESTFW_TEST_BEGIN( "mat34_log applies natural log to each element" )
        mat34_t m = mat34(
            vec4( 1.0f, 0,0,0 ),
            vec4( 2.718282f, 0,0,0 ),
            vec4( 7.3890561f,0,0,0 ) );
        mat34_t r = mat34_log( m );
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
    TESTFW_TEST_END();

    // mat34_log2
    TESTFW_TEST_BEGIN( "mat34_log2 applies base-2 logarithm to each element" )
        mat34_t m = mat34(
            vec4( 16.0f, 0,0,0 ),
            vec4( 0.25f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ) );
        mat34_t r = mat34_log2( m );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

        // mat34_log10
    TESTFW_TEST_BEGIN( "mat34_log10 applies base-10 logarithm to each element" )
        mat34_t m = mat34(
            vec4( 100.0f, 0,0,0 ),
            vec4( 0.001f, 0,0,0 ),
            vec4( 10.0f, 0,0,0 ) );
        mat34_t r = mat34_log10( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat34_max
    TESTFW_TEST_BEGIN( "mat34_max returns element-wise maximum of two matrices" )
        mat34_t a = mat34(
            vec4( 3.0f, 0,0,0 ),
            vec4( -5.0f, 0,0,0 ),
            vec4( 7.0f, 0,0,0 ) );
        mat34_t b = mat34(
            vec4( 2.0f, 0,0,0 ),
            vec4( -4.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ) );
        mat34_t r = mat34_max( a, b );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 8.0f );
    TESTFW_TEST_END();

    // mat34_min
    TESTFW_TEST_BEGIN( "mat34_min returns element-wise minimum of two matrices" )
        mat34_t a = mat34(
            vec4( 3.0f, 0,0,0 ),
            vec4( -5.0f, 0,0,0 ),
            vec4( 7.0f, 0,0,0 ) );
        mat34_t b = mat34(
            vec4( 2.0f, 0,0,0 ),
            vec4( -4.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ) );
        mat34_t r = mat34_min( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -5.0f );
        TESTFW_EXPECTED( r.z.x == 7.0f );
    TESTFW_TEST_END();

    // mat34_pow
    TESTFW_TEST_BEGIN( "mat34_pow applies pow to each element" )
        mat34_t a = mat34(
            vec4( 4.0f, 0,0,0 ),
            vec4( 9.0f, 0,0,0 ),
            vec4( 16.0f, 0,0,0 ) );
        mat34_t b = mat34f( 0.5f );
        mat34_t r = mat34_pow( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == 4.0f );
    TESTFW_TEST_END();

    // mat34_radians
    TESTFW_TEST_BEGIN( "mat34_radians converts degrees to radians element-wise" )
        mat34_t m = mat34(
            vec4( 90.0f, 0,0,0 ),
            vec4( -45.0f, 0,0,0 ),
            vec4( 180.0f, 0,0,0 ) );
        mat34_t r = mat34_radians( m );
        TESTFW_EXPECTED( r.x.x == 1.57079633f );
        TESTFW_EXPECTED( r.y.x == -0.78539816f );
        TESTFW_EXPECTED( r.z.x == 3.14159265f );
    TESTFW_TEST_END();

    // mat34_rcp
    TESTFW_TEST_BEGIN( "mat34_rcp returns element-wise reciprocal" )
        mat34_t m = mat34(
            vec4( 4.0f, 0,0,0 ),
            vec4( -0.5f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ) );
        mat34_t r = mat34_rcp( m );
        TESTFW_EXPECTED( r.x.x == 0.25f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
    TESTFW_TEST_END();

    // mat34_round
    TESTFW_TEST_BEGIN( "mat34_round rounds each element to nearest integer" )
        mat34_t m = mat34(
            vec4( 2.6f, 0,0,0 ),
            vec4( -3.4f, 0,0,0 ),
            vec4( -1.7f, 0,0,0 ) );
        mat34_t r = mat34_round( m );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == -2.0f );
    TESTFW_TEST_END();

    // mat34_rsqrt
    TESTFW_TEST_BEGIN( "mat34_rsqrt returns reciprocal square root of each element" )
        mat34_t m = mat34(
            vec4( 4.0f, 0,0,0 ),
            vec4( 0.25f, 0,0,0 ),
            vec4( 16.0f, 0,0,0 ) );
        mat34_t r = mat34_rsqrt( m );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
    TESTFW_TEST_END();

    // mat34_saturate
    TESTFW_TEST_BEGIN( "mat34_saturate clamps each element to the [0, 1] range" )
        mat34_t m = mat34(
            vec4(-2.0f, 0,0,0 ),
            vec4( 1.5f, 0,0,0 ),
            vec4( 0.5f, 0,0,0 ) );
        mat34_t r = mat34_saturate( m );
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
    TESTFW_TEST_END();

    // mat34_sign
    TESTFW_TEST_BEGIN( "mat34_sign returns sign of each element" )
        mat34_t m = mat34(
            vec4( 3.5f, 0,0,0 ),
            vec4(-2.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ) );
        mat34_t r = mat34_sign( m );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat34_sin
    TESTFW_TEST_BEGIN( "mat34_sin applies sin to each element" )
        mat34_t m = mat34(
            vec4( 0.5f, 0,0,0 ),
            vec4(-2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ) );
        mat34_t r = mat34_sin( m );
        TESTFW_EXPECTED( r.x.x == 0.47942554f );
        TESTFW_EXPECTED( r.y.x == -0.90929743f );
        TESTFW_EXPECTED( r.z.x == 0.84147098f );
    TESTFW_TEST_END();

    // mat34_sinh
    TESTFW_TEST_BEGIN( "mat34_sinh applies sinh to each element" )
        mat34_t m = mat34(
            vec4(-1.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ) );
        mat34_t r = mat34_sinh( m );
        TESTFW_EXPECTED( r.x.x == -1.17520119f );
        TESTFW_EXPECTED( r.y.x == 0.00000000f );
        TESTFW_EXPECTED( r.z.x == 1.17520119f );
    TESTFW_TEST_END();

    // mat34_smoothstep
    TESTFW_TEST_BEGIN( "mat34_smoothstep performs Hermite interpolation element-wise" )
        mat34_t a = mat34(
            vec4( 2.0f, 0,0,0 ),
            vec4(10.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ) );
        mat34_t b = mat34(
            vec4( 6.0f, 0,0,0 ),
            vec4(14.0f, 0,0,0 ),
            vec4( 4.0f, 0,0,0 ) );
        mat34_t t = mat34(
            vec4( 3.0f, 0,0,0 ),
            vec4(12.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ) );
        mat34_t r = mat34_smoothstep( a, b, t );
        TESTFW_EXPECTED( r.x.x == 0.15625f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 0.15625f );
    TESTFW_TEST_END();

    // mat34_smootherstep
    TESTFW_TEST_BEGIN( "mat34_smootherstep performs quintic Hermite interpolation element-wise" )
        mat34_t a = mat34(
            vec4( 0.0f, 0,0,0 ),
            vec4( 4.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ) );
        mat34_t b = mat34(
            vec4( 8.0f, 0,0,0 ),
            vec4(12.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ) );
        mat34_t t = mat34(
            vec4( 4.0f, 0,0,0 ),
            vec4(10.0f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ) );
        mat34_t r = mat34_smootherstep( a, b, t );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 0.89648438f );
        TESTFW_EXPECTED( r.z.x == 0.103515625f );
    TESTFW_TEST_END();

    // mat34_sqrt
    TESTFW_TEST_BEGIN( "mat34_sqrt returns square root of each element" )
        mat34_t m = mat34(
            vec4(16.0f, 0,0,0 ),
            vec4( 0.25f,0,0,0 ),
            vec4( 9.0f, 0,0,0 ) );
        mat34_t r = mat34_sqrt( m );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
    TESTFW_TEST_END();

    // mat34_step
    TESTFW_TEST_BEGIN( "mat34_step returns 0.0 or 1.0 per element based on threshold" )
        mat34_t a = mat34(
            vec4(2.5f, 0,0,0 ),
            vec4(6.0f, 0,0,0 ),
            vec4(4.0f, 0,0,0 ) );
        mat34_t b = mat34(
            vec4(3.0f, 0,0,0 ),
            vec4(5.0f, 0,0,0 ),
            vec4(4.0f, 0,0,0 ) );
        mat34_t r = mat34_step( a, b );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
    TESTFW_TEST_END();

    // mat34_tan
    TESTFW_TEST_BEGIN( "mat34_tan applies tan to each element" )
        mat34_t m = mat34(
            vec4( 0.5f, 0,0,0 ),
            vec4(-1.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ) );
        mat34_t r = mat34_tan( m );
        TESTFW_EXPECTED( r.x.x == 0.54630249f );
        TESTFW_EXPECTED( r.y.x == -1.55740772f );
        TESTFW_EXPECTED( r.z.x == 1.55740772f );
    TESTFW_TEST_END();

    // mat34_tanh
    TESTFW_TEST_BEGIN( "mat34_tanh applies tanh to each element" )
        mat34_t m = mat34(
            vec4( 1.0f, 0,0,0 ),
            vec4(-2.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ) );
        mat34_t r = mat34_tanh( m );
        TESTFW_EXPECTED( r.x.x == 0.76159416f );
        TESTFW_EXPECTED( r.y.x == -0.96402758f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();

    // mat34_trunc
    TESTFW_TEST_BEGIN( "mat34_trunc removes fractional part of each element" )
        mat34_t m = mat34(
            vec4( 3.7f, 0,0,0 ),
            vec4(-2.9f, 0,0,0 ),
            vec4( 0.5f, 0,0,0 ) );
        mat34_t r = mat34_trunc( m );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
    TESTFW_TEST_END();
}


void test_mat42( void ) {
    // mat42
    TESTFW_TEST_BEGIN( "mat42 constructs matrix from four distinct row vectors" )
        mat42_t m = mat42(
            vec2( 1.0f, 2.0f ),
            vec2( 5.0f, 6.0f ),
            vec2( 9.0f, 10.0f ),
            vec2(13.0f, 14.0f )
        );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 2.0f );
        TESTFW_EXPECTED( m.y.x == 5.0f );
        TESTFW_EXPECTED( m.y.y == 6.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
        TESTFW_EXPECTED( m.z.y == 10.0f );
        TESTFW_EXPECTED( m.w.x == 13.0f );
        TESTFW_EXPECTED( m.w.y == 14.0f );
    TESTFW_TEST_END();

    // mat42f
    TESTFW_TEST_BEGIN( "mat42f constructs a matrix with all elements equal to input" )
        mat42_t m = mat42f( -3.5f );
        TESTFW_EXPECTED( m.x.x == -3.5f );
        TESTFW_EXPECTED( m.x.y == -3.5f );
        TESTFW_EXPECTED( m.y.x == -3.5f );
        TESTFW_EXPECTED( m.y.y == -3.5f );
        TESTFW_EXPECTED( m.z.x == -3.5f );
        TESTFW_EXPECTED( m.z.y == -3.5f );
        TESTFW_EXPECTED( m.w.x == -3.5f );
        TESTFW_EXPECTED( m.w.y == -3.5f );
    TESTFW_TEST_END();

    // mat42_get
    TESTFW_TEST_BEGIN( "mat42_get returns each row by index" )
        mat42_t m = mat42(
            vec2( 10, 0 ),
            vec2( 20, 0 ),
            vec2( 30, 0 ),
            vec2( 40, 0 )
        );
        vec2_t r0 = mat42_get( m, 0 );
        vec2_t r1 = mat42_get( m, 1 );
        vec2_t r2 = mat42_get( m, 2 );
        vec2_t r3 = mat42_get( m, 3 );
        TESTFW_EXPECTED( r0.x == 10.0f );
        TESTFW_EXPECTED( r1.x == 20.0f );
        TESTFW_EXPECTED( r2.x == 30.0f );
        TESTFW_EXPECTED( r3.x == 40.0f );
    TESTFW_TEST_END();

    // mat42_set
    TESTFW_TEST_BEGIN( "mat42_set modifies only the specified row" )
        mat42_t m = mat42(
            vec2(1,0), vec2(2,0),
            vec2(3,0), vec2(4,0)
        );
        mat42_set( &m, 0, vec2(9,0) );
        TESTFW_EXPECTED( m.x.x == 9.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );
        TESTFW_EXPECTED( m.w.x == 4.0f );

        m = mat42( vec2(1,0), vec2(2,0), vec2(3,0), vec2(4,0) );
        mat42_set( &m, 1, vec2(9,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 9.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );
        TESTFW_EXPECTED( m.w.x == 4.0f );

        m = mat42( vec2(1,0), vec2(2,0), vec2(3,0), vec2(4,0) );
        mat42_set( &m, 2, vec2(9,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
        TESTFW_EXPECTED( m.w.x == 4.0f );

        m = mat42( vec2(1,0), vec2(2,0), vec2(3,0), vec2(4,0) );
        mat42_set( &m, 3, vec2(9,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );
        TESTFW_EXPECTED( m.w.x == 9.0f );
    TESTFW_TEST_END();

    // mat42_neg
    TESTFW_TEST_BEGIN( "mat42_neg negates each element of the matrix" )
        mat42_t m = mat42(
            vec2( 1, -2 ),
            vec2( -3, 4 ),
            vec2( 5, -6 ),
            vec2( -7, 8 )
        );
        mat42_t r = mat42_neg( m );
        TESTFW_EXPECTED( r.x.x == -1.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == -5.0f );
        TESTFW_EXPECTED( r.w.x == 7.0f );
    TESTFW_TEST_END();

    // mat42_eq
    TESTFW_TEST_BEGIN( "mat42_eq returns nonzero if all corresponding rows are equal" )
        mat42_t a = mat42(
            vec2(1,2),
            vec2(5,6),
            vec2(9,10),
            vec2(13,14)
        );
        mat42_t b = a;
        TESTFW_EXPECTED( mat42_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat42_eq returns zero if any element differs" )
        mat42_t a = mat42(
            vec2(1,2),
            vec2(5,6),
            vec2(9,10),
            vec2(13,14)
        );
        mat42_t b = a;
        b.z.y = 99.0f;
        TESTFW_EXPECTED( mat42_eq( a, b ) == 0 );

        b = a;
        b.x.x = 0.0f;
        TESTFW_EXPECTED( mat42_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // mat42_add
    TESTFW_TEST_BEGIN( "mat42_add adds corresponding elements of two matrices" )
        mat42_t a = mat42(
            vec2( 1, 0 ),
            vec2( 6, 0 ),
            vec2( 8, 0 ),
            vec2(15, 0 )
        );
        mat42_t b = mat42(
            vec2( 4, 0 ),
            vec2( 9, 0 ),
            vec2( 3, 0 ),
            vec2( 4, 0 )
        );
        mat42_t r = mat42_add( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 15.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
        TESTFW_EXPECTED( r.w.x == 19.0f );
    TESTFW_TEST_END();

    // mat42_sub
    TESTFW_TEST_BEGIN( "mat42_sub subtracts corresponding elements of two matrices" )
        mat42_t a = mat42(
            vec2( 8, 0 ),
            vec2(15, 0 ),
            vec2( 5, 0 ),
            vec2(10, 0 )
        );
        mat42_t b = mat42(
            vec2( 3, 0 ),
            vec2( 4, 0 ),
            vec2( 2, 0 ),
            vec2( 5, 0 )
        );
        mat42_t r = mat42_sub( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 11.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == 5.0f );
    TESTFW_TEST_END();

    // mat42_mul_elem
    TESTFW_TEST_BEGIN( "mat42_mul_elem multiplies corresponding elements of two matrices" )
        mat42_t a = mat42(
            vec2( 2, 0 ),
            vec2( 5, 0 ),
            vec2(10, 0 ),
            vec2(12, 0 )
        );
        mat42_t b = mat42(
            vec2( 3, 0 ),
            vec2( 4, 0 ),
            vec2( 2, 0 ),
            vec2( 3, 0 )
        );
        mat42_t r = mat42_mul_elem( a, b );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 20.0f );
        TESTFW_EXPECTED( r.z.x == 20.0f );
        TESTFW_EXPECTED( r.w.x == 36.0f );
    TESTFW_TEST_END();

    // mat42_div
    TESTFW_TEST_BEGIN( "mat42_div divides corresponding elements of two matrices" )
        mat42_t a = mat42(
            vec2(10, 0 ),
            vec2(18, 0 ),
            vec2(12, 0 ),
            vec2( 9, 0 )
        );
        mat42_t b = mat42(
            vec2( 2, 0 ),
            vec2( 3, 0 ),
            vec2( 4, 0 ),
            vec2( 3, 0 )
        );
        mat42_t r = mat42_div( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 6.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat42_addf
    TESTFW_TEST_BEGIN( "mat42_addf adds scalar to all elements of matrix" )
        mat42_t m = mat42(
            vec2( 2.0f, 0 ),
            vec2( 5.0f, 0 ),
            vec2( 8.0f, 0 ),
            vec2(-1.0f, 0 )
        );
        mat42_t r = mat42_addf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 8.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
        TESTFW_EXPECTED( r.w.x == 2.0f );
    TESTFW_TEST_END();

    // mat42_subf
    TESTFW_TEST_BEGIN( "mat42_subf subtracts scalar from all elements of matrix" )
        mat42_t m = mat42(
            vec2(10.0f, 0 ),
            vec2( 6.0f, 0 ),
            vec2( 0.0f, 0 ),
            vec2( 4.0f, 0 )
        );
        mat42_t r = mat42_subf( m, 4.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == -4.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat42_mulf
    TESTFW_TEST_BEGIN( "mat42_mulf multiplies all elements by scalar" )
        mat42_t m = mat42(
            vec2( 2.0f, 0 ),
            vec2(-1.0f, 0 ),
            vec2( 3.0f, 0 ),
            vec2(-2.0f, 0 )
        );
        mat42_t r = mat42_mulf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 9.0f );
        TESTFW_EXPECTED( r.w.x == -6.0f );
    TESTFW_TEST_END();

    // mat42_divf
    TESTFW_TEST_BEGIN( "mat42_divf divides all elements by scalar" )
        mat42_t m = mat42(
            vec2( 4.0f, 0 ),
            vec2(-4.0f, 0 ),
            vec2( 6.0f, 0 ),
            vec2(-6.0f, 0 )
        );
        mat42_t r = mat42_divf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == -3.0f );
    TESTFW_TEST_END();

    // mat42_abs
    TESTFW_TEST_BEGIN( "mat42_abs applies absolute value to each element of the matrix" )
        mat42_t m = mat42(
            vec2( -1.0f, 0.0f ),
            vec2( 0.0f, -2.0f ),
            vec2( 0.0f, 0.0f ),
            vec2( 0.0f, 0.0f )
        );
        mat42_t r = mat42_abs( m );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 2.0f );
    TESTFW_TEST_END();

    // mat42_acos
    TESTFW_TEST_BEGIN( "mat42_acos applies acos to each element" )
        mat42_t m = mat42(
            vec2( 0.5f, 0 ),
            vec2( -1.0f, 0 ),
            vec2( 1.0f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat42_t r = mat42_acos( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 1.04719758f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, 3.14159265f ));
        TESTFW_EXPECTED( test_cmp(r.z.x, 0.00000000f ));
        TESTFW_EXPECTED( test_cmp(r.w.x, 1.57079633f ));
    TESTFW_TEST_END();

    // mat42_all
    TESTFW_TEST_BEGIN( "mat42_all returns nonzero only if all eight elements are nonzero" )
        TESTFW_EXPECTED( mat42_all( mat42(
            vec2(1,1), vec2(1,1),
            vec2(1,1), vec2(1,1)
        ) ) != 0 );

        TESTFW_EXPECTED( mat42_all( mat42(
            vec2(0,1), vec2(1,1),
            vec2(1,1), vec2(1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat42_all( mat42(
            vec2(1,1), vec2(1,0),
            vec2(1,1), vec2(1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat42_all( mat42f( 1.0f ) ) != 0 );
    TESTFW_TEST_END();

    // mat42_any
    TESTFW_TEST_BEGIN( "mat42_any returns nonzero if any element is nonzero" )
        TESTFW_EXPECTED( mat42_any( mat42(
            vec2(0,1), vec2(0,0),
            vec2(0,0), vec2(0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat42_any( mat42(
            vec2(0,0), vec2(0,1),
            vec2(0,0), vec2(0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat42_any( mat42(
            vec2(0,0), vec2(0,0),
            vec2(0,1), vec2(0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat42_any( mat42(
            vec2(0,0), vec2(0,0),
            vec2(0,0), vec2(1,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat42_any( mat42f( 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // mat42_asin
    TESTFW_TEST_BEGIN( "mat42_asin applies asin to each element" )
        mat42_t m = mat42(
            vec2( 0.5f, 0 ),
            vec2( -1.0f, 0 ),
            vec2( 1.0f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat42_t r = mat42_asin( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 0.52359878f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, -1.57079633f ));
        TESTFW_EXPECTED( test_cmp(r.z.x, 1.57079633f ));
        TESTFW_EXPECTED( test_cmp(r.w.x, 0.00000000f ));
    TESTFW_TEST_END();

    // mat42_atan
    TESTFW_TEST_BEGIN( "mat42_atan applies atan to each element" )
        mat42_t m = mat42(
            vec2( 0.5f, 0 ),
            vec2( -2.0f, 0 ),
            vec2( 1.0f, 0 ),
            vec2( -1.0f, 0 )
        );
        mat42_t r = mat42_atan( m );
        TESTFW_EXPECTED( r.x.x == 0.46364761f );
        TESTFW_EXPECTED( r.y.x == -1.10714872f );
        TESTFW_EXPECTED( r.z.x == 0.78539816f );
        TESTFW_EXPECTED( r.w.x == -0.78539816f );
    TESTFW_TEST_END();

    // mat42_atan2
    TESTFW_TEST_BEGIN( "mat42_atan2 applies atan2 to each element" )
        mat42_t y = mat42(
            vec2( 2.0f, 0 ),
            vec2( -3.0f, 0 ),
            vec2( 1.0f, 0 ),
            vec2( 3.0f, 0 )
        );
        mat42_t x = mat42(
            vec2( 1.0f, 0 ),
            vec2( -4.0f, 0 ),
            vec2( -1.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat42_t r = mat42_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.10714872f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, -2.49809154f ));
        TESTFW_EXPECTED( test_cmp( r.z.x, 2.35619449f ));
        TESTFW_EXPECTED( test_cmp( r.w.x, 1.24904577f ));
    TESTFW_TEST_END();

    // mat42_ceil
    TESTFW_TEST_BEGIN( "mat42_ceil applies ceil to each element" )
        mat42_t m = mat42(
            vec2( 1.2f, 0 ),
            vec2( -3.7f, 0 ),
            vec2( -0.1f, 0 ),
            vec2( 2.9f, 0 )
        );
        mat42_t r = mat42_ceil( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat42_clamp
    TESTFW_TEST_BEGIN( "mat42_clamp clamps each element using corresponding min and max matrices" )
        mat42_t v = mat42( vec2( 5.0f, 0 ), vec2(-10.0f, 0 ), vec2( 0.5f, 0 ), vec2( 3.0f, 0 ) );
        mat42_t mn = mat42( vec2( 0.0f, 0 ), vec2( -8.0f, 0 ), vec2( -1.0f, 0 ), vec2( 0.0f, 0 ) );
        mat42_t mx = mat42( vec2( 4.0f, 0 ), vec2( -7.0f, 0 ), vec2( 2.0f, 0 ), vec2( 1.0f, 0 ) );
        mat42_t r = mat42_clamp( v, mn, mx );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -8.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat42_cos
    TESTFW_TEST_BEGIN( "mat42_cos applies cos to each element" )
        mat42_t m = mat42( vec2( 0.5f, 0 ), vec2( 2.0f, 0 ), vec2( 3.14159265f, 0 ), vec2( 0.0f, 0 ) );
        mat42_t r = mat42_cos( m );
        TESTFW_EXPECTED( r.x.x == 0.87758256f );
        TESTFW_EXPECTED( r.y.x == -0.41614684f );
        TESTFW_EXPECTED( r.z.x == -1.00000000f );
        TESTFW_EXPECTED( r.w.x == 1.00000000f );
    TESTFW_TEST_END();

    // mat42_cosh
    TESTFW_TEST_BEGIN( "mat42_cosh applies cosh to each element" )
        mat42_t m = mat42( vec2( 0.5f, 0 ), vec2( 2.0f, 0 ), vec2( 1.0f, 0 ), vec2( 0.0f, 0 ) );
        mat42_t r = mat42_cosh( m );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.12762597f ) );
        TESTFW_EXPECTED( test_cmp( r.y.x, 3.76219569f ) );
        TESTFW_EXPECTED( test_cmp( r.z.x, 1.54308063f ) );
        TESTFW_EXPECTED( test_cmp( r.w.x, 1.00000000f ) );
    TESTFW_TEST_END();

    // mat42_degrees
    TESTFW_TEST_BEGIN( "mat42_degrees converts radians to degrees element-wise" )
        mat42_t m = mat42( vec2( 0.5f, 0 ), vec2( -1.0f, 0 ), vec2( 3.14159265f, 0 ), vec2( 0.0f, 0 ) );
        mat42_t r = mat42_degrees( m );
        TESTFW_EXPECTED( r.x.x == 28.6478898f );
        TESTFW_EXPECTED( r.y.x == -57.2957795f );
        TESTFW_EXPECTED( r.z.x == 180.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat42_exp
    TESTFW_TEST_BEGIN( "mat42_exp applies exp to each element" )
        mat42_t m = mat42( vec2( 0.5f, 0 ), vec2( -2.0f, 0 ), vec2( 1.0f, 0 ), vec2( 0.0f, 0 ) );
        mat42_t r = mat42_exp( m );
        TESTFW_EXPECTED( r.x.x == 1.64872127f );
        TESTFW_EXPECTED( r.y.x == 0.13533528f );
        TESTFW_EXPECTED( r.z.x == 2.71828183f );
        TESTFW_EXPECTED( r.w.x == 1.00000000f );
    TESTFW_TEST_END();

    // mat42_exp2
    TESTFW_TEST_BEGIN( "mat42_exp2 applies exp2 to each element" )
        mat42_t m = mat42( vec2( 3.0f, 0 ), vec2( -2.0f, 0 ), vec2( 1.0f, 0 ), vec2( 0.0f, 0 ) );
        mat42_t r = mat42_exp2( m );
        TESTFW_EXPECTED( r.x.x == 8.0f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat42_floor
    TESTFW_TEST_BEGIN( "mat42_floor applies floor to each element" )
        mat42_t m = mat42( vec2( 2.7f, 0 ), vec2( -3.2f, 0 ), vec2( 0.0f, 0 ), vec2( -1.5f, 0 ) );
        mat42_t r = mat42_floor( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == -2.0f );
    TESTFW_TEST_END();

    // mat42_fmod
    TESTFW_TEST_BEGIN( "mat42_fmod applies fmod to each element" )
        mat42_t a = mat42( vec2( 6.5f, 0 ), vec2( -5.0f, 0 ), vec2( 7.75f, 0 ), vec2( 5.5f, 0 ) );
        mat42_t b = mat42( vec2( 2.0f, 0 ), vec2( 3.0f, 0 ), vec2( 2.5f, 0 ), vec2( 4.0f, 0 ) );
        mat42_t r = mat42_fmod( a, b );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
        TESTFW_EXPECTED( r.w.x == 1.5f );
    TESTFW_TEST_END();

    // mat42_frac
    TESTFW_TEST_BEGIN( "mat42_frac returns fractional part of each element" )
        mat42_t m = mat42( vec2( 3.75f, 0 ), vec2( -2.25f, 0 ), vec2( 1.5f, 0 ), vec2( -3.125f, 0 ) );
        mat42_t r = mat42_frac( m );
        TESTFW_EXPECTED( r.x.x == 0.75f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 0.50f );
        TESTFW_EXPECTED( r.w.x == 0.125f );
    TESTFW_TEST_END();

    // mat42_lerp
    TESTFW_TEST_BEGIN( "mat42_lerp linearly interpolates between matrices element-wise" )
        mat42_t a = mat42(
            vec2( 2.0f, 0 ),
            vec2(-4.0f, 0 ),
            vec2( 0.0f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat42_t b = mat42(
            vec2( 6.0f, 0 ),
            vec2( 8.0f, 0 ),
            vec2( 4.0f, 0 ),
            vec2(12.0f, 0 )
        );
        mat42_t r = mat42_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat42_log
    TESTFW_TEST_BEGIN( "mat42_log applies natural log to each element" )
        mat42_t m = mat42(
            vec2( 1.0f, 0 ),
            vec2( 2.718282f, 0 ),
            vec2( 7.3890561f, 0 ),
            vec2( 20.085537f, 0 )
        );
        mat42_t r = mat42_log( m );
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat42_log2
    TESTFW_TEST_BEGIN( "mat42_log2 applies base-2 logarithm to each element" )
        mat42_t m = mat42(
            vec2( 16.0f, 0 ),
            vec2( 0.25f, 0 ),
            vec2( 2.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat42_t r = mat42_log2( m );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat42_log10
    TESTFW_TEST_BEGIN( "mat42_log10 applies base-10 logarithm to each element" )
        mat42_t m = mat42(
            vec2( 100.0f, 0 ),
            vec2( 0.001f,0 ),
            vec2( 10.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat42_t r = mat42_log10( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat42_max
    TESTFW_TEST_BEGIN( "mat42_max returns element-wise maximum of two matrices" )
        mat42_t a = mat42(
            vec2( 3.0f, 0 ),
            vec2( -5.0f, 0 ),
            vec2( 7.0f, 0 ),
            vec2( 2.0f, 0 )
        );
        mat42_t b = mat42(
            vec2( 2.0f, 0 ),
            vec2( -4.0f, 0 ),
            vec2( 8.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat42_t r = mat42_max( a, b );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 8.0f );
        TESTFW_EXPECTED( r.w.x == 2.0f );
    TESTFW_TEST_END();

    // mat42_min
    TESTFW_TEST_BEGIN( "mat42_min returns element-wise minimum of two matrices" )
        mat42_t a = mat42(
            vec2( 3.0f, 0 ),
            vec2( -5.0f, 0 ),
            vec2( 7.0f, 0 ),
            vec2( 2.0f, 0 )
        );
        mat42_t b = mat42(
            vec2( 2.0f, 0 ),
            vec2( -4.0f, 0 ),
            vec2( 8.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat42_t r = mat42_min( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -5.0f );
        TESTFW_EXPECTED( r.z.x == 7.0f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat42_pow
    TESTFW_TEST_BEGIN( "mat42_pow applies pow to each element" )
        mat42_t a = mat42(
            vec2( 4.0f, 0 ),
            vec2( 9.0f, 0 ),
            vec2( 16.0f, 0 ),
            vec2( 25.0f, 0 )
        );
        mat42_t b = mat42f( 0.5f );
        mat42_t r = mat42_pow( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == 4.0f );
        TESTFW_EXPECTED( r.w.x == 5.0f );
    TESTFW_TEST_END();

    // mat42_radians
    TESTFW_TEST_BEGIN( "mat42_radians converts degrees to radians element-wise" )
        mat42_t m = mat42(
            vec2( 90.0f, 0 ),
            vec2( -45.0f, 0 ),
            vec2( 180.0f, 0 ),
            vec2( 360.0f, 0 )
        );
        mat42_t r = mat42_radians( m );
        TESTFW_EXPECTED( r.x.x == 1.57079633f );
        TESTFW_EXPECTED( r.y.x == -0.78539816f );
        TESTFW_EXPECTED( r.z.x == 3.14159265f );
        TESTFW_EXPECTED( r.w.x == 6.28318531f );
    TESTFW_TEST_END();

    // mat42_rcp
    TESTFW_TEST_BEGIN( "mat42_rcp returns element-wise reciprocal" )
        mat42_t m = mat42(
            vec2( 4.0f, 0 ),
            vec2( -0.5f, 0 ),
            vec2( 2.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat42_t r = mat42_rcp( m );
        TESTFW_EXPECTED( r.x.x == 0.25f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat42_round
    TESTFW_TEST_BEGIN( "mat42_round rounds each element to nearest integer" )
        mat42_t m = mat42(
            vec2( 2.6f, 0 ),
            vec2( -3.4f, 0 ),
            vec2( -1.7f, 0 ),
            vec2( 4.3f, 0 )
        );
        mat42_t r = mat42_round( m );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == -2.0f );
        TESTFW_EXPECTED( r.w.x == 4.0f );
    TESTFW_TEST_END();

    // mat42_rsqrt
    TESTFW_TEST_BEGIN( "mat42_rsqrt returns reciprocal square root of each element" )
        mat42_t m = mat42(
            vec2( 4.0f, 0 ),
            vec2( 0.25f, 0 ),
            vec2( 16.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat42_t r = mat42_rsqrt(m);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat42_saturate
    TESTFW_TEST_BEGIN( "mat42_saturate clamps each element to the [0, 1] range" )
        mat42_t m = mat42(
            vec2(-2.0f, 0 ),
            vec2( 1.5f, 0 ),
            vec2( 0.5f, 0 ),
            vec2( 2.0f, 0 )
        );
        mat42_t r = mat42_saturate(m);
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat42_sign
    TESTFW_TEST_BEGIN( "mat42_sign returns sign of each element" )
        mat42_t m = mat42(
            vec2( 3.5f, 0 ),
            vec2(-2.0f, 0 ),
            vec2( 0.0f, 0 ),
            vec2(-4.7f, 0 )
        );
        mat42_t r = mat42_sign(m);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == -1.0f );
    TESTFW_TEST_END();

    // mat42_sin
    TESTFW_TEST_BEGIN( "mat42_sin applies sin to each element" )
        mat42_t m = mat42(
            vec2( 0.5f, 0 ),
            vec2(-2.0f, 0 ),
            vec2( 1.0f, 0 ),
            vec2(-1.0f, 0 )
        );
        mat42_t r = mat42_sin(m);
        TESTFW_EXPECTED( r.x.x == 0.47942554f );
        TESTFW_EXPECTED( r.y.x == -0.90929743f );
        TESTFW_EXPECTED( r.z.x == 0.84147098f );
        TESTFW_EXPECTED( r.w.x == -0.84147098f );
    TESTFW_TEST_END();

    // mat42_sinh
    TESTFW_TEST_BEGIN( "mat42_sinh applies sinh to each element" )
        mat42_t m = mat42(
            vec2(-1.0f, 0 ),
            vec2( 0.0f, 0 ),
            vec2( 1.0f, 0 ),
            vec2( 0.5f, 0 )
        );
        mat42_t r = mat42_sinh(m);
        TESTFW_EXPECTED( r.x.x == -1.17520119f );
        TESTFW_EXPECTED( r.y.x == 0.00000000f );
        TESTFW_EXPECTED( r.z.x == 1.17520119f );
        TESTFW_EXPECTED( r.w.x == 0.521095276f );
    TESTFW_TEST_END();

    // mat42_smoothstep
    TESTFW_TEST_BEGIN( "mat42_smoothstep performs Hermite interpolation element-wise" )
        mat42_t a = mat42(
            vec2( 2.0f, 0 ),
            vec2(10.0f, 0 ),
            vec2( 0.0f, 0 ),
            vec2( 5.0f, 0 )
        );
        mat42_t b = mat42(
            vec2( 6.0f, 0 ),
            vec2(14.0f, 0 ),
            vec2( 4.0f, 0 ),
            vec2(15.0f, 0 )
        );
        mat42_t t = mat42(
            vec2( 3.0f, 0 ),
            vec2(12.0f, 0 ),
            vec2( 1.0f, 0 ),
            vec2(10.0f, 0 )
        );
        mat42_t r = mat42_smoothstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.15625f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 0.15625f );
        TESTFW_EXPECTED( r.w.x == 0.5f );
    TESTFW_TEST_END();

    // mat42_smootherstep
    TESTFW_TEST_BEGIN( "mat42_smootherstep performs quintic Hermite interpolation element-wise" )
        mat42_t a = mat42(
            vec2( 0.0f, 0 ),
            vec2( 4.0f, 0 ),
            vec2( 0.0f, 0 ),
            vec2( 0.0f, 0 )
        );
        mat42_t b = mat42(
            vec2( 8.0f, 0 ),
            vec2(12.0f, 0 ),
            vec2( 8.0f, 0 ),
            vec2( 8.0f, 0 )
        );
        mat42_t t = mat42(
            vec2( 4.0f, 0 ),
            vec2(10.0f, 0 ),
            vec2( 2.0f, 0 ),
            vec2( 4.0f, 0 )
        );
        mat42_t r = mat42_smootherstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 0.89648438f );
        TESTFW_EXPECTED( r.z.x == 0.103515625f );
        TESTFW_EXPECTED( r.w.x == 0.5f );
    TESTFW_TEST_END();

    // mat42_sqrt
    TESTFW_TEST_BEGIN( "mat42_sqrt returns square root of each element" )
        mat42_t m = mat42(
            vec2(16.0f, 0 ),
            vec2( 0.25f,0 ),
            vec2( 9.0f, 0 ),
            vec2( 1.0f, 0 )
        );
        mat42_t r = mat42_sqrt(m);
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat42_step
    TESTFW_TEST_BEGIN( "mat42_step returns 0.0 or 1.0 per element based on threshold" )
        mat42_t a = mat42(
            vec2(2.5f, 0 ),
            vec2(6.0f, 0 ),
            vec2(4.0f, 0 ),
            vec2(1.0f, 0 )
        );
        mat42_t b = mat42(
            vec2(3.0f, 0 ),
            vec2(5.0f, 0 ),
            vec2(4.0f, 0 ),
            vec2(0.5f, 0 )
        );
        mat42_t r = mat42_step(a, b);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat42_tan
    TESTFW_TEST_BEGIN( "mat42_tan applies tan to each element" )
        mat42_t m = mat42(
            vec2( 0.5f, 0 ),
            vec2(-1.0f, 0 ),
            vec2( 1.0f, 0 ),
            vec2(-0.5f, 0 )
        );
        mat42_t r = mat42_tan(m);
        TESTFW_EXPECTED( r.x.x == 0.54630249f );
        TESTFW_EXPECTED( r.y.x == -1.55740772f );
        TESTFW_EXPECTED( r.z.x == 1.55740772f );
        TESTFW_EXPECTED( r.w.x == -0.54630249f );
    TESTFW_TEST_END();

    // mat42_tanh
    TESTFW_TEST_BEGIN( "mat42_tanh applies tanh to each element" )
        mat42_t m = mat42(
            vec2( 1.0f, 0 ),
            vec2(-2.0f, 0 ),
            vec2( 0.0f, 0 ),
            vec2( 0.5f, 0 )
        );
        mat42_t r = mat42_tanh(m);
        TESTFW_EXPECTED( r.x.x == 0.76159416f );
        TESTFW_EXPECTED( r.y.x == -0.96402758f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == 0.46211716f );
    TESTFW_TEST_END();

    // mat42_trunc
    TESTFW_TEST_BEGIN( "mat42_trunc removes fractional part of each element" )
        mat42_t m = mat42(
            vec2( 3.7f, 0 ),
            vec2(-2.9f, 0 ),
            vec2( 0.5f, 0 ),
            vec2(-0.5f, 0 )
        );
        mat42_t r = mat42_trunc(m);
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();
}


void test_mat43( void ) {
    // mat43
    TESTFW_TEST_BEGIN( "mat43 constructs matrix from four distinct row vectors" )
        mat43_t m = mat43(
            vec3( 1.0f, 2.0f, 3.0f ),
            vec3( 4.0f, 5.0f, 6.0f ),
            vec3( 7.0f, 8.0f, 9.0f ),
            vec3(10.0f, 11.0f, 12.0f )
        );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 2.0f );
        TESTFW_EXPECTED( m.x.z == 3.0f );
        TESTFW_EXPECTED( m.y.x == 4.0f );
        TESTFW_EXPECTED( m.y.y == 5.0f );
        TESTFW_EXPECTED( m.y.z == 6.0f );
        TESTFW_EXPECTED( m.z.x == 7.0f );
        TESTFW_EXPECTED( m.z.y == 8.0f );
        TESTFW_EXPECTED( m.z.z == 9.0f );
        TESTFW_EXPECTED( m.w.x == 10.0f );
        TESTFW_EXPECTED( m.w.y == 11.0f );
        TESTFW_EXPECTED( m.w.z == 12.0f );
    TESTFW_TEST_END();

    // mat43f
    TESTFW_TEST_BEGIN( "mat43f constructs a matrix with all elements equal to input" )
        mat43_t m = mat43f( -3.5f );
        TESTFW_EXPECTED( m.x.x == -3.5f );
        TESTFW_EXPECTED( m.x.y == -3.5f );
        TESTFW_EXPECTED( m.x.z == -3.5f );
        TESTFW_EXPECTED( m.y.x == -3.5f );
        TESTFW_EXPECTED( m.y.y == -3.5f );
        TESTFW_EXPECTED( m.y.z == -3.5f );
        TESTFW_EXPECTED( m.z.x == -3.5f );
        TESTFW_EXPECTED( m.z.y == -3.5f );
        TESTFW_EXPECTED( m.z.z == -3.5f );
        TESTFW_EXPECTED( m.w.x == -3.5f );
        TESTFW_EXPECTED( m.w.y == -3.5f );
        TESTFW_EXPECTED( m.w.z == -3.5f );
    TESTFW_TEST_END();

    // mat43_get
    TESTFW_TEST_BEGIN( "mat43_get returns each row by index" )
        mat43_t m = mat43(
            vec3(10, 0, 0),
            vec3(20, 0, 0),
            vec3(30, 0, 0),
            vec3(40, 0, 0)
        );
        vec3_t r0 = mat43_get( m, 0 );
        vec3_t r1 = mat43_get( m, 1 );
        vec3_t r2 = mat43_get( m, 2 );
        vec3_t r3 = mat43_get( m, 3 );
        TESTFW_EXPECTED( r0.x == 10.0f );
        TESTFW_EXPECTED( r1.x == 20.0f );
        TESTFW_EXPECTED( r2.x == 30.0f );
        TESTFW_EXPECTED( r3.x == 40.0f );
    TESTFW_TEST_END();

    // mat43_set
    TESTFW_TEST_BEGIN( "mat43_set modifies only the specified row" )
        mat43_t m = mat43(
            vec3(1,0,0), vec3(2,0,0),
            vec3(3,0,0), vec3(4,0,0)
        );
        mat43_set( &m, 0, vec3(9,0,0) );
        TESTFW_EXPECTED( m.x.x == 9.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );
        TESTFW_EXPECTED( m.w.x == 4.0f );

        m = mat43(
            vec3(1,0,0), vec3(2,0,0),
            vec3(3,0,0), vec3(4,0,0)
        );
        mat43_set( &m, 1, vec3(9,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 9.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );
        TESTFW_EXPECTED( m.w.x == 4.0f );

        m = mat43(
            vec3(1,0,0), vec3(2,0,0),
            vec3(3,0,0), vec3(4,0,0)
        );
        mat43_set( &m, 2, vec3(9,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
        TESTFW_EXPECTED( m.w.x == 4.0f );

        m = mat43(
            vec3(1,0,0), vec3(2,0,0),
            vec3(3,0,0), vec3(4,0,0)
        );
        mat43_set( &m, 3, vec3(9,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );
        TESTFW_EXPECTED( m.w.x == 9.0f );
    TESTFW_TEST_END();

    // mat43_neg
    TESTFW_TEST_BEGIN( "mat43_neg negates each element of the matrix" )
        mat43_t m = mat43(
            vec3( 1, -2, 0 ),
            vec3( -3, 4, 0 ),
            vec3( 5, -6, 0 ),
            vec3( -7, 8, 0 )
        );
        mat43_t r = mat43_neg( m );
        TESTFW_EXPECTED( r.x.x == -1.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == -5.0f );
        TESTFW_EXPECTED( r.w.x == 7.0f );
    TESTFW_TEST_END();

    // mat43_eq
    TESTFW_TEST_BEGIN( "mat43_eq returns nonzero if all corresponding rows are equal" )
        mat43_t a = mat43(
            vec3(1,2,3),
            vec3(4,5,6),
            vec3(7,8,9),
            vec3(10,11,12)
        );
        mat43_t b = a;
        TESTFW_EXPECTED( mat43_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat43_eq returns zero if any element differs" )
        mat43_t a = mat43(
            vec3(1,2,3),
            vec3(4,5,6),
            vec3(7,8,9),
            vec3(10,11,12)
        );
        mat43_t b = a;
        b.z.z = 99.0f;
        TESTFW_EXPECTED( mat43_eq( a, b ) == 0 );

        b = a;
        b.x.x = 0.0f;
        TESTFW_EXPECTED( mat43_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // mat43_add
    TESTFW_TEST_BEGIN( "mat43_add adds corresponding elements of two matrices" )
        mat43_t a = mat43(
            vec3( 1, 0, 0 ),
            vec3( 6, 0, 0 ),
            vec3( 8, 0, 0 ),
            vec3(15, 0, 0 )
        );
        mat43_t b = mat43(
            vec3( 4, 0, 0 ),
            vec3( 9, 0, 0 ),
            vec3( 3, 0, 0 ),
            vec3( 4, 0, 0 )
        );
        mat43_t r = mat43_add( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 15.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
        TESTFW_EXPECTED( r.w.x == 19.0f );
    TESTFW_TEST_END();

    // mat43_sub
    TESTFW_TEST_BEGIN( "mat43_sub subtracts corresponding elements of two matrices" )
        mat43_t a = mat43(
            vec3( 8, 0, 0 ),
            vec3(15, 0, 0 ),
            vec3( 5, 0, 0 ),
            vec3(10, 0, 0 )
        );
        mat43_t b = mat43(
            vec3( 3, 0, 0 ),
            vec3( 4, 0, 0 ),
            vec3( 2, 0, 0 ),
            vec3( 5, 0, 0 )
        );
        mat43_t r = mat43_sub( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 11.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == 5.0f );
    TESTFW_TEST_END();

    // mat43_mul_elem
    TESTFW_TEST_BEGIN( "mat43_mul_elem multiplies corresponding elements of two matrices" )
        mat43_t a = mat43(
            vec3( 2, 0, 0 ),
            vec3( 5, 0, 0 ),
            vec3(10, 0, 0 ),
            vec3(12, 0, 0 )
        );
        mat43_t b = mat43(
            vec3( 3, 0, 0 ),
            vec3( 4, 0, 0 ),
            vec3( 2, 0, 0 ),
            vec3( 3, 0, 0 )
        );
        mat43_t r = mat43_mul_elem( a, b );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 20.0f );
        TESTFW_EXPECTED( r.z.x == 20.0f );
        TESTFW_EXPECTED( r.w.x == 36.0f );
    TESTFW_TEST_END();

    // mat43_div
    TESTFW_TEST_BEGIN( "mat43_div divides corresponding elements of two matrices" )
        mat43_t a = mat43(
            vec3(10, 0, 0 ),
            vec3(18, 0, 0 ),
            vec3(12, 0, 0 ),
            vec3( 9, 0, 0 )
        );
        mat43_t b = mat43(
            vec3( 2, 0, 0 ),
            vec3( 3, 0, 0 ),
            vec3( 4, 0, 0 ),
            vec3( 3, 0, 0 )
        );
        mat43_t r = mat43_div( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 6.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat43_addf
    TESTFW_TEST_BEGIN( "mat43_addf adds scalar to all elements of matrix" )
        mat43_t m = mat43(
            vec3( 2.0f, 0, 0 ),
            vec3( 5.0f, 0, 0 ),
            vec3( 8.0f, 0, 0 ),
            vec3(-1.0f, 0, 0 )
        );
        mat43_t r = mat43_addf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 8.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
        TESTFW_EXPECTED( r.w.x == 2.0f );
    TESTFW_TEST_END();

    // mat43_subf
    TESTFW_TEST_BEGIN( "mat43_subf subtracts scalar from all elements of matrix" )
        mat43_t m = mat43(
            vec3(10.0f, 0, 0 ),
            vec3( 6.0f, 0, 0 ),
            vec3( 0.0f, 0, 0 ),
            vec3( 4.0f, 0, 0 )
        );
        mat43_t r = mat43_subf( m, 4.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == -4.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat43_mulf
    TESTFW_TEST_BEGIN( "mat43_mulf multiplies all elements by scalar" )
        mat43_t m = mat43(
            vec3( 2.0f, 0, 0 ),
            vec3(-1.0f, 0, 0 ),
            vec3( 3.0f, 0, 0 ),
            vec3(-2.0f, 0, 0 )
        );
        mat43_t r = mat43_mulf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 9.0f );
        TESTFW_EXPECTED( r.w.x == -6.0f );
    TESTFW_TEST_END();

    // mat43_divf
    TESTFW_TEST_BEGIN( "mat43_divf divides all elements by scalar" )
        mat43_t m = mat43(
            vec3( 4.0f, 0, 0 ),
            vec3(-4.0f, 0, 0 ),
            vec3( 6.0f, 0, 0 ),
            vec3(-6.0f, 0, 0 )
        );
        mat43_t r = mat43_divf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == -3.0f );
    TESTFW_TEST_END();

    // mat43_abs
    TESTFW_TEST_BEGIN( "mat43_abs applies absolute value to each element of the matrix" )
        mat43_t m = mat43(
            vec3( -1.0f, 0.0f, 0.0f ),
            vec3( 0.0f, -2.0f, 0.0f ),
            vec3( 0.0f, 0.0f, -3.5f ),
            vec3( 0.0f, 0.0f, 0.0f )
        );
        mat43_t r = mat43_abs( m );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 2.0f );
        TESTFW_EXPECTED( r.z.z == 3.5f );
    TESTFW_TEST_END();

    // mat43_acos
    TESTFW_TEST_BEGIN( "mat43_acos applies acos to each element" )
        mat43_t m = mat43(
            vec3( 0.5f, 0, 0 ),
            vec3( -1.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 ),
            vec3( 0.0f, 0, 0 )
        );
        mat43_t r = mat43_acos( m );
        TESTFW_EXPECTED( test_cmp(r.x.x,1.04719758f ));
        TESTFW_EXPECTED( test_cmp(r.y.x,3.14159265f ));
        TESTFW_EXPECTED( test_cmp(r.z.x,0.00000000f ));
        TESTFW_EXPECTED( test_cmp(r.w.x,1.57079633f ));
    TESTFW_TEST_END();

    // mat43_all
    TESTFW_TEST_BEGIN( "mat43_all returns nonzero only if all twelve elements are nonzero" )
        TESTFW_EXPECTED( mat43_all( mat43(
            vec3(1,1,1), vec3(1,1,1),
            vec3(1,1,1), vec3(1,1,1)
        ) ) != 0 );

        TESTFW_EXPECTED( mat43_all( mat43(
            vec3(0,1,1), vec3(1,1,1),
            vec3(1,1,1), vec3(1,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat43_all( mat43(
            vec3(1,1,1), vec3(1,0,1),
            vec3(1,1,1), vec3(1,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat43_all( mat43(
            vec3(1,1,1), vec3(1,1,1),
            vec3(1,1,0), vec3(1,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat43_all( mat43(
            vec3(1,1,1), vec3(1,1,1),
            vec3(1,1,1), vec3(1,1,0)
        ) ) == 0 );

        TESTFW_EXPECTED( mat43_all( mat43f( 1.0f ) ) != 0 );
    TESTFW_TEST_END();

    // mat43_any
    TESTFW_TEST_BEGIN( "mat43_any returns nonzero if any element is nonzero" )
        TESTFW_EXPECTED( mat43_any( mat43(
            vec3(0,1,0), vec3(0,0,0),
            vec3(0,0,0), vec3(0,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat43_any( mat43(
            vec3(0,0,0), vec3(0,0,1),
            vec3(0,0,0), vec3(0,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat43_any( mat43(
            vec3(0,0,0), vec3(0,0,0),
            vec3(0,0,0), vec3(1,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat43_any( mat43f( 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // mat43_asin
    TESTFW_TEST_BEGIN( "mat43_asin applies asin to each element" )
        mat43_t m = mat43(
            vec3( 0.5f, 0, 0 ),
            vec3( -1.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 ),
            vec3( 0.0f, 0, 0 )
        );
        mat43_t r = mat43_asin( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 0.52359878f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, -1.57079633f ));
        TESTFW_EXPECTED( test_cmp(r.z.x, 1.57079633f ));
        TESTFW_EXPECTED( test_cmp(r.w.x, 0.00000000f ));
    TESTFW_TEST_END();

    // mat43_atan
    TESTFW_TEST_BEGIN( "mat43_atan applies atan to each element" )
        mat43_t m = mat43(
            vec3( 0.5f, 0, 0 ),
            vec3( -2.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 ),
            vec3( -1.0f, 0, 0 )
        );
        mat43_t r = mat43_atan( m );
        TESTFW_EXPECTED( r.x.x == 0.46364761f );
        TESTFW_EXPECTED( r.y.x == -1.10714872f );
        TESTFW_EXPECTED( r.z.x == 0.78539816f );
        TESTFW_EXPECTED( r.w.x == -0.78539816f );
    TESTFW_TEST_END();

    // mat43_atan2
    TESTFW_TEST_BEGIN( "mat43_atan2 applies atan2 to each element" )
        mat43_t y = mat43(
            vec3( 2.0f, 0, 0 ),
            vec3(-3.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 ),
            vec3( 3.0f, 0, 0 )
        );
        mat43_t x = mat43(
            vec3( 1.0f, 0, 0 ),
            vec3(-4.0f, 0, 0 ),
            vec3(-1.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat43_t r = mat43_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.10714872f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, -2.49809154f ));
        TESTFW_EXPECTED( test_cmp( r.z.x, 2.35619449f ));
        TESTFW_EXPECTED( test_cmp( r.w.x, 1.24904577f ));
    TESTFW_TEST_END();

    // mat43_ceil
    TESTFW_TEST_BEGIN( "mat43_ceil applies ceil to each element" )
        mat43_t m = mat43(
            vec3( 1.2f, 0, 0 ),
            vec3( -3.7f, 0, 0 ),
            vec3( -0.1f, 0, 0 ),
            vec3( 2.9f, 0, 0 )
        );
        mat43_t r = mat43_ceil( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat43_clamp
    TESTFW_TEST_BEGIN( "mat43_clamp clamps each element using corresponding min and max matrices" )
        mat43_t v = mat43(
            vec3( 5.0f, 0, 0 ),
            vec3(-10.0f, 0, 0 ),
            vec3( 0.5f, 0, 0 ),
            vec3( 3.0f, 0, 0 )
        );
        mat43_t mn = mat43(
            vec3( 0.0f, 0, 0 ),
            vec3( -8.0f, 0, 0 ),
            vec3( -1.0f, 0, 0 ),
            vec3( 0.0f, 0, 0 )
        );
        mat43_t mx = mat43(
            vec3( 4.0f, 0, 0 ),
            vec3( -7.0f, 0, 0 ),
            vec3( 2.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat43_t r = mat43_clamp( v, mn, mx );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -8.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat43_cos
    TESTFW_TEST_BEGIN( "mat43_cos applies cos to each element" )
        mat43_t m = mat43(
            vec3( 0.5f, 0, 0 ),
            vec3( 2.0f, 0, 0 ),
            vec3( 3.14159265f, 0, 0 ),
            vec3( 0.0f, 0, 0 )
        );
        mat43_t r = mat43_cos( m );
        TESTFW_EXPECTED( r.x.x == 0.87758256f );
        TESTFW_EXPECTED( r.y.x == -0.41614684f );
        TESTFW_EXPECTED( r.z.x == -1.00000000f );
        TESTFW_EXPECTED( r.w.x == 1.00000000f );
    TESTFW_TEST_END();

    // mat43_cosh
    TESTFW_TEST_BEGIN( "mat43_cosh applies cosh to each element" )
        mat43_t m = mat43(
            vec3( 0.5f, 0, 0 ),
            vec3( 2.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 ),
            vec3( 0.0f, 0, 0 )
        );
        mat43_t r = mat43_cosh( m );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.12762597f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, 3.76219569f ));
        TESTFW_EXPECTED( test_cmp( r.z.x, 1.54308063f ));
        TESTFW_EXPECTED( test_cmp( r.w.x, 1.00000000f ));
    TESTFW_TEST_END();

    // mat43_degrees
    TESTFW_TEST_BEGIN( "mat43_degrees converts radians to degrees element-wise" )
        mat43_t m = mat43(
            vec3( 0.5f, 0, 0 ),
            vec3( -1.0f, 0, 0 ),
            vec3( 3.14159265f, 0, 0 ),
            vec3( 0.0f, 0, 0 )
        );
        mat43_t r = mat43_degrees( m );
        TESTFW_EXPECTED( r.x.x == 28.6478898f );
        TESTFW_EXPECTED( r.y.x == -57.2957795f );
        TESTFW_EXPECTED( r.z.x == 180.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat43_exp
    TESTFW_TEST_BEGIN( "mat43_exp applies exp to each element" )
        mat43_t m = mat43(
            vec3( 0.5f, 0, 0 ),
            vec3( -2.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 ),
            vec3( 0.0f, 0, 0 )
        );
        mat43_t r = mat43_exp( m );
        TESTFW_EXPECTED( r.x.x == 1.64872127f );
        TESTFW_EXPECTED( r.y.x == 0.13533528f );
        TESTFW_EXPECTED( r.z.x == 2.71828183f );
        TESTFW_EXPECTED( r.w.x == 1.00000000f );
    TESTFW_TEST_END();

    // mat43_exp2
    TESTFW_TEST_BEGIN( "mat43_exp2 applies exp2 to each element" )
        mat43_t m = mat43(
            vec3( 3.0f, 0, 0 ),
            vec3( -2.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 ),
            vec3( 0.0f, 0, 0 )
        );
        mat43_t r = mat43_exp2( m );
        TESTFW_EXPECTED( r.x.x == 8.0f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat43_floor
    TESTFW_TEST_BEGIN( "mat43_floor applies floor to each element" )
        mat43_t m = mat43(
            vec3( 2.7f, 0, 0 ),
            vec3( -3.2f, 0, 0 ),
            vec3( 0.0f, 0, 0 ),
            vec3( -1.5f, 0, 0 )
        );
        mat43_t r = mat43_floor( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == -2.0f );
    TESTFW_TEST_END();

    // mat43_fmod
    TESTFW_TEST_BEGIN( "mat43_fmod applies fmod to each element" )
        mat43_t a = mat43(
            vec3( 6.5f, 0, 0 ),
            vec3(-5.0f, 0, 0 ),
            vec3( 7.75f,0, 0 ),
            vec3( 5.5f, 0, 0 )
        );
        mat43_t b = mat43(
            vec3( 2.0f, 0, 0 ),
            vec3( 3.0f, 0, 0 ),
            vec3( 2.5f, 0, 0 ),
            vec3( 4.0f, 0, 0 )
        );
        mat43_t r = mat43_fmod( a, b );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
        TESTFW_EXPECTED( r.w.x == 1.5f );
    TESTFW_TEST_END();

    // mat43_frac
    TESTFW_TEST_BEGIN( "mat43_frac returns fractional part of each element" )
        mat43_t m = mat43(
            vec3( 3.75f, 0, 0 ),
            vec3( -2.25f, 0, 0 ),
            vec3( 1.5f, 0, 0 ),
            vec3( -3.125f,0, 0 )
        );
        mat43_t r = mat43_frac( m );
        TESTFW_EXPECTED( r.x.x == 0.75f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 0.50f );
        TESTFW_EXPECTED( r.w.x == 0.125f );
    TESTFW_TEST_END();

    // mat43_lerp
    TESTFW_TEST_BEGIN( "mat43_lerp linearly interpolates between matrices element-wise" )
        mat43_t a = mat43(
            vec3( 2.0f, 0, 0 ),
            vec3(-4.0f, 0, 0 ),
            vec3( 0.0f, 0, 0 ),
            vec3( 0.0f, 0, 0 )
        );
        mat43_t b = mat43(
            vec3( 6.0f, 0, 0 ),
            vec3( 8.0f, 0, 0 ),
            vec3( 4.0f, 0, 0 ),
            vec3(12.0f, 0, 0 )
        );
        mat43_t r = mat43_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat43_log
    TESTFW_TEST_BEGIN( "mat43_log applies natural log to each element" )
        mat43_t m = mat43(
            vec3( 1.0f, 0, 0 ),
            vec3( 2.718282f, 0, 0 ),
            vec3( 7.3890561f, 0, 0 ),
            vec3(20.085537f, 0, 0 )
        );
        mat43_t r = mat43_log( m );
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat43_log2
    TESTFW_TEST_BEGIN( "mat43_log2 applies base-2 logarithm to each element" )
        mat43_t m = mat43(
            vec3( 16.0f, 0, 0 ),
            vec3( 0.25f,0, 0 ),
            vec3( 2.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat43_t r = mat43_log2( m );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat43_log10
    TESTFW_TEST_BEGIN( "mat43_log10 applies base-10 logarithm to each element" )
        mat43_t m = mat43(
            vec3( 100.0f, 0, 0 ),
            vec3( 0.001f, 0, 0 ),
            vec3( 10.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat43_t r = mat43_log10( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat43_max
    TESTFW_TEST_BEGIN( "mat43_max returns element-wise maximum of two matrices" )
        mat43_t a = mat43(
            vec3( 3.0f, 0, 0 ),
            vec3( -5.0f, 0, 0 ),
            vec3( 7.0f, 0, 0 ),
            vec3( 2.0f, 0, 0 )
        );
        mat43_t b = mat43(
            vec3( 2.0f, 0, 0 ),
            vec3( -4.0f, 0, 0 ),
            vec3( 8.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat43_t r = mat43_max( a, b );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 8.0f );
        TESTFW_EXPECTED( r.w.x == 2.0f );
    TESTFW_TEST_END();

    // mat43_min
    TESTFW_TEST_BEGIN( "mat43_min returns element-wise minimum of two matrices" )
        mat43_t a = mat43(
            vec3( 3.0f, 0, 0 ),
            vec3( -5.0f, 0, 0 ),
            vec3( 7.0f, 0, 0 ),
            vec3( 2.0f, 0, 0 )
        );
        mat43_t b = mat43(
            vec3( 2.0f, 0, 0 ),
            vec3( -4.0f, 0, 0 ),
            vec3( 8.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat43_t r = mat43_min( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -5.0f );
        TESTFW_EXPECTED( r.z.x == 7.0f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat43_pow
    TESTFW_TEST_BEGIN( "mat43_pow applies pow to each element" )
        mat43_t a = mat43(
            vec3( 4.0f, 0, 0 ),
            vec3( 9.0f, 0, 0 ),
            vec3( 16.0f, 0, 0 ),
            vec3( 25.0f, 0, 0 )
        );
        mat43_t b = mat43f( 0.5f );
        mat43_t r = mat43_pow( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == 4.0f );
        TESTFW_EXPECTED( r.w.x == 5.0f );
    TESTFW_TEST_END();

    // mat43_radians
    TESTFW_TEST_BEGIN( "mat43_radians converts degrees to radians element-wise" )
        mat43_t m = mat43(
            vec3( 90.0f, 0, 0 ),
            vec3( -45.0f, 0, 0 ),
            vec3( 180.0f, 0, 0 ),
            vec3( 360.0f, 0, 0 )
        );
        mat43_t r = mat43_radians( m );
        TESTFW_EXPECTED( r.x.x == 1.57079633f );
        TESTFW_EXPECTED( r.y.x == -0.78539816f );
        TESTFW_EXPECTED( r.z.x == 3.14159265f );
        TESTFW_EXPECTED( r.w.x == 6.28318531f );
    TESTFW_TEST_END();

    // mat43_rcp
    TESTFW_TEST_BEGIN( "mat43_rcp returns element-wise reciprocal" )
        mat43_t m = mat43(
            vec3( 4.0f, 0, 0 ),
            vec3( -0.5f, 0, 0 ),
            vec3( 2.0f, 0, 0 ),
            vec3( 1.0f, 0, 0 )
        );
        mat43_t r = mat43_rcp( m );
        TESTFW_EXPECTED( r.x.x == 0.25f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat43_round
    TESTFW_TEST_BEGIN( "mat43_round rounds each element to nearest integer" )
        mat43_t m = mat43(
            vec3( 2.6f, 0, 0 ),
            vec3( -3.4f, 0, 0 ),
            vec3( -1.7f, 0, 0 ),
            vec3( 4.3f, 0, 0 )
        );
        mat43_t r = mat43_round( m );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == -2.0f );
        TESTFW_EXPECTED( r.w.x == 4.0f );
    TESTFW_TEST_END();

    // mat43_rsqrt
    TESTFW_TEST_BEGIN( "mat43_rsqrt returns reciprocal square root of each element" )
        mat43_t m = mat43(
            vec3( 4.0f, 0,0 ),
            vec3( 0.25f, 0,0 ),
            vec3( 16.0f, 0,0 ),
            vec3( 1.0f, 0,0 )
        );
        mat43_t r = mat43_rsqrt(m);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat43_saturate
    TESTFW_TEST_BEGIN( "mat43_saturate clamps each element to the [0, 1] range" )
        mat43_t m = mat43(
            vec3(-2.0f, 0,0 ),
            vec3( 1.5f, 0,0 ),
            vec3( 0.5f, 0,0 ),
            vec3( 2.0f, 0,0 )
        );
        mat43_t r = mat43_saturate(m);
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat43_sign
    TESTFW_TEST_BEGIN( "mat43_sign returns sign of each element" )
        mat43_t m = mat43(
            vec3( 3.5f, 0,0 ),
            vec3(-2.0f, 0,0 ),
            vec3( 0.0f, 0,0 ),
            vec3(-4.7f, 0,0 )
        );
        mat43_t r = mat43_sign(m);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == -1.0f );
    TESTFW_TEST_END();

    // mat43_sin
    TESTFW_TEST_BEGIN( "mat43_sin applies sin to each element" )
        mat43_t m = mat43(
            vec3( 0.5f, 0,0 ),
            vec3(-2.0f, 0,0 ),
            vec3( 1.0f, 0,0 ),
            vec3(-1.0f, 0,0 )
        );
        mat43_t r = mat43_sin(m);
        TESTFW_EXPECTED( r.x.x == 0.47942554f );
        TESTFW_EXPECTED( r.y.x == -0.90929743f );
        TESTFW_EXPECTED( r.z.x == 0.84147098f );
        TESTFW_EXPECTED( r.w.x == -0.84147098f );
    TESTFW_TEST_END();

    // mat43_sinh
    TESTFW_TEST_BEGIN( "mat43_sinh applies sinh to each element" )
        mat43_t m = mat43(
            vec3(-1.0f, 0,0 ),
            vec3( 0.0f, 0,0 ),
            vec3( 1.0f, 0,0 ),
            vec3( 0.5f, 0,0 )
        );
        mat43_t r = mat43_sinh(m);
        TESTFW_EXPECTED( r.x.x == -1.17520119f );
        TESTFW_EXPECTED( r.y.x == 0.00000000f );
        TESTFW_EXPECTED( r.z.x == 1.17520119f );
        TESTFW_EXPECTED( r.w.x == 0.521095276f );
    TESTFW_TEST_END();

    // mat43_smoothstep
    TESTFW_TEST_BEGIN( "mat43_smoothstep performs Hermite interpolation element-wise" )
        mat43_t a = mat43(
            vec3( 2.0f, 0,0 ),
            vec3(10.0f, 0,0 ),
            vec3( 0.0f, 0,0 ),
            vec3( 5.0f, 0,0 )
        );
        mat43_t b = mat43(
            vec3( 6.0f, 0,0 ),
            vec3(14.0f, 0,0 ),
            vec3( 4.0f, 0,0 ),
            vec3(15.0f, 0,0 )
        );
        mat43_t t = mat43(
            vec3( 3.0f, 0,0 ),
            vec3(12.0f, 0,0 ),
            vec3( 1.0f, 0,0 ),
            vec3(10.0f, 0,0 )
        );
        mat43_t r = mat43_smoothstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.15625f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 0.15625f );
        TESTFW_EXPECTED( r.w.x == 0.5f );
    TESTFW_TEST_END();

    // mat43_smootherstep
    TESTFW_TEST_BEGIN( "mat43_smootherstep performs quintic Hermite interpolation element-wise" )
        mat43_t a = mat43(
            vec3( 0.0f, 0,0 ),
            vec3( 4.0f, 0,0 ),
            vec3( 0.0f, 0,0 ),
            vec3( 0.0f, 0,0 )
        );
        mat43_t b = mat43(
            vec3( 8.0f, 0,0 ),
            vec3(12.0f, 0,0 ),
            vec3( 8.0f, 0,0 ),
            vec3( 8.0f, 0,0 )
        );
        mat43_t t = mat43(
            vec3( 4.0f, 0,0 ),
            vec3(10.0f, 0,0 ),
            vec3( 2.0f, 0,0 ),
            vec3( 4.0f, 0,0 )
        );
        mat43_t r = mat43_smootherstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 0.89648438f );
        TESTFW_EXPECTED( r.z.x == 0.103515625f );
        TESTFW_EXPECTED( r.w.x == 0.5f );
    TESTFW_TEST_END();

    // mat43_sqrt
    TESTFW_TEST_BEGIN( "mat43_sqrt returns square root of each element" )
        mat43_t m = mat43(
            vec3(16.0f, 0,0 ),
            vec3( 0.25f,0,0 ),
            vec3( 9.0f, 0,0 ),
            vec3( 1.0f, 0,0 )
        );
        mat43_t r = mat43_sqrt(m);
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat43_step
    TESTFW_TEST_BEGIN( "mat43_step returns 0.0 or 1.0 per element based on threshold" )
        mat43_t a = mat43(
            vec3(2.5f, 0,0 ),
            vec3(6.0f, 0,0 ),
            vec3(4.0f, 0,0 ),
            vec3(1.0f, 0,0 )
        );
        mat43_t b = mat43(
            vec3(3.0f, 0,0 ),
            vec3(5.0f, 0,0 ),
            vec3(4.0f, 0,0 ),
            vec3(0.5f, 0,0 )
        );
        mat43_t r = mat43_step(a, b);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat43_tan
    TESTFW_TEST_BEGIN( "mat43_tan applies tan to each element" )
        mat43_t m = mat43(
            vec3( 0.5f, 0,0 ),
            vec3(-1.0f, 0,0 ),
            vec3( 1.0f, 0,0 ),
            vec3(-0.5f, 0,0 )
        );
        mat43_t r = mat43_tan(m);
        TESTFW_EXPECTED( r.x.x == 0.54630249f );
        TESTFW_EXPECTED( r.y.x == -1.55740772f );
        TESTFW_EXPECTED( r.z.x == 1.55740772f );
        TESTFW_EXPECTED( r.w.x == -0.54630249f );
    TESTFW_TEST_END();

    // mat43_tanh
    TESTFW_TEST_BEGIN( "mat43_tanh applies tanh to each element" )
        mat43_t m = mat43(
            vec3( 1.0f, 0,0 ),
            vec3(-2.0f, 0,0 ),
            vec3( 0.0f, 0,0 ),
            vec3( 0.5f, 0,0 )
        );
        mat43_t r = mat43_tanh(m);
        TESTFW_EXPECTED( r.x.x == 0.76159416f );
        TESTFW_EXPECTED( r.y.x == -0.96402758f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == 0.46211716f );
    TESTFW_TEST_END();

    // mat43_trunc
    TESTFW_TEST_BEGIN( "mat43_trunc removes fractional part of each element" )
        mat43_t m = mat43(
            vec3( 3.7f, 0,0 ),
            vec3(-2.9f, 0,0 ),
            vec3( 0.5f, 0,0 ),
            vec3(-0.5f, 0,0 )
        );
        mat43_t r = mat43_trunc(m);
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();
}


void test_mat44( void ) {
    // mat44
    TESTFW_TEST_BEGIN( "mat44 constructs matrix from four distinct row vectors" )
        mat44_t m = mat44(
            vec4( 1.0f, 2.0f, 3.0f, 4.0f ),
            vec4( 5.0f, 6.0f, 7.0f, 8.0f ),
            vec4( 9.0f, 10.0f, 11.0f, 12.0f ),
            vec4(13.0f, 14.0f, 15.0f, 16.0f )
        );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 2.0f );
        TESTFW_EXPECTED( m.x.z == 3.0f );
        TESTFW_EXPECTED( m.x.w == 4.0f );
        TESTFW_EXPECTED( m.y.x == 5.0f );
        TESTFW_EXPECTED( m.y.y == 6.0f );
        TESTFW_EXPECTED( m.y.z == 7.0f );
        TESTFW_EXPECTED( m.y.w == 8.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
        TESTFW_EXPECTED( m.z.y == 10.0f );
        TESTFW_EXPECTED( m.z.z == 11.0f );
        TESTFW_EXPECTED( m.z.w == 12.0f );
        TESTFW_EXPECTED( m.w.x == 13.0f );
        TESTFW_EXPECTED( m.w.y == 14.0f );
        TESTFW_EXPECTED( m.w.z == 15.0f );
        TESTFW_EXPECTED( m.w.w == 16.0f );
    TESTFW_TEST_END();

    // mat44f
    TESTFW_TEST_BEGIN( "mat44f constructs a matrix with all elements equal to input" )
        mat44_t m = mat44f( -3.5f );
        TESTFW_EXPECTED( m.x.x == -3.5f );
        TESTFW_EXPECTED( m.x.y == -3.5f );
        TESTFW_EXPECTED( m.x.z == -3.5f );
        TESTFW_EXPECTED( m.x.w == -3.5f );
        TESTFW_EXPECTED( m.y.x == -3.5f );
        TESTFW_EXPECTED( m.y.y == -3.5f );
        TESTFW_EXPECTED( m.y.z == -3.5f );
        TESTFW_EXPECTED( m.y.w == -3.5f );
        TESTFW_EXPECTED( m.z.x == -3.5f );
        TESTFW_EXPECTED( m.z.y == -3.5f );
        TESTFW_EXPECTED( m.z.z == -3.5f );
        TESTFW_EXPECTED( m.z.w == -3.5f );
        TESTFW_EXPECTED( m.w.x == -3.5f );
        TESTFW_EXPECTED( m.w.y == -3.5f );
        TESTFW_EXPECTED( m.w.z == -3.5f );
        TESTFW_EXPECTED( m.w.w == -3.5f );
    TESTFW_TEST_END();

    // mat44_get
    TESTFW_TEST_BEGIN( "mat44_get returns each row by index" )
        mat44_t m = mat44(
            vec4( 10, 0, 0, 0 ),
            vec4( 20, 0, 0, 0 ),
            vec4( 30, 0, 0, 0 ),
            vec4( 40, 0, 0, 0 )
        );
        vec4_t r0 = mat44_get( m, 0 );
        vec4_t r1 = mat44_get( m, 1 );
        vec4_t r2 = mat44_get( m, 2 );
        vec4_t r3 = mat44_get( m, 3 );
        TESTFW_EXPECTED( r0.x == 10.0f );
        TESTFW_EXPECTED( r1.x == 20.0f );
        TESTFW_EXPECTED( r2.x == 30.0f );
        TESTFW_EXPECTED( r3.x == 40.0f );
    TESTFW_TEST_END();


    // mat44_set
    TESTFW_TEST_BEGIN( "mat44_set modifies only the specified row" )
        mat44_t m = mat44(
            vec4(1,0,0,0), vec4(2,0,0,0),
            vec4(3,0,0,0), vec4(4,0,0,0)
        );
        mat44_set( &m, 0, vec4(9,0,0,0) );
        TESTFW_EXPECTED( m.x.x == 9.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );
        TESTFW_EXPECTED( m.w.x == 4.0f );

        m = mat44(
            vec4(1,0,0,0), vec4(2,0,0,0),
            vec4(3,0,0,0), vec4(4,0,0,0)
        );
        mat44_set( &m, 1, vec4(9,0,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 9.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );
        TESTFW_EXPECTED( m.w.x == 4.0f );

        m = mat44(
            vec4(1,0,0,0), vec4(2,0,0,0),
            vec4(3,0,0,0), vec4(4,0,0,0)
        );
        mat44_set( &m, 2, vec4(9,0,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 9.0f );
        TESTFW_EXPECTED( m.w.x == 4.0f );

        m = mat44(
            vec4(1,0,0,0), vec4(2,0,0,0),
            vec4(3,0,0,0), vec4(4,0,0,0)
        );
        mat44_set( &m, 3, vec4(9,0,0,0) );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.y.x == 2.0f );
        TESTFW_EXPECTED( m.z.x == 3.0f );
        TESTFW_EXPECTED( m.w.x == 9.0f );
    TESTFW_TEST_END();

    // mat44_neg
    TESTFW_TEST_BEGIN( "mat44_neg negates each element of the matrix" )
        mat44_t m = mat44(
            vec4( 1, -2, 0, 0 ),
            vec4( -3, 4, 0, 0 ),
            vec4( 5, -6, 0, 0 ),
            vec4( -7, 8, 0, 0 )
        );
        mat44_t r = mat44_neg( m );
        TESTFW_EXPECTED( r.x.x == -1.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == -5.0f );
        TESTFW_EXPECTED( r.w.x == 7.0f );
    TESTFW_TEST_END();

    // mat44_eq
    TESTFW_TEST_BEGIN( "mat44_eq returns nonzero if all corresponding rows are equal" )
        mat44_t a = mat44(
            vec4(1,2,3,4),
            vec4(5,6,7,8),
            vec4(9,10,11,12),
            vec4(13,14,15,16)
        );
        mat44_t b = a;
        TESTFW_EXPECTED( mat44_eq( a, b ) != 0 );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_eq returns zero if any element differs" )
        mat44_t a = mat44(
            vec4(1,2,3,4),
            vec4(5,6,7,8),
            vec4(9,10,11,12),
            vec4(13,14,15,16)
        );
        mat44_t b = a;
        b.z.z = 99.0f;
        TESTFW_EXPECTED( mat44_eq( a, b ) == 0 );

        b = a;
        b.x.x = 0.0f;
        TESTFW_EXPECTED( mat44_eq( a, b ) == 0 );
    TESTFW_TEST_END();

    // mat44_add
    TESTFW_TEST_BEGIN( "mat44_add adds corresponding elements of two matrices" )
        mat44_t a = mat44(
            vec4( 1, 0,0,0 ),
            vec4( 6, 0,0,0 ),
            vec4( 8, 0,0,0 ),
            vec4(15, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4( 4, 0,0,0 ),
            vec4( 9, 0,0,0 ),
            vec4( 3, 0,0,0 ),
            vec4( 4, 0,0,0 )
        );
        mat44_t r = mat44_add( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 15.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
        TESTFW_EXPECTED( r.w.x == 19.0f );
    TESTFW_TEST_END();

    // mat44_sub
    TESTFW_TEST_BEGIN( "mat44_sub subtracts corresponding elements of two matrices" )
        mat44_t a = mat44(
            vec4( 8, 0,0,0 ),
            vec4(15, 0,0,0 ),
            vec4( 5, 0,0,0 ),
            vec4(10, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4( 3, 0,0,0 ),
            vec4( 4, 0,0,0 ),
            vec4( 2, 0,0,0 ),
            vec4( 5, 0,0,0 )
        );
        mat44_t r = mat44_sub( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 11.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == 5.0f );
    TESTFW_TEST_END();

    // mat44_mul_elem
    TESTFW_TEST_BEGIN( "mat44_mul_elem multiplies corresponding elements of two matrices" )
        mat44_t a = mat44(
            vec4( 2, 0,0,0 ),
            vec4( 5, 0,0,0 ),
            vec4(10, 0,0,0 ),
            vec4(12, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4( 3, 0,0,0 ),
            vec4( 4, 0,0,0 ),
            vec4( 2, 0,0,0 ),
            vec4( 3, 0,0,0 )
        );
        mat44_t r = mat44_mul_elem( a, b );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 20.0f );
        TESTFW_EXPECTED( r.z.x == 20.0f );
        TESTFW_EXPECTED( r.w.x == 36.0f );
    TESTFW_TEST_END();

    // mat44_div
    TESTFW_TEST_BEGIN( "mat44_div divides corresponding elements of two matrices" )
        mat44_t a = mat44(
            vec4(10, 0,0,0 ),
            vec4(18, 0,0,0 ),
            vec4(12, 0,0,0 ),
            vec4( 9, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4( 2, 0,0,0 ),
            vec4( 3, 0,0,0 ),
            vec4( 4, 0,0,0 ),
            vec4( 3, 0,0,0 )
        );
        mat44_t r = mat44_div( a, b );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 6.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat44_addf
    TESTFW_TEST_BEGIN( "mat44_addf adds scalar to all elements of matrix" )
        mat44_t m = mat44(
            vec4( 2.0f, 0,0,0 ),
            vec4( 5.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ),
            vec4(-1.0f, 0,0,0 )
        );
        mat44_t r = mat44_addf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 5.0f );
        TESTFW_EXPECTED( r.y.x == 8.0f );
        TESTFW_EXPECTED( r.z.x == 11.0f );
        TESTFW_EXPECTED( r.w.x == 2.0f );
    TESTFW_TEST_END();

    // mat44_subf
    TESTFW_TEST_BEGIN( "mat44_subf subtracts scalar from all elements of matrix" )
        mat44_t m = mat44(
            vec4(10.0f, 0,0,0 ),
            vec4( 6.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ),
            vec4( 4.0f, 0,0,0 )
        );
        mat44_t r = mat44_subf( m, 4.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == -4.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat44_mulf
    TESTFW_TEST_BEGIN( "mat44_mulf multiplies all elements by scalar" )
        mat44_t m = mat44(
            vec4( 2.0f, 0,0,0 ),
            vec4(-1.0f, 0,0,0 ),
            vec4( 3.0f, 0,0,0 ),
            vec4(-2.0f, 0,0,0 )
        );
        mat44_t r = mat44_mulf( m, 3.0f );
        TESTFW_EXPECTED( r.x.x == 6.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 9.0f );
        TESTFW_EXPECTED( r.w.x == -6.0f );
    TESTFW_TEST_END();

    // mat44_divf
    TESTFW_TEST_BEGIN( "mat44_divf divides all elements by scalar" )
        mat44_t m = mat44(
            vec4( 4.0f, 0,0,0 ),
            vec4(-4.0f, 0,0,0 ),
            vec4( 6.0f, 0,0,0 ),
            vec4(-6.0f, 0,0,0 )
        );
        mat44_t r = mat44_divf( m, 2.0f );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == -3.0f );
    TESTFW_TEST_END();

    // mat44_abs
    TESTFW_TEST_BEGIN( "mat44_abs applies absolute value to each element of the matrix" )
        mat44_t m = mat44(
            vec4( -1.0f, 0.0f, 0.0f, 0.0f ),
            vec4( 0.0f, -2.0f, 0.0f, 0.0f ),
            vec4( 0.0f, 0.0f, -3.5f, 0.0f ),
            vec4( 0.0f, 0.0f, 0.0f, -4.25f )
        );
        mat44_t r = mat44_abs( m );
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.y == 2.0f );
        TESTFW_EXPECTED( r.z.z == 3.5f );
        TESTFW_EXPECTED( r.w.w == 4.25f );
    TESTFW_TEST_END();

    // mat44_acos
    TESTFW_TEST_BEGIN( "mat44_acos applies acos to each element" )
        mat44_t m = mat44(
            vec4( 0.5f, 0, 0, 0 ),
            vec4( -1.0f, 0, 0, 0 ),
            vec4( 1.0f, 0, 0, 0 ),
            vec4( 0.0f, 0, 0, 0 )
        );
        mat44_t r = mat44_acos( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 1.04719758f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, 3.14159265f ));
        TESTFW_EXPECTED( test_cmp(r.z.x, 0.00000000f ));
        TESTFW_EXPECTED( test_cmp(r.w.x, 1.57079633f ));
    TESTFW_TEST_END();

    // mat44_all
    TESTFW_TEST_BEGIN( "mat44_all returns nonzero only if all sixteen elements are nonzero" )
        TESTFW_EXPECTED( mat44_all( mat44(
            vec4(1,1,1,1), vec4(1,1,1,1),
            vec4(1,1,1,1), vec4(1,1,1,1)
        ) ) != 0 );

        TESTFW_EXPECTED( mat44_all( mat44(
            vec4(0,1,1,1), vec4(1,1,1,1),
            vec4(1,1,1,1), vec4(1,1,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat44_all( mat44(
            vec4(1,1,1,1), vec4(1,0,1,1),
            vec4(1,1,1,1), vec4(1,1,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat44_all( mat44(
            vec4(1,1,1,1), vec4(1,1,1,1),
            vec4(1,1,0,1), vec4(1,1,1,1)
        ) ) == 0 );

        TESTFW_EXPECTED( mat44_all( mat44(
            vec4(1,1,1,1), vec4(1,1,1,1),
            vec4(1,1,1,1), vec4(1,1,1,0)
        ) ) == 0 );

        TESTFW_EXPECTED( mat44_all( mat44f( 1.0f ) ) != 0 );
    TESTFW_TEST_END();

    // mat44_any
    TESTFW_TEST_BEGIN( "mat44_any returns nonzero if any element is nonzero" )
        TESTFW_EXPECTED( mat44_any( mat44(
            vec4(0,1,0,0), vec4(0,0,0,0),
            vec4(0,0,0,0), vec4(0,0,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat44_any( mat44(
            vec4(0,0,0,0), vec4(0,0,1,0),
            vec4(0,0,0,0), vec4(0,0,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat44_any( mat44(
            vec4(0,0,0,0), vec4(0,0,0,0),
            vec4(0,0,0,1), vec4(0,0,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat44_any( mat44(
            vec4(0,0,0,0), vec4(0,0,0,0),
            vec4(0,0,0,0), vec4(1,0,0,0)
        ) ) != 0 );

        TESTFW_EXPECTED( mat44_any( mat44f( 0.0f ) ) == 0 );
    TESTFW_TEST_END();

    // mat44_asin
    TESTFW_TEST_BEGIN( "mat44_asin applies asin to each element" )
        mat44_t m = mat44(
            vec4( 0.5f, 0, 0, 0 ),
            vec4( -1.0f, 0, 0, 0 ),
            vec4( 1.0f, 0, 0, 0 ),
            vec4( 0.0f, 0, 0, 0 )
        );
        mat44_t r = mat44_asin( m );
        TESTFW_EXPECTED( test_cmp(r.x.x, 0.52359878f ));
        TESTFW_EXPECTED( test_cmp(r.y.x, -1.57079633f ));
        TESTFW_EXPECTED( test_cmp(r.z.x, 1.57079633f ));
        TESTFW_EXPECTED( test_cmp(r.w.x, 0.00000000f ));
    TESTFW_TEST_END();

    // mat44_atan
    TESTFW_TEST_BEGIN( "mat44_atan applies atan to each element" )
        mat44_t m = mat44(
            vec4( 0.5f, 0,0,0 ),
            vec4( -2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ),
            vec4( -1.0f, 0,0,0 )
        );
        mat44_t r = mat44_atan( m );
        TESTFW_EXPECTED( r.x.x == 0.46364761f );
        TESTFW_EXPECTED( r.y.x == -1.10714872f );
        TESTFW_EXPECTED( r.z.x == 0.78539816f );
        TESTFW_EXPECTED( r.w.x == -0.78539816f );
    TESTFW_TEST_END();

    // mat44_atan2
    TESTFW_TEST_BEGIN( "mat44_atan2 applies atan2 to each element" )
        mat44_t y = mat44(
            vec4( 2.0f, 0,0,0 ),
            vec4( -3.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ),
            vec4( 3.0f, 0,0,0 )
        );
        mat44_t x = mat44(
            vec4( 1.0f, 0,0,0 ),
            vec4( -4.0f, 0,0,0 ),
            vec4( -1.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 )
        );
        mat44_t r = mat44_atan2( y, x );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.10714872f ));
        TESTFW_EXPECTED( test_cmp( r.y.x, -2.49809154f ));
        TESTFW_EXPECTED( test_cmp( r.z.x, 2.35619449f ));
        TESTFW_EXPECTED( test_cmp( r.w.x, 1.24904577f ));
    TESTFW_TEST_END();

    // mat44_ceil
    TESTFW_TEST_BEGIN( "mat44_ceil applies ceil to each element" )
        mat44_t m = mat44(
            vec4( 1.2f, 0,0,0 ),
            vec4( -3.7f, 0,0,0 ),
            vec4( -0.1f, 0,0,0 ),
            vec4( 2.9f, 0,0,0 )
        );
        mat44_t r = mat44_ceil( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat44_clamp
    TESTFW_TEST_BEGIN( "mat44_clamp clamps each element using corresponding min and max matrices" )
        mat44_t v = mat44(
            vec4( 5.0f, 0,0,0 ),
            vec4(-10.0f, 0,0,0 ),
            vec4( 0.5f, 0,0,0 ),
            vec4( 3.0f, 0,0,0 )
        );
        mat44_t mn = mat44(
            vec4( 0.0f, 0,0,0 ),
            vec4( -8.0f, 0,0,0 ),
            vec4( -1.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 )
        );
        mat44_t mx = mat44(
            vec4( 4.0f, 0,0,0 ),
            vec4( -7.0f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 )
        );
        mat44_t r = mat44_clamp( v, mn, mx );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -8.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat44_cos
    TESTFW_TEST_BEGIN( "mat44_cos applies cos to each element" )
        mat44_t m = mat44(
            vec4( 0.5f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ),
            vec4( 3.14159265f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 )
        );
        mat44_t r = mat44_cos( m );
        TESTFW_EXPECTED( r.x.x == 0.87758256f );
        TESTFW_EXPECTED( r.y.x == -0.41614684f );
        TESTFW_EXPECTED( r.z.x == -1.00000000f );
        TESTFW_EXPECTED( r.w.x == 1.00000000f );
    TESTFW_TEST_END();

    // mat44_cosh
    TESTFW_TEST_BEGIN( "mat44_cosh applies cosh to each element" )
        mat44_t m = mat44(
            vec4( 0.5f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 )
        );
        mat44_t r = mat44_cosh( m );
        TESTFW_EXPECTED( test_cmp( r.x.x, 1.12762597f ) );
        TESTFW_EXPECTED( test_cmp( r.y.x, 3.76219569f ) );
        TESTFW_EXPECTED( test_cmp( r.z.x, 1.54308063f ) );
        TESTFW_EXPECTED( test_cmp( r.w.x, 1.00000000f ) );
    TESTFW_TEST_END();

    // mat44_degrees
    TESTFW_TEST_BEGIN( "mat44_degrees converts radians to degrees element-wise" )
        mat44_t m = mat44(
            vec4( 0.5f, 0,0,0 ),
            vec4( -1.0f, 0,0,0 ),
            vec4( 3.14159265f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 )
        );
        mat44_t r = mat44_degrees( m );
        TESTFW_EXPECTED( r.x.x == 28.6478898f );
        TESTFW_EXPECTED( r.y.x == -57.2957795f );
        TESTFW_EXPECTED( r.z.x == 180.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat44_exp
    TESTFW_TEST_BEGIN( "mat44_exp applies exp to each element" )
        mat44_t m = mat44(
            vec4( 0.5f, 0,0,0 ),
            vec4( -2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 )
        );
        mat44_t r = mat44_exp( m );
        TESTFW_EXPECTED( r.x.x == 1.64872127f );
        TESTFW_EXPECTED( r.y.x == 0.13533528f );
        TESTFW_EXPECTED( r.z.x == 2.71828183f );
        TESTFW_EXPECTED( r.w.x == 1.00000000f );
    TESTFW_TEST_END();

    // mat44_exp2
    TESTFW_TEST_BEGIN( "mat44_exp2 applies exp2 to each element" )
        mat44_t m = mat44(
            vec4( 3.0f, 0,0,0 ),
            vec4( -2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 )
        );
        mat44_t r = mat44_exp2( m );
        TESTFW_EXPECTED( r.x.x == 8.0f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat44_floor
    TESTFW_TEST_BEGIN( "mat44_floor applies floor to each element" )
        mat44_t m = mat44(
            vec4( 2.7f, 0,0,0 ),
            vec4( -3.2f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ),
            vec4( -1.5f, 0,0,0 )
        );
        mat44_t r = mat44_floor( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == -2.0f );
    TESTFW_TEST_END();

    // mat44_fmod
    TESTFW_TEST_BEGIN( "mat44_fmod applies fmod to each element" )
        mat44_t a = mat44(
            vec4( 6.5f, 0,0,0 ),
            vec4(-5.0f, 0,0,0 ),
            vec4( 7.75f, 0,0,0 ),
            vec4( 5.5f, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4( 2.0f, 0,0,0 ),
            vec4( 3.0f, 0,0,0 ),
            vec4( 2.5f, 0,0,0 ),
            vec4( 4.0f, 0,0,0 )
        );
        mat44_t r = mat44_fmod( a, b );
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
        TESTFW_EXPECTED( r.w.x == 1.5f );
    TESTFW_TEST_END();

    // mat44_frac
    TESTFW_TEST_BEGIN( "mat44_frac returns fractional part of each element" )
        mat44_t m = mat44(
            vec4( 3.75f, 0,0,0 ),
            vec4( -2.25f, 0,0,0 ),
            vec4( 1.5f, 0,0,0 ),
            vec4( -3.125f,0,0,0 )
        );
        mat44_t r = mat44_frac( m );
        TESTFW_EXPECTED( r.x.x == 0.75f );
        TESTFW_EXPECTED( r.y.x == 0.25f );
        TESTFW_EXPECTED( r.z.x == 0.50f );
        TESTFW_EXPECTED( r.w.x == 0.125f );
    TESTFW_TEST_END();

    // mat44_lerp
    TESTFW_TEST_BEGIN( "mat44_lerp linearly interpolates between matrices element-wise" )
        mat44_t a = mat44(
            vec4( 2.0f, 0,0,0 ),
            vec4(-4.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4( 6.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ),
            vec4( 4.0f, 0,0,0 ),
            vec4(12.0f, 0,0,0 )
        );
        mat44_t r = mat44_lerp( a, b, 0.25f );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat44_log
    TESTFW_TEST_BEGIN( "mat44_log applies natural log to each element" )
        mat44_t m = mat44(
            vec4( 1.0f, 0,0,0 ),
            vec4( 2.718282f, 0,0,0 ),
            vec4( 7.3890561f,0,0,0 ),
            vec4( 20.085537f,0,0,0 )
        );
        mat44_t r = mat44_log( m );
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 2.0f );
        TESTFW_EXPECTED( r.w.x == 3.0f );
    TESTFW_TEST_END();

    // mat44_log2
    TESTFW_TEST_BEGIN( "mat44_log2 applies base-2 logarithm to each element" )
        mat44_t m = mat44(
            vec4( 16.0f, 0,0,0 ),
            vec4( 0.25f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 )
        );
        mat44_t r = mat44_log2( m );
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat44_log10
    TESTFW_TEST_BEGIN( "mat44_log10 applies base-10 logarithm to each element" )
        mat44_t m = mat44(
            vec4( 100.0f, 0,0,0 ),
            vec4( 0.001f,0,0,0 ),
            vec4( 10.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 )
        );
        mat44_t r = mat44_log10( m );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat44_max
    TESTFW_TEST_BEGIN( "mat44_max returns element-wise maximum of two matrices" )
        mat44_t a = mat44(
            vec4( 3.0f, 0,0,0 ),
            vec4( -5.0f, 0,0,0 ),
            vec4( 7.0f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4( 2.0f, 0,0,0 ),
            vec4( -4.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 )
        );
        mat44_t r = mat44_max( a, b );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -4.0f );
        TESTFW_EXPECTED( r.z.x == 8.0f );
        TESTFW_EXPECTED( r.w.x == 2.0f );
    TESTFW_TEST_END();

    // mat44_min
    TESTFW_TEST_BEGIN( "mat44_min returns element-wise minimum of two matrices" )
        mat44_t a = mat44(
            vec4( 3.0f, 0,0,0 ),
            vec4( -5.0f, 0,0,0 ),
            vec4( 7.0f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4( 2.0f, 0,0,0 ),
            vec4( -4.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 )
        );
        mat44_t r = mat44_min( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == -5.0f );
        TESTFW_EXPECTED( r.z.x == 7.0f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat44_pow
    TESTFW_TEST_BEGIN( "mat44_pow applies pow to each element" )
        mat44_t a = mat44(
            vec4( 4.0f, 0,0,0 ),
            vec4( 9.0f, 0,0,0 ),
            vec4( 16.0f, 0,0,0 ),
            vec4( 25.0f, 0,0,0 )
        );
        mat44_t b = mat44f( 0.5f );
        mat44_t r = mat44_pow( a, b );
        TESTFW_EXPECTED( r.x.x == 2.0f );
        TESTFW_EXPECTED( r.y.x == 3.0f );
        TESTFW_EXPECTED( r.z.x == 4.0f );
        TESTFW_EXPECTED( r.w.x == 5.0f );
    TESTFW_TEST_END();

    // mat44_radians
    TESTFW_TEST_BEGIN( "mat44_radians converts degrees to radians element-wise" )
        mat44_t m = mat44(
            vec4( 90.0f, 0,0,0 ),
            vec4( -45.0f, 0,0,0 ),
            vec4( 180.0f, 0,0,0 ),
            vec4( 360.0f, 0,0,0 )
        );
        mat44_t r = mat44_radians( m );
        TESTFW_EXPECTED( r.x.x == 1.57079633f );
        TESTFW_EXPECTED( r.y.x == -0.78539816f );
        TESTFW_EXPECTED( r.z.x == 3.14159265f );
        TESTFW_EXPECTED( r.w.x == 6.28318531f );
    TESTFW_TEST_END();

    // mat44_rcp
    TESTFW_TEST_BEGIN( "mat44_rcp returns element-wise reciprocal" )
        mat44_t m = mat44(
            vec4( 4.0f, 0,0,0 ),
            vec4( -0.5f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 )
        );
        mat44_t r = mat44_rcp( m );
        TESTFW_EXPECTED( r.x.x == 0.25f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat44_round
    TESTFW_TEST_BEGIN( "mat44_round rounds each element to nearest integer" )
        mat44_t m = mat44(
            vec4( 2.6f, 0,0,0 ),
            vec4( -3.4f, 0,0,0 ),
            vec4( -1.7f, 0,0,0 ),
            vec4( 4.3f, 0,0,0 )
        );
        mat44_t r = mat44_round( m );
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -3.0f );
        TESTFW_EXPECTED( r.z.x == -2.0f );
        TESTFW_EXPECTED( r.w.x == 4.0f );
    TESTFW_TEST_END();

    // mat44_rsqrt
    TESTFW_TEST_BEGIN( "mat44_rsqrt returns reciprocal square root of each element" )
        mat44_t m = mat44(
            vec4( 4.0f, 0,0,0 ),
            vec4( 0.25f, 0,0,0 ),
            vec4( 16.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 )
        );
        mat44_t r = mat44_rsqrt(m);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 2.0f );
        TESTFW_EXPECTED( r.z.x == 0.25f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat44_saturate
    TESTFW_TEST_BEGIN( "mat44_saturate clamps each element to the [0, 1] range" )
        mat44_t m = mat44(
            vec4(-2.0f, 0,0,0 ),
            vec4( 1.5f, 0,0,0 ),
            vec4( 0.5f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 )
        );
        mat44_t r = mat44_saturate(m);
        TESTFW_EXPECTED( r.x.x == 0.0f );
        TESTFW_EXPECTED( r.y.x == 1.0f );
        TESTFW_EXPECTED( r.z.x == 0.5f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat44_sign
    TESTFW_TEST_BEGIN( "mat44_sign returns sign of each element" )
        mat44_t m = mat44(
            vec4( 3.5f, 0,0,0 ),
            vec4(-2.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ),
            vec4(-4.7f, 0,0,0 )
        );
        mat44_t r = mat44_sign(m);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == -1.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == -1.0f );
    TESTFW_TEST_END();

    // mat44_sin
    TESTFW_TEST_BEGIN( "mat44_sin applies sin to each element" )
        mat44_t m = mat44(
            vec4( 0.5f, 0,0,0 ),
            vec4(-2.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ),
            vec4(-1.0f, 0,0,0 )
        );
        mat44_t r = mat44_sin(m);
        TESTFW_EXPECTED( r.x.x == 0.47942554f );
        TESTFW_EXPECTED( r.y.x == -0.90929743f );
        TESTFW_EXPECTED( r.z.x == 0.84147098f );
        TESTFW_EXPECTED( r.w.x == -0.84147098f );
    TESTFW_TEST_END();

    // mat44_sinh
    TESTFW_TEST_BEGIN( "mat44_sinh applies sinh to each element" )
        mat44_t m = mat44(
            vec4(-1.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ),
            vec4( 0.5f, 0,0,0 )
        );
        mat44_t r = mat44_sinh(m);
        TESTFW_EXPECTED( r.x.x == -1.17520119f );
        TESTFW_EXPECTED( r.y.x == 0.00000000f );
        TESTFW_EXPECTED( r.z.x == 1.17520119f );
        TESTFW_EXPECTED( r.w.x == 0.521095276f );
    TESTFW_TEST_END();

    // mat44_smoothstep
    TESTFW_TEST_BEGIN( "mat44_smoothstep performs Hermite interpolation element-wise" )
        mat44_t a = mat44(
            vec4( 2.0f, 0,0,0 ),
            vec4(10.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ),
            vec4( 5.0f, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4( 6.0f, 0,0,0 ),
            vec4(14.0f, 0,0,0 ),
            vec4( 4.0f, 0,0,0 ),
            vec4(15.0f, 0,0,0 )
        );
        mat44_t t = mat44(
            vec4( 3.0f, 0,0,0 ),
            vec4(12.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ),
            vec4(10.0f, 0,0,0 )
        );
        mat44_t r = mat44_smoothstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.15625f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 0.15625f );
        TESTFW_EXPECTED( r.w.x == 0.5f );
    TESTFW_TEST_END();

    // mat44_smootherstep
    TESTFW_TEST_BEGIN( "mat44_smootherstep performs quintic Hermite interpolation element-wise" )
        mat44_t a = mat44(
            vec4( 0.0f, 0,0,0 ),
            vec4( 4.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4( 8.0f, 0,0,0 ),
            vec4(12.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 ),
            vec4( 8.0f, 0,0,0 )
        );
        mat44_t t = mat44(
            vec4( 4.0f, 0,0,0 ),
            vec4(10.0f, 0,0,0 ),
            vec4( 2.0f, 0,0,0 ),
            vec4( 4.0f, 0,0,0 )
        );
        mat44_t r = mat44_smootherstep(a, b, t);
        TESTFW_EXPECTED( r.x.x == 0.5f );
        TESTFW_EXPECTED( r.y.x == 0.89648438f );
        TESTFW_EXPECTED( r.z.x == 0.103515625f );
        TESTFW_EXPECTED( r.w.x == 0.5f );
    TESTFW_TEST_END();

    // mat44_sqrt
    TESTFW_TEST_BEGIN( "mat44_sqrt returns square root of each element" )
        mat44_t m = mat44(
            vec4(16.0f, 0,0,0 ),
            vec4( 0.25f,0,0,0 ),
            vec4( 9.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 )
        );
        mat44_t r = mat44_sqrt(m);
        TESTFW_EXPECTED( r.x.x == 4.0f );
        TESTFW_EXPECTED( r.y.x == 0.5f );
        TESTFW_EXPECTED( r.z.x == 3.0f );
        TESTFW_EXPECTED( r.w.x == 1.0f );
    TESTFW_TEST_END();

    // mat44_step
    TESTFW_TEST_BEGIN( "mat44_step returns 0.0 or 1.0 per element based on threshold" )
        mat44_t a = mat44(
            vec4(2.5f, 0,0,0 ),
            vec4(6.0f, 0,0,0 ),
            vec4(4.0f, 0,0,0 ),
            vec4(1.0f, 0,0,0 )
        );
        mat44_t b = mat44(
            vec4(3.0f, 0,0,0 ),
            vec4(5.0f, 0,0,0 ),
            vec4(4.0f, 0,0,0 ),
            vec4(0.5f, 0,0,0 )
        );
        mat44_t r = mat44_step(a, b);
        TESTFW_EXPECTED( r.x.x == 1.0f );
        TESTFW_EXPECTED( r.y.x == 0.0f );
        TESTFW_EXPECTED( r.z.x == 1.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();

    // mat44_tan
    TESTFW_TEST_BEGIN( "mat44_tan applies tan to each element" )
        mat44_t m = mat44(
            vec4( 0.5f, 0,0,0 ),
            vec4(-1.0f, 0,0,0 ),
            vec4( 1.0f, 0,0,0 ),
            vec4(-0.5f, 0,0,0 )
        );
        mat44_t r = mat44_tan(m);
        TESTFW_EXPECTED( r.x.x == 0.54630249f );
        TESTFW_EXPECTED( r.y.x == -1.55740772f );
        TESTFW_EXPECTED( r.z.x == 1.55740772f );
        TESTFW_EXPECTED( r.w.x == -0.54630249f );
    TESTFW_TEST_END();

    // mat44_tanh
    TESTFW_TEST_BEGIN( "mat44_tanh applies tanh to each element" )
        mat44_t m = mat44(
            vec4( 1.0f, 0,0,0 ),
            vec4(-2.0f, 0,0,0 ),
            vec4( 0.0f, 0,0,0 ),
            vec4( 0.5f, 0,0,0 )
        );
        mat44_t r = mat44_tanh(m);
        TESTFW_EXPECTED( r.x.x == 0.76159416f );
        TESTFW_EXPECTED( r.y.x == -0.96402758f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == 0.46211716f );
    TESTFW_TEST_END();

    // mat44_trunc
    TESTFW_TEST_BEGIN( "mat44_trunc removes fractional part of each element" )
        mat44_t m = mat44(
            vec4( 3.7f, 0,0,0 ),
            vec4(-2.9f, 0,0,0 ),
            vec4( 0.5f, 0,0,0 ),
            vec4(-0.5f, 0,0,0 )
        );
        mat44_t r = mat44_trunc(m);
        TESTFW_EXPECTED( r.x.x == 3.0f );
        TESTFW_EXPECTED( r.y.x == -2.0f );
        TESTFW_EXPECTED( r.z.x == 0.0f );
        TESTFW_EXPECTED( r.w.x == 0.0f );
    TESTFW_TEST_END();
}


void test_matrix_math( void ) {
    // mat22_transpose
    TESTFW_TEST_BEGIN("mat22_transpose swaps rows and columns")
        mat22_t a = mat22(
            vec2(1, 2), 
            vec2(3, 4)
        );
        mat22_t r = mat22_transpose(a);
        TESTFW_EXPECTED(r.x.x == 1.0f);
        TESTFW_EXPECTED(r.x.y == 3.0f);
        TESTFW_EXPECTED(r.y.x == 2.0f);
        TESTFW_EXPECTED(r.y.y == 4.0f);
    TESTFW_TEST_END();

    // mat23_transpose
    TESTFW_TEST_BEGIN("mat23_transpose swaps rows and columns")
        mat23_t a = mat23(
            vec3(1, 2, 3), 
            vec3(4, 5, 6)
        );
        mat32_t r = mat23_transpose(a);
        TESTFW_EXPECTED(r.x.x == 1.0f);
        TESTFW_EXPECTED(r.x.y == 4.0f);
        TESTFW_EXPECTED(r.y.x == 2.0f);
        TESTFW_EXPECTED(r.y.y == 5.0f);
        TESTFW_EXPECTED(r.z.x == 3.0f);
        TESTFW_EXPECTED(r.z.y == 6.0f);
    TESTFW_TEST_END();

    // mat32_transpose
    TESTFW_TEST_BEGIN("mat32_transpose swaps rows and columns")
        mat32_t a = mat32(
            vec2(1, 2), 
            vec2(3, 4), 
            vec2(5, 6)
        );
        mat23_t r = mat32_transpose(a);
        TESTFW_EXPECTED(r.x.x == 1.0f);
        TESTFW_EXPECTED(r.x.y == 3.0f);
        TESTFW_EXPECTED(r.x.z == 5.0f);
        TESTFW_EXPECTED(r.y.x == 2.0f);
        TESTFW_EXPECTED(r.y.y == 4.0f);
        TESTFW_EXPECTED(r.y.z == 6.0f);
    TESTFW_TEST_END();

    // mat33_transpose
    TESTFW_TEST_BEGIN("mat33_transpose swaps rows and columns")
        mat33_t a = mat33(
            vec3(1, 2, 3), 
            vec3(4, 5, 6), 
            vec3(7, 8, 9)
        );
        mat33_t r = mat33_transpose(a);
        TESTFW_EXPECTED(r.x.x == 1.0f);
        TESTFW_EXPECTED(r.x.y == 4.0f);
        TESTFW_EXPECTED(r.x.z == 7.0f);
        TESTFW_EXPECTED(r.y.x == 2.0f);
        TESTFW_EXPECTED(r.y.y == 5.0f);
        TESTFW_EXPECTED(r.y.z == 8.0f);
        TESTFW_EXPECTED(r.z.x == 3.0f);
        TESTFW_EXPECTED(r.z.y == 6.0f);
        TESTFW_EXPECTED(r.z.z == 9.0f);
    TESTFW_TEST_END();

    // mat24_transpose
    TESTFW_TEST_BEGIN("mat24_transpose swaps rows and columns")
        mat24_t a = mat24(
            vec4(1, 2, 3, 4),
            vec4(5, 6, 7, 8)
        );
        mat42_t r = mat24_transpose(a);
        TESTFW_EXPECTED(r.x.x == 1.0f);
        TESTFW_EXPECTED(r.x.y == 5.0f);
        TESTFW_EXPECTED(r.y.x == 2.0f);
        TESTFW_EXPECTED(r.y.y == 6.0f);
        TESTFW_EXPECTED(r.z.x == 3.0f);
        TESTFW_EXPECTED(r.z.y == 7.0f);
        TESTFW_EXPECTED(r.w.x == 4.0f);
        TESTFW_EXPECTED(r.w.y == 8.0f);
    TESTFW_TEST_END();

    // mat34_transpose
    TESTFW_TEST_BEGIN("mat34_transpose swaps rows and columns")
        mat34_t a = mat34(
            vec4(1, 2, 3, 4),
            vec4(5, 6, 7, 8),
            vec4(9, 10, 11, 12)
        );
        mat43_t r = mat34_transpose(a);
        TESTFW_EXPECTED(r.x.x == 1.0f);
        TESTFW_EXPECTED(r.x.y == 5.0f);
        TESTFW_EXPECTED(r.x.z == 9.0f);
        TESTFW_EXPECTED(r.y.x == 2.0f);
        TESTFW_EXPECTED(r.y.y == 6.0f);
        TESTFW_EXPECTED(r.y.z == 10.0f);
        TESTFW_EXPECTED(r.z.x == 3.0f);
        TESTFW_EXPECTED(r.z.y == 7.0f);
        TESTFW_EXPECTED(r.z.z == 11.0f);
        TESTFW_EXPECTED(r.w.x == 4.0f);
        TESTFW_EXPECTED(r.w.y == 8.0f);
        TESTFW_EXPECTED(r.w.z == 12.0f);
    TESTFW_TEST_END();

    // mat42_transpose
    TESTFW_TEST_BEGIN("mat42_transpose swaps rows and columns")
        mat42_t a = mat42(
            vec2(1, 2),
            vec2(3, 4),
            vec2(5, 6),
            vec2(7, 8)
        );
        mat24_t r = mat42_transpose(a);
        TESTFW_EXPECTED(r.x.x == 1.0f);
        TESTFW_EXPECTED(r.x.y == 3.0f);
        TESTFW_EXPECTED(r.x.z == 5.0f);
        TESTFW_EXPECTED(r.x.w == 7.0f);
        TESTFW_EXPECTED(r.y.x == 2.0f);
        TESTFW_EXPECTED(r.y.y == 4.0f);
        TESTFW_EXPECTED(r.y.z == 6.0f);
        TESTFW_EXPECTED(r.y.w == 8.0f);
    TESTFW_TEST_END();

    // mat43_transpose
    TESTFW_TEST_BEGIN("mat43_transpose swaps rows and columns")
        mat43_t a = mat43(
            vec3(1, 2, 3),
            vec3(4, 5, 6),
            vec3(7, 8, 9),
            vec3(10, 11, 12)
        );
        mat34_t r = mat43_transpose(a);
        TESTFW_EXPECTED(r.x.x == 1.0f);
        TESTFW_EXPECTED(r.x.y == 4.0f);
        TESTFW_EXPECTED(r.x.z == 7.0f);
        TESTFW_EXPECTED(r.x.w == 10.0f);
        TESTFW_EXPECTED(r.y.x == 2.0f);
        TESTFW_EXPECTED(r.y.y == 5.0f);
        TESTFW_EXPECTED(r.y.z == 8.0f);
        TESTFW_EXPECTED(r.y.w == 11.0f);
        TESTFW_EXPECTED(r.z.x == 3.0f);
        TESTFW_EXPECTED(r.z.y == 6.0f);
        TESTFW_EXPECTED(r.z.z == 9.0f);
        TESTFW_EXPECTED(r.z.w == 12.0f);
    TESTFW_TEST_END();

    // mat44_transpose
    TESTFW_TEST_BEGIN("mat44_transpose swaps rows and columns")
        mat44_t a = mat44(
            vec4(1, 2, 3, 4),
            vec4(5, 6, 7, 8),
            vec4(9, 10, 11, 12),
            vec4(13, 14, 15, 16)
        );
        mat44_t r = mat44_transpose(a);
        TESTFW_EXPECTED(r.x.x == 1.0f);
        TESTFW_EXPECTED(r.x.y == 5.0f);
        TESTFW_EXPECTED(r.x.z == 9.0f);
        TESTFW_EXPECTED(r.x.w == 13.0f);
        TESTFW_EXPECTED(r.y.x == 2.0f);
        TESTFW_EXPECTED(r.y.y == 6.0f);
        TESTFW_EXPECTED(r.y.z == 10.0f);
        TESTFW_EXPECTED(r.y.w == 14.0f);
        TESTFW_EXPECTED(r.z.x == 3.0f);
        TESTFW_EXPECTED(r.z.y == 7.0f);
        TESTFW_EXPECTED(r.z.z == 11.0f);
        TESTFW_EXPECTED(r.z.w == 15.0f);
        TESTFW_EXPECTED(r.w.x == 4.0f);
        TESTFW_EXPECTED(r.w.y == 8.0f);
        TESTFW_EXPECTED(r.w.z == 12.0f);
        TESTFW_EXPECTED(r.w.w == 16.0f);
    TESTFW_TEST_END();

    // mat22_determinant
    TESTFW_TEST_BEGIN("mat22_determinant returns 1 for identity matrix")
        mat22_t m = mat22(
            vec2(1, 0),
            vec2(0, 1)
        );
        float r = mat22_determinant(m);
        TESTFW_EXPECTED(r == 1.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat22_determinant returns 0 for singular matrix")
        mat22_t m = mat22(
            vec2(1, 2),
            vec2(2, 4)
        );
        float r = mat22_determinant(m);
        TESTFW_EXPECTED(r == 0.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat22_determinant computes correct value for non-singular matrix")
        mat22_t m = mat22(
            vec2(5, 2),
            vec2(3, 7)
        );
        float r = mat22_determinant(m);
        TESTFW_EXPECTED(r == 29.0f);
    TESTFW_TEST_END();

    // mat33_determinant
    TESTFW_TEST_BEGIN("mat33_determinant returns 1 for identity matrix")
        mat33_t m = mat33(
            vec3(1, 0, 0),
            vec3(0, 1, 0),
            vec3(0, 0, 1)
        );
        float r = mat33_determinant(m);
        TESTFW_EXPECTED(r == 1.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat33_determinant returns 0 for singular matrix")
        mat33_t m = mat33(
            vec3(1, 2, 3),
            vec3(4, 5, 6),
            vec3(7, 8, 9)
        );
        float r = mat33_determinant(m);
        TESTFW_EXPECTED(r == 0.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat33_determinant computes correct value for non-singular matrix")
        mat33_t m = mat33(
            vec3( 3, 8, 1),
            vec3( 4, 6, 2),
            vec3( 7, 5, 9)
        );
        float r = mat33_determinant(m);
        TESTFW_EXPECTED(r == -66.0f);
    TESTFW_TEST_END();

    // mat44_determinant
    TESTFW_TEST_BEGIN("mat44_determinant returns 1 for identity matrix")
        mat44_t m = mat44(
            vec4(1, 0, 0, 0),
            vec4(0, 1, 0, 0),
            vec4(0, 0, 1, 0),
            vec4(0, 0, 0, 1)
        );
        float r = mat44_determinant(m);
        TESTFW_EXPECTED(r == 1.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_determinant returns 0 for singular matrix")
        mat44_t m = mat44(
            vec4( 1, 2, 3, 4),
            vec4( 5, 6, 7, 8),
            vec4( 9, 10, 11, 12),
            vec4(13, 14, 15, 16)
        );
        float r = mat44_determinant(m);
        TESTFW_EXPECTED(r == 0.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_determinant computes correct value for non-singular matrix")
        mat44_t m = mat44(
            vec4( 4, 7, 2, 13),
            vec4( 0, 5, 9, 1),
            vec4( 6, 3, 11, 10),
            vec4( 14, 12, 8, 15)
        );
        float r = mat44_determinant(m);
        TESTFW_EXPECTED(r == -8280.0f);
    TESTFW_TEST_END();

    // mat22_identity
    TESTFW_TEST_BEGIN("mat22_identity returns a matrix with 1s on diagonal and 0s elsewhere")
        mat22_t m = mat22_identity();
        TESTFW_EXPECTED(m.x.x == 1.0f);
        TESTFW_EXPECTED(m.x.y == 0.0f);
        TESTFW_EXPECTED(m.y.x == 0.0f);
        TESTFW_EXPECTED(m.y.y == 1.0f);
    TESTFW_TEST_END();

    // mat33_identity
    TESTFW_TEST_BEGIN("mat33_identity returns a matrix with 1s on diagonal and 0s elsewhere")
        mat33_t m = mat33_identity();
        TESTFW_EXPECTED(m.x.x == 1.0f);
        TESTFW_EXPECTED(m.x.y == 0.0f);
        TESTFW_EXPECTED(m.x.z == 0.0f);
        TESTFW_EXPECTED(m.y.x == 0.0f);
        TESTFW_EXPECTED(m.y.y == 1.0f);
        TESTFW_EXPECTED(m.y.z == 0.0f);
        TESTFW_EXPECTED(m.z.x == 0.0f);
        TESTFW_EXPECTED(m.z.y == 0.0f);
        TESTFW_EXPECTED(m.z.z == 1.0f);
    TESTFW_TEST_END();

    // mat44_identity
    TESTFW_TEST_BEGIN("mat44_identity returns a matrix with 1s on diagonal and 0s elsewhere")
        mat44_t m = mat44_identity();
        TESTFW_EXPECTED(m.x.x == 1.0f);
        TESTFW_EXPECTED(m.x.y == 0.0f);
        TESTFW_EXPECTED(m.x.z == 0.0f);
        TESTFW_EXPECTED(m.x.w == 0.0f);
        TESTFW_EXPECTED(m.y.x == 0.0f);
        TESTFW_EXPECTED(m.y.y == 1.0f);
        TESTFW_EXPECTED(m.y.z == 0.0f);
        TESTFW_EXPECTED(m.y.w == 0.0f);
        TESTFW_EXPECTED(m.z.x == 0.0f);
        TESTFW_EXPECTED(m.z.y == 0.0f);
        TESTFW_EXPECTED(m.z.z == 1.0f);
        TESTFW_EXPECTED(m.z.w == 0.0f);
        TESTFW_EXPECTED(m.w.x == 0.0f);
        TESTFW_EXPECTED(m.w.y == 0.0f);
        TESTFW_EXPECTED(m.w.z == 0.0f);
        TESTFW_EXPECTED(m.w.w == 1.0f);
    TESTFW_TEST_END();

    // mat22_is_identity
    TESTFW_TEST_BEGIN("mat22_is_identity returns nonzero for identity matrix")
        mat22_t m = mat22(
            vec2(1, 0),
            vec2(0, 1)
        );
        TESTFW_EXPECTED(mat22_is_identity(m) != 0);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat22_is_identity returns zero for non-identity matrix")
        mat22_t m = mat22(
            vec2(1, 0),
            vec2(0, 2)
        );
        TESTFW_EXPECTED(mat22_is_identity(m) == 0);
    TESTFW_TEST_END();

    // mat33_is_identity
    TESTFW_TEST_BEGIN("mat33_is_identity returns nonzero for identity matrix")
        mat33_t m = mat33(
            vec3(1, 0, 0),
            vec3(0, 1, 0),
            vec3(0, 0, 1)
        );
        TESTFW_EXPECTED(mat33_is_identity(m) != 0);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat33_is_identity returns zero for non-identity matrix")
        mat33_t m = mat33(
            vec3(1, 0, 0),
            vec3(0, 2, 0),
            vec3(0, 0, 1)
        );
        TESTFW_EXPECTED(mat33_is_identity(m) == 0);
    TESTFW_TEST_END();

    // mat44_is_identity
    TESTFW_TEST_BEGIN("mat44_is_identity returns nonzero for identity matrix")
        mat44_t m = mat44(
            vec4(1, 0, 0, 0),
            vec4(0, 1, 0, 0),
            vec4(0, 0, 1, 0),
            vec4(0, 0, 0, 1)
        );
        TESTFW_EXPECTED(mat44_is_identity(m) != 0);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_is_identity returns zero for non-identity matrix")
        mat44_t m = mat44(
            vec4(1, 0, 0, 0),
            vec4(0, 1, 0, 0),
            vec4(0, 0, 1, 0),
            vec4(0, 0, 0, 2)
        );
        TESTFW_EXPECTED(mat44_is_identity(m) == 0);
    TESTFW_TEST_END();

    // mat22_inverse
    TESTFW_TEST_BEGIN("mat22_inverse returns identity for identity matrix")
        mat22_t m = mat22_identity();
        mat22_t inv;
        float det;
        int ok = mat22_inverse(&inv, &det, m);
        TESTFW_EXPECTED(ok != 0);
        TESTFW_EXPECTED(det == 1.0f);
        TESTFW_EXPECTED(mat22_eq(inv, mat22_identity()));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat22_inverse returns 0 for singular matrix")
        mat22_t m = mat22(
            vec2(1, 2),
            vec2(2, 4)
        );
        mat22_t inv = mat22f(999);
        float det = 999.0f;
        int ok = mat22_inverse(&inv, &det, m);
        TESTFW_EXPECTED(ok == 0);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat22_inverse computes exact inverse that multiplies to identity")
        mat22_t m = mat22(
            vec2( 0.6f, -0.7f ),
            vec2( -0.2f, 0.4f )
        );
        mat22_t inv;
        float det;
        int ok = mat22_inverse(&inv, &det, m);
        TESTFW_EXPECTED(ok != 0);
        mat22_t prod = mat22_mul_mat22(m, inv);
        TESTFW_EXPECTED(test_identity_mat22(prod));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat22_inverse(inverse(m)) approximately returns original matrix")
        mat22_t m = mat22(
            vec2(2, 5),
            vec2(1, 3)
        );
        mat22_t inv1, inv2;
        float det1, det2;
        int ok1 = mat22_inverse(&inv1, &det1, m);
        int ok2 = mat22_inverse(&inv2, &det2, inv1);
        TESTFW_EXPECTED(ok1 != 0);
        TESTFW_EXPECTED(ok2 != 0);
        TESTFW_EXPECTED(test_cmp(inv2.x.x,m.x.x ));
        TESTFW_EXPECTED(test_cmp(inv2.x.y,m.x.y ));
        TESTFW_EXPECTED(test_cmp(inv2.y.x,m.y.x ));
        TESTFW_EXPECTED(test_cmp(inv2.y.y,m.y.y ));
    TESTFW_TEST_END();

    // mat33_inverse
    TESTFW_TEST_BEGIN("mat33_inverse returns identity for identity matrix")
        mat33_t m = mat33_identity();
        mat33_t inv;
        float det;
        int ok = mat33_inverse(&inv, &det, m);
        TESTFW_EXPECTED(ok != 0);
        TESTFW_EXPECTED(det == 1.0f);
        TESTFW_EXPECTED(mat33_eq(inv, mat33_identity()));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat33_inverse returns 0 for singular matrix")
        mat33_t m = mat33(
            vec3(1, 2, 3),
            vec3(4, 5, 6),
            vec3(7, 8, 9)
        );
        mat33_t inv = mat33f(999);
        float det = 999.0f;
        int ok = mat33_inverse(&inv, &det, m);
        TESTFW_EXPECTED(ok == 0);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat33_inverse computes exact inverse that multiplies to identity")
        mat33_t m = mat33(
            vec3(2, 5, 7),
            vec3(6, 3, 4),
            vec3(5, -2, -3)
        );
        mat33_t inv;
        float det;
        int ok = mat33_inverse(&inv, &det, m);
        TESTFW_EXPECTED(ok != 0);
        mat33_t prod = mat33_mul_mat33(m, inv);
        TESTFW_EXPECTED(test_identity_mat33(prod));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat33_inverse(inverse(m)) approximately returns original matrix")
        mat33_t m = mat33(
            vec3(3, 0, 2),
            vec3(2, 0, -2),
            vec3(0, 1, 1)
        );
        mat33_t inv1, inv2;
        float det1, det2;
        int ok1 = mat33_inverse(&inv1, &det1, m);
        int ok2 = mat33_inverse(&inv2, &det2, inv1);
        TESTFW_EXPECTED(ok1 != 0);
        TESTFW_EXPECTED(ok2 != 0);
        TESTFW_EXPECTED(test_cmp(inv2.x.x, m.x.x));
        TESTFW_EXPECTED(test_cmp(inv2.x.y, m.x.y));
        TESTFW_EXPECTED(test_cmp(inv2.x.z, m.x.z));
        TESTFW_EXPECTED(test_cmp(inv2.y.x, m.y.x));
        TESTFW_EXPECTED(test_cmp(inv2.y.y, m.y.y));
        TESTFW_EXPECTED(test_cmp(inv2.y.z, m.y.z));
        TESTFW_EXPECTED(test_cmp(inv2.z.x, m.z.x));
        TESTFW_EXPECTED(test_cmp(inv2.z.y, m.z.y));
        TESTFW_EXPECTED(test_cmp(inv2.z.z, m.z.z));
    TESTFW_TEST_END();

    // mat44_inverse
    TESTFW_TEST_BEGIN("mat44_inverse returns identity for identity matrix")
        mat44_t m = mat44_identity();
        mat44_t inv;
        float det;
        int ok = mat44_inverse(&inv, &det, m);
        TESTFW_EXPECTED(ok != 0);
        TESTFW_EXPECTED(det == 1.0f);
        TESTFW_EXPECTED(mat44_eq(inv, mat44_identity()));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_inverse returns 0 for singular matrix")
        mat44_t m = mat44(
            vec4(1, 2, 3, 4),
            vec4(2, 4, 6, 8),
            vec4(1, 0, 1, 0),
            vec4(0, 1, 0, 1)
        );
        mat44_t inv = mat44f(999);
        float det = 999.0f;
        int ok = mat44_inverse(&inv, &det, m);
        TESTFW_EXPECTED(ok == 0);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_inverse computes exact inverse that multiplies to identity")
        mat44_t m = mat44(
            vec4( 2, 3, 1, 5),
            vec4( 6, 13, 5, 19),
            vec4( 2, 19, 10, 23),
            vec4( 4, 10, 11, 31)
        );
        mat44_t inv;
        float det;
        int ok = mat44_inverse(&inv, &det, m);
        TESTFW_EXPECTED(ok != 0);
        mat44_t prod = mat44_mul_mat44(m, inv);
        TESTFW_EXPECTED(test_identity_mat44(prod));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_inverse(inverse(m)) approximately returns original matrix")
        mat44_t m = mat44(
            vec4( 3, 0, 2, -1),
            vec4( 1, 2, 0, -2),
            vec4( 4, 0, 6, -3),
            vec4( 5, 0, 2, 0)
        );
        mat44_t inv1, inv2;
        float det1, det2;
        int ok1 = mat44_inverse(&inv1, &det1, m);
        int ok2 = mat44_inverse(&inv2, &det2, inv1);
        TESTFW_EXPECTED(ok1 != 0);
        TESTFW_EXPECTED(ok2 != 0);
        TESTFW_EXPECTED(test_cmp(inv2.x.x, m.x.x));
        TESTFW_EXPECTED(test_cmp(inv2.x.y, m.x.y));
        TESTFW_EXPECTED(test_cmp(inv2.x.z, m.x.z));
        TESTFW_EXPECTED(test_cmp(inv2.x.w, m.x.w));
        TESTFW_EXPECTED(test_cmp(inv2.y.x, m.y.x));
        TESTFW_EXPECTED(test_cmp(inv2.y.y, m.y.y));
        TESTFW_EXPECTED(test_cmp(inv2.y.z, m.y.z));
        TESTFW_EXPECTED(test_cmp(inv2.y.w, m.y.w));
        TESTFW_EXPECTED(test_cmp(inv2.z.x, m.z.x));
        TESTFW_EXPECTED(test_cmp(inv2.z.y, m.z.y));
        TESTFW_EXPECTED(test_cmp(inv2.z.z, m.z.z));
        TESTFW_EXPECTED(test_cmp(inv2.z.w, m.z.w));
        TESTFW_EXPECTED(test_cmp(inv2.w.x, m.w.x));
        TESTFW_EXPECTED(test_cmp(inv2.w.y, m.w.y));
        TESTFW_EXPECTED(test_cmp(inv2.w.z, m.w.z));
        TESTFW_EXPECTED(test_cmp(inv2.w.w, m.w.w));
    TESTFW_TEST_END();
}


void test_matrix_multiplications( void ) {
    // vec2_mul_vec2
    TESTFW_TEST_BEGIN("vec2_mul_vec2 returns dot product of the two vectors")
        vec2_t a = vec2(2, 3);
        vec2_t b = vec2(4, 5);
        float r = vec2_mul_vec2(a, b);
        TESTFW_EXPECTED(r == 23.0f);
    TESTFW_TEST_END();

    // vec3_mul_vec3
    TESTFW_TEST_BEGIN("vec3_mul_vec3 returns dot product of the two vectors")
        vec3_t a = vec3(1, 2, 3);
        vec3_t b = vec3(4, 5, 6);
        float r = vec3_mul_vec3(a, b);
        TESTFW_EXPECTED(r == 32.0f);
    TESTFW_TEST_END();

    // vec4_mul_vec4
    TESTFW_TEST_BEGIN("vec4_mul_vec4 returns dot product of the two vectors")
        vec4_t a = vec4(1, 2, 3, 4);
        vec4_t b = vec4(5, 6, 7, 8);
        float r = vec4_mul_vec4(a, b);
        TESTFW_EXPECTED(r == 70.0f);
    TESTFW_TEST_END();


    // vec2_mul_mat22
    TESTFW_TEST_BEGIN("vec2_mul_mat22 performs correct vector-matrix multiplication")
        vec2_t v = vec2(1, 2);
        mat22_t m = mat22(
            vec2(101, 102),
            vec2(103, 104)
        );
        vec2_t r = vec2_mul_mat22(v, m);
        TESTFW_EXPECTED(r.x == 307.0f);
        TESTFW_EXPECTED(r.y == 310.0f);
    TESTFW_TEST_END();

    // vec2_mul_mat23
    TESTFW_TEST_BEGIN("vec2_mul_mat23 performs correct vector-matrix multiplication")
        vec2_t v = vec2(1, 2);
        mat23_t m = mat23(
            vec3(101, 102, 103),
            vec3(104, 105, 106)
        );
        vec3_t r = vec2_mul_mat23(v, m);
        TESTFW_EXPECTED(r.x == 309.0f);
        TESTFW_EXPECTED(r.y == 312.0f);
        TESTFW_EXPECTED(r.z == 315.0f);
    TESTFW_TEST_END();

    // vec2_mul_mat24
    TESTFW_TEST_BEGIN("vec2_mul_mat24 performs correct vector-matrix multiplication")
        vec2_t v = vec2(1, 2);
        mat24_t m = mat24(
            vec4(101, 102, 103, 104),
            vec4(105, 106, 107, 108)
        );
        vec4_t r = vec2_mul_mat24(v, m);
        TESTFW_EXPECTED(r.x == 311.0f);
        TESTFW_EXPECTED(r.y == 314.0f);
        TESTFW_EXPECTED(r.z == 317.0f);
        TESTFW_EXPECTED(r.w == 320.0f);
    TESTFW_TEST_END();

    // vec3_mul_mat32
    TESTFW_TEST_BEGIN("vec3_mul_mat32 performs correct vector-matrix multiplication")
        vec3_t v = vec3(1, 2, 3);
        mat32_t m = mat32(
            vec2(101, 102),
            vec2(103, 104),
            vec2(105, 106)
        );
        vec2_t r = vec3_mul_mat32(v, m);
        TESTFW_EXPECTED(r.x == 622.0f);
        TESTFW_EXPECTED(r.y == 628.0f);
    TESTFW_TEST_END();

    // vec3_mul_mat33
    TESTFW_TEST_BEGIN("vec3_mul_mat33 performs correct vector-matrix multiplication")
        vec3_t v = vec3(1, 2, 3);
        mat33_t m = mat33(
            vec3(101, 102, 103),
            vec3(104, 105, 106),
            vec3(107, 108, 109)
        );
        vec3_t r = vec3_mul_mat33(v, m);
        TESTFW_EXPECTED(r.x == 630.0f);
        TESTFW_EXPECTED(r.y == 636.0f);
        TESTFW_EXPECTED(r.z == 642.0f);
    TESTFW_TEST_END();

    // vec3_mul_mat34
    TESTFW_TEST_BEGIN("vec3_mul_mat34 performs correct vector-matrix multiplication")
        vec3_t v = vec3(1, 2, 3);
        mat34_t m = mat34(
            vec4(101, 102, 103, 104),
            vec4(105, 106, 107, 108),
            vec4(109, 110, 111, 112)
        );
        vec4_t r = vec3_mul_mat34(v, m);
        TESTFW_EXPECTED(r.x == 638.0f);
        TESTFW_EXPECTED(r.y == 644.0f);
        TESTFW_EXPECTED(r.z == 650.0f);
        TESTFW_EXPECTED(r.w == 656.0f);
    TESTFW_TEST_END();

    // vec4_mul_mat42
    TESTFW_TEST_BEGIN("vec4_mul_mat42 performs correct vector-matrix multiplication")
        vec4_t v = vec4(1, 2, 3, 4);
        mat42_t m = mat42(
            vec2(101, 102),
            vec2(105, 106),
            vec2(109, 110),
            vec2(113, 114)
        );
        vec2_t r = vec4_mul_mat42(v, m);
        TESTFW_EXPECTED(r.x == 1090.0f);
        TESTFW_EXPECTED(r.y == 1100.0f);
    TESTFW_TEST_END();

    // vec4_mul_mat43
    TESTFW_TEST_BEGIN("vec4_mul_mat43 performs correct vector-matrix multiplication")
        vec4_t v = vec4(1, 2, 3, 4);
        mat43_t m = mat43(
            vec3(101, 102, 103),
            vec3(105, 106, 107),
            vec3(109, 110, 111),
            vec3(113, 114, 115)
        );
        vec3_t r = vec4_mul_mat43(v, m);
        TESTFW_EXPECTED(r.x == 1090.0f);
        TESTFW_EXPECTED(r.y == 1100.0f);
        TESTFW_EXPECTED(r.z == 1110.0f);
    TESTFW_TEST_END();

    // vec4_mul_mat44
    TESTFW_TEST_BEGIN("vec4_mul_mat44 performs correct vector-matrix multiplication")
        vec4_t v = vec4(1, 2, 3, 4);
        mat44_t m = mat44(
            vec4(101, 102, 103, 104),
            vec4(105, 106, 107, 108),
            vec4(109, 110, 111, 112),
            vec4(113, 114, 115, 116)
        );
        vec4_t r = vec4_mul_mat44(v, m);
        TESTFW_EXPECTED(r.x == 1090.0f);
        TESTFW_EXPECTED(r.y == 1100.0f);
        TESTFW_EXPECTED(r.z == 1110.0f);
        TESTFW_EXPECTED(r.w == 1120.0f);
    TESTFW_TEST_END();

    // mat22_mul_vec2
    TESTFW_TEST_BEGIN("mat22_mul_vec2 performs correct matrix-vector multiplication")
        mat22_t m = mat22(
            vec2(1, 2),
            vec2(3, 4)
        );
        vec2_t v = vec2(101, 102);
        vec2_t r = mat22_mul_vec2(m, v);
        TESTFW_EXPECTED(r.x == 305.0f);
        TESTFW_EXPECTED(r.y == 711.0f);
    TESTFW_TEST_END();

    // mat32_mul_vec2
    TESTFW_TEST_BEGIN("mat32_mul_vec2 performs correct matrix-vector multiplication")
        mat32_t m = mat32(
            vec2(1, 2),
            vec2(3, 4),
            vec2(5, 6)
        );
        vec2_t v = vec2(101, 102);
        vec3_t r = mat32_mul_vec2(m, v);
        TESTFW_EXPECTED(r.x == 305.0f);
        TESTFW_EXPECTED(r.y == 711.0f);
        TESTFW_EXPECTED(r.z == 1117.0f);
    TESTFW_TEST_END();

    // mat42_mul_vec2
    TESTFW_TEST_BEGIN("mat42_mul_vec2 performs correct matrix-vector multiplication")
        mat42_t m = mat42(
            vec2(1, 2),
            vec2(3, 4),
            vec2(5, 6),
            vec2(7, 8)
        );
        vec2_t v = vec2(101, 102);
        vec4_t r = mat42_mul_vec2(m, v);
        TESTFW_EXPECTED(r.x == 305.0f);
        TESTFW_EXPECTED(r.y == 711.0f);
        TESTFW_EXPECTED(r.z == 1117.0f);
        TESTFW_EXPECTED(r.w == 1523.0f);
    TESTFW_TEST_END();

    // mat23_mul_vec3
    TESTFW_TEST_BEGIN("mat23_mul_vec3 performs correct matrix-vector multiplication")
        mat23_t m = mat23(
            vec3(1, 2, 3),
            vec3(4, 5, 6)
        );
        vec3_t v = vec3(101, 102, 103);
        vec2_t r = mat23_mul_vec3(m, v);
        TESTFW_EXPECTED(r.x == 614.0f);
        TESTFW_EXPECTED(r.y == 1532.0f);
    TESTFW_TEST_END();

    // mat33_mul_vec3
    TESTFW_TEST_BEGIN("mat33_mul_vec3 performs correct matrix-vector multiplication")
        mat33_t m = mat33(
            vec3(1, 2, 3),
            vec3(4, 5, 6),
            vec3(7, 8, 9)
        );
        vec3_t v = vec3(101, 102, 103);
        vec3_t r = mat33_mul_vec3(m, v);
        TESTFW_EXPECTED(r.x == 614.0f);
        TESTFW_EXPECTED(r.y == 1532.0f);
        TESTFW_EXPECTED(r.z == 2450.0f);
    TESTFW_TEST_END();
    
    // mat43_mul_vec3
    TESTFW_TEST_BEGIN("mat43_mul_vec3 performs correct matrix-vector multiplication")
        mat43_t m = mat43(
            vec3( 1, 2, 3),
            vec3( 4, 5, 6),
            vec3( 7, 8, 9),
            vec3(10, 11, 12)
        );
        vec3_t v = vec3(101, 102, 103);
        vec4_t r = mat43_mul_vec3(m, v);
        TESTFW_EXPECTED(r.x == 614.0f);
        TESTFW_EXPECTED(r.y == 1532.0f);
        TESTFW_EXPECTED(r.z == 2450.0f);
        TESTFW_EXPECTED(r.w == 3368.0f);
    TESTFW_TEST_END();

    // mat24_mul_vec4
    TESTFW_TEST_BEGIN("mat24_mul_vec4 performs correct matrix-vector multiplication")
        mat24_t m = mat24(
            vec4( 1, 2, 3, 4),
            vec4( 5, 6, 7, 8)
        );
        vec4_t v = vec4(101, 102, 103, 104);
        vec2_t r = mat24_mul_vec4(m, v);
        TESTFW_EXPECTED(r.x == 1030.0f);
        TESTFW_EXPECTED(r.y == 2670.0f);
    TESTFW_TEST_END();

    // mat34_mul_vec4
    TESTFW_TEST_BEGIN("mat34_mul_vec4 performs correct matrix-vector multiplication")
        mat34_t m = mat34(
            vec4( 1, 2, 3, 4),
            vec4( 5, 6, 7, 8),
            vec4( 9, 10, 11, 12)
        );
        vec4_t v = vec4(101, 102, 103, 104);
        vec3_t r = mat34_mul_vec4(m, v);
        TESTFW_EXPECTED(r.x == 1030.0f);
        TESTFW_EXPECTED(r.y == 2670.0f);
        TESTFW_EXPECTED(r.z == 4310.0f);
    TESTFW_TEST_END();

    // mat44_mul_vec4
    TESTFW_TEST_BEGIN("mat44_mul_vec4 performs correct matrix-vector multiplication")
        mat44_t m = mat44(
            vec4( 1, 2, 3, 4),
            vec4( 5, 6, 7, 8),
            vec4( 9, 10, 11, 12),
            vec4(13, 14, 15, 16)
        );
        vec4_t v = vec4(101, 102, 103, 104);
        vec4_t r = mat44_mul_vec4(m, v);
        TESTFW_EXPECTED(r.x == 1030.0f);
        TESTFW_EXPECTED(r.y == 2670.0f);
        TESTFW_EXPECTED(r.z == 4310.0f);
        TESTFW_EXPECTED(r.w == 5950.0f);
    TESTFW_TEST_END();

    // mat22_mul_mat22 
    TESTFW_TEST_BEGIN("mat22_mul_mat22 performs correct matrix multiplication")
        mat22_t a = mat22(
            vec2(1, 2),
            vec2(3, 4)
        );
        mat22_t b = mat22(
            vec2(101, 102),
            vec2(103, 104)
        );
        mat22_t r = mat22_mul_mat22(a, b);
        TESTFW_EXPECTED(r.x.x == 307.0f);
        TESTFW_EXPECTED(r.x.y == 310.0f);
        TESTFW_EXPECTED(r.y.x == 715.0f);
        TESTFW_EXPECTED(r.y.y == 722.0f);
    TESTFW_TEST_END();

    // mat22_mul_mat23
    TESTFW_TEST_BEGIN("mat22_mul_mat23 performs correct matrix multiplication")
        mat22_t a = mat22(
            vec2(1, 2),
            vec2(3, 4)
        );
        mat23_t b = mat23(
            vec3(101, 102, 103),
            vec3(104, 105, 106)
        );
        mat23_t r = mat22_mul_mat23(a, b);
        TESTFW_EXPECTED(r.x.x == 309.0f);
        TESTFW_EXPECTED(r.x.y == 312.0f);
        TESTFW_EXPECTED(r.x.z == 315.0f);
        TESTFW_EXPECTED(r.y.x == 719.0f);
        TESTFW_EXPECTED(r.y.y == 726.0f);
        TESTFW_EXPECTED(r.y.z == 733.0f);
    TESTFW_TEST_END();


    // mat22_mul_mat24
    TESTFW_TEST_BEGIN("mat22_mul_mat24 performs correct matrix multiplication")
        mat22_t a = mat22(
            vec2(1, 2),
            vec2(3, 4)
        );
        mat24_t b = mat24(
            vec4(101, 102, 103, 104),
            vec4(105, 106, 107, 108)
        );
        mat24_t r = mat22_mul_mat24(a, b);
        TESTFW_EXPECTED(r.x.x == 311.0f);
        TESTFW_EXPECTED(r.x.y == 314.0f);
        TESTFW_EXPECTED(r.x.z == 317.0f);
        TESTFW_EXPECTED(r.x.w == 320.0f);
        TESTFW_EXPECTED(r.y.x == 723.0f);
        TESTFW_EXPECTED(r.y.y == 730.0f);
        TESTFW_EXPECTED(r.y.z == 737.0f);
        TESTFW_EXPECTED(r.y.w == 744.0f);
    TESTFW_TEST_END();

    // mat23_mul_mat32
    TESTFW_TEST_BEGIN("mat23_mul_mat32 performs correct matrix multiplication")
        mat23_t a = mat23(
            vec3(1, 2, 3),
            vec3(4, 5, 6)
        );
        mat32_t b = mat32(
            vec2(101, 102),
            vec2(103, 104),
            vec2(105, 106)
        );
        mat22_t r = mat23_mul_mat32(a, b);

        TESTFW_EXPECTED(r.x.x == 622.0f);
        TESTFW_EXPECTED(r.x.y == 628.0f);
        TESTFW_EXPECTED(r.y.x == 1549.0f);
        TESTFW_EXPECTED(r.y.y == 1564.0f);
    TESTFW_TEST_END();

    // mat23_mul_mat33
    TESTFW_TEST_BEGIN("mat23_mul_mat33 performs correct matrix multiplication")
        mat23_t a = mat23(
            vec3(1, 2, 3),
            vec3(4, 5, 6)
        );
        mat33_t b = mat33(
            vec3(101,102,103),
            vec3(104,105,106),
            vec3(107,108,109)
        );
        mat23_t r = mat23_mul_mat33(a, b);
        TESTFW_EXPECTED(r.x.x == 630.0f);
        TESTFW_EXPECTED(r.x.y == 636.0f);
        TESTFW_EXPECTED(r.x.z == 642.0f);
        TESTFW_EXPECTED(r.y.x == 1566.0f);
        TESTFW_EXPECTED(r.y.y == 1581.0f);
        TESTFW_EXPECTED(r.y.z == 1596.0f);
    TESTFW_TEST_END();

    // mat23_mul_mat34
    TESTFW_TEST_BEGIN("mat23_mul_mat34 performs correct matrix multiplication")
        mat23_t a = mat23(
            vec3(1, 2, 3),
            vec3(4, 5, 6)
        );
        mat34_t b = mat34(
            vec4(101,102,103,104),
            vec4(105,106,107,108),
            vec4(109,110,111,112)
        );
        mat24_t r = mat23_mul_mat34(a, b);
        TESTFW_EXPECTED(r.x.x == 638.0f);
        TESTFW_EXPECTED(r.x.y == 644.0f);
        TESTFW_EXPECTED(r.x.z == 650.0f);
        TESTFW_EXPECTED(r.x.w == 656.0f);
        TESTFW_EXPECTED(r.y.x == 1583.0f);
        TESTFW_EXPECTED(r.y.y == 1598.0f);
        TESTFW_EXPECTED(r.y.z == 1613.0f);
        TESTFW_EXPECTED(r.y.w == 1628.0f);
    TESTFW_TEST_END();

    // mat24_mul_mat42
    TESTFW_TEST_BEGIN( "mat24_mul_mat42 performs correct matrix multiplication" )
        mat24_t a = mat24(
            vec4( 1, 2, 3, 4 ),
            vec4( 5, 6, 7, 8 )
        );
        mat42_t b = mat42(
            vec2(101, 102),
            vec2(103, 104),
            vec2(105, 106),
            vec2(107, 108)
        );
        mat22_t r = mat24_mul_mat42( a, b );
        TESTFW_EXPECTED( r.x.x == 1050.0f );
        TESTFW_EXPECTED( r.x.y == 1060.0f );
        TESTFW_EXPECTED( r.y.x == 2714.0f );
        TESTFW_EXPECTED( r.y.y == 2740.0f );
    TESTFW_TEST_END();

    // mat24_mul_mat43
    TESTFW_TEST_BEGIN("mat24_mul_mat43 performs correct matrix multiplication")
        mat24_t a = mat24(
            vec4(1, 2, 3, 4),
            vec4(5, 6, 7, 8)
        );
        mat43_t b = mat43(
            vec3(101,102,103),
            vec3(104,105,106),
            vec3(107,108,109),
            vec3(110,111,112)
        );
        mat23_t r = mat24_mul_mat43(a, b);
        TESTFW_EXPECTED(r.x.x == 1070.0f);
        TESTFW_EXPECTED(r.x.y == 1080.0f);
        TESTFW_EXPECTED(r.x.z == 1090.0f);
        TESTFW_EXPECTED(r.y.x == 2758.0f);
        TESTFW_EXPECTED(r.y.y == 2784.0f);
        TESTFW_EXPECTED(r.y.z == 2810.0f);
    TESTFW_TEST_END();

    // mat24_mul_mat44
    TESTFW_TEST_BEGIN("mat24_mul_mat44 performs correct matrix multiplication")
        mat24_t a = mat24(
            vec4(1, 2, 3, 4),
            vec4(5, 6, 7, 8)
        );
        mat44_t b = mat44(
            vec4(101,102,103,104),
            vec4(105,106,107,108),
            vec4(109,110,111,112),
            vec4(113,114,115,116)
        );
        mat24_t r = mat24_mul_mat44(a, b);
        TESTFW_EXPECTED(r.x.x == 1090.0f);
        TESTFW_EXPECTED(r.x.y == 1100.0f);
        TESTFW_EXPECTED(r.x.z == 1110.0f);
        TESTFW_EXPECTED(r.x.w == 1120.0f);
        TESTFW_EXPECTED(r.y.x == 2802.0f);
        TESTFW_EXPECTED(r.y.y == 2828.0f);
        TESTFW_EXPECTED(r.y.z == 2854.0f);
        TESTFW_EXPECTED(r.y.w == 2880.0f);
    TESTFW_TEST_END();

    // mat32_mul_mat22
    TESTFW_TEST_BEGIN("mat32_mul_mat22 performs correct matrix multiplication")
        mat32_t a = mat32(
            vec2(1, 2),
            vec2(3, 4),
            vec2(5, 6)
        );
        mat22_t b = mat22(
            vec2(101, 102),
            vec2(103, 104)
        );
        mat32_t r = mat32_mul_mat22(a, b);
        TESTFW_EXPECTED(r.x.x == 307.0f);
        TESTFW_EXPECTED(r.x.y == 310.0f);
        TESTFW_EXPECTED(r.y.x == 715.0f);
        TESTFW_EXPECTED(r.y.y == 722.0f);
        TESTFW_EXPECTED(r.z.x == 1123.0f);
        TESTFW_EXPECTED(r.z.y == 1134.0f);
    TESTFW_TEST_END();

    // mat32_mul_mat23
    TESTFW_TEST_BEGIN("mat32_mul_mat23 performs correct matrix multiplication")
        mat32_t a = mat32(
            vec2(1, 2),
            vec2(3, 4),
            vec2(5, 6)
        );
        mat23_t b = mat23(
            vec3(101, 102, 103),
            vec3(104, 105, 106)
        );
        mat33_t r = mat32_mul_mat23(a, b);
        TESTFW_EXPECTED(r.x.x == 309.0f);
        TESTFW_EXPECTED(r.x.y == 312.0f);
        TESTFW_EXPECTED(r.x.z == 315.0f);
        TESTFW_EXPECTED(r.y.x == 719.0f);
        TESTFW_EXPECTED(r.y.y == 726.0f);
        TESTFW_EXPECTED(r.y.z == 733.0f);
        TESTFW_EXPECTED(r.z.x == 1129.0f);
        TESTFW_EXPECTED(r.z.y == 1140.0f);
        TESTFW_EXPECTED(r.z.z == 1151.0f);
    TESTFW_TEST_END();

    // mat32_mul_mat24
    TESTFW_TEST_BEGIN("mat32_mul_mat24 performs correct matrix multiplication")
        mat32_t a = mat32(
            vec2( 1, 2 ),
            vec2( 3, 4 ),
            vec2( 5, 6 )
        );
        mat24_t b = mat24(
            vec4(101,102,103,104),
            vec4(105,106,107,108)
        );
        mat34_t r = mat32_mul_mat24(a, b);
        TESTFW_EXPECTED(r.x.x == 311.0f);
        TESTFW_EXPECTED(r.x.y == 314.0f);
        TESTFW_EXPECTED(r.x.z == 317.0f);
        TESTFW_EXPECTED(r.x.w == 320.0f);
        TESTFW_EXPECTED(r.y.x == 723.0f);
        TESTFW_EXPECTED(r.y.y == 730.0f);
        TESTFW_EXPECTED(r.y.z == 737.0f);
        TESTFW_EXPECTED(r.y.w == 744.0f);
        TESTFW_EXPECTED(r.z.x == 1135.0f);
        TESTFW_EXPECTED(r.z.y == 1146.0f);
        TESTFW_EXPECTED(r.z.z == 1157.0f);
        TESTFW_EXPECTED(r.z.w == 1168.0f);
    TESTFW_TEST_END();

    // mat33_mul_mat32
    TESTFW_TEST_BEGIN("mat33_mul_mat32 performs correct matrix multiplication")
        mat33_t a = mat33(
            vec3( 1, 2, 3 ),
            vec3( 4, 5, 6 ),
            vec3( 7, 8, 9 )
        );
        mat32_t b = mat32(
            vec2(101,102),
            vec2(103,104),
            vec2(105,106)
        );
        mat32_t r = mat33_mul_mat32(a, b);
        TESTFW_EXPECTED(r.x.x == 622.0f);
        TESTFW_EXPECTED(r.x.y == 628.0f);
        TESTFW_EXPECTED(r.y.x == 1549.0f);
        TESTFW_EXPECTED(r.y.y == 1564.0f);
        TESTFW_EXPECTED(r.z.x == 2476.0f);
        TESTFW_EXPECTED(r.z.y == 2500.0f);
    TESTFW_TEST_END();

    // mat33_mul_mat33 
    TESTFW_TEST_BEGIN("mat33_mul_mat33 performs correct matrix multiplication")
        mat33_t a = mat33(
            vec3(1, 2, 3),
            vec3(4, 5, 6),
            vec3(7, 8, 9)
        );
        mat33_t b = mat33(
            vec3(101, 102, 103),
            vec3(104, 105, 106),
            vec3(107, 108, 109)
        );
        mat33_t r = mat33_mul_mat33(a, b);

        TESTFW_EXPECTED(r.x.x == 630.0f);
        TESTFW_EXPECTED(r.x.y == 636.0f);
        TESTFW_EXPECTED(r.x.z == 642.0f);
        TESTFW_EXPECTED(r.y.x == 1566.0f);
        TESTFW_EXPECTED(r.y.y == 1581.0f);
        TESTFW_EXPECTED(r.y.z == 1596.0f);
        TESTFW_EXPECTED(r.z.x == 2502.0f);
        TESTFW_EXPECTED(r.z.y == 2526.0f);
        TESTFW_EXPECTED(r.z.z == 2550.0f);
    TESTFW_TEST_END();

    // mat33_mul_mat34
    TESTFW_TEST_BEGIN("mat33_mul_mat34 performs correct matrix multiplication")
        mat33_t a = mat33(
            vec3( 1, 2, 3 ),
            vec3( 4, 5, 6 ),
            vec3( 7, 8, 9 )
        );
        mat34_t b = mat34(
            vec4(101,102,103,104),
            vec4(105,106,107,108),
            vec4(109,110,111,112)
        );
        mat34_t r = mat33_mul_mat34(a, b);
        TESTFW_EXPECTED(r.x.x == 638.0f);
        TESTFW_EXPECTED(r.x.y == 644.0f);
        TESTFW_EXPECTED(r.x.z == 650.0f);
        TESTFW_EXPECTED(r.x.w == 656.0f);
        TESTFW_EXPECTED(r.y.x == 1583.0f);
        TESTFW_EXPECTED(r.y.y == 1598.0f);
        TESTFW_EXPECTED(r.y.z == 1613.0f);
        TESTFW_EXPECTED(r.y.w == 1628.0f);
        TESTFW_EXPECTED(r.z.x == 2528.0f);
        TESTFW_EXPECTED(r.z.y == 2552.0f);
        TESTFW_EXPECTED(r.z.z == 2576.0f);
        TESTFW_EXPECTED(r.z.w == 2600.0f);
    TESTFW_TEST_END();

    // mat34_mul_mat42
    TESTFW_TEST_BEGIN("mat34_mul_mat42 performs correct matrix multiplication")
        mat34_t a = mat34(
            vec4( 1, 2, 3, 4 ),
            vec4( 5, 6, 7, 8 ),
            vec4( 9, 10, 11, 12 )
        );
        mat42_t b = mat42(
            vec2(101,102),
            vec2(103,104),
            vec2(105,106),
            vec2(107,108)
        );
        mat32_t r = mat34_mul_mat42(a, b);
        TESTFW_EXPECTED(r.x.x == 1050.0f);
        TESTFW_EXPECTED(r.x.y == 1060.0f);
        TESTFW_EXPECTED(r.y.x == 2714.0f);
        TESTFW_EXPECTED(r.y.y == 2740.0f);
        TESTFW_EXPECTED(r.z.x == 4378.0f);
        TESTFW_EXPECTED(r.z.y == 4420.0f);
    TESTFW_TEST_END();

    // mat34_mul_mat43
    TESTFW_TEST_BEGIN( "mat34_mul_mat43 performs correct matrix multiplication" )
        mat34_t a = mat34(
            vec4( 1, 2, 3, 4 ),
            vec4( 5, 6, 7, 8 ),
            vec4( 9, 10, 11, 12 )
        );
        mat43_t b = mat43(
            vec3(101,102,103),
            vec3(104,105,106),
            vec3(107,108,109),
            vec3(110,111,112)
        );
        mat33_t r = mat34_mul_mat43( a, b );
        TESTFW_EXPECTED( r.x.x == 1070.0f );
        TESTFW_EXPECTED( r.x.y == 1080.0f );
        TESTFW_EXPECTED( r.x.z == 1090.0f );
        TESTFW_EXPECTED( r.y.x == 2758.0f );
        TESTFW_EXPECTED( r.y.y == 2784.0f );
        TESTFW_EXPECTED( r.y.z == 2810.0f );
        TESTFW_EXPECTED( r.z.x == 4446.0f );
        TESTFW_EXPECTED( r.z.y == 4488.0f );
        TESTFW_EXPECTED( r.z.z == 4530.0f );
    TESTFW_TEST_END();

    // mat34_mul_mat44
    TESTFW_TEST_BEGIN("mat34_mul_mat44 performs correct matrix multiplication")
        mat34_t a = mat34(
            vec4( 1, 2, 3, 4 ),
            vec4( 5, 6, 7, 8 ),
            vec4( 9, 10, 11, 12 )
        );
        mat44_t b = mat44(
            vec4(101,102,103,104),
            vec4(105,106,107,108),
            vec4(109,110,111,112),
            vec4(113,114,115,116)
        );
        mat34_t r = mat34_mul_mat44(a, b);
        TESTFW_EXPECTED(r.x.x == 1090.0f);
        TESTFW_EXPECTED(r.x.y == 1100.0f);
        TESTFW_EXPECTED(r.x.z == 1110.0f);
        TESTFW_EXPECTED(r.x.w == 1120.0f);
        TESTFW_EXPECTED(r.y.x == 2802.0f);
        TESTFW_EXPECTED(r.y.y == 2828.0f);
        TESTFW_EXPECTED(r.y.z == 2854.0f);
        TESTFW_EXPECTED(r.y.w == 2880.0f);
        TESTFW_EXPECTED(r.z.x == 4514.0f);
        TESTFW_EXPECTED(r.z.y == 4556.0f);
        TESTFW_EXPECTED(r.z.z == 4598.0f);
        TESTFW_EXPECTED(r.z.w == 4640.0f);
    TESTFW_TEST_END();

    // mat42_mul_mat22
    TESTFW_TEST_BEGIN("mat42_mul_mat22 performs correct matrix multiplication")
        mat42_t a = mat42(
            vec2( 1, 2 ),
            vec2( 3, 4 ),
            vec2( 5, 6 ),
            vec2( 7, 8 )
        );
        mat22_t b = mat22(
            vec2(101,102),
            vec2(103,104)
        );
        mat42_t r = mat42_mul_mat22(a, b);
        TESTFW_EXPECTED(r.x.x == 307.0f);
        TESTFW_EXPECTED(r.x.y == 310.0f);
        TESTFW_EXPECTED(r.y.x == 715.0f);
        TESTFW_EXPECTED(r.y.y == 722.0f);
        TESTFW_EXPECTED(r.z.x == 1123.0f);
        TESTFW_EXPECTED(r.z.y == 1134.0f);
        TESTFW_EXPECTED(r.w.x == 1531.0f);
        TESTFW_EXPECTED(r.w.y == 1546.0f);
    TESTFW_TEST_END();

    // mat42_mul_mat23
    TESTFW_TEST_BEGIN("mat42_mul_mat23 performs correct matrix multiplication")
        mat42_t a = mat42(
            vec2( 1, 2 ),
            vec2( 3, 4 ),
            vec2( 5, 6 ),
            vec2( 7, 8 )
        );
        mat23_t b = mat23(
            vec3(101,102,103),
            vec3(104,105,106)
        );
        mat43_t r = mat42_mul_mat23(a, b);
        TESTFW_EXPECTED(r.x.x == 309.0f);
        TESTFW_EXPECTED(r.x.y == 312.0f);
        TESTFW_EXPECTED(r.x.z == 315.0f);
        TESTFW_EXPECTED(r.y.x == 719.0f);
        TESTFW_EXPECTED(r.y.y == 726.0f);
        TESTFW_EXPECTED(r.y.z == 733.0f);
        TESTFW_EXPECTED(r.z.x == 1129.0f);
        TESTFW_EXPECTED(r.z.y == 1140.0f);
        TESTFW_EXPECTED(r.z.z == 1151.0f);
        TESTFW_EXPECTED(r.w.x == 1539.0f);
        TESTFW_EXPECTED(r.w.y == 1554.0f);
        TESTFW_EXPECTED(r.w.z == 1569.0f);
    TESTFW_TEST_END();

    // mat42_mul_mat24
    TESTFW_TEST_BEGIN("mat42_mul_mat24 performs correct matrix multiplication")
        mat42_t a = mat42(
            vec2(1, 2),
            vec2(3, 4),
            vec2(5, 6),
            vec2(7, 8)
        );
        mat24_t b = mat24(
            vec4(101, 102, 103, 104),
            vec4(105, 106, 107, 108)
        );
        mat44_t r = mat42_mul_mat24(a, b);
        TESTFW_EXPECTED(r.x.x == 311.0f);
        TESTFW_EXPECTED(r.x.y == 314.0f);
        TESTFW_EXPECTED(r.x.z == 317.0f);
        TESTFW_EXPECTED(r.x.w == 320.0f);
        TESTFW_EXPECTED(r.y.x == 723.0f);
        TESTFW_EXPECTED(r.y.y == 730.0f);
        TESTFW_EXPECTED(r.y.z == 737.0f);
        TESTFW_EXPECTED(r.y.w == 744.0f);
        TESTFW_EXPECTED(r.z.x == 1135.0f);
        TESTFW_EXPECTED(r.z.y == 1146.0f);
        TESTFW_EXPECTED(r.z.z == 1157.0f);
        TESTFW_EXPECTED(r.z.w == 1168.0f);
        TESTFW_EXPECTED(r.w.x == 1547.0f);
        TESTFW_EXPECTED(r.w.y == 1562.0f);
        TESTFW_EXPECTED(r.w.z == 1577.0f);
        TESTFW_EXPECTED(r.w.w == 1592.0f);
    TESTFW_TEST_END();

    // mat43_mul_mat32
    TESTFW_TEST_BEGIN("mat43_mul_mat32 performs correct matrix multiplication")
        mat43_t a = mat43(
            vec3( 1, 2, 3 ),
            vec3( 4, 5, 6 ),
            vec3( 7, 8, 9 ),
            vec3( 10, 11, 12 )
        );
        mat32_t b = mat32(
            vec2(101,102),
            vec2(103,104),
            vec2(105,106)
        );
        mat42_t r = mat43_mul_mat32(a, b);
        TESTFW_EXPECTED(r.x.x == 622.0f);
        TESTFW_EXPECTED(r.x.y == 628.0f);
        TESTFW_EXPECTED(r.y.x == 1549.0f);
        TESTFW_EXPECTED(r.y.y == 1564.0f);
        TESTFW_EXPECTED(r.z.x == 2476.0f);
        TESTFW_EXPECTED(r.z.y == 2500.0f);
        TESTFW_EXPECTED(r.w.x == 3403.0f);
        TESTFW_EXPECTED(r.w.y == 3436.0f);
    TESTFW_TEST_END();

    // mat43_mul_mat33
    TESTFW_TEST_BEGIN("mat43_mul_mat33 performs correct matrix multiplication")
        mat43_t a = mat43(
            vec3( 1, 2, 3 ),
            vec3( 4, 5, 6 ),
            vec3( 7, 8, 9 ),
            vec3( 10, 11, 12 )
        );
        mat33_t b = mat33(
            vec3(101,102,103),
            vec3(104,105,106),
            vec3(107,108,109)
        );
        mat43_t r = mat43_mul_mat33(a, b);
        TESTFW_EXPECTED(r.x.x == 630.0f);
        TESTFW_EXPECTED(r.x.y == 636.0f);
        TESTFW_EXPECTED(r.x.z == 642.0f);
        TESTFW_EXPECTED(r.y.x == 1566.0f);
        TESTFW_EXPECTED(r.y.y == 1581.0f);
        TESTFW_EXPECTED(r.y.z == 1596.0f);
        TESTFW_EXPECTED(r.z.x == 2502.0f);
        TESTFW_EXPECTED(r.z.y == 2526.0f);
        TESTFW_EXPECTED(r.z.z == 2550.0f);
        TESTFW_EXPECTED(r.w.x == 3438.0f);
        TESTFW_EXPECTED(r.w.y == 3471.0f);
        TESTFW_EXPECTED(r.w.z == 3504.0f);
    TESTFW_TEST_END();

    // mat43_mul_mat34
    TESTFW_TEST_BEGIN( "mat43_mul_mat34 performs correct matrix multiplication" )
        mat43_t a = mat43(
            vec3( 1, 2, 3 ),
            vec3( 4, 5, 6 ),
            vec3( 7, 8, 9 ),
            vec3( 10, 11, 12 )
        );
        mat34_t b = mat34(
            vec4(101, 102, 103, 104),
            vec4(105, 106, 107, 108),
            vec4(109, 110, 111, 112)
        );
        mat44_t r = mat43_mul_mat34( a, b );
        TESTFW_EXPECTED( r.x.x == 638.0f );
        TESTFW_EXPECTED( r.x.y == 644.0f );
        TESTFW_EXPECTED( r.x.z == 650.0f );
        TESTFW_EXPECTED( r.x.w == 656.0f );
        TESTFW_EXPECTED( r.y.x == 1583.0f );
        TESTFW_EXPECTED( r.y.y == 1598.0f );
        TESTFW_EXPECTED( r.y.z == 1613.0f );
        TESTFW_EXPECTED( r.y.w == 1628.0f );
        TESTFW_EXPECTED( r.z.x == 2528.0f );
        TESTFW_EXPECTED( r.z.y == 2552.0f );
        TESTFW_EXPECTED( r.z.z == 2576.0f );
        TESTFW_EXPECTED( r.z.w == 2600.0f );
        TESTFW_EXPECTED( r.w.x == 3473.0f );
        TESTFW_EXPECTED( r.w.y == 3506.0f );
        TESTFW_EXPECTED( r.w.z == 3539.0f );
        TESTFW_EXPECTED( r.w.w == 3572.0f );
    TESTFW_TEST_END();

    // mat44_mul_mat42
    TESTFW_TEST_BEGIN("mat44_mul_mat42 performs correct matrix multiplication")
        mat44_t a = mat44(
            vec4( 1, 2, 3, 4),
            vec4( 5, 6, 7, 8),
            vec4( 9, 10, 11, 12),
            vec4(13, 14, 15, 16)
        );
        mat42_t b = mat42(
            vec2(101, 102),
            vec2(103, 104),
            vec2(105, 106),
            vec2(107, 108)
        );
        mat42_t r = mat44_mul_mat42(a, b);
        TESTFW_EXPECTED(r.x.x == 1050.0f);
        TESTFW_EXPECTED(r.x.y == 1060.0f);
        TESTFW_EXPECTED(r.y.x == 2714.0f);
        TESTFW_EXPECTED(r.y.y == 2740.0f);
        TESTFW_EXPECTED(r.z.x == 4378.0f);
        TESTFW_EXPECTED(r.z.y == 4420.0f);
        TESTFW_EXPECTED(r.w.x == 6042.0f);
        TESTFW_EXPECTED(r.w.y == 6100.0f);
    TESTFW_TEST_END();

    // mat44_mul_mat43
    TESTFW_TEST_BEGIN("mat44_mul_mat43 performs correct matrix multiplication")
        mat44_t a = mat44(
            vec4( 1, 2, 3, 4),
            vec4( 5, 6, 7, 8),
            vec4( 9, 10, 11, 12),
            vec4(13, 14, 15, 16)
        );
        mat43_t b = mat43(
            vec3(101, 102, 103),
            vec3(104, 105, 106),
            vec3(107, 108, 109),
            vec3(110, 111, 112)
        );
        mat43_t r = mat44_mul_mat43(a, b);
        TESTFW_EXPECTED(r.x.x == 1070.0f);
        TESTFW_EXPECTED(r.x.y == 1080.0f);
        TESTFW_EXPECTED(r.x.z == 1090.0f);
        TESTFW_EXPECTED(r.y.x == 2758.0f);
        TESTFW_EXPECTED(r.y.y == 2784.0f);
        TESTFW_EXPECTED(r.y.z == 2810.0f);
        TESTFW_EXPECTED(r.z.x == 4446.0f);
        TESTFW_EXPECTED(r.z.y == 4488.0f);
        TESTFW_EXPECTED(r.z.z == 4530.0f);
        TESTFW_EXPECTED(r.w.x == 6134.0f);
        TESTFW_EXPECTED(r.w.y == 6192.0f);
        TESTFW_EXPECTED(r.w.z == 6250.0f);
    TESTFW_TEST_END();

    // mat44_mul_mat44
    TESTFW_TEST_BEGIN( "mat44_mul_mat44 performs correct matrix multiplication" )
        mat44_t a = mat44(
            vec4( 1, 2, 3, 4 ),
            vec4( 5, 6, 7, 8 ),
            vec4( 9, 10, 11, 12 ),
            vec4( 13, 14, 15, 16 )
        );
        mat44_t b = mat44(
            vec4(101,102,103,104),
            vec4(105,106,107,108),
            vec4(109,110,111,112),
            vec4(113,114,115,116)
        );
        mat44_t r = mat44_mul_mat44( a, b );
        TESTFW_EXPECTED( r.x.x == 1090.0f );
        TESTFW_EXPECTED( r.x.y == 1100.0f );
        TESTFW_EXPECTED( r.x.z == 1110.0f );
        TESTFW_EXPECTED( r.x.w == 1120.0f );
        TESTFW_EXPECTED( r.y.x == 2802.0f );
        TESTFW_EXPECTED( r.y.y == 2828.0f );
        TESTFW_EXPECTED( r.y.z == 2854.0f );
        TESTFW_EXPECTED( r.y.w == 2880.0f );
        TESTFW_EXPECTED( r.z.x == 4514.0f );
        TESTFW_EXPECTED( r.z.y == 4556.0f );
        TESTFW_EXPECTED( r.z.z == 4598.0f );
        TESTFW_EXPECTED( r.z.w == 4640.0f );
        TESTFW_EXPECTED( r.w.x == 6226.0f );
        TESTFW_EXPECTED( r.w.y == 6284.0f );
        TESTFW_EXPECTED( r.w.z == 6342.0f );
        TESTFW_EXPECTED( r.w.w == 6400.0f );
    TESTFW_TEST_END();
}


void test_quaternions( void ) {
    // quat_barycentric
    TESTFW_TEST_BEGIN("quat_barycentric returns q1 when f = g = 0")
        vec4_t q1 = vec4(0, 0, 0, 1);
        vec4_t q2 = vec4(1, 0, 0, 0);
        vec4_t q3 = vec4(0, 1, 0, 0);
        vec4_t r = quat_barycentric(q1, q2, q3, 0.0f, 0.0f);
        TESTFW_EXPECTED(test_cmp(r.x, q1.x));
        TESTFW_EXPECTED(test_cmp(r.y, q1.y));
        TESTFW_EXPECTED(test_cmp(r.z, q1.z));
        TESTFW_EXPECTED(test_cmp(r.w, q1.w));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_barycentric matches nested slerp result when f = 0.5, g = 0")
        vec4_t q1 = vec4(0, 0, 0, 1);
        vec4_t q2 = vec4(1, 0, 0, 0);
        vec4_t q3 = vec4(0, 1, 0, 0);
        vec4_t expected = quat_slerp(q1, q2, 0.5f);
        vec4_t r = quat_barycentric(q1, q2, q3, 0.5f, 0.0f);
        TESTFW_EXPECTED(test_cmp(r.x, expected.x));
        TESTFW_EXPECTED(test_cmp(r.y, expected.y));
        TESTFW_EXPECTED(test_cmp(r.z, expected.z));
        TESTFW_EXPECTED(test_cmp(r.w, expected.w));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_barycentric returns balanced result when f = g = 1/3")
        vec4_t q1 = vec4(0, 0, 0, 1);
        vec4_t q2 = vec4(1, 0, 0, 0);
        vec4_t q3 = vec4(0, 1, 0, 0);
        float f = 1.0f / 3.0f;
        float g = 1.0f / 3.0f;
        vec4_t mid1 = quat_slerp(q1, q2, f + g);
        vec4_t mid2 = quat_slerp(q1, q3, f + g);
        vec4_t expected = quat_slerp(mid1, mid2, g / (f + g));
        vec4_t r = quat_barycentric(q1, q2, q3, f, g);
        TESTFW_EXPECTED(test_cmp(r.x, expected.x));
        TESTFW_EXPECTED(test_cmp(r.y, expected.y));
        TESTFW_EXPECTED(test_cmp(r.z, expected.z));
        TESTFW_EXPECTED(test_cmp(r.w, expected.w));
    TESTFW_TEST_END();
    
    // quat_slerp
    TESTFW_TEST_BEGIN("quat_slerp returns a when t=0")
        vec4_t a = vec4(0, 0, 0, 1);
        vec4_t b = vec4(1, 0, 0, 0);
        vec4_t r = quat_slerp(a, b, 0.0f);
        TESTFW_EXPECTED(test_cmp(r.x, a.x));
        TESTFW_EXPECTED(test_cmp(r.y, a.y));
        TESTFW_EXPECTED(test_cmp(r.z, a.z));
        TESTFW_EXPECTED(test_cmp(r.w, a.w));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_slerp returns b when t=1")
        vec4_t a = vec4(0, 0, 0, 1);
        vec4_t b = vec4(1, 0, 0, 0);
        vec4_t r = quat_slerp(a, b, 1.0f);
        TESTFW_EXPECTED(test_cmp(r.x, b.x));
        TESTFW_EXPECTED(test_cmp(r.y, b.y));
        TESTFW_EXPECTED(test_cmp(r.z, b.z));
        TESTFW_EXPECTED(test_cmp(r.w, b.w));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_slerp returns expected midpoint when t=0.5")
        vec4_t a = vec4(0, 0, 0, 1);
        vec4_t b = vec4(1, 0, 0, 0);
        vec4_t r = quat_slerp(a, b, 0.5f);
        TESTFW_EXPECTED(test_cmp(r.x,0.70710678f));
        TESTFW_EXPECTED(test_cmp(r.y,0.0f));
        TESTFW_EXPECTED(test_cmp(r.z,0.0f));
        TESTFW_EXPECTED(test_cmp(r.w,0.70710678f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_slerp returns a when a == -b (180 degree apart)")
        vec4_t a = vec4(0, 0, 1, 0);
        vec4_t b = vec4(0, 0, -1, 0);
        vec4_t r = quat_slerp(a, b, 0.5f);
        TESTFW_EXPECTED(test_cmp(r.x, a.x));
        TESTFW_EXPECTED(test_cmp(r.y, a.y));
        TESTFW_EXPECTED(test_cmp(r.z, a.z));
        TESTFW_EXPECTED(test_cmp(r.w, a.w));
    TESTFW_TEST_END();

    // quat_conjugate 
    TESTFW_TEST_BEGIN("quat_conjugate negates vector part and preserves scalar")
        vec4_t q = vec4(1.0f, -2.0f, 3.0f, 4.0f);
        vec4_t r = quat_conjugate(q);
        TESTFW_EXPECTED(r.x == -1.0f);
        TESTFW_EXPECTED(r.y == 2.0f);
        TESTFW_EXPECTED(r.z == -3.0f);
        TESTFW_EXPECTED(r.w == 4.0f);
    TESTFW_TEST_END();

    // quat_exp
    TESTFW_TEST_BEGIN("quat_exp returns expected result for pure X rotation")
        vec4_t q = vec4(1.0f, 0.0f, 0.0f, 0.0f);
        vec4_t r = quat_exp(q);
        TESTFW_EXPECTED(test_cmp(r.x, 0.84147098f));
        TESTFW_EXPECTED(test_cmp(r.y, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.z, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.w, 0.54030231f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_exp returns expected result for pure Y rotation")
        vec4_t q = vec4(0.0f, 1.0f, 0.0f, 0.0f);
        vec4_t r = quat_exp(q);
        TESTFW_EXPECTED(test_cmp(r.x, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.y, 0.84147098f));
        TESTFW_EXPECTED(test_cmp(r.z, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.w, 0.54030231f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_exp returns expected result for pure Z rotation")
        vec4_t q = vec4(0.0f, 0.0f, 1.0f, 0.0f);
        vec4_t r = quat_exp(q);
        TESTFW_EXPECTED(test_cmp(r.x, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.y, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.z, 0.84147098f));
        TESTFW_EXPECTED(test_cmp(r.w, 0.54030231f));
    TESTFW_TEST_END();

    // quat_identity 
    TESTFW_TEST_BEGIN("quat_identity returns quaternion (0,0,0,1)")
        vec4_t q = quat_identity();
        TESTFW_EXPECTED(q.x == 0.0f);
        TESTFW_EXPECTED(q.y == 0.0f);
        TESTFW_EXPECTED(q.z == 0.0f);
        TESTFW_EXPECTED(q.w == 1.0f);
    TESTFW_TEST_END();

    // quat_inverse
    TESTFW_TEST_BEGIN("quat_inverse returns conjugate for unit quaternion")
        vec4_t q = vec4_normalize(vec4(1.0f, 2.0f, 3.0f, 4.0f));
        vec4_t r = quat_inverse(q);
        vec4_t c = quat_conjugate(q);
        TESTFW_EXPECTED(test_cmp(r.x,c.x));
        TESTFW_EXPECTED(test_cmp(r.y,c.y));
        TESTFW_EXPECTED(test_cmp(r.z,c.z));
        TESTFW_EXPECTED(test_cmp(r.w,c.w));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_inverse of identity returns identity")
        vec4_t q = vec4(0, 0, 0, 1);
        vec4_t r = quat_inverse(q);
        TESTFW_EXPECTED(r.x == 0.0f);
        TESTFW_EXPECTED(r.y == 0.0f);
        TESTFW_EXPECTED(r.z == 0.0f);
        TESTFW_EXPECTED(r.w == 1.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_inverse returns reciprocal for non-unit quaternion")
        vec4_t q = vec4(1.0f, -2.0f, 3.0f, 4.0f);
        vec4_t r = quat_inverse(q);
        float s = 1.0f / (1*1 + 2*2 + 3*3 + 4*4);
        TESTFW_EXPECTED(test_cmp(r.x, (-1.0f * s)));
        TESTFW_EXPECTED(test_cmp(r.y, ( 2.0f * s)));
        TESTFW_EXPECTED(test_cmp(r.z, (-3.0f * s)));
        TESTFW_EXPECTED(test_cmp(r.w, ( 4.0f * s)));
    TESTFW_TEST_END();

    /// quat_is_identity
    TESTFW_TEST_BEGIN("quat_is_identity returns 1 for (0,0,0,1)")
        vec4_t q = vec4(0.0f, 0.0f, 0.0f, 1.0f);
        TESTFW_EXPECTED(quat_is_identity(q) == 1);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_is_identity returns 0 for quaternion with any nonzero vector part")
        vec4_t q = vec4(0.0001f, 0.0f, 0.0f, 1.0f);
        TESTFW_EXPECTED(quat_is_identity(q) == 0);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_is_identity returns 0 for quaternion with wrong scalar part")
        vec4_t q = vec4(0.0f, 0.0f, 0.0f, 0.9999f);
        TESTFW_EXPECTED(quat_is_identity(q) == 0);
    TESTFW_TEST_END();

    // quat_ln
    TESTFW_TEST_BEGIN("quat_ln returns zero for identity quaternion")
        vec4_t q = vec4(0.0f, 0.0f, 0.0f, 1.0f);
        vec4_t r = quat_ln(q);
        TESTFW_EXPECTED(test_cmp(r.x,0.0f));
        TESTFW_EXPECTED(test_cmp(r.y,0.0f));
        TESTFW_EXPECTED(test_cmp(r.z,0.0f));
        TESTFW_EXPECTED(test_cmp(r.w,0.0f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_ln returns expected result for 90 degree rotation around X")
        vec4_t q = vec4_normalize( vec4(0.70710678f, 0.0f, 0.0f, 0.70710678f) );
        vec4_t r = quat_ln(q);
        TESTFW_EXPECTED(test_cmp(r.x, 0.7853981f));
        TESTFW_EXPECTED(test_cmp(r.y, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.z, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.w, 0.0f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_ln returns expected result for 60 deg around normalized (1,2,3)")
        vec3_t axis = vec3_normalize(vec3(1, 2, 3));
        float angle = 1.04719755f;
        float s = vecmath_sin(angle * 0.5f);
        float c = vecmath_cos(angle * 0.5f);
        vec4_t q = vec4(axis.x * s, axis.y * s, axis.z * s, c);
        vec4_t r = quat_ln(q);
        float sin_half = vecmath_sqrt(q.x*q.x + q.y*q.y + q.z*q.z);
        float theta = vecmath_acos(q.w);
        float scale = (sin_half > 0.00001f) ? theta / sin_half : 1.0f;
        vec4_t expected = vec4(q.x * scale, q.y * scale, q.z * scale, 0.0f);
        TESTFW_EXPECTED(test_cmp(r.x, expected.x));
        TESTFW_EXPECTED(test_cmp(r.y, expected.y));
        TESTFW_EXPECTED(test_cmp(r.z, expected.z));
        TESTFW_EXPECTED(test_cmp(r.w, expected.w));
    TESTFW_TEST_END();


    // quat_mul
    TESTFW_TEST_BEGIN("quat_mul performs Hamilton product of two quaternions")
        vec4_t a = vec4(1, 2, 3, 4);
        vec4_t b = vec4(5, 6, 7, 8);
        vec4_t r = quat_mul(a, b);
        TESTFW_EXPECTED(r.x == 32.0f);
        TESTFW_EXPECTED(r.y == 32.0f);
        TESTFW_EXPECTED(r.z == 56.0f);
        TESTFW_EXPECTED(r.w == -6.0f);
    TESTFW_TEST_END();


    // quat_rotation_axis
    TESTFW_TEST_BEGIN("quat_rotation_axis creates quaternion for rotation around X by PI")
        vec3_t axis = vec3(1, 0, 0);
        float angle = 3.14159265f;
        vec4_t r = quat_rotation_axis(axis, angle);
        TESTFW_EXPECTED(test_cmp(r.x, 1.0f));
        TESTFW_EXPECTED(test_cmp(r.y, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.z, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.w, 0.0f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotation_axis creates quaternion for rotation around Y by PI")
        vec3_t axis = vec3(0, 1, 0);
        float angle = 3.14159265f;
        vec4_t r = quat_rotation_axis(axis, angle);
        TESTFW_EXPECTED(test_cmp(r.x, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.y, 1.0f));
        TESTFW_EXPECTED(test_cmp(r.z, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.w, 0.0f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotation_axis creates quaternion for rotation around Z by PI")
        vec3_t axis = vec3(0, 0, 1);
        float angle = 3.14159265f;
        vec4_t r = quat_rotation_axis(axis, angle);
        TESTFW_EXPECTED(test_cmp(r.x, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.y, 0.0f));
        TESTFW_EXPECTED(test_cmp(r.z, 1.0f));
        TESTFW_EXPECTED(test_cmp(r.w, 0.0f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotation_axis handles arbitrary axis and angle")
        vec3_t axis = vec3_normalize( vec3(1, 2, 3) );
        float angle = 1.04719755f;
        vec4_t r = quat_rotation_axis(axis, angle);
        TESTFW_EXPECTED( r.x == 0.133630633f );
        TESTFW_EXPECTED( r.y == 0.267261267f );
        TESTFW_EXPECTED( r.z == 0.400891870f );
        TESTFW_EXPECTED( r.w == 0.866025400f );
    TESTFW_TEST_END();

    // quat_rotation_matrix
    TESTFW_TEST_BEGIN("quat_rotation_matrix returns identity quaternion for identity matrix")
        mat44_t m = mat44(
            vec4(1, 0, 0, 0),
            vec4(0, 1, 0, 0),
            vec4(0, 0, 1, 0),
            vec4(0, 0, 0, 1)
        );
        vec4_t q = quat_rotation_matrix(m);
        TESTFW_EXPECTED(q.x == 0.0f);
        TESTFW_EXPECTED(q.y == 0.0f);
        TESTFW_EXPECTED(q.z == 0.0f);
        TESTFW_EXPECTED(q.w == 1.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotation_matrix returns quaternion for 180 degree rotation around X")
        mat44_t m = mat44(
            vec4(1, 0, 0, 0),
            vec4(0, -1, 0, 0),
            vec4(0, 0, -1, 0),
            vec4(0, 0, 0, 1)
        );
        vec4_t q = quat_rotation_matrix(m);
        TESTFW_EXPECTED(q.x == 1.0f);
        TESTFW_EXPECTED(q.y == 0.0f);
        TESTFW_EXPECTED(q.z == 0.0f);
        TESTFW_EXPECTED(q.w == 0.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotation_matrix returns quaternion for 180 degree rotation around Y")
        mat44_t m = mat44(
            vec4(-1, 0, 0, 0),
            vec4( 0, 1, 0, 0),
            vec4( 0, 0, -1, 0),
            vec4( 0, 0, 0, 1)
        );
        vec4_t q = quat_rotation_matrix(m);
        TESTFW_EXPECTED(q.x == 0.0f);
        TESTFW_EXPECTED(q.y == 1.0f);
        TESTFW_EXPECTED(q.z == 0.0f);
        TESTFW_EXPECTED(q.w == 0.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotation_matrix returns quaternion for 180 degree rotation around Z")
        mat44_t m = mat44(
            vec4(-1, 0, 0, 0),
            vec4( 0, -1, 0, 0),
            vec4( 0, 0, 1, 0),
            vec4( 0, 0, 0, 1)
        );
        vec4_t q = quat_rotation_matrix(m);
        TESTFW_EXPECTED(q.x == 0.0f);
        TESTFW_EXPECTED(q.y == 0.0f);
        TESTFW_EXPECTED(q.z == 1.0f);
        TESTFW_EXPECTED(q.w == 0.0f);
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotation_matrix returns expected quaternion for rotation around all axes")
        mat44_t m = mat44(
            vec4( 0.353553f, -0.573223f, 0.739198f, 0 ),
            vec4( 0.612372f, 0.739198f, 0.280330f, 0 ),
            vec4(-0.707107f, 0.353553f, 0.612372f, 0 ),
            vec4( 0, 0, 0, 1)
        );
        vec4_t q = quat_rotation_matrix(m);
        TESTFW_EXPECTED( q.x == -0.0222599395f);
        TESTFW_EXPECTED( q.y == -0.4396796820f);
        TESTFW_EXPECTED( q.z == -0.3604232970f);
        TESTFW_EXPECTED( q.w == 0.8223629000f);
    TESTFW_TEST_END();

    // quat_rotation_yaw_pitch_roll
    TESTFW_TEST_BEGIN("quat_rotation_yaw_pitch_roll returns quaternion for roll = PI")
        vec4_t q = quat_rotation_yaw_pitch_roll(0.0f, 0.0f, 3.14159265f);
        TESTFW_EXPECTED(test_cmp(q.x, 0.0f));
        TESTFW_EXPECTED(test_cmp(q.y, 0.0f));
        TESTFW_EXPECTED(test_cmp(q.z, 1.0f));
        TESTFW_EXPECTED(test_cmp(q.w, 0.0f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotation_yaw_pitch_roll returns quaternion for pitch = PI")
        vec4_t q = quat_rotation_yaw_pitch_roll(0.0f, 3.14159265f, 0.0f);
        TESTFW_EXPECTED(test_cmp(q.x, 1.0f));
        TESTFW_EXPECTED(test_cmp(q.y, 0.0f));
        TESTFW_EXPECTED(test_cmp(q.z, 0.0f));
        TESTFW_EXPECTED(test_cmp(q.w, 0.0f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotation_yaw_pitch_roll returns quaternion for yaw = PI")
        vec4_t q = quat_rotation_yaw_pitch_roll(3.14159265f, 0.0f, 0.0f);
        TESTFW_EXPECTED(test_cmp(q.x, 0.0f));
        TESTFW_EXPECTED(test_cmp(q.y, 1.0f));
        TESTFW_EXPECTED(test_cmp(q.z, 0.0f));
        TESTFW_EXPECTED(test_cmp(q.w, 0.0f));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotation_yaw_pitch_roll returns expected quaternion for known angles")
        float yaw = 0.25f;
        float pitch = 1.0f;
        float roll = 0.5f;
        vec4_t q = quat_rotation_yaw_pitch_roll(yaw, pitch, roll);
        TESTFW_EXPECTED(test_cmp(q.x, 0.48796606f));
        TESTFW_EXPECTED(test_cmp(q.y, -0.01167532f));
        TESTFW_EXPECTED(test_cmp(q.z, 0.1575093f));
        TESTFW_EXPECTED(test_cmp(q.w, 0.85845421f));
    TESTFW_TEST_END();

    // quat_squad 
    TESTFW_TEST_BEGIN("quat_squad returns 45 degree midpoint between 0 and 90 degrees around X")
        vec4_t q0 = quat_rotation_axis( vec3(1, 0, 0), 0.0f );
        vec4_t q1 = quat_rotation_axis( vec3(1, 0, 0), 0.0f );
        vec4_t q2 = quat_rotation_axis( vec3(1, 0, 0), 1.5707963f );
        vec4_t q3 = quat_rotation_axis( vec3(1, 0, 0), 1.5707963f );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        vec4_t r = quat_squad( q1, a, b, c, 0.5f );
        TESTFW_EXPECTED( test_cmp(r.x, 0.382683432f) );
        TESTFW_EXPECTED( test_cmp(r.y, 0.0f)  );
        TESTFW_EXPECTED( test_cmp(r.z, 0.0f)  );
        TESTFW_EXPECTED( test_cmp(r.w, 0.923879533f) );
    TESTFW_TEST_END();
    
    TESTFW_TEST_BEGIN("quat_squad midpoint from -90 to +90 degrees yields [-0.7071, 0.7071]")
        vec4_t q0 = quat_rotation_axis( vec3(1, 0, 0), -3.1415926f );
        vec4_t q1 = quat_rotation_axis( vec3(1, 0, 0), -1.5707963f );
        vec4_t q2 = quat_rotation_axis( vec3(1, 0, 0), 1.5707963f );
        vec4_t q3 = quat_rotation_axis( vec3(1, 0, 0), 3.1415926f );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        vec4_t r = quat_squad( q1, a, b, c, 0.5f );

        TESTFW_EXPECTED( test_cmp(r.x, -0.70710678f)  );
        TESTFW_EXPECTED( test_cmp(r.y, 0.0f)  );
        TESTFW_EXPECTED( test_cmp(r.z, 0.0f)  );
        TESTFW_EXPECTED( test_cmp(r.w, 0.70710678f)  );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_squad with t=0 returns q1 exactly")
        vec4_t q0 = quat_rotation_axis( vec3(0, 1, 0), 0.0f );
        vec4_t q1 = quat_rotation_axis( vec3(0, 1, 0), 0.25f );
        vec4_t q2 = quat_rotation_axis( vec3(0, 1, 0), 0.5f );
        vec4_t q3 = quat_rotation_axis( vec3(0, 1, 0), 0.75f );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        vec4_t r = quat_squad( q1, a, b, q2, 0.0f );
        TESTFW_EXPECTED( test_cmp(r.x, q1.x)  );
        TESTFW_EXPECTED( test_cmp(r.y, q1.y)  );
        TESTFW_EXPECTED( test_cmp(r.z, q1.z)  );
        TESTFW_EXPECTED( test_cmp(r.w, q1.w)  );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_squad with t=1 returns q2 exactly")
        vec4_t q0 = quat_rotation_axis( vec3(0, 0, 1), 0.0f );
        vec4_t q1 = quat_rotation_axis( vec3(0, 0, 1), 0.5f );
        vec4_t q2 = quat_rotation_axis( vec3(0, 0, 1), 1.0f );
        vec4_t q3 = quat_rotation_axis( vec3(0, 0, 1), 1.5f );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        vec4_t r = quat_squad( q1, a, b, q2, 1.0f );
        TESTFW_EXPECTED( test_cmp(r.x, q2.x)  );
        TESTFW_EXPECTED( test_cmp(r.y, q2.y)  );
        TESTFW_EXPECTED( test_cmp(r.z, q2.z)  );
        TESTFW_EXPECTED( test_cmp(r.w, q2.w)  );
    TESTFW_TEST_END();


    // quat_to_axis_angle
    TESTFW_TEST_BEGIN("quat_to_axis_angle returns axis X and angle PI for 180 degree rotation")
        vec4_t q = quat_rotation_axis(vec3(1, 0, 0), 3.1415926f);
        vec3_t axis;
        float angle;
        quat_to_axis_angle(q, &axis, &angle);
        TESTFW_EXPECTED(test_cmp(axis.x, 1.0f) );
        TESTFW_EXPECTED(test_cmp(axis.y, 0.0f) );
        TESTFW_EXPECTED(test_cmp(axis.z, 0.0f) );
        TESTFW_EXPECTED(test_cmp(angle, 3.1415926f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_to_axis_angle returns axis Y and angle PI for 180 degree rotation")
        vec4_t q = quat_rotation_axis(vec3(0, 1, 0), 3.1415926f);
        vec3_t axis;
        float angle;
        quat_to_axis_angle(q, &axis, &angle);
        TESTFW_EXPECTED(test_cmp(axis.x,  0.0f) );
        TESTFW_EXPECTED(test_cmp(axis.y,  1.0f) );
        TESTFW_EXPECTED(test_cmp(axis.z,  0.0f) );
        TESTFW_EXPECTED(test_cmp(angle,  3.1415926f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_to_axis_angle returns axis Z and angle PI for 180 degree rotation")
        vec4_t q = quat_rotation_axis(vec3(0, 0, 1), 3.1415926f);
        vec3_t axis;
        float angle;
        quat_to_axis_angle(q, &axis, &angle);
        TESTFW_EXPECTED(test_cmp(axis.x, 0.0f) );
        TESTFW_EXPECTED(test_cmp(axis.y, 0.0f) );
        TESTFW_EXPECTED(test_cmp(axis.z, 1.0f) );
        TESTFW_EXPECTED(test_cmp(angle, 3.1415926f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_to_axis_angle returns 0 angle and normalized axis for identity quaternion")
        vec4_t q = vec4(0, 0, 0, 1);
        vec3_t axis;
        float angle;
        quat_to_axis_angle(q, &axis, &angle);
        TESTFW_EXPECTED(test_cmp(angle, 0.0f) );
        TESTFW_EXPECTED(test_cmp(vec3_length(axis), 0.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_to_axis_angle handles arbitrary normalized quaternion")
        vec3_t input_axis = vec3_normalize(vec3(1, 2, 3));
        vec4_t q = quat_rotation_axis(input_axis, 1.04719755f);
        vec3_t axis;
        float angle;
        quat_to_axis_angle(q, &axis, &angle);
        vec3_t norm_axis = vec3_normalize(axis);
        float d = vec3_dot(norm_axis, input_axis);
        TESTFW_EXPECTED(d > 0.99999f || d < -0.99999f);
        TESTFW_EXPECTED(test_cmp(angle,1.04719755f) );
    TESTFW_TEST_END();

    // quat_rotate_vector
    TESTFW_TEST_BEGIN("quat_rotate_vector returns same vector for identity quaternion")
        vec3_t v = vec3(1, 2, 3);
        vec4_t q = vec4(0, 0, 0, 1); // identity rotation
        vec3_t r = quat_rotate_vector(v, q);
        TESTFW_EXPECTED(test_cmp(r.x,1.0f) );
        TESTFW_EXPECTED(test_cmp(r.y,2.0f) );
        TESTFW_EXPECTED(test_cmp(r.z,3.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotate_vector rotates X axis 90 degrees around Y")
        vec3_t v = vec3(1, 0, 0);
        vec4_t q = quat_rotation_axis(vec3(0, 1, 0), 1.5707963f);
        vec3_t r = quat_rotate_vector(v, q);
        TESTFW_EXPECTED(test_cmp(r.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(r.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(r.z,-1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotate_vector rotates Y axis 90 degrees around Z")
        vec3_t v = vec3(0, 1, 0);
        vec4_t q = quat_rotation_axis(vec3(0, 0, 1), 1.5707963f);
        vec3_t r = quat_rotate_vector(v, q);
        TESTFW_EXPECTED(test_cmp(r.x,-1.0f) );
        TESTFW_EXPECTED(test_cmp(r.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(r.z,0.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotate_vector rotates Z axis 90 degrees around X")
        vec3_t v = vec3(0, 0, 1);
        vec4_t q = quat_rotation_axis(vec3(1, 0, 0), 1.5707963f);
        vec3_t r = quat_rotate_vector(v, q);
        TESTFW_EXPECTED(test_cmp(r.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(r.y,-1.0f) );
        TESTFW_EXPECTED(test_cmp(r.z,0.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_rotate_vector rotates arbitrary vector around normalized axis")
        vec3_t v = vec3(1, 2, 3);
        vec3_t axis = vec3_normalize(vec3(1, 1, 0));
        float angle = 1.04719755f; // 60 degrees
        vec4_t q = quat_rotation_axis(axis, angle);
        vec3_t r = quat_rotate_vector(v, q);

        TESTFW_EXPECTED(test_cmp(r.x,3.08711731f) );
        TESTFW_EXPECTED(test_cmp(r.y,-0.08711731f) );
        TESTFW_EXPECTED(test_cmp(r.z,2.11237244f) );
    TESTFW_TEST_END();

    //quat_shortest_arc
    TESTFW_TEST_BEGIN("quat_shortest_arc returns identity quaternion for equal vectors")
        vec3_t v = vec3_normalize(vec3(1, 2, 3));
        vec4_t q = quat_shortest_arc(v, v);
        TESTFW_EXPECTED(test_cmp(q.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.w,1.0f) );
    TESTFW_TEST_END();
    
    TESTFW_TEST_BEGIN("quat_shortest_arc returns 180 degree rotation for opposite vectors")
        vec3_t from = vec3(1, 0, 0);
        vec3_t to = vec3(-1, 0, 0);
        vec4_t q = quat_shortest_arc(from, to);
        TESTFW_EXPECTED(test_cmp(q.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.z,1.0f) ); // rotation around Z is valid
        TESTFW_EXPECTED(test_cmp(q.w,0.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_shortest_arc rotates X to Y around Z by 90 degrees")
        vec3_t from = vec3(1, 0, 0);
        vec3_t to = vec3(0, 1, 0);
        vec4_t q = quat_shortest_arc(from, to);
        vec3_t r = quat_rotate_vector(from, q);
        TESTFW_EXPECTED(test_cmp(r.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(r.y,1.0f) );
        TESTFW_EXPECTED(test_cmp(r.z,0.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_shortest_arc rotates arbitrary normalized from/to vector")
        vec3_t from = vec3_normalize(vec3(1, 2, 3));
        vec3_t to = vec3_normalize(vec3(-1, 1, 4));
        vec4_t q = quat_shortest_arc(from, to);
        vec3_t r = quat_rotate_vector(from, q);
        TESTFW_EXPECTED(test_cmp(r.x,to.x) );
        TESTFW_EXPECTED(test_cmp(r.y,to.y) );
        TESTFW_EXPECTED(test_cmp(r.z,to.z) );
    TESTFW_TEST_END();

    // quat_from_mat33 
    TESTFW_TEST_BEGIN("quat_from_mat33 returns identity quaternion for identity matrix")
        mat33_t m = mat33(
            vec3(1, 0, 0),
            vec3(0, 1, 0),
            vec3(0, 0, 1)
        );
        vec4_t q = quat_from_mat33(m);
        TESTFW_EXPECTED(test_cmp(q.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.w,1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_from_mat33 returns 180 deg rotation quaternion around X")
        mat33_t m = mat33(
            vec3(1, 0, 0),
            vec3(0, -1, 0),
            vec3(0, 0, -1)
        );
        vec4_t q = quat_from_mat33(m);
        TESTFW_EXPECTED(test_cmp(q.x,1.0f) );
        TESTFW_EXPECTED(test_cmp(q.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.w,0.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_from_mat33 returns 90 deg rotation quaternion around Y")
        mat33_t m = mat33(
            vec3( 0, 0, -1),
            vec3( 0, 1, 0),
            vec3( 1, 0, 0)
        );
        vec4_t q = quat_from_mat33(m);
        TESTFW_EXPECTED(test_cmp(q.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.y,0.70710678f) );
        TESTFW_EXPECTED(test_cmp(q.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.w,0.70710678f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_from_mat33 returns quaternion matching known matrix rotation")
        mat33_t m = mat33(
            vec3( 0.353553f, -0.573223f, 0.739198f ),
            vec3( 0.612372f, 0.739198f, 0.280330f ),
            vec3(-0.707107f, 0.353553f, 0.612372f )
        );
        vec4_t q = quat_from_mat33(m);
        TESTFW_EXPECTED(test_cmp(q.x,-0.02225994f) );
        TESTFW_EXPECTED(test_cmp(q.y,-0.43967968f) );
        TESTFW_EXPECTED(test_cmp(q.z,-0.36042330f) );
        TESTFW_EXPECTED(test_cmp(q.w,0.82236290f) );
    TESTFW_TEST_END();

    // quat_from_mat44
    TESTFW_TEST_BEGIN("quat_from_mat44 returns identity quaternion for identity matrix")
        mat44_t m = mat44(
            vec4(1, 0, 0, 0),
            vec4(0, 1, 0, 0),
            vec4(0, 0, 1, 0),
            vec4(0, 0, 0, 1)
        );
        vec4_t q = quat_from_mat44(m);
        TESTFW_EXPECTED(test_cmp(q.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.w,1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_from_mat44 returns 180 deg rotation quaternion around X")
        mat44_t m = mat44(
            vec4(1, 0, 0, 0),
            vec4(0, -1, 0, 0),
            vec4(0, 0, -1, 0),
            vec4(0, 0, 0, 1)
        );
        vec4_t q = quat_from_mat44(m);
        TESTFW_EXPECTED(test_cmp(q.x,1.0f) );
        TESTFW_EXPECTED(test_cmp(q.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.w,0.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_from_mat44 returns 90 deg rotation quaternion around Y")
        mat44_t m = mat44(
            vec4( 0, 0, -1, 0),
            vec4( 0, 1, 0, 0),
            vec4( 1, 0, 0, 0),
            vec4( 0, 0, 0, 1)
        );
        vec4_t q = quat_from_mat44(m);
        TESTFW_EXPECTED(test_cmp(q.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.y,0.70710678f) );
        TESTFW_EXPECTED(test_cmp(q.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(q.w,0.70710678f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_from_mat44 returns quaternion matching known matrix rotation")
        mat44_t m = mat44(
            vec4( 0.353553f, -0.573223f, 0.739198f, 0.0f ),
            vec4( 0.612372f, 0.739198f, 0.280330f, 0.0f ),
            vec4(-0.707107f, 0.353553f, 0.612372f, 0.0f ),
            vec4( 0.0f, 0.0f, 0.0f, 1.0f )
        );
        vec4_t q = quat_from_mat44(m);
        TESTFW_EXPECTED(test_cmp(q.x,-0.02225994f) );
        TESTFW_EXPECTED(test_cmp(q.y,-0.43967968f) );
        TESTFW_EXPECTED(test_cmp(q.z,-0.36042330f) );
        TESTFW_EXPECTED(test_cmp(q.w,0.82236290f) );
    TESTFW_TEST_END();

    // quat_angle
    TESTFW_TEST_BEGIN("quat_angle returns 0 for identical quaternions")
        vec4_t q = quat_rotation_axis(vec3(1, 0, 0), 1.0f);
        float angle = quat_angle(q, q);
        TESTFW_EXPECTED(test_cmp(angle,0.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_angle returns 0 for negated quaternions")
        vec4_t q1 = vec4_normalize( quat_rotation_axis(vec3(0, 1, 0), 2.0f) );
        vec4_t q2 = vec4(-q1.x, -q1.y, -q1.z, -q1.w);
        float angle = quat_angle(q1, q2);
        TESTFW_EXPECTED(test_cmp(angle,0.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_angle returns PI for opposite 180-degree rotations")
        vec4_t q1 = quat_rotation_axis(vec3(0, 0, 1), 0.0f);
        vec4_t q2 = quat_rotation_axis(vec3(0, 0, 1), 3.1415926f);
        float angle = quat_angle(q1, q2);
        TESTFW_EXPECTED(test_cmp(angle,3.1415926f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("quat_angle returns expected value for 45-degree difference")
        vec4_t q1 = quat_rotation_axis(vec3(1, 0, 0), 0.0f);
        vec4_t q2 = quat_rotation_axis(vec3(1, 0, 0), 0.78539816f); // 45 degrees
        float angle = quat_angle(q1, q2);
        TESTFW_EXPECTED(test_cmp(angle,0.78539816f) );
    TESTFW_TEST_END();


    // mat33_from_quat
    TESTFW_TEST_BEGIN("mat33_from_quat returns identity matrix for identity quaternion")
        vec4_t q = vec4(0, 0, 0, 1);
        mat33_t m = mat33_from_quat(q);
        TESTFW_EXPECTED(test_cmp(m.x.x,1.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.y,1.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.z,1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat33_from_quat returns matrix rotating 180 deg around X")
        vec4_t q = quat_rotation_axis(vec3(1, 0, 0), 3.1415926f);
        mat33_t m = mat33_from_quat(q);
        TESTFW_EXPECTED(test_cmp(m.x.x,1.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.y,-1.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.z,-1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.y,1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.z.z,-1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat33_from_quat returns matrix rotating 180 deg around Y")
        vec4_t q = quat_rotation_axis(vec3(0, 1, 0), 3.1415926f);
        mat33_t m = mat33_from_quat(q);
        TESTFW_EXPECTED(test_cmp(m.x.x,-1.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.z,1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.y,1.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,-1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.z.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.z,-1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat33_from_quat returns matrix rotating 180 deg around Z")
        vec4_t q = quat_rotation_axis(vec3(0, 0, 1), 3.1415926f);
        mat33_t m = mat33_from_quat(q);
        TESTFW_EXPECTED(test_cmp(m.x.x,-1.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.y,-1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.x.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.y.y,-1.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.z,1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat33_from_quat returns matrix matching known composite rotation")
        vec4_t q = quat_rotation_axis(vec3_normalize(vec3(1, 2, 3)), 1.04719755f);
        mat33_t m = mat33_from_quat(q);
        TESTFW_EXPECTED(test_cmp(m.x.x,0.5357143283f) );
        TESTFW_EXPECTED(test_cmp(m.x.y,0.7657935619f) );
        TESTFW_EXPECTED(test_cmp(m.x.z,-0.3557671905f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,-0.6229364872f) );
        TESTFW_EXPECTED(test_cmp(m.y.y,0.6428571939f) );
        TESTFW_EXPECTED(test_cmp(m.y.z,0.4457406998f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,0.5700528622f) );
        TESTFW_EXPECTED(test_cmp(m.z.y,-0.0171693116f) );
        TESTFW_EXPECTED(test_cmp(m.z.z,0.8214285970f) );
    TESTFW_TEST_END();

    // mat44_from_quat
    TESTFW_TEST_BEGIN("mat44_from_quat returns identity matrix for identity quaternion")
        vec4_t q = vec4(0, 0, 0, 1);
        mat44_t m = mat44_from_quat(q);
        TESTFW_EXPECTED(test_cmp(m.x.x,1.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.y,1.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.z,1.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.w,1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_from_quat returns 180 degree rotation matrix around X")
        vec4_t q = quat_rotation_axis(vec3(1, 0, 0), 3.1415926f);
        mat44_t m = mat44_from_quat(q);
        TESTFW_EXPECTED(test_cmp(m.x.x,1.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.y,-1.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.z,-1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.y.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.y,1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.z.z,-1.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.w,1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_from_quat returns 180 degree rotation matrix around Y")
        vec4_t q = quat_rotation_axis(vec3(0, 1, 0), 3.1415926f);
        mat44_t m = mat44_from_quat(q);
        TESTFW_EXPECTED(test_cmp(m.x.x,-1.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.z,1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.x.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.y,1.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,-1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.z.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.z,-1.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.w,1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_from_quat returns 180 degree rotation matrix around Z")
        vec4_t q = quat_rotation_axis(vec3(0, 0, 1), 3.1415926f);
        mat44_t m = mat44_from_quat(q);
        TESTFW_EXPECTED(test_cmp(m.x.x,-1.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.y,-1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.x.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.x.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,1.2246469e-16f) );
        TESTFW_EXPECTED(test_cmp(m.y.y,-1.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.z,1.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.w,1.0f) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_from_quat returns matrix matching known composite rotation")
        vec4_t q = quat_rotation_axis(vec3_normalize(vec3(1, 2, 3)), 1.04719755f);
        mat44_t m = mat44_from_quat(q);
        TESTFW_EXPECTED(test_cmp(m.x.x,0.5357143283f) );
        TESTFW_EXPECTED(test_cmp(m.x.y,0.7657935619f) );
        TESTFW_EXPECTED(test_cmp(m.x.z,-0.3557671905f) );
        TESTFW_EXPECTED(test_cmp(m.x.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,-0.6229364872f) );
        TESTFW_EXPECTED(test_cmp(m.y.y,0.6428571939f) );
        TESTFW_EXPECTED(test_cmp(m.y.z,0.4457406998f) );
        TESTFW_EXPECTED(test_cmp(m.y.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,0.5700528622f) );
        TESTFW_EXPECTED(test_cmp(m.z.y,-0.0171693116f) );
        TESTFW_EXPECTED(test_cmp(m.z.z,0.8214285970f) );
        TESTFW_EXPECTED(test_cmp(m.z.w,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.x,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.y,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.z,0.0f) );
        TESTFW_EXPECTED(test_cmp(m.w.w,1.0f) );
    TESTFW_TEST_END();
}

void test_matrix_utils( void ) {
    // mat44_look_at_lh
    TESTFW_TEST_BEGIN( "mat44_look_at_lh is identity when looking along +Z from origin" )
        mat44_t m = mat44_look_at_lh(
            vec3( 0.0f, 0.0f, 0.0f ),
            vec3( 0.0f, 0.0f, 1.0f ),
            vec3( 0.0f, 1.0f, 0.0f )
        );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 1.0f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 1.0f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_lh builds +X forward matrix with Y-up" )
        mat44_t m = mat44_look_at_lh(
            vec3( 0.0f, 0.0f, 0.0f ),
            vec3( 1.0f, 0.0f, 0.0f ),
            vec3( 0.0f, 1.0f, 0.0f )
        );
        TESTFW_EXPECTED( m.x.x == 0.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 1.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 1.0f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == -1.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 0.0f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_lh builds -Y forward matrix with Z-up" )
        mat44_t m = mat44_look_at_lh(
            vec3( 0.0f, 0.0f, 0.0f ),
            vec3( 0.0f, -1.0f, 0.0f ),
            vec3( 0.0f, 0.0f, 1.0f )
        );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.0f ); TESTFW_EXPECTED( m.y.z == -1.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 1.0f ); TESTFW_EXPECTED( m.z.z == 0.0f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_lh maps eye to view-space origin" )
        mat44_t m = mat44_look_at_lh(
            vec3( 1.0f, 2.0f, 3.0f ),
            vec3( 4.0f, 6.0f, 9.0f ),
            vec3( 0.0f, 1.0f, 0.0f )
        );
        vec4_t p = vec4( 1.0f, 2.0f, 3.0f, 1.0f );
        vec4_t v = vec4_mul_mat44( p, m );
        TESTFW_EXPECTED( v.x == 0.0f );
        TESTFW_EXPECTED( v.y == 0.0f );
        TESTFW_EXPECTED( v.z == 0.0f );
        TESTFW_EXPECTED( v.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_lh basis matches expected orientation" )
        vec3_t eye = vec3( 0.0f, 0.0f, 0.0f );
        vec3_t at = vec3( 0.0f, 0.0f, 1.0f );
        vec3_t up = vec3( 0.0f, 1.0f, 0.0f );
        mat44_t m = mat44_look_at_lh( eye, at, up );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 0.0f );
        TESTFW_EXPECTED( m.x.z == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f );
        TESTFW_EXPECTED( m.y.y == 1.0f );
        TESTFW_EXPECTED( m.y.z == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f );
        TESTFW_EXPECTED( m.z.y == 0.0f );
        TESTFW_EXPECTED( m.z.z == 1.0f );
    TESTFW_TEST_END();

    // mat44_look_at_rh
    TESTFW_TEST_BEGIN( "mat44_look_at_rh is identity when looking along -Z from origin" )
        mat44_t m = mat44_look_at_rh(
            vec3( 0.0f, 0.0f, 0.0f ),
            vec3( 0.0f, 0.0f, -1.0f ),
            vec3( 0.0f, 1.0f, 0.0f )
        );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 1.0f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 1.0f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_rh builds +X forward matrix with Y-up" )
        mat44_t m = mat44_look_at_rh(
            vec3( 0.0f, 0.0f, 0.0f ),
            vec3( 1.0f, 0.0f, 0.0f ),
            vec3( 0.0f, 1.0f, 0.0f )
        );
        TESTFW_EXPECTED( m.x.x == 0.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == -1.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 1.0f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 1.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 0.0f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_rh builds -Y forward matrix with Z-up" )
        mat44_t m = mat44_look_at_rh(
            vec3( 0.0f, 0.0f, 0.0f ),
            vec3( 0.0f, -1.0f, 0.0f ),
            vec3( 0.0f, 0.0f, 1.0f )
        );
        TESTFW_EXPECTED( m.x.x == -1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.0f ); TESTFW_EXPECTED( m.y.z == 1.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 1.0f ); TESTFW_EXPECTED( m.z.z == 0.0f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_rh maps eye to view-space origin" )
        mat44_t m = mat44_look_at_rh(
            vec3( 1.0f, 2.0f, 3.0f ),
            vec3( 4.0f, 6.0f, 9.0f ),
            vec3( 0.0f, 1.0f, 0.0f )
        );
        vec4_t p = vec4( 1.0f, 2.0f, 3.0f, 1.0f );
        vec4_t v = vec4_mul_mat44( p, m );
        TESTFW_EXPECTED( v.x == 0.0f );
        TESTFW_EXPECTED( v.y == 0.0f );
        TESTFW_EXPECTED( v.z == 0.0f );
        TESTFW_EXPECTED( v.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_rh basis matches expected orientation" )
        vec3_t eye = vec3( 0.0f, 0.0f, 0.0f );
        vec3_t at = vec3( 0.0f, 0.0f, -1.0f );
        vec3_t up = vec3( 0.0f, 1.0f, 0.0f );
        mat44_t m = mat44_look_at_rh( eye, at, up );
        TESTFW_EXPECTED( m.x.x == 1.0f );
        TESTFW_EXPECTED( m.x.y == 0.0f );
        TESTFW_EXPECTED( m.x.z == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f );
        TESTFW_EXPECTED( m.y.y == 1.0f );
        TESTFW_EXPECTED( m.y.z == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f );
        TESTFW_EXPECTED( m.z.y == 0.0f );
        TESTFW_EXPECTED( m.z.z == 1.0f );
    TESTFW_TEST_END();

    // mat44_ortho_lh
    TESTFW_TEST_BEGIN( "mat44_ortho_lh produces expected matrix for w=2, h=4, zn=1, zf=5" )
        mat44_t m = mat44_ortho_lh( 2.0f, 4.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 0.25f );TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -0.25f );TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_lh handles symmetric volume at origin" )
        mat44_t m = mat44_ortho_lh( 10.0f, 10.0f, 0.0f, 10.0f );
        TESTFW_EXPECTED( m.x.x == 0.2f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.2f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 0.1f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    // mat44_ortho_rh
    TESTFW_TEST_BEGIN( "mat44_ortho_rh produces expected matrix for w=2, h=4, zn=1, zf=5" )
        mat44_t m = mat44_ortho_rh( 2.0f, 4.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == -0.25f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -0.25f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_rh handles symmetric volume at origin" )
        mat44_t m = mat44_ortho_rh( 10.0f, 10.0f, 0.0f, 10.0f );
        TESTFW_EXPECTED( m.x.x == 0.2f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.2f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == -0.1f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    // mat44_ortho_off_center_lh
    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_lh produces expected matrix for l=-1, r=1, b=-2, t=2, zn=1, zf=5" )
        mat44_t m = mat44_ortho_off_center_lh( -1.0f, 1.0f, -2.0f, 2.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 0.25f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -0.25f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_lh handles symmetric centered volume" )
        mat44_t m = mat44_ortho_off_center_lh( -5.0f, 5.0f, -5.0f, 5.0f, 0.0f, 10.0f );
        TESTFW_EXPECTED( m.x.x == 0.2f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.2f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 0.1f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_lh produces translation for asymmetric view volume" )
        mat44_t m = mat44_ortho_off_center_lh( 1.0f, 5.0f, -3.0f, 1.0f, 0.0f, 4.0f );
        TESTFW_EXPECTED( m.x.x == 0.5f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.z == 0.25f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == -1.5f ); TESTFW_EXPECTED( m.w.y == 0.5f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    // mat44_ortho_off_center_rh
    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_rh produces expected matrix for l=-1, r=1, b=-2, t=2, zn=1, zf=5" )
        mat44_t m = mat44_ortho_off_center_rh( -1.0f, 1.0f, -2.0f, 2.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == -0.25f );TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -0.25f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_rh handles symmetric centered volume" )
        mat44_t m = mat44_ortho_off_center_rh( -5.0f, 5.0f, -5.0f, 5.0f, 0.0f, 10.0f );
        TESTFW_EXPECTED( m.x.x == 0.2f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.2f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == -0.1f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_rh produces translation for asymmetric view volume" )
        mat44_t m = mat44_ortho_off_center_rh( 1.0f, 5.0f, -3.0f, 1.0f, 0.0f, 4.0f );
        TESTFW_EXPECTED( m.x.x == 0.5f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == -0.25f ); TESTFW_EXPECTED( m.z.w == 0.0f );
        TESTFW_EXPECTED( m.w.x == -1.5f ); TESTFW_EXPECTED( m.w.y == 0.5f ); TESTFW_EXPECTED( m.w.z == 0.0f ); TESTFW_EXPECTED( m.w.w == 1.0f );
    TESTFW_TEST_END();

    // mat44_perspective_lh
    TESTFW_TEST_BEGIN( "mat44_perspective_lh produces expected matrix for w=2, h=4, zn=1, zf=5" )
        mat44_t m = mat44_perspective_lh( 2.0f, 4.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 1.25f ); TESTFW_EXPECTED( m.z.w == 1.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -1.25f ); TESTFW_EXPECTED( m.w.w == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_lh handles symmetric centered frustum at origin" )
        mat44_t m = mat44_perspective_lh( 10.0f, 10.0f, 1.0f, 11.0f );
        TESTFW_EXPECTED( m.x.x == 0.2f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.2f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 1.1f ); TESTFW_EXPECTED( m.z.w == 1.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -1.1f ); TESTFW_EXPECTED( m.w.w == 0.0f );
    TESTFW_TEST_END();

    // mat44_perspective_rh
    TESTFW_TEST_BEGIN( "mat44_perspective_rh produces expected matrix for w=2, h=4, zn=1, zf=5" )
        mat44_t m = mat44_perspective_rh( 2.0f, 4.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == -1.25f ); TESTFW_EXPECTED( m.z.w == -1.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -1.25f ); TESTFW_EXPECTED( m.w.w == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_rh handles symmetric centered frustum at origin" )
        mat44_t m = mat44_perspective_rh( 10.0f, 10.0f, 1.0f, 11.0f );
        TESTFW_EXPECTED( m.x.x == 0.2f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.2f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == -1.1f ); TESTFW_EXPECTED( m.z.w == -1.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -1.1f ); TESTFW_EXPECTED( m.w.w == 0.0f );
    TESTFW_TEST_END();

    // mat44_perspective_off_center_lh
    TESTFW_TEST_BEGIN( "mat44_perspective_off_center_lh produces expected matrix for l=-1, r=1, b=-2, t=2, zn=1, zf=5" )
        mat44_t m = mat44_perspective_off_center_lh( -1.0f, 1.0f, -2.0f, 2.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 1.25f ); TESTFW_EXPECTED( m.z.w == 1.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -1.25f ); TESTFW_EXPECTED( m.w.w == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_off_center_lh handles asymmetric frustum with translation" )
        mat44_t m = mat44_perspective_off_center_lh( 1.0f, 5.0f, -3.0f, 1.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 0.5f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == -1.5f ); TESTFW_EXPECTED( m.z.y == 0.5f ); TESTFW_EXPECTED( m.z.z == 1.25f ); TESTFW_EXPECTED( m.z.w == 1.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -1.25f ); TESTFW_EXPECTED( m.w.w == 0.0f );
    TESTFW_TEST_END();

    // mat44_perspective_off_center_rh
    TESTFW_TEST_BEGIN( "mat44_perspective_off_center_rh produces expected matrix for l=-1, r=1, b=-2, t=2, zn=1, zf=5" )
        mat44_t m = mat44_perspective_off_center_rh( -1.0f, 1.0f, -2.0f, 2.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == -1.25f ); TESTFW_EXPECTED( m.z.w == -1.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -1.25f ); TESTFW_EXPECTED( m.w.w == 0.0f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_off_center_rh handles asymmetric frustum with translation" )
        mat44_t m = mat44_perspective_off_center_rh( 1.0f, 5.0f, -3.0f, 1.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 0.5f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 0.5f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 1.5f ); TESTFW_EXPECTED( m.z.y == -0.5f ); TESTFW_EXPECTED( m.z.z == -1.25f ); TESTFW_EXPECTED( m.z.w == -1.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -1.25f ); TESTFW_EXPECTED( m.w.w == 0.0f );
    TESTFW_TEST_END();

    // mat44_perspective_fov_lh
    TESTFW_TEST_BEGIN( "mat44_perspective_fov_lh produces expected matrix for fovy=90, aspect=1, zn=1, zf=5" )
        mat44_t m = mat44_perspective_fov_lh( 1.57079633f, 1.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 1.0f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == 1.25f ); TESTFW_EXPECTED( m.z.w == 1.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -1.25f ); TESTFW_EXPECTED( m.w.w == 0.0f );
    TESTFW_TEST_END();

    // mat44_perspective_fov_rh
    TESTFW_TEST_BEGIN( "mat44_perspective_fov_rh produces expected matrix for fovy=90deg, aspect=1, zn=1, zf=5" )
        mat44_t m = mat44_perspective_fov_rh( 1.57079633f, 1.0f, 1.0f, 5.0f );
        TESTFW_EXPECTED( m.x.x == 1.0f ); TESTFW_EXPECTED( m.x.y == 0.0f ); TESTFW_EXPECTED( m.x.z == 0.0f ); TESTFW_EXPECTED( m.x.w == 0.0f );
        TESTFW_EXPECTED( m.y.x == 0.0f ); TESTFW_EXPECTED( m.y.y == 1.0f ); TESTFW_EXPECTED( m.y.z == 0.0f ); TESTFW_EXPECTED( m.y.w == 0.0f );
        TESTFW_EXPECTED( m.z.x == 0.0f ); TESTFW_EXPECTED( m.z.y == 0.0f ); TESTFW_EXPECTED( m.z.z == -1.25f ); TESTFW_EXPECTED( m.z.w == -1.0f );
        TESTFW_EXPECTED( m.w.x == 0.0f ); TESTFW_EXPECTED( m.w.y == 0.0f ); TESTFW_EXPECTED( m.w.z == -1.25f ); TESTFW_EXPECTED( m.w.w == 0.0f );
    TESTFW_TEST_END();

    // mat44_rotation_axis
    TESTFW_TEST_BEGIN( "mat44_rotation_axis produces 90deg rotation around +X axis" )
        vec3_t axis = vec3( 1.0f, 0.0f, 0.0f );
        float angle = 1.57079633f;
        mat44_t m = mat44_rotation_axis( axis, angle );
        TESTFW_EXPECTED( test_cmp(m.x.x,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_axis produces 90deg rotation around +Y axis" )
        vec3_t axis = vec3( 0.0f, 1.0f, 0.0f );
        float angle = 1.57079633f;
        mat44_t m = mat44_rotation_axis( axis, angle );
        TESTFW_EXPECTED( test_cmp(m.x.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_axis produces 90deg rotation around +Z axis" )
        vec3_t axis = vec3( 0.0f, 0.0f, 1.0f );
        float angle = 1.57079633f;
        mat44_t m = mat44_rotation_axis( axis, angle );
        TESTFW_EXPECTED( test_cmp(m.x.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_axis produces 60deg rotation around arbitrary normalized axis" )
        vec3_t axis = vec3_normalize(vec3( 1.0f, 2.0f, 3.0f ));
        float angle = 1.04719755f; // 60deg in radians
        mat44_t m = mat44_rotation_axis( axis, angle );
        vec3_t r0 = vec3( m.x.x, m.x.y, m.x.z );
        vec3_t r1 = vec3( m.y.x, m.y.y, m.y.z );
        vec3_t r2 = vec3( m.z.x, m.z.y, m.z.z );
        TESTFW_EXPECTED( test_cmp(vec3_dot(r0, r0),1.0f)  );
        TESTFW_EXPECTED( test_cmp(vec3_dot(r1, r1),1.0f)  );
        TESTFW_EXPECTED( test_cmp(vec3_dot(r2, r2),1.0f)  );
        TESTFW_EXPECTED( test_cmp(vec3_dot(r0, r1), 0.0f ) );
        TESTFW_EXPECTED( test_cmp(vec3_dot(r0, r2), 0.0f ) );
        TESTFW_EXPECTED( test_cmp(vec3_dot(r1, r2), 0.0f ) );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    // mat44_rotation_x
    TESTFW_TEST_BEGIN( "mat44_rotation_x produces 90deg rotation around +X axis" )
        float angle = 1.57079633f; // 90deg in radians
        mat44_t m = mat44_rotation_x(angle);
        TESTFW_EXPECTED( test_cmp(m.x.x,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    // mat44_rotation_y
    TESTFW_TEST_BEGIN( "mat44_rotation_y produces 90deg rotation around +Y axis" )
        float angle = 1.57079633f; // 90deg in radians
        mat44_t m = mat44_rotation_y(angle);
        TESTFW_EXPECTED( test_cmp(m.x.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    // mat44_rotation_z
    TESTFW_TEST_BEGIN( "mat44_rotation_z produces 90deg rotation around +Z axis" )
        float angle = 1.57079633f; // 90deg in radians
        mat44_t m = mat44_rotation_z(angle);
        TESTFW_EXPECTED( test_cmp(m.x.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    // mat44_rotation_yaw_pitch_roll
    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll produces matrix for roll = PI" )
        float yaw = 0.0f;
        float pitch = 0.0f;
        float roll = 3.14159265f;
        mat44_t m = mat44_rotation_yaw_pitch_roll( yaw, pitch, roll );
        TESTFW_EXPECTED( test_cmp(m.x.x,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll produces matrix for pitch = PI" )
        float yaw = 0.0f;
        float pitch = 3.14159265f;
        float roll = 0.0f;
        mat44_t m = mat44_rotation_yaw_pitch_roll( yaw, pitch, roll );
        TESTFW_EXPECTED( test_cmp(m.x.x,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll produces matrix for yaw = PI" )
        float yaw = 3.14159265f;
        float pitch = 0.0f;
        float roll = 0.0f;
        mat44_t m = mat44_rotation_yaw_pitch_roll( yaw, pitch, roll );
        TESTFW_EXPECTED( test_cmp(m.x.x,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,0.000000f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,-1.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll produces expected matrix for known angles" )
        float yaw = 0.25f;
        float pitch = 1.0f;
        float roll = 0.5f;
        mat44_t m = mat44_rotation_yaw_pitch_roll( yaw, pitch, roll );      
        TESTFW_EXPECTED(test_cmp(m.x.x,0.950109005f) ); TESTFW_EXPECTED(test_cmp(m.x.y,0.259034753f) ); TESTFW_EXPECTED(test_cmp(m.x.z,0.173763901f) ); TESTFW_EXPECTED(test_cmp(m.x.w,0.00000000f) );
        TESTFW_EXPECTED(test_cmp(m.y.x,-0.281823397f) ); TESTFW_EXPECTED(test_cmp(m.y.y,0.474159837f) ); TESTFW_EXPECTED(test_cmp(m.y.z,0.834115207f) ); TESTFW_EXPECTED(test_cmp(m.y.w,0.00000000f) );
        TESTFW_EXPECTED(test_cmp(m.z.x,0.133672923f) ); TESTFW_EXPECTED(test_cmp(m.z.y,-0.841471136f) ); TESTFW_EXPECTED(test_cmp(m.z.z,0.523505569f) ); TESTFW_EXPECTED(test_cmp(m.z.w,0.00000000f) );
        TESTFW_EXPECTED(test_cmp(m.w.x,0.0f) ); TESTFW_EXPECTED(test_cmp(m.w.y,0.0f) ); TESTFW_EXPECTED(test_cmp(m.w.z,0.0f) ); TESTFW_EXPECTED(test_cmp(m.w.w,1.0f) );
    TESTFW_TEST_END();

    // mat44_scaling
    TESTFW_TEST_BEGIN( "mat44_scaling produces correct matrix for sx=2, sy=3, sz=4" )
        mat44_t m = mat44_scaling( 2.0f, 3.0f, 4.0f );

        TESTFW_EXPECTED( test_cmp(m.x.x,2.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,3.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,4.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    // mat44_translation
    TESTFW_TEST_BEGIN( "mat44_translation produces correct matrix for tx=2, ty=3, tz=4" )
        mat44_t m = mat44_translation( 2.0f, 3.0f, 4.0f );

        TESTFW_EXPECTED( test_cmp(m.x.x,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.x.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.y.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.y,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.z,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.y.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.z.x,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.y,0.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.z,1.0f)  ); TESTFW_EXPECTED( test_cmp(m.z.w,0.0f)  );
        TESTFW_EXPECTED( test_cmp(m.w.x,2.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.y,3.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.z,4.0f)  ); TESTFW_EXPECTED( test_cmp(m.w.w,1.0f)  );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN("mat44_decompose extracts scale, rotation, and translation from matrix with rotation around Y and X")
        mat44_t mS = mat44_scaling(2.0f,3.0f,4.0f);
        mat44_t mR = mat44_rotation_yaw_pitch_roll(3.14159265f*0.5f,3.14159265f,0.0f);
        mat44_t mT = mat44_translation(5.0f,6.0f,7.0f);
        mat44_t m = mat44_mul_mat44(mat44_mul_mat44(mS,mR),mT);
        vec3_t s,t; vec4_t q; mat44_decompose(&s,&q,&t,m);
        vec4_t expected_q = vec4(vecmath_sin(-3.14159265f/4.0f),0.0f,vecmath_sin(3.14159265f/4.0f),0.0f);
        TESTFW_EXPECTED(test_cmp(s.x,2.0f)&&test_cmp(s.y,3.0f)&&test_cmp(s.z,4.0f));
        TESTFW_EXPECTED(test_cmp(t.x,5.0f)&&test_cmp(t.y,6.0f)&&test_cmp(t.z,7.0f));
        TESTFW_EXPECTED(test_cmp(q.x,expected_q.x)&&test_cmp(q.y,expected_q.y)&&test_cmp(q.z,expected_q.z)&&test_cmp(q.w,expected_q.w));
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_transform applies rotation, scaling, and translation as vec4" )
        vec2_t v = vec2( 1.0f, 2.0f );
        mat44_t m = mat44_mul_mat44( mat44_mul_mat44( mat44_rotation_z( 1.57079633f ), mat44_scaling( 2.0f, 3.0f, 4.0f ) ), mat44_translation( 10.0f, 20.0f, 30.0f ) );
        vec4_t r = vec2_transform( v, m );
        TESTFW_EXPECTED( test_cmp( r.x, 6.0f ) );
        TESTFW_EXPECTED( test_cmp( r.y, 23.0f ) );
        TESTFW_EXPECTED( test_cmp( r.z, 30.0f ) );
        TESTFW_EXPECTED( test_cmp( r.w, 1.0f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_transform_coord applies rotation, scaling, translation and perspective divide" )
        vec2_t v = vec2( 1.0f, 2.0f );
        mat44_t m = mat44_mul_mat44( mat44_mul_mat44( mat44_rotation_z( 1.57079633f ), mat44_scaling( 2.0f, 3.0f, 4.0f ) ), mat44_translation( 10.0f, 20.0f, 30.0f ) );
        m = mat44_mul_mat44( m, mat44_perspective_lh( 100.0f, 100.0f, 1.0f, 1000.0f ) );
        vec2_t r = vec2_transform_coord( v, m );
        TESTFW_EXPECTED( test_cmp( r.x, 0.004f ) );
        TESTFW_EXPECTED( test_cmp( r.y, 0.01533333f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_transform_normal applies rotation and scaling but ignores translation" )
        vec2_t v = vec2( 1.0f, 2.0f );
        mat44_t m = mat44_mul_mat44( mat44_mul_mat44( mat44_rotation_z( 1.57079633f ), mat44_scaling( 2.0f, 3.0f, 4.0f ) ), mat44_translation( 10.0f, 20.0f, 30.0f ) );
        vec2_t r = vec2_transform_normal( v, m );
        TESTFW_EXPECTED( test_cmp( r.x, -4.0f ) );
        TESTFW_EXPECTED( test_cmp( r.y, 3.0f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_transform applies rotation, scaling, and translation as vec4" )
        vec3_t v = vec3( 1.0f, 2.0f, 3.0f );
        mat44_t m = mat44_mul_mat44( mat44_mul_mat44( mat44_rotation_z( 1.57079633f ), mat44_scaling( 2.0f, 3.0f, 4.0f ) ), mat44_translation( 10.0f, 20.0f, 30.0f ) );
        vec4_t r = vec3_transform( v, m );
        TESTFW_EXPECTED( test_cmp( r.x, 6.0f ) );
        TESTFW_EXPECTED( test_cmp( r.y, 23.0f ) );
        TESTFW_EXPECTED( test_cmp( r.z, 42.0f ) );
        TESTFW_EXPECTED( test_cmp( r.w, 1.0f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_transform_coord applies rotation, scaling, translation and perspective divide" )
        vec3_t v = vec3( 1.0f, 2.0f, 3.0f );
        mat44_t m = mat44_mul_mat44( mat44_mul_mat44( mat44_rotation_z( 1.57079633f ), mat44_scaling( 2.0f, 3.0f, 4.0f ) ), mat44_translation( 10.0f, 20.0f, 30.0f ) );
        m = mat44_mul_mat44( m, mat44_perspective_lh( 100.0f, 100.0f, 1.0f, 1000.0f ) );
        vec3_t r = vec3_transform_coord( v, m );
        TESTFW_EXPECTED( test_cmp( r.x, 0.00285714f ) );
        TESTFW_EXPECTED( test_cmp( r.y, 0.01095238f ) );
        TESTFW_EXPECTED( test_cmp( r.z, 0.97716764f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_transform_normal applies rotation and scaling but ignores translation" )
        vec3_t v = vec3( 1.0f, 2.0f, 3.0f );
        mat44_t m = mat44_mul_mat44( mat44_mul_mat44( mat44_rotation_z( 1.57079633f ), mat44_scaling( 2.0f, 3.0f, 4.0f ) ), mat44_translation( 10.0f, 20.0f, 30.0f ) );
        vec3_t r = vec3_transform_normal( v, m );
        TESTFW_EXPECTED( test_cmp( r.x, -4.0f ) );
        TESTFW_EXPECTED( test_cmp( r.y, 3.0f ) );
        TESTFW_EXPECTED( test_cmp( r.z, 12.0f ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_transform applies rotation, scaling, and translation" )
        vec4_t v = vec4( 1.0f, 2.0f, 3.0f, 1.0f );
        mat44_t m = mat44_mul_mat44( mat44_mul_mat44( mat44_rotation_z( 1.57079633f ), mat44_scaling( 2.0f, 3.0f, 4.0f ) ), mat44_translation( 10.0f, 20.0f, 30.0f ) );
        vec4_t r = vec4_transform( v, m );
        TESTFW_EXPECTED( test_cmp( r.x, 6.0f ) );
        TESTFW_EXPECTED( test_cmp( r.y, 23.0f ) );
        TESTFW_EXPECTED( test_cmp( r.z, 42.0f ) );
        TESTFW_EXPECTED( test_cmp( r.w, 1.0f ) );
    TESTFW_TEST_END();

}


void test_swizzling_vec2( void ) {

    // vec2 swizzling from vec2

    TESTFW_TEST_BEGIN( "vec2 swizzling from vec2" )
        TESTFW_EXPECTED( vec2_eq( vec2_xx( vec2( 1, 2 ) ), vec2( 1, 1 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec2_xy( vec2( 1, 2 ) ), vec2( 1, 2 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec2_yx( vec2( 1, 2 ) ), vec2( 2, 1 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec2_yy( vec2( 1, 2 ) ), vec2( 2, 2 ) ) );
    TESTFW_TEST_END();


    // vec3 swizzling from vec2

    TESTFW_TEST_BEGIN( "vec3 swizzling from vec2" )
        TESTFW_EXPECTED( vec3_eq( vec2_xxx( vec2( 1, 2 ) ), vec3( 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec2_xxy( vec2( 1, 2 ) ), vec3( 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec2_xyx( vec2( 1, 2 ) ), vec3( 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec2_xyy( vec2( 1, 2 ) ), vec3( 1, 2, 2 ) ) );

        TESTFW_EXPECTED( vec3_eq( vec2_yxx( vec2( 1, 2 ) ), vec3( 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec2_yxy( vec2( 1, 2 ) ), vec3( 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec2_yyx( vec2( 1, 2 ) ), vec3( 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec2_yyy( vec2( 1, 2 ) ), vec3( 2, 2, 2 ) ) );
    TESTFW_TEST_END();


    // vec4 swizzling from vec2

    TESTFW_TEST_BEGIN( "vec4 swizzling from vec2" )
        TESTFW_EXPECTED( vec4_eq( vec2_xxxx( vec2( 1, 2 ) ), vec4( 1, 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_xxxy( vec2( 1, 2 ) ), vec4( 1, 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_xxyx( vec2( 1, 2 ) ), vec4( 1, 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_xxyy( vec2( 1, 2 ) ), vec4( 1, 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_xyxx( vec2( 1, 2 ) ), vec4( 1, 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_xyxy( vec2( 1, 2 ) ), vec4( 1, 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_xyyx( vec2( 1, 2 ) ), vec4( 1, 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_xyyy( vec2( 1, 2 ) ), vec4( 1, 2, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_yxxx( vec2( 1, 2 ) ), vec4( 2, 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_yxxy( vec2( 1, 2 ) ), vec4( 2, 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_yxyx( vec2( 1, 2 ) ), vec4( 2, 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_yxyy( vec2( 1, 2 ) ), vec4( 2, 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_yyxx( vec2( 1, 2 ) ), vec4( 2, 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_yyxy( vec2( 1, 2 ) ), vec4( 2, 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_yyyx( vec2( 1, 2 ) ), vec4( 2, 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2_yyyy( vec2( 1, 2 ) ), vec4( 2, 2, 2, 2 ) ) );
    TESTFW_TEST_END();
}


void test_swizzling_vec3( void ) {

    // vec2 swizzling from vec3

    TESTFW_TEST_BEGIN( "vec2 swizzling from vec3" )
        TESTFW_EXPECTED( vec2_eq( vec3_xx( vec3( 1, 2, 3 ) ), vec2( 1, 1 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec3_xy( vec3( 1, 2, 3 ) ), vec2( 1, 2 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec3_xz( vec3( 1, 2, 3 ) ), vec2( 1, 3 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec3_yx( vec3( 1, 2, 3 ) ), vec2( 2, 1 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec3_yy( vec3( 1, 2, 3 ) ), vec2( 2, 2 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec3_yz( vec3( 1, 2, 3 ) ), vec2( 2, 3 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec3_zx( vec3( 1, 2, 3 ) ), vec2( 3, 1 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec3_zy( vec3( 1, 2, 3 ) ), vec2( 3, 2 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec3_zz( vec3( 1, 2, 3 ) ), vec2( 3, 3 ) ) );
    TESTFW_TEST_END();


    // vec3 swizzling from vec3

    TESTFW_TEST_BEGIN( "vec3 swizzling from vec3" )
        TESTFW_EXPECTED( vec3_eq( vec3_xxx( vec3( 1, 2, 3 ) ), vec3( 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_xxy( vec3( 1, 2, 3 ) ), vec3( 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_xxz( vec3( 1, 2, 3 ) ), vec3( 1, 1, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_xyx( vec3( 1, 2, 3 ) ), vec3( 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_xyy( vec3( 1, 2, 3 ) ), vec3( 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_xyz( vec3( 1, 2, 3 ) ), vec3( 1, 2, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_xzx( vec3( 1, 2, 3 ) ), vec3( 1, 3, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_xzy( vec3( 1, 2, 3 ) ), vec3( 1, 3, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_xzz( vec3( 1, 2, 3 ) ), vec3( 1, 3, 3 ) ) );

        TESTFW_EXPECTED( vec3_eq( vec3_yxx( vec3( 1, 2, 3 ) ), vec3( 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_yxy( vec3( 1, 2, 3 ) ), vec3( 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_yxz( vec3( 1, 2, 3 ) ), vec3( 2, 1, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_yyx( vec3( 1, 2, 3 ) ), vec3( 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_yyy( vec3( 1, 2, 3 ) ), vec3( 2, 2, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_yyz( vec3( 1, 2, 3 ) ), vec3( 2, 2, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_yzx( vec3( 1, 2, 3 ) ), vec3( 2, 3, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_yzy( vec3( 1, 2, 3 ) ), vec3( 2, 3, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_yzz( vec3( 1, 2, 3 ) ), vec3( 2, 3, 3 ) ) );

        TESTFW_EXPECTED( vec3_eq( vec3_zxx( vec3( 1, 2, 3 ) ), vec3( 3, 1, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_zxy( vec3( 1, 2, 3 ) ), vec3( 3, 1, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_zxz( vec3( 1, 2, 3 ) ), vec3( 3, 1, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_zyx( vec3( 1, 2, 3 ) ), vec3( 3, 2, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_zyy( vec3( 1, 2, 3 ) ), vec3( 3, 2, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_zyz( vec3( 1, 2, 3 ) ), vec3( 3, 2, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_zzx( vec3( 1, 2, 3 ) ), vec3( 3, 3, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_zzy( vec3( 1, 2, 3 ) ), vec3( 3, 3, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3_zzz( vec3( 1, 2, 3 ) ), vec3( 3, 3, 3 ) ) );
    TESTFW_TEST_END();


    // vec4 swizzling from vec3

    TESTFW_TEST_BEGIN( "vec4 swizzling from vec3" )
        TESTFW_EXPECTED( vec4_eq( vec3_xxxx( vec3( 1, 2, 3 ) ), vec4( 1, 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xxxy( vec3( 1, 2, 3 ) ), vec4( 1, 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xxxz( vec3( 1, 2, 3 ) ), vec4( 1, 1, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xxyx( vec3( 1, 2, 3 ) ), vec4( 1, 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xxyy( vec3( 1, 2, 3 ) ), vec4( 1, 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xxyz( vec3( 1, 2, 3 ) ), vec4( 1, 1, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xxzx( vec3( 1, 2, 3 ) ), vec4( 1, 1, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xxzy( vec3( 1, 2, 3 ) ), vec4( 1, 1, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xxzz( vec3( 1, 2, 3 ) ), vec4( 1, 1, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xyxx( vec3( 1, 2, 3 ) ), vec4( 1, 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xyxy( vec3( 1, 2, 3 ) ), vec4( 1, 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xyxz( vec3( 1, 2, 3 ) ), vec4( 1, 2, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xyyx( vec3( 1, 2, 3 ) ), vec4( 1, 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xyyy( vec3( 1, 2, 3 ) ), vec4( 1, 2, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xyyz( vec3( 1, 2, 3 ) ), vec4( 1, 2, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xyzx( vec3( 1, 2, 3 ) ), vec4( 1, 2, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xyzy( vec3( 1, 2, 3 ) ), vec4( 1, 2, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xyzz( vec3( 1, 2, 3 ) ), vec4( 1, 2, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xzxx( vec3( 1, 2, 3 ) ), vec4( 1, 3, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xzxy( vec3( 1, 2, 3 ) ), vec4( 1, 3, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xzxz( vec3( 1, 2, 3 ) ), vec4( 1, 3, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xzyx( vec3( 1, 2, 3 ) ), vec4( 1, 3, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xzyy( vec3( 1, 2, 3 ) ), vec4( 1, 3, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xzyz( vec3( 1, 2, 3 ) ), vec4( 1, 3, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xzzx( vec3( 1, 2, 3 ) ), vec4( 1, 3, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xzzy( vec3( 1, 2, 3 ) ), vec4( 1, 3, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_xzzz( vec3( 1, 2, 3 ) ), vec4( 1, 3, 3, 3 ) ) );

        TESTFW_EXPECTED( vec4_eq( vec3_yxxx( vec3( 1, 2, 3 ) ), vec4( 2, 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yxxy( vec3( 1, 2, 3 ) ), vec4( 2, 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yxxz( vec3( 1, 2, 3 ) ), vec4( 2, 1, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yxyx( vec3( 1, 2, 3 ) ), vec4( 2, 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yxyy( vec3( 1, 2, 3 ) ), vec4( 2, 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yxyz( vec3( 1, 2, 3 ) ), vec4( 2, 1, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yxzx( vec3( 1, 2, 3 ) ), vec4( 2, 1, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yxzy( vec3( 1, 2, 3 ) ), vec4( 2, 1, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yxzz( vec3( 1, 2, 3 ) ), vec4( 2, 1, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yyxx( vec3( 1, 2, 3 ) ), vec4( 2, 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yyxy( vec3( 1, 2, 3 ) ), vec4( 2, 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yyxz( vec3( 1, 2, 3 ) ), vec4( 2, 2, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yyyx( vec3( 1, 2, 3 ) ), vec4( 2, 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yyyy( vec3( 1, 2, 3 ) ), vec4( 2, 2, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yyyz( vec3( 1, 2, 3 ) ), vec4( 2, 2, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yyzx( vec3( 1, 2, 3 ) ), vec4( 2, 2, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yyzy( vec3( 1, 2, 3 ) ), vec4( 2, 2, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yyzz( vec3( 1, 2, 3 ) ), vec4( 2, 2, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yzxx( vec3( 1, 2, 3 ) ), vec4( 2, 3, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yzxy( vec3( 1, 2, 3 ) ), vec4( 2, 3, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yzxz( vec3( 1, 2, 3 ) ), vec4( 2, 3, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yzyx( vec3( 1, 2, 3 ) ), vec4( 2, 3, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yzyy( vec3( 1, 2, 3 ) ), vec4( 2, 3, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yzyz( vec3( 1, 2, 3 ) ), vec4( 2, 3, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yzzx( vec3( 1, 2, 3 ) ), vec4( 2, 3, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yzzy( vec3( 1, 2, 3 ) ), vec4( 2, 3, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_yzzz( vec3( 1, 2, 3 ) ), vec4( 2, 3, 3, 3 ) ) );

        TESTFW_EXPECTED( vec4_eq( vec3_zxxx( vec3( 1, 2, 3 ) ), vec4( 3, 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zxxy( vec3( 1, 2, 3 ) ), vec4( 3, 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zxxz( vec3( 1, 2, 3 ) ), vec4( 3, 1, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zxyx( vec3( 1, 2, 3 ) ), vec4( 3, 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zxyy( vec3( 1, 2, 3 ) ), vec4( 3, 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zxyz( vec3( 1, 2, 3 ) ), vec4( 3, 1, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zxzx( vec3( 1, 2, 3 ) ), vec4( 3, 1, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zxzy( vec3( 1, 2, 3 ) ), vec4( 3, 1, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zxzz( vec3( 1, 2, 3 ) ), vec4( 3, 1, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zyxx( vec3( 1, 2, 3 ) ), vec4( 3, 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zyxy( vec3( 1, 2, 3 ) ), vec4( 3, 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zyxz( vec3( 1, 2, 3 ) ), vec4( 3, 2, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zyyx( vec3( 1, 2, 3 ) ), vec4( 3, 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zyyy( vec3( 1, 2, 3 ) ), vec4( 3, 2, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zyyz( vec3( 1, 2, 3 ) ), vec4( 3, 2, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zyzx( vec3( 1, 2, 3 ) ), vec4( 3, 2, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zyzy( vec3( 1, 2, 3 ) ), vec4( 3, 2, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zyzz( vec3( 1, 2, 3 ) ), vec4( 3, 2, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zzxx( vec3( 1, 2, 3 ) ), vec4( 3, 3, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zzxy( vec3( 1, 2, 3 ) ), vec4( 3, 3, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zzxz( vec3( 1, 2, 3 ) ), vec4( 3, 3, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zzyx( vec3( 1, 2, 3 ) ), vec4( 3, 3, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zzyy( vec3( 1, 2, 3 ) ), vec4( 3, 3, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zzyz( vec3( 1, 2, 3 ) ), vec4( 3, 3, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zzzx( vec3( 1, 2, 3 ) ), vec4( 3, 3, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zzzy( vec3( 1, 2, 3 ) ), vec4( 3, 3, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3_zzzz( vec3( 1, 2, 3 ) ), vec4( 3, 3, 3, 3 ) ) );
    TESTFW_TEST_END();

}


void test_swizzling_vec4( void ) {

    // vec2 swizzling from vec4

    TESTFW_TEST_BEGIN( "vec2 swizzling from vec4" )
        TESTFW_EXPECTED( vec2_eq( vec4_xx( vec4( 1, 2, 3, 4 ) ), vec2( 1, 1 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_xy( vec4( 1, 2, 3, 4 ) ), vec2( 1, 2 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_xz( vec4( 1, 2, 3, 4 ) ), vec2( 1, 3 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_xw( vec4( 1, 2, 3, 4 ) ), vec2( 1, 4 ) ) );

        TESTFW_EXPECTED( vec2_eq( vec4_yx( vec4( 1, 2, 3, 4 ) ), vec2( 2, 1 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_yy( vec4( 1, 2, 3, 4 ) ), vec2( 2, 2 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_yz( vec4( 1, 2, 3, 4 ) ), vec2( 2, 3 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_yw( vec4( 1, 2, 3, 4 ) ), vec2( 2, 4 ) ) );

        TESTFW_EXPECTED( vec2_eq( vec4_zx( vec4( 1, 2, 3, 4 ) ), vec2( 3, 1 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_zy( vec4( 1, 2, 3, 4 ) ), vec2( 3, 2 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_zz( vec4( 1, 2, 3, 4 ) ), vec2( 3, 3 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_zw( vec4( 1, 2, 3, 4 ) ), vec2( 3, 4 ) ) );

        TESTFW_EXPECTED( vec2_eq( vec4_wx( vec4( 1, 2, 3, 4 ) ), vec2( 4, 1 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_wy( vec4( 1, 2, 3, 4 ) ), vec2( 4, 2 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_wz( vec4( 1, 2, 3, 4 ) ), vec2( 4, 3 ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4_ww( vec4( 1, 2, 3, 4 ) ), vec2( 4, 4 ) ) );
    TESTFW_TEST_END();


    // vec3 swizzling from vec4

    TESTFW_TEST_BEGIN( "vec3 swizzling from vec4" )
        TESTFW_EXPECTED( vec3_eq( vec4_xxx( vec4( 1, 2, 3, 4 ) ), vec3( 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xxy( vec4( 1, 2, 3, 4 ) ), vec3( 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xxz( vec4( 1, 2, 3, 4 ) ), vec3( 1, 1, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xxw( vec4( 1, 2, 3, 4 ) ), vec3( 1, 1, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xyx( vec4( 1, 2, 3, 4 ) ), vec3( 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xyy( vec4( 1, 2, 3, 4 ) ), vec3( 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xyz( vec4( 1, 2, 3, 4 ) ), vec3( 1, 2, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xyw( vec4( 1, 2, 3, 4 ) ), vec3( 1, 2, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xzx( vec4( 1, 2, 3, 4 ) ), vec3( 1, 3, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xzy( vec4( 1, 2, 3, 4 ) ), vec3( 1, 3, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xzz( vec4( 1, 2, 3, 4 ) ), vec3( 1, 3, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xzw( vec4( 1, 2, 3, 4 ) ), vec3( 1, 3, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xwx( vec4( 1, 2, 3, 4 ) ), vec3( 1, 4, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xwy( vec4( 1, 2, 3, 4 ) ), vec3( 1, 4, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xwz( vec4( 1, 2, 3, 4 ) ), vec3( 1, 4, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_xww( vec4( 1, 2, 3, 4 ) ), vec3( 1, 4, 4 ) ) );

        TESTFW_EXPECTED( vec3_eq( vec4_yxx( vec4( 1, 2, 3, 4 ) ), vec3( 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yxy( vec4( 1, 2, 3, 4 ) ), vec3( 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yxz( vec4( 1, 2, 3, 4 ) ), vec3( 2, 1, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yxw( vec4( 1, 2, 3, 4 ) ), vec3( 2, 1, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yyx( vec4( 1, 2, 3, 4 ) ), vec3( 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yyy( vec4( 1, 2, 3, 4 ) ), vec3( 2, 2, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yyz( vec4( 1, 2, 3, 4 ) ), vec3( 2, 2, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yyw( vec4( 1, 2, 3, 4 ) ), vec3( 2, 2, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yzx( vec4( 1, 2, 3, 4 ) ), vec3( 2, 3, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yzy( vec4( 1, 2, 3, 4 ) ), vec3( 2, 3, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yzz( vec4( 1, 2, 3, 4 ) ), vec3( 2, 3, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yzw( vec4( 1, 2, 3, 4 ) ), vec3( 2, 3, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_ywx( vec4( 1, 2, 3, 4 ) ), vec3( 2, 4, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_ywy( vec4( 1, 2, 3, 4 ) ), vec3( 2, 4, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_ywz( vec4( 1, 2, 3, 4 ) ), vec3( 2, 4, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_yww( vec4( 1, 2, 3, 4 ) ), vec3( 2, 4, 4 ) ) );

        TESTFW_EXPECTED( vec3_eq( vec4_zxx( vec4( 1, 2, 3, 4 ) ), vec3( 3, 1, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zxy( vec4( 1, 2, 3, 4 ) ), vec3( 3, 1, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zxz( vec4( 1, 2, 3, 4 ) ), vec3( 3, 1, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zxw( vec4( 1, 2, 3, 4 ) ), vec3( 3, 1, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zyx( vec4( 1, 2, 3, 4 ) ), vec3( 3, 2, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zyy( vec4( 1, 2, 3, 4 ) ), vec3( 3, 2, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zyz( vec4( 1, 2, 3, 4 ) ), vec3( 3, 2, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zyw( vec4( 1, 2, 3, 4 ) ), vec3( 3, 2, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zzx( vec4( 1, 2, 3, 4 ) ), vec3( 3, 3, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zzy( vec4( 1, 2, 3, 4 ) ), vec3( 3, 3, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zzz( vec4( 1, 2, 3, 4 ) ), vec3( 3, 3, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zzw( vec4( 1, 2, 3, 4 ) ), vec3( 3, 3, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zwx( vec4( 1, 2, 3, 4 ) ), vec3( 3, 4, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zwy( vec4( 1, 2, 3, 4 ) ), vec3( 3, 4, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zwz( vec4( 1, 2, 3, 4 ) ), vec3( 3, 4, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_zww( vec4( 1, 2, 3, 4 ) ), vec3( 3, 4, 4 ) ) );

        TESTFW_EXPECTED( vec3_eq( vec4_wxx( vec4( 1, 2, 3, 4 ) ), vec3( 4, 1, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wxy( vec4( 1, 2, 3, 4 ) ), vec3( 4, 1, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wxz( vec4( 1, 2, 3, 4 ) ), vec3( 4, 1, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wxw( vec4( 1, 2, 3, 4 ) ), vec3( 4, 1, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wyx( vec4( 1, 2, 3, 4 ) ), vec3( 4, 2, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wyy( vec4( 1, 2, 3, 4 ) ), vec3( 4, 2, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wyz( vec4( 1, 2, 3, 4 ) ), vec3( 4, 2, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wyw( vec4( 1, 2, 3, 4 ) ), vec3( 4, 2, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wzx( vec4( 1, 2, 3, 4 ) ), vec3( 4, 3, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wzy( vec4( 1, 2, 3, 4 ) ), vec3( 4, 3, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wzz( vec4( 1, 2, 3, 4 ) ), vec3( 4, 3, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wzw( vec4( 1, 2, 3, 4 ) ), vec3( 4, 3, 4 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wwx( vec4( 1, 2, 3, 4 ) ), vec3( 4, 4, 1 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wwy( vec4( 1, 2, 3, 4 ) ), vec3( 4, 4, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_wwz( vec4( 1, 2, 3, 4 ) ), vec3( 4, 4, 3 ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4_www( vec4( 1, 2, 3, 4 ) ), vec3( 4, 4, 4 ) ) );
    TESTFW_TEST_END();


    // vec4 swizzling from vec4

    TESTFW_TEST_BEGIN( "vec4 swizzling from vec4" )
        TESTFW_EXPECTED( vec4_eq( vec4_xxxx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxxy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxxz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxxw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxyx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxyy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxyz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxyw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxzx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxzy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxzz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxzw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxwx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxwy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxwz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xxww( vec4( 1, 2, 3, 4 ) ), vec4( 1, 1, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyxx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyxy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyxz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyxw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyyx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyyy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyyz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyyw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyzx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyzy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyzz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyzw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xywx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xywy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xywz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xyww( vec4( 1, 2, 3, 4 ) ), vec4( 1, 2, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzxx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzxy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzxz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzxw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzyx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzyy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzyz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzyw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzzx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzzy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzzz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzzw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzwx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzwy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzwz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xzww( vec4( 1, 2, 3, 4 ) ), vec4( 1, 3, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwxx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwxy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwxz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwxw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwyx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwyy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwyz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwyw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwzx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwzy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwzz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwzw( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwwx( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwwy( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwwz( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_xwww( vec4( 1, 2, 3, 4 ) ), vec4( 1, 4, 4, 4 ) ) );

        TESTFW_EXPECTED( vec4_eq( vec4_yxxx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxxy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxxz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxxw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxyx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxyy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxyz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxyw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxzx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxzy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxzz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxzw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxwx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxwy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxwz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yxww( vec4( 1, 2, 3, 4 ) ), vec4( 2, 1, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyxx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyxy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyxz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyxw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyyx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyyy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyyz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyyw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyzx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyzy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyzz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyzw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yywx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yywy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yywz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yyww( vec4( 1, 2, 3, 4 ) ), vec4( 2, 2, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzxx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzxy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzxz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzxw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzyx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzyy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzyz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzyw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzzx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzzy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzzz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzzw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzwx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzwy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzwz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_yzww( vec4( 1, 2, 3, 4 ) ), vec4( 2, 3, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywxx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywxy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywxz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywxw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywyx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywyy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywyz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywyw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywzx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywzy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywzz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywzw( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywwx( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywwy( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywwz( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_ywww( vec4( 1, 2, 3, 4 ) ), vec4( 2, 4, 4, 4 ) ) );

        TESTFW_EXPECTED( vec4_eq( vec4_zxxx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxxy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxxz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxxw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxyx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxyy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxyz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxyw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxzx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxzy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxzz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxzw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxwx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxwy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxwz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zxww( vec4( 1, 2, 3, 4 ) ), vec4( 3, 1, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyxx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyxy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyxz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyxw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyyx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyyy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyyz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyyw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyzx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyzy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyzz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyzw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zywx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zywy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zywz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zyww( vec4( 1, 2, 3, 4 ) ), vec4( 3, 2, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzxx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzxy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzxz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzxw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzyx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzyy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzyz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzyw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzzx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzzy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzzz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzzw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzwx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzwy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzwz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zzww( vec4( 1, 2, 3, 4 ) ), vec4( 3, 3, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwxx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwxy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwxz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwxw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwyx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwyy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwyz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwyw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwzx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwzy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwzz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwzw( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwwx( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwwy( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwwz( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_zwww( vec4( 1, 2, 3, 4 ) ), vec4( 3, 4, 4, 4 ) ) );

        TESTFW_EXPECTED( vec4_eq( vec4_wxxx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxxy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxxz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxxw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxyx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxyy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxyz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxyw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxzx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxzy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxzz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxzw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxwx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxwy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxwz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wxww( vec4( 1, 2, 3, 4 ) ), vec4( 4, 1, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyxx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyxy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyxz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyxw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyyx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyyy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyyz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyyw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyzx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyzy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyzz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyzw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wywx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wywy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wywz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wyww( vec4( 1, 2, 3, 4 ) ), vec4( 4, 2, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzxx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzxy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzxz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzxw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzyx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzyy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzyz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzyw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzzx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzzy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzzz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzzw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzwx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzwy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzwz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wzww( vec4( 1, 2, 3, 4 ) ), vec4( 4, 3, 4, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwxx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 1, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwxy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 1, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwxz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 1, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwxw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 1, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwyx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 2, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwyy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 2, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwyz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 2, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwyw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 2, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwzx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 3, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwzy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 3, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwzz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 3, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwzw( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 3, 4 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwwx( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 4, 1 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwwy( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 4, 2 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwwz( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 4, 3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4_wwww( vec4( 1, 2, 3, 4 ) ), vec4( 4, 4, 4, 4 ) ) );
    TESTFW_TEST_END();
}


#if defined( VECMATH_GENERICS ) && ( defined( __cplusplus ) || ( ( defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L ) || defined(__TINYC__) ) )

void test_generics( void ) {
    // vm_neg
    TESTFW_TEST_BEGIN( "vm_neg dispatches to correct *_neg implementation" )
        TESTFW_EXPECTED( vm_neg( 1.0f ) == -1.0f );
        TESTFW_EXPECTED( vec2_eq( vm_neg( vec2( 1, -2 ) ), vec2( -1, 2 ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_neg( vec3( 1, -2, 3 ) ), vec3( -1, 2, -3 ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_neg( vec4( 1, -2, 3, -4 ) ), vec4( -1, 2, -3, 4 ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_neg( mat22( vec2(1,2), vec2(3,4) ) ), mat22( vec2(-1,-2), vec2(-3,-4) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_neg( mat23( vec3(1,2,3), vec3(4,5,6) ) ), mat23( vec3(-1,-2,-3), vec3(-4,-5,-6) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_neg( mat24( vec4(1,2,3,4), vec4(5,6,7,8) ) ), mat24( vec4(-1,-2,-3,-4), vec4(-5,-6,-7,-8) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_neg( mat32( vec2(1,2), vec2(3,4), vec2(5,6) ) ), mat32( vec2(-1,-2), vec2(-3,-4), vec2(-5,-6) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_neg( mat33( vec3(1,2,3), vec3(4,5,6), vec3(7,8,9) ) ), mat33( vec3(-1,-2,-3), vec3(-4,-5,-6), vec3(-7,-8,-9) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_neg( mat34( vec4(1,2,3,4), vec4(5,6,7,8), vec4(9,10,11,12) ) ), mat34( vec4(-1,-2,-3,-4), vec4(-5,-6,-7,-8), vec4(-9,-10,-11,-12) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_neg( mat42( vec2(1,2), vec2(3,4), vec2(5,6), vec2(7,8) ) ), mat42( vec2(-1,-2), vec2(-3,-4), vec2(-5,-6), vec2(-7,-8) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_neg( mat43( vec3(1,2,3), vec3(4,5,6), vec3(7,8,9), vec3(10,11,12) ) ), mat43( vec3(-1,-2,-3), vec3(-4,-5,-6), vec3(-7,-8,-9), vec3(-10,-11,-12) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_neg( mat44( vec4(1,2,3,4), vec4(5,6,7,8), vec4(9,10,11,12), vec4(13,14,15,16) ) ), mat44( vec4(-1,-2,-3,-4), vec4(-5,-6,-7,-8), vec4(-9,-10,-11,-12), vec4(-13,-14,-15,-16) ) ) );
    TESTFW_TEST_END();

    // vm_eq
    TESTFW_TEST_BEGIN( "vm_eq dispatches to correct *_eq implementation" )
        TESTFW_EXPECTED( vm_eq( 1.0f, 1.0f ) );
        TESTFW_EXPECTED( vm_eq( vec2( 1, 2 ), vec2( 1, 2 ) ) );
        TESTFW_EXPECTED( vm_eq( vec3( 1, 2, 3 ), vec3( 1, 2, 3 ) ) );
        TESTFW_EXPECTED( vm_eq( vec4( 1, 2, 3, 4 ), vec4( 1, 2, 3, 4 ) ) );
        TESTFW_EXPECTED( vm_eq( mat22( vec2(1,2), vec2(3,4) ), mat22( vec2(1,2), vec2(3,4) ) ) );
        TESTFW_EXPECTED( vm_eq( mat23( vec3(1,2,3), vec3(4,5,6) ), mat23( vec3(1,2,3), vec3(4,5,6) ) ) );
        TESTFW_EXPECTED( vm_eq( mat24( vec4(1,2,3,4), vec4(5,6,7,8) ), mat24( vec4(1,2,3,4), vec4(5,6,7,8) ) ) );
        TESTFW_EXPECTED( vm_eq( mat32( vec2(1,2), vec2(3,4), vec2(5,6) ), mat32( vec2(1,2), vec2(3,4), vec2(5,6) ) ) );
        TESTFW_EXPECTED( vm_eq( mat33( vec3(1,2,3), vec3(4,5,6), vec3(7,8,9) ), mat33( vec3(1,2,3), vec3(4,5,6), vec3(7,8,9) ) ) );
        TESTFW_EXPECTED( vm_eq( mat34( vec4(1,2,3,4), vec4(5,6,7,8), vec4(9,10,11,12) ), mat34( vec4(1,2,3,4), vec4(5,6,7,8), vec4(9,10,11,12) ) ) );
        TESTFW_EXPECTED( vm_eq( mat42( vec2(1,2), vec2(3,4), vec2(5,6), vec2(7,8) ), mat42( vec2(1,2), vec2(3,4), vec2(5,6), vec2(7,8) ) ) );
        TESTFW_EXPECTED( vm_eq( mat43( vec3(1,2,3), vec3(4,5,6), vec3(7,8,9), vec3(10,11,12) ), mat43( vec3(1,2,3), vec3(4,5,6), vec3(7,8,9), vec3(10,11,12) ) ) );
        TESTFW_EXPECTED( vm_eq( mat44( vec4(1,2,3,4), vec4(5,6,7,8), vec4(9,10,11,12), vec4(13,14,15,16) ), mat44( vec4(1,2,3,4), vec4(5,6,7,8), vec4(9,10,11,12), vec4(13,14,15,16) ) ) );
    TESTFW_TEST_END();

    // vm_add
    TESTFW_TEST_BEGIN( "vm_add dispatches to correct *_add implementation" )
        TESTFW_EXPECTED( vm_add( 1.0f, 2.0f ) == 3.0f );
        TESTFW_EXPECTED( vec2_eq( vm_add( vec2(1,2), vec2(3,4) ), vec2(4,6) ) );
        TESTFW_EXPECTED( vec2_eq( vm_add( vec2(1,2), 5.0f ), vec2(6,7) ) );
        TESTFW_EXPECTED( vec3_eq( vm_add( vec3(1,2,3), vec3(4,5,6) ), vec3(5,7,9) ) );
        TESTFW_EXPECTED( vec3_eq( vm_add( vec3(1,2,3), 2.0f ), vec3(3,4,5) ) );
        TESTFW_EXPECTED( vec4_eq( vm_add( vec4(1,2,3,4), vec4(5,6,7,8) ), vec4(6,8,10,12) ) );
        TESTFW_EXPECTED( vec4_eq( vm_add( vec4(1,2,3,4), 1.0f ), vec4(2,3,4,5) ) );
        TESTFW_EXPECTED( mat22_eq( vm_add( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)) ), mat22(vec2(6,8),vec2(10,12)) ) );
        TESTFW_EXPECTED( mat22_eq( vm_add( mat22(vec2(1,2),vec2(3,4)), 1.0f ), mat22(vec2(2,3),vec2(4,5)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_add( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(7,8,9),vec3(10,11,12)) ), mat23(vec3(8,10,12),vec3(14,16,18)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_add( mat23(vec3(1,2,3),vec3(4,5,6)), 2.0f ), mat23(vec3(3,4,5),vec3(6,7,8)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_add( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ), mat24(vec4(10,12,14,16),vec4(18,20,22,24)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_add( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), 3.0f ), mat24(vec4(4,5,6,7),vec4(8,9,10,11)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_add( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ), mat32(vec2(8,10),vec2(12,14),vec2(16,18)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_add( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), 1.0f ), mat32(vec2(2,3),vec2(4,5),vec2(6,7)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_add( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) ), mat33(vec3(10,10,10),vec3(10,10,10),vec3(10,10,10)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_add( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), 2.0f ), mat33(vec3(3,4,5),vec3(6,7,8),vec3(9,10,11)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_add( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ), mat34(vec4(14,16,18,20),vec4(22,24,26,28),vec4(30,32,34,36)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_add( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), 1.0f ), mat34(vec4(2,3,4,5),vec4(6,7,8,9),vec4(10,11,12,13)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_add( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ), mat42(vec2(10,12),vec2(14,16),vec2(18,20),vec2(22,24)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_add( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), 2.0f ), mat42(vec2(3,4),vec2(5,6),vec2(7,8),vec2(9,10)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_add( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ), mat43(vec3(14,16,18),vec3(20,22,24),vec3(26,28,30),vec3(32,34,36)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_add( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), 1.0f ), mat43(vec3(2,3,4),vec3(5,6,7),vec3(8,9,10),vec3(11,12,13)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_add( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ), mat44(vec4(18,20,22,24),vec4(26,28,30,32),vec4(34,36,38,40),vec4(42,44,46,48)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_add( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), 2.0f ), mat44(vec4(3,4,5,6),vec4(7,8,9,10),vec4(11,12,13,14),vec4(15,16,17,18)) ) );
        TESTFW_EXPECTED( vec2_eq( vm_add( 5.0f, vec2(1,2) ), vec2(6,7) ) );
        TESTFW_EXPECTED( vec3_eq( vm_add( 2.0f, vec3(1,2,3) ), vec3(3,4,5) ) );
        TESTFW_EXPECTED( vec4_eq( vm_add( 1.0f, vec4(1,2,3,4) ), vec4(2,3,4,5) ) );
        TESTFW_EXPECTED( mat22_eq( vm_add( 1.0f, mat22(vec2(1,2),vec2(3,4)) ), mat22(vec2(2,3),vec2(4,5)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_add( 2.0f, mat23(vec3(1,2,3),vec3(4,5,6)) ), mat23(vec3(3,4,5),vec3(6,7,8)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_add( 3.0f, mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), mat24(vec4(4,5,6,7),vec4(8,9,10,11)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_add( 1.0f, mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), mat32(vec2(2,3),vec2(4,5),vec2(6,7)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_add( 2.0f, mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), mat33(vec3(3,4,5),vec3(6,7,8),vec3(9,10,11)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_add( 1.0f, mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), mat34(vec4(2,3,4,5),vec4(6,7,8,9),vec4(10,11,12,13)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_add( 2.0f, mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), mat42(vec2(3,4),vec2(5,6),vec2(7,8),vec2(9,10)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_add( 1.0f, mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), mat43(vec3(2,3,4),vec3(5,6,7),vec3(8,9,10),vec3(11,12,13)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_add( 2.0f, mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), mat44(vec4(3,4,5,6),vec4(7,8,9,10),vec4(11,12,13,14),vec4(15,16,17,18)) ) );
    TESTFW_TEST_END();

    // vm_sub
    TESTFW_TEST_BEGIN( "vm_sub dispatches to correct *_sub implementation" )
        TESTFW_EXPECTED( vm_sub( 5.0f, 2.0f ) == 3.0f );
        TESTFW_EXPECTED( vec2_eq( vm_sub( vec2(5,7), vec2(3,2) ), vec2(2,5) ) );
        TESTFW_EXPECTED( vec2_eq( vm_sub( vec2(5,7), 2.0f ), vec2(3,5) ) );
        TESTFW_EXPECTED( vec3_eq( vm_sub( vec3(5,7,9), vec3(1,2,3) ), vec3(4,5,6) ) );
        TESTFW_EXPECTED( vec3_eq( vm_sub( vec3(5,7,9), 1.0f ), vec3(4,6,8) ) );
        TESTFW_EXPECTED( vec4_eq( vm_sub( vec4(9,8,7,6), vec4(1,2,3,4) ), vec4(8,6,4,2) ) );
        TESTFW_EXPECTED( vec4_eq( vm_sub( vec4(9,8,7,6), 1.0f ), vec4(8,7,6,5) ) );
        TESTFW_EXPECTED( mat22_eq( vm_sub( mat22(vec2(5,6),vec2(7,8)), mat22(vec2(1,2),vec2(3,4)) ), mat22(vec2(4,4),vec2(4,4)) ) );
        TESTFW_EXPECTED( mat22_eq( vm_sub( mat22(vec2(5,6),vec2(7,8)), 1.0f ), mat22(vec2(4,5),vec2(6,7)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_sub( mat23(vec3(9,8,7),vec3(6,5,4)), mat23(vec3(1,2,3),vec3(4,5,6)) ), mat23(vec3(8,6,4),vec3(2,0,-2)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_sub( mat23(vec3(9,8,7),vec3(6,5,4)), 2.0f ), mat23(vec3(7,6,5),vec3(4,3,2)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_sub( mat24(vec4(9,8,7,6),vec4(5,4,3,2)), mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), mat24(vec4(8,6,4,2),vec4(0,-2,-4,-6)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_sub( mat24(vec4(9,8,7,6),vec4(5,4,3,2)), 1.0f ), mat24(vec4(8,7,6,5),vec4(4,3,2,1)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_sub( mat32(vec2(9,8),vec2(7,6),vec2(5,4)), mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), mat32(vec2(8,6),vec2(4,2),vec2(0,-2)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_sub( mat32(vec2(9,8),vec2(7,6),vec2(5,4)), 2.0f ), mat32(vec2(7,6),vec2(5,4),vec2(3,2)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_sub( mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)), mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), mat33(vec3(8,6,4),vec3(2,0,-2),vec3(-4,-6,-8)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_sub( mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)), 3.0f ), mat33(vec3(6,5,4),vec3(3,2,1),vec3(0,-1,-2)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_sub( mat34(vec4(9,8,7,6),vec4(5,4,3,2),vec4(1,0,-1,-2)), mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), mat34(vec4(8,6,4,2),vec4(0,-2,-4,-6),vec4(-8,-10,-12,-14)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_sub( mat34(vec4(9,8,7,6),vec4(5,4,3,2),vec4(1,0,-1,-2)), 1.0f ), mat34(vec4(8,7,6,5),vec4(4,3,2,1),vec4(0,-1,-2,-3)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_sub( mat42(vec2(9,8),vec2(7,6),vec2(5,4),vec2(3,2)), mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), mat42(vec2(8,6),vec2(4,2),vec2(0,-2),vec2(-4,-6)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_sub( mat42(vec2(9,8),vec2(7,6),vec2(5,4),vec2(3,2)), 2.0f ), mat42(vec2(7,6),vec2(5,4),vec2(3,2),vec2(1,0)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_sub( mat43(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1),vec3(0,-1,-2)), mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), mat43(vec3(8,6,4),vec3(2,0,-2),vec3(-4,-6,-8),vec3(-10,-12,-14)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_sub( mat43(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1),vec3(0,-1,-2)), 1.0f ), mat43(vec3(8,7,6),vec3(5,4,3),vec3(2,1,0),vec3(-1,-2,-3)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_sub( mat44(vec4(9,8,7,6),vec4(5,4,3,2),vec4(1,0,-1,-2),vec4(-3,-4,-5,-6)), mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), mat44(vec4(8,6,4,2),vec4(0,-2,-4,-6),vec4(-8,-10,-12,-14),vec4(-16,-18,-20,-22)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_sub( mat44(vec4(9,8,7,6),vec4(5,4,3,2),vec4(1,0,-1,-2),vec4(-3,-4,-5,-6)), 2.0f ), mat44(vec4(7,6,5,4),vec4(3,2,1,0),vec4(-1,-2,-3,-4),vec4(-5,-6,-7,-8)) ) );
        TESTFW_EXPECTED( vec2_eq( vm_sub( 5.0f, vec2(1,2) ), vec2(4,3) ) );
        TESTFW_EXPECTED( vec3_eq( vm_sub( 6.0f, vec3(1,2,3) ), vec3(5,4,3) ) );
        TESTFW_EXPECTED( vec4_eq( vm_sub( 10.0f, vec4(1,2,3,4) ), vec4(9,8,7,6) ) );
        TESTFW_EXPECTED( mat22_eq( vm_sub( 2.0f, mat22(vec2(1,2),vec2(3,4)) ), mat22(vec2(1,0),vec2(-1,-2)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_sub( 3.0f, mat23(vec3(1,2,3),vec3(4,5,6)) ), mat23(vec3(2,1,0),vec3(-1,-2,-3)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_sub( 4.0f, mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), mat24(vec4(3,2,1,0),vec4(-1,-2,-3,-4)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_sub( 5.0f, mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), mat32(vec2(4,3),vec2(2,1),vec2(0,-1)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_sub( 6.0f, mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), mat33(vec3(5,4,3),vec3(2,1,0),vec3(-1,-2,-3)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_sub( 7.0f, mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), mat34(vec4(6,5,4,3),vec4(2,1,0,-1),vec4(-2,-3,-4,-5)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_sub( 8.0f, mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), mat42(vec2(7,6),vec2(5,4),vec2(3,2),vec2(1,0)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_sub( 9.0f, mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), mat43(vec3(8,7,6),vec3(5,4,3),vec3(2,1,0),vec3(-1,-2,-3)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_sub( 10.0f, mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), mat44(vec4(9,8,7,6),vec4(5,4,3,2),vec4(1,0,-1,-2),vec4(-3,-4,-5,-6)) ) );
    TESTFW_TEST_END();

    // vm_mul
    TESTFW_TEST_BEGIN( "vm_mul dispatches to correct *_mul implementation" )
        TESTFW_EXPECTED( vm_mul( 2.0f, 3.0f ) == vecmath_fmul( 2.0f, 3.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_mul( 2.0f, vec2(1,2) ), vec2_fmul( 2.0f, vec2(1,2) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_mul( 2.0f, vec3(1,2,3) ), vec3_fmul( 2.0f, vec3(1,2,3) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_mul( 2.0f, vec4(1,2,3,4) ), vec4_fmul( 2.0f, vec4(1,2,3,4) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_mul( 2.0f, mat22(vec2(1,2),vec2(3,4)) ), mat22_fmul( 2.0f, mat22(vec2(1,2),vec2(3,4)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_mul( 2.0f, mat23(vec3(1,2,3),vec3(4,5,6)) ), mat23_fmul( 2.0f, mat23(vec3(1,2,3),vec3(4,5,6)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_mul( 2.0f, mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), mat24_fmul( 2.0f, mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_mul( 2.0f, mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), mat32_fmul( 2.0f, mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_mul( 2.0f, mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), mat33_fmul( 2.0f, mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_mul( 2.0f, mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), mat34_fmul( 2.0f, mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_mul( 2.0f, mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), mat42_fmul( 2.0f, mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_mul( 2.0f, mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), mat43_fmul( 2.0f, mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_mul( 2.0f, mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), mat44_fmul( 2.0f, mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) ) );
        TESTFW_EXPECTED( vec2_eq( vm_mul( vec2(1,2), vec2(3,4) ), vec2_mul( vec2(1,2), vec2(3,4) ) ) );
        TESTFW_EXPECTED( vec2_eq( vm_mul( vec2(1,2), 2.0f ), vec2_mulf( vec2(1,2), 2.0f ) ) );
        TESTFW_EXPECTED( vec2_eq( vm_mul( vec2(1,2), mat22(vec2(3,4),vec2(5,6)) ), vec2_mul_mat22( vec2(1,2), mat22(vec2(3,4),vec2(5,6)) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_mul( vec2(1,2), mat23(vec3(3,4,5),vec3(6,7,8)) ), vec2_mul_mat23( vec2(1,2), mat23(vec3(3,4,5),vec3(6,7,8)) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_mul( vec2(1,2), mat24(vec4(3,4,5,6),vec4(7,8,9,10)) ), vec2_mul_mat24( vec2(1,2), mat24(vec4(3,4,5,6),vec4(7,8,9,10)) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_mul( vec3(1,2,3), vec3(4,5,6) ), vec3_mul( vec3(1,2,3), vec3(4,5,6) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_mul( vec3(1,2,3), 2.0f ), vec3_mulf( vec3(1,2,3), 2.0f ) ) );
        TESTFW_EXPECTED( vec2_eq( vm_mul( vec3(1,2,3), mat32(vec2(4,5),vec2(6,7),vec2(8,9)) ), vec3_mul_mat32( vec3(1,2,3), mat32(vec2(4,5),vec2(6,7),vec2(8,9)) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_mul( vec3(1,2,3), mat33(vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), vec3_mul_mat33( vec3(1,2,3), mat33(vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_mul( vec3(1,2,3), mat34(vec4(4,5,6,7),vec4(8,9,10,11),vec4(12,13,14,15)) ), vec3_mul_mat34( vec3(1,2,3), mat34(vec4(4,5,6,7),vec4(8,9,10,11),vec4(12,13,14,15)) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_mul( vec4(1,2,3,4), vec4(5,6,7,8) ), vec4_mul( vec4(1,2,3,4), vec4(5,6,7,8) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_mul( vec4(1,2,3,4), 2.0f ), vec4_mulf( vec4(1,2,3,4), 2.0f ) ) );
        TESTFW_EXPECTED( vec2_eq( vm_mul( vec4(1,2,3,4), mat42(vec2(5,6),vec2(7,8),vec2(9,10),vec2(11,12)) ), vec4_mul_mat42( vec4(1,2,3,4), mat42(vec2(5,6),vec2(7,8),vec2(9,10),vec2(11,12)) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_mul( vec4(1,2,3,4), mat43(vec3(5,6,7),vec3(8,9,10),vec3(11,12,13),vec3(14,15,16)) ), vec4_mul_mat43( vec4(1,2,3,4), mat43(vec3(5,6,7),vec3(8,9,10),vec3(11,12,13),vec3(14,15,16)) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_mul( vec4(1,2,3,4), mat44(vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16),vec4(17,18,19,20)) ), vec4_mul_mat44( vec4(1,2,3,4), mat44(vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16),vec4(17,18,19,20)) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_mul( mat22(vec2(1,2),vec2(3,4)), 2.0f ), mat22_mulf( mat22(vec2(1,2),vec2(3,4)), 2.0f ) ) );
        TESTFW_EXPECTED( vec2_eq( vm_mul( mat22(vec2(1,2),vec2(3,4)), vec2(5,6) ), mat22_mul_vec2( mat22(vec2(1,2),vec2(3,4)), vec2(5,6) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_mul( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)) ), mat22_mul_mat22( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_mul( mat22(vec2(1,2),vec2(3,4)), mat23(vec3(5,6,7),vec3(8,9,10)) ), mat22_mul_mat23( mat22(vec2(1,2),vec2(3,4)), mat23(vec3(5,6,7),vec3(8,9,10)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_mul( mat22(vec2(1,2),vec2(3,4)), mat24(vec4(5,6,7,8),vec4(9,10,11,12)) ), mat22_mul_mat24( mat22(vec2(1,2),vec2(3,4)), mat24(vec4(5,6,7,8),vec4(9,10,11,12)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_mul( mat23(vec3(1,2,3),vec3(4,5,6)), 2.0f ), mat23_mulf( mat23(vec3(1,2,3),vec3(4,5,6)), 2.0f ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_mul( mat23(vec3(1,2,3),vec3(4,5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ), mat23_mul_mat32( mat23(vec3(1,2,3),vec3(4,5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_mul( mat23(vec3(1,2,3),vec3(4,5,6)), mat33(vec3(7,8,9),vec3(10,11,12),vec3(13,14,15)) ), mat23_mul_mat33( mat23(vec3(1,2,3),vec3(4,5,6)), mat33(vec3(7,8,9),vec3(10,11,12),vec3(13,14,15)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_mul( mat23(vec3(1,2,3),vec3(4,5,6)), mat34(vec4(7,8,9,10),vec4(11,12,13,14),vec4(15,16,17,18)) ), mat23_mul_mat34( mat23(vec3(1,2,3),vec3(4,5,6)), mat34(vec4(7,8,9,10),vec4(11,12,13,14),vec4(15,16,17,18)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_mul( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), 2.0f ), mat24_mulf( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), 2.0f ) ) );
        TESTFW_EXPECTED( vec2_eq( vm_mul( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), vec4(9,10,11,12) ), mat24_mul_vec4( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), vec4(9,10,11,12) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_mul( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), 2.0f ), mat32_mulf( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), 2.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_mul( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), vec2(7,8) ), mat32_mul_vec2( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), vec2(7,8) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_mul( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat22(vec2(7,8),vec2(9,10)) ), mat32_mul_mat22( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat22(vec2(7,8),vec2(9,10)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_mul( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat23(vec3(7,8,9),vec3(10,11,12)) ), mat32_mul_mat23( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat23(vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_mul( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat24(vec4(7,8,9,10),vec4(11,12,13,14)) ), mat32_mul_mat24( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat24(vec4(7,8,9,10),vec4(11,12,13,14)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_mul( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), 2.0f ), mat33_mulf( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), 2.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_mul( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), vec3(10,11,12) ), mat33_mul_vec3( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), vec3(10,11,12) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_mul( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat32(vec2(10,11),vec2(12,13),vec2(14,15)) ), mat33_mul_mat32( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat32(vec2(10,11),vec2(12,13),vec2(14,15)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_mul( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)) ), mat33_mul_mat33( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_mul( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat34(vec4(10,11,12,13),vec4(14,15,16,17),vec4(18,19,20,21)) ), mat33_mul_mat34( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat34(vec4(10,11,12,13),vec4(14,15,16,17),vec4(18,19,20,21)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_mul( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), 2.0f ), mat34_mulf( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), 2.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_mul( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), vec4(13,14,15,16) ), mat34_mul_vec4( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), vec4(13,14,15,16) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_mul( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), 2.0f ), mat42_mulf( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), 2.0f ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_mul( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), vec2(9,10) ), mat42_mul_vec2( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), vec2(9,10) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_mul( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat22(vec2(9,10),vec2(11,12)) ), mat42_mul_mat22( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat22(vec2(9,10),vec2(11,12)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_mul( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat23(vec3(9,10,11),vec3(12,13,14)) ), mat42_mul_mat23( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat23(vec3(9,10,11),vec3(12,13,14)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_mul( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ), mat42_mul_mat24( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_mul( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), 2.0f ), mat43_mulf( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), 2.0f ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_mul( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), vec3(13,14,15) ), mat43_mul_vec3( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), vec3(13,14,15) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_mul( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat32(vec2(13,14),vec2(15,16),vec2(17,18)) ), mat43_mul_mat32( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat32(vec2(13,14),vec2(15,16),vec2(17,18)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_mul( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat33(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21)) ), mat43_mul_mat33( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat33(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_mul( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ), mat43_mul_mat34( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_mul( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), 2.0f ), mat44_mulf( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), 2.0f ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_mul( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), vec4(17,18,19,20) ), mat44_mul_vec4( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), vec4(17,18,19,20) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_mul( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ), mat24_mul_mat42( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_mul( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat43(vec3(9,10,11),vec3(12,13,14),vec3(15,16,17),vec3(18,19,20)) ), mat24_mul_mat43( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat43(vec3(9,10,11),vec3(12,13,14),vec3(15,16,17),vec3(18,19,20)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_mul( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat44(vec4(9,10,11,12),vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ), mat24_mul_mat44( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat44(vec4(9,10,11,12),vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_mul( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat42(vec2(13,14),vec2(15,16),vec2(17,18),vec2(19,20)) ), mat34_mul_mat42( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat42(vec2(13,14),vec2(15,16),vec2(17,18),vec2(19,20)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_mul( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ), mat34_mul_mat43( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_mul( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat44(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28)) ), mat34_mul_mat44( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat44(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_mul( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat42(vec2(17,18),vec2(19,20),vec2(21,22),vec2(23,24)) ), mat44_mul_mat42( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat42(vec2(17,18),vec2(19,20),vec2(21,22),vec2(23,24)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_mul( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat43(vec3(17,18,19),vec3(20,21,22),vec3(23,24,25),vec3(26,27,28)) ), mat44_mul_mat43( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat43(vec3(17,18,19),vec3(20,21,22),vec3(23,24,25),vec3(26,27,28)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_mul( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ), mat44_mul_mat44( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ) ) );
        TESTFW_EXPECTED( vec2_eq( vm_mul( mat23(vec3(1,2,3),vec3(4,5,6)), vec3(7,8,9) ), mat23_mul_vec3( mat23(vec3(1,2,3),vec3(4,5,6)), vec3(7,8,9) ) ) );
    TESTFW_TEST_END();

    // vm_div
    TESTFW_TEST_BEGIN( "vm_div dispatches to correct *_div implementation" )
        TESTFW_EXPECTED( vm_div( 6.0f, 2.0f ) == 3.0f );
        TESTFW_EXPECTED( vec2_eq( vm_div( vec2(6,8), vec2(2,4) ), vec2(3,2) ) );
        TESTFW_EXPECTED( vec2_eq( vm_div( vec2(6,8), 2.0f ), vec2(3,4) ) );
        TESTFW_EXPECTED( vec3_eq( vm_div( vec3(6,9,12), vec3(2,3,4) ), vec3(3,3,3) ) );
        TESTFW_EXPECTED( vec3_eq( vm_div( vec3(6,9,12), 3.0f ), vec3(2,3,4) ) );
        TESTFW_EXPECTED( vec4_eq( vm_div( vec4(8,10,12,14), vec4(2,2,3,7) ), vec4(4,5,4,2) ) );
        TESTFW_EXPECTED( vec4_eq( vm_div( vec4(8,10,12,14), 2.0f ), vec4(4,5,6,7) ) );
        TESTFW_EXPECTED( mat22_eq( vm_div( mat22(vec2(6,8),vec2(10,12)), mat22(vec2(2,2),vec2(2,3)) ), mat22(vec2(3,4),vec2(5,4)) ) );
        TESTFW_EXPECTED( mat22_eq( vm_div( mat22(vec2(6,8),vec2(10,12)), 2.0f ), mat22(vec2(3,4),vec2(5,6)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_div( mat23(vec3(6,8,10),vec3(12,14,16)), mat23(vec3(2,2,2),vec3(2,2,2)) ), mat23(vec3(3,4,5),vec3(6,7,8)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_div( mat23(vec3(6,8,10),vec3(12,14,16)), 2.0f ), mat23(vec3(3,4,5),vec3(6,7,8)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_div( mat24(vec4(6,8,10,12),vec4(14,16,18,20)), mat24(vec4(2,2,2,2),vec4(2,2,2,2)) ), mat24(vec4(3,4,5,6),vec4(7,8,9,10)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_div( mat24(vec4(6,8,10,12),vec4(14,16,18,20)), 2.0f ), mat24(vec4(3,4,5,6),vec4(7,8,9,10)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_div( mat32(vec2(6,8),vec2(10,12),vec2(14,16)), mat32(vec2(2,2),vec2(2,2),vec2(2,2)) ), mat32(vec2(3,4),vec2(5,6),vec2(7,8)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_div( mat32(vec2(6,8),vec2(10,12),vec2(14,16)), 2.0f ), mat32(vec2(3,4),vec2(5,6),vec2(7,8)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_div( mat33(vec3(6,8,10),vec3(12,14,16),vec3(18,20,22)), mat33(vec3(2,2,2),vec3(2,2,2),vec3(2,2,2)) ), mat33(vec3(3,4,5),vec3(6,7,8),vec3(9,10,11)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_div( mat33(vec3(6,8,10),vec3(12,14,16),vec3(18,20,22)), 2.0f ), mat33(vec3(3,4,5),vec3(6,7,8),vec3(9,10,11)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_div( mat34(vec4(6,8,10,12),vec4(14,16,18,20),vec4(22,24,26,28)), mat34(vec4(2,2,2,2),vec4(2,2,2,2),vec4(2,2,2,2)) ), mat34(vec4(3,4,5,6),vec4(7,8,9,10),vec4(11,12,13,14)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_div( mat34(vec4(6,8,10,12),vec4(14,16,18,20),vec4(22,24,26,28)), 2.0f ), mat34(vec4(3,4,5,6),vec4(7,8,9,10),vec4(11,12,13,14)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_div( mat42(vec2(6,8),vec2(10,12),vec2(14,16),vec2(18,20)), mat42(vec2(2,2),vec2(2,2),vec2(2,2),vec2(2,2)) ), mat42(vec2(3,4),vec2(5,6),vec2(7,8),vec2(9,10)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_div( mat42(vec2(6,8),vec2(10,12),vec2(14,16),vec2(18,20)), 2.0f ), mat42(vec2(3,4),vec2(5,6),vec2(7,8),vec2(9,10)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_div( mat43(vec3(6,8,10),vec3(12,14,16),vec3(18,20,22),vec3(24,26,28)), mat43(vec3(2,2,2),vec3(2,2,2),vec3(2,2,2),vec3(2,2,2)) ), mat43(vec3(3,4,5),vec3(6,7,8),vec3(9,10,11),vec3(12,13,14)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_div( mat43(vec3(6,8,10),vec3(12,14,16),vec3(18,20,22),vec3(24,26,28)), 2.0f ), mat43(vec3(3,4,5),vec3(6,7,8),vec3(9,10,11),vec3(12,13,14)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_div( mat44(vec4(6,8,10,12),vec4(14,16,18,20),vec4(22,24,26,28),vec4(30,32,34,36)), mat44(vec4(2,2,2,2),vec4(2,2,2,2),vec4(2,2,2,2),vec4(2,2,2,2)) ), mat44(vec4(3,4,5,6),vec4(7,8,9,10),vec4(11,12,13,14),vec4(15,16,17,18)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_div( mat44(vec4(6,8,10,12),vec4(14,16,18,20),vec4(22,24,26,28),vec4(30,32,34,36)), 2.0f ), mat44(vec4(3,4,5,6),vec4(7,8,9,10),vec4(11,12,13,14),vec4(15,16,17,18)) ) );
        TESTFW_EXPECTED( vec2_eq( vm_div( 12.0f, vec2(2,3) ), vec2(6,4) ) );
        TESTFW_EXPECTED( vec3_eq( vm_div( 12.0f, vec3(2,3,4) ), vec3(6,4,3) ) );
        TESTFW_EXPECTED( vec4_eq( vm_div( 16.0f, vec4(2,4,8,16) ), vec4(8,4,2,1) ) );
        TESTFW_EXPECTED( mat22_eq( vm_div( 8.0f, mat22(vec2(1,2),vec2(4,8)) ), mat22(vec2(8,4),vec2(2,1)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_div( 9.0f, mat23(vec3(1,3,9),vec3(2,6,18)) ), mat23(vec3(9,3,1),vec3(4.5f,1.5f,0.5f)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_div( 12.0f, mat24(vec4(1,2,3,4),vec4(6,3,2,1)) ), mat24(vec4(12,6,4,3),vec4(2,4,6,12)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_div( 6.0f, mat32(vec2(1,2),vec2(3,6),vec2(2,3)) ), mat32(vec2(6,3),vec2(2,1),vec2(3,2)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_div( 18.0f, mat33(vec3(1,2,3),vec3(6,3,2),vec3(9,6,3)) ), mat33(vec3(18,9,6),vec3(3,6,9),vec3(2,3,6)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_div( 24.0f, mat34(vec4(1,2,3,4),vec4(6,3,2,1),vec4(12,6,3,1)) ), mat34(vec4(24,12,8,6),vec4(4,8,12,24),vec4(2,4,8,24)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_div( 10.0f, mat42(vec2(1,2),vec2(5,10),vec2(2,5),vec2(10,1)) ), mat42(vec2(10,5),vec2(2,1),vec2(5,2),vec2(1,10)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_div( 12.0f, mat43(vec3(1,2,3),vec3(6,3,2),vec3(12,4,2),vec3(3,6,1)) ), mat43(vec3(12,6,4),vec3(2,4,6),vec3(1,3,6),vec3(4,2,12)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_div( 16.0f, mat44(vec4(1,2,4,8),vec4(8,4,2,1),vec4(2,4,8,16),vec4(16,8,4,2)) ), mat44(vec4(16,8,4,2),vec4(2,4,8,16),vec4(8,4,2,1),vec4(1,2,4,8)) ) );
    TESTFW_TEST_END();

    // vm_abs
    TESTFW_TEST_BEGIN( "vm_abs dispatches to correct *_abs implementation" )
        TESTFW_EXPECTED( vm_abs( -3.0f ) == 3.0f );
        TESTFW_EXPECTED( vec2_eq( vm_abs( vec2(-1,-2) ), vec2(1,2) ) );
        TESTFW_EXPECTED( vec3_eq( vm_abs( vec3(-1,-2,-3) ), vec3(1,2,3) ) );
        TESTFW_EXPECTED( vec4_eq( vm_abs( vec4(-1,-2,-3,-4) ), vec4(1,2,3,4) ) );
        TESTFW_EXPECTED( mat22_eq( vm_abs( mat22(vec2(-1,-2),vec2(-3,-4)) ), mat22(vec2(1,2),vec2(3,4)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_abs( mat23(vec3(-1,-2,-3),vec3(-4,-5,-6)) ), mat23(vec3(1,2,3),vec3(4,5,6)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_abs( mat24(vec4(-1,-2,-3,-4),vec4(-5,-6,-7,-8)) ), mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_abs( mat32(vec2(-1,-2),vec2(-3,-4),vec2(-5,-6)) ), mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_abs( mat33(vec3(-1,-2,-3),vec3(-4,-5,-6),vec3(-7,-8,-9)) ), mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_abs( mat34(vec4(-1,-2,-3,-4),vec4(-5,-6,-7,-8),vec4(-9,-10,-11,-12)) ), mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_abs( mat42(vec2(-1,-2),vec2(-3,-4),vec2(-5,-6),vec2(-7,-8)) ), mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_abs( mat43(vec3(-1,-2,-3),vec3(-4,-5,-6),vec3(-7,-8,-9),vec3(-10,-11,-12)) ), mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_abs( mat44(vec4(-1,-2,-3,-4),vec4(-5,-6,-7,-8),vec4(-9,-10,-11,-12),vec4(-13,-14,-15,-16)) ), mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) );
    TESTFW_TEST_END();

    // vm_acos
    TESTFW_TEST_BEGIN( "vm_acos dispatches to correct *_acos implementation" )
        TESTFW_EXPECTED( vm_acos( 0.5f ) == vecmath_acos( 0.5f ) );
        TESTFW_EXPECTED( vec2_eq( vm_acos( vec2(0.5f,-0.5f) ), vec2(vecmath_acos(0.5f),vecmath_acos(-0.5f)) ) );
        TESTFW_EXPECTED( vec3_eq( vm_acos( vec3(0.1f,0.2f,0.3f) ), vec3(vecmath_acos(0.1f),vecmath_acos(0.2f),vecmath_acos(0.3f)) ) );
        TESTFW_EXPECTED( vec4_eq( vm_acos( vec4(0.4f,0.5f,0.6f,0.7f) ), vec4(vecmath_acos(0.4f),vecmath_acos(0.5f),vecmath_acos(0.6f),vecmath_acos(0.7f)) ) );
        TESTFW_EXPECTED( mat22_eq( vm_acos( mat22(vec2(0.1f,0.2f),vec2(0.3f,0.4f)) ), mat22(vec2(vecmath_acos(0.1f),vecmath_acos(0.2f)),vec2(vecmath_acos(0.3f),vecmath_acos(0.4f))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_acos( mat23(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f)) ), mat23(vec3(vecmath_acos(0.1f),vecmath_acos(0.2f),vecmath_acos(0.3f)),vec3(vecmath_acos(0.4f),vecmath_acos(0.5f),vecmath_acos(0.6f))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_acos( mat24(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f)) ), mat24(vec4(vecmath_acos(0.1f),vecmath_acos(0.2f),vecmath_acos(0.3f),vecmath_acos(0.4f)),vec4(vecmath_acos(0.5f),vecmath_acos(0.6f),vecmath_acos(0.7f),vecmath_acos(0.8f))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_acos( mat32(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f)) ), mat32(vec2(vecmath_acos(0.1f),vecmath_acos(0.2f)),vec2(vecmath_acos(0.3f),vecmath_acos(0.4f)),vec2(vecmath_acos(0.5f),vecmath_acos(0.6f))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_acos( mat33(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f)) ), mat33(vec3(vecmath_acos(0.1f),vecmath_acos(0.2f),vecmath_acos(0.3f)),vec3(vecmath_acos(0.4f),vecmath_acos(0.5f),vecmath_acos(0.6f)),vec3(vecmath_acos(0.7f),vecmath_acos(0.8f),vecmath_acos(0.9f))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_acos( mat34(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,-0.1f,-0.2f,-0.3f)) ), mat34(vec4(vecmath_acos(0.1f),vecmath_acos(0.2f),vecmath_acos(0.3f),vecmath_acos(0.4f)),vec4(vecmath_acos(0.5f),vecmath_acos(0.6f),vecmath_acos(0.7f),vecmath_acos(0.8f)),vec4(vecmath_acos(0.9f),vecmath_acos(-0.1f),vecmath_acos(-0.2f),vecmath_acos(-0.3f))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_acos( mat42(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f),vec2(0.7f,0.8f)) ), mat42(vec2(vecmath_acos(0.1f),vecmath_acos(0.2f)),vec2(vecmath_acos(0.3f),vecmath_acos(0.4f)),vec2(vecmath_acos(0.5f),vecmath_acos(0.6f)),vec2(vecmath_acos(0.7f),vecmath_acos(0.8f))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_acos( mat43(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f),vec3(-0.1f,-0.2f,-0.3f)) ), mat43(vec3(vecmath_acos(0.1f),vecmath_acos(0.2f),vecmath_acos(0.3f)),vec3(vecmath_acos(0.4f),vecmath_acos(0.5f),vecmath_acos(0.6f)),vec3(vecmath_acos(0.7f),vecmath_acos(0.8f),vecmath_acos(0.9f)),vec3(vecmath_acos(-0.1f),vecmath_acos(-0.2f),vecmath_acos(-0.3f))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_acos( mat44(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,-0.1f,-0.2f,-0.3f),vec4(-0.4f,-0.5f,-0.6f,-0.7f)) ), mat44(vec4(vecmath_acos(0.1f),vecmath_acos(0.2f),vecmath_acos(0.3f),vecmath_acos(0.4f)),vec4(vecmath_acos(0.5f),vecmath_acos(0.6f),vecmath_acos(0.7f),vecmath_acos(0.8f)),vec4(vecmath_acos(0.9f),vecmath_acos(-0.1f),vecmath_acos(-0.2f),vecmath_acos(-0.3f)),vec4(vecmath_acos(-0.4f),vecmath_acos(-0.5f),vecmath_acos(-0.6f),vecmath_acos(-0.7f))) ) );
    TESTFW_TEST_END();

    // vm_all
    TESTFW_TEST_BEGIN( "vm_all dispatches to correct *_all implementation" )
        TESTFW_EXPECTED( vm_all( vec2(1,1) ) );
        TESTFW_EXPECTED( !vm_all( vec2(1,0) ) );
        TESTFW_EXPECTED( vm_all( vec3(1,1,1) ) );
        TESTFW_EXPECTED( !vm_all( vec3(1,0,1) ) );
        TESTFW_EXPECTED( vm_all( vec4(1,1,1,1) ) );
        TESTFW_EXPECTED( !vm_all( vec4(1,1,0,1) ) );
        TESTFW_EXPECTED( vm_all( mat22(vec2(1,1),vec2(1,1)) ) );
        TESTFW_EXPECTED( !vm_all( mat22(vec2(1,1),vec2(1,0)) ) );
        TESTFW_EXPECTED( vm_all( mat23(vec3(1,1,1),vec3(1,1,1)) ) );
        TESTFW_EXPECTED( !vm_all( mat23(vec3(1,1,1),vec3(1,0,1)) ) );
        TESTFW_EXPECTED( vm_all( mat24(vec4(1,1,1,1),vec4(1,1,1,1)) ) );
        TESTFW_EXPECTED( !vm_all( mat24(vec4(1,1,1,1),vec4(1,1,0,1)) ) );
        TESTFW_EXPECTED( vm_all( mat32(vec2(1,1),vec2(1,1),vec2(1,1)) ) );
        TESTFW_EXPECTED( !vm_all( mat32(vec2(1,1),vec2(1,0),vec2(1,1)) ) );
        TESTFW_EXPECTED( vm_all( mat33(vec3(1,1,1),vec3(1,1,1),vec3(1,1,1)) ) );
        TESTFW_EXPECTED( !vm_all( mat33(vec3(1,1,1),vec3(1,0,1),vec3(1,1,1)) ) );
        TESTFW_EXPECTED( vm_all( mat34(vec4(1,1,1,1),vec4(1,1,1,1),vec4(1,1,1,1)) ) );
        TESTFW_EXPECTED( !vm_all( mat34(vec4(1,1,1,1),vec4(1,1,0,1),vec4(1,1,1,1)) ) );
        TESTFW_EXPECTED( vm_all( mat42(vec2(1,1),vec2(1,1),vec2(1,1),vec2(1,1)) ) );
        TESTFW_EXPECTED( !vm_all( mat42(vec2(1,1),vec2(1,1),vec2(1,1),vec2(1,0)) ) );
        TESTFW_EXPECTED( vm_all( mat43(vec3(1,1,1),vec3(1,1,1),vec3(1,1,1),vec3(1,1,1)) ) );
        TESTFW_EXPECTED( !vm_all( mat43(vec3(1,1,1),vec3(1,0,1),vec3(1,1,1),vec3(1,1,1)) ) );
        TESTFW_EXPECTED( vm_all( mat44(vec4(1,1,1,1),vec4(1,1,1,1),vec4(1,1,1,1),vec4(1,1,1,1)) ) );
        TESTFW_EXPECTED( !vm_all( mat44(vec4(1,1,1,1),vec4(1,1,1,1),vec4(1,0,1,1),vec4(1,1,1,1)) ) );
    TESTFW_TEST_END();

    // vm_any
    TESTFW_TEST_BEGIN( "vm_any dispatches to correct *_any implementation" )
        TESTFW_EXPECTED( vm_any( vec2(0,1) ) );
        TESTFW_EXPECTED( !vm_any( vec2(0,0) ) );
        TESTFW_EXPECTED( vm_any( vec3(0,1,0) ) );
        TESTFW_EXPECTED( !vm_any( vec3(0,0,0) ) );
        TESTFW_EXPECTED( vm_any( vec4(0,0,0,1) ) );
        TESTFW_EXPECTED( !vm_any( vec4(0,0,0,0) ) );
        TESTFW_EXPECTED( vm_any( mat22(vec2(0,0),vec2(0,1)) ) );
        TESTFW_EXPECTED( !vm_any( mat22(vec2(0,0),vec2(0,0)) ) );
        TESTFW_EXPECTED( vm_any( mat23(vec3(0,0,0),vec3(1,0,0)) ) );
        TESTFW_EXPECTED( !vm_any( mat23(vec3(0,0,0),vec3(0,0,0)) ) );
        TESTFW_EXPECTED( vm_any( mat24(vec4(0,0,0,0),vec4(1,0,0,0)) ) );
        TESTFW_EXPECTED( !vm_any( mat24(vec4(0,0,0,0),vec4(0,0,0,0)) ) );
        TESTFW_EXPECTED( vm_any( mat32(vec2(0,0),vec2(0,0),vec2(0,1)) ) );
        TESTFW_EXPECTED( !vm_any( mat32(vec2(0,0),vec2(0,0),vec2(0,0)) ) );
        TESTFW_EXPECTED( vm_any( mat33(vec3(0,0,0),vec3(0,0,0),vec3(1,0,0)) ) );
        TESTFW_EXPECTED( !vm_any( mat33(vec3(0,0,0),vec3(0,0,0),vec3(0,0,0)) ) );
        TESTFW_EXPECTED( vm_any( mat34(vec4(0,0,0,0),vec4(0,0,0,0),vec4(0,1,0,0)) ) );
        TESTFW_EXPECTED( !vm_any( mat34(vec4(0,0,0,0),vec4(0,0,0,0),vec4(0,0,0,0)) ) );
        TESTFW_EXPECTED( vm_any( mat42(vec2(0,0),vec2(0,0),vec2(0,0),vec2(1,0)) ) );
        TESTFW_EXPECTED( !vm_any( mat42(vec2(0,0),vec2(0,0),vec2(0,0),vec2(0,0)) ) );
        TESTFW_EXPECTED( vm_any( mat43(vec3(0,0,0),vec3(0,0,0),vec3(0,0,0),vec3(0,0,1)) ) );
        TESTFW_EXPECTED( !vm_any( mat43(vec3(0,0,0),vec3(0,0,0),vec3(0,0,0),vec3(0,0,0)) ) );
        TESTFW_EXPECTED( vm_any( mat44(vec4(0,0,0,0),vec4(0,0,0,0),vec4(0,0,0,0),vec4(0,0,1,0)) ) );
        TESTFW_EXPECTED( !vm_any( mat44(vec4(0,0,0,0),vec4(0,0,0,0),vec4(0,0,0,0),vec4(0,0,0,0)) ) );
    TESTFW_TEST_END();

    // vm_asin
    TESTFW_TEST_BEGIN( "vm_asin dispatches to correct *_asin implementation" )
        TESTFW_EXPECTED( vm_asin( 0.5f ) == vecmath_asin( 0.5f ) );
        TESTFW_EXPECTED( vec2_eq( vm_asin( vec2(0.5f,-0.5f) ), vec2(vecmath_asin(0.5f),vecmath_asin(-0.5f)) ) );
        TESTFW_EXPECTED( vec3_eq( vm_asin( vec3(0.1f,0.2f,0.3f) ), vec3(vecmath_asin(0.1f),vecmath_asin(0.2f),vecmath_asin(0.3f)) ) );
        TESTFW_EXPECTED( vec4_eq( vm_asin( vec4(0.4f,0.5f,0.6f,0.7f) ), vec4(vecmath_asin(0.4f),vecmath_asin(0.5f),vecmath_asin(0.6f),vecmath_asin(0.7f)) ) );
        TESTFW_EXPECTED( mat22_eq( vm_asin( mat22(vec2(0.1f,0.2f),vec2(0.3f,0.4f)) ), mat22(vec2(vecmath_asin(0.1f),vecmath_asin(0.2f)),vec2(vecmath_asin(0.3f),vecmath_asin(0.4f))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_asin( mat23(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f)) ), mat23(vec3(vecmath_asin(0.1f),vecmath_asin(0.2f),vecmath_asin(0.3f)),vec3(vecmath_asin(0.4f),vecmath_asin(0.5f),vecmath_asin(0.6f))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_asin( mat24(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f)) ), mat24(vec4(vecmath_asin(0.1f),vecmath_asin(0.2f),vecmath_asin(0.3f),vecmath_asin(0.4f)),vec4(vecmath_asin(0.5f),vecmath_asin(0.6f),vecmath_asin(0.7f),vecmath_asin(0.8f))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_asin( mat32(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f)) ), mat32(vec2(vecmath_asin(0.1f),vecmath_asin(0.2f)),vec2(vecmath_asin(0.3f),vecmath_asin(0.4f)),vec2(vecmath_asin(0.5f),vecmath_asin(0.6f))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_asin( mat33(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f)) ), mat33(vec3(vecmath_asin(0.1f),vecmath_asin(0.2f),vecmath_asin(0.3f)),vec3(vecmath_asin(0.4f),vecmath_asin(0.5f),vecmath_asin(0.6f)),vec3(vecmath_asin(0.7f),vecmath_asin(0.8f),vecmath_asin(0.9f))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_asin( mat34(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,-0.1f,-0.2f,-0.3f)) ), mat34(vec4(vecmath_asin(0.1f),vecmath_asin(0.2f),vecmath_asin(0.3f),vecmath_asin(0.4f)),vec4(vecmath_asin(0.5f),vecmath_asin(0.6f),vecmath_asin(0.7f),vecmath_asin(0.8f)),vec4(vecmath_asin(0.9f),vecmath_asin(-0.1f),vecmath_asin(-0.2f),vecmath_asin(-0.3f))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_asin( mat42(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f),vec2(0.7f,0.8f)) ), mat42(vec2(vecmath_asin(0.1f),vecmath_asin(0.2f)),vec2(vecmath_asin(0.3f),vecmath_asin(0.4f)),vec2(vecmath_asin(0.5f),vecmath_asin(0.6f)),vec2(vecmath_asin(0.7f),vecmath_asin(0.8f))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_asin( mat43(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f),vec3(-0.1f,-0.2f,-0.3f)) ), mat43(vec3(vecmath_asin(0.1f),vecmath_asin(0.2f),vecmath_asin(0.3f)),vec3(vecmath_asin(0.4f),vecmath_asin(0.5f),vecmath_asin(0.6f)),vec3(vecmath_asin(0.7f),vecmath_asin(0.8f),vecmath_asin(0.9f)),vec3(vecmath_asin(-0.1f),vecmath_asin(-0.2f),vecmath_asin(-0.3f))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_asin( mat44(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,-0.1f,-0.2f,-0.3f),vec4(-0.4f,-0.5f,-0.6f,-0.7f)) ), mat44(vec4(vecmath_asin(0.1f),vecmath_asin(0.2f),vecmath_asin(0.3f),vecmath_asin(0.4f)),vec4(vecmath_asin(0.5f),vecmath_asin(0.6f),vecmath_asin(0.7f),vecmath_asin(0.8f)),vec4(vecmath_asin(0.9f),vecmath_asin(-0.1f),vecmath_asin(-0.2f),vecmath_asin(-0.3f)),vec4(vecmath_asin(-0.4f),vecmath_asin(-0.5f),vecmath_asin(-0.6f),vecmath_asin(-0.7f))) ) );
    TESTFW_TEST_END();

    // vm_atan
    TESTFW_TEST_BEGIN( "vm_atan dispatches to correct *_atan implementation" )
        TESTFW_EXPECTED( vm_atan( 1.0f ) == vecmath_atan( 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_atan( vec2(1.0f,-1.0f) ), vec2(vecmath_atan(1.0f),vecmath_atan(-1.0f)) ) );
        TESTFW_EXPECTED( vec3_eq( vm_atan( vec3(0.1f,0.2f,0.3f) ), vec3(vecmath_atan(0.1f),vecmath_atan(0.2f),vecmath_atan(0.3f)) ) );
        TESTFW_EXPECTED( vec4_eq( vm_atan( vec4(0.4f,0.5f,0.6f,0.7f) ), vec4(vecmath_atan(0.4f),vecmath_atan(0.5f),vecmath_atan(0.6f),vecmath_atan(0.7f)) ) );
        TESTFW_EXPECTED( mat22_eq( vm_atan( mat22(vec2(0.1f,0.2f),vec2(0.3f,0.4f)) ), mat22(vec2(vecmath_atan(0.1f),vecmath_atan(0.2f)),vec2(vecmath_atan(0.3f),vecmath_atan(0.4f))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_atan( mat23(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f)) ), mat23(vec3(vecmath_atan(0.1f),vecmath_atan(0.2f),vecmath_atan(0.3f)),vec3(vecmath_atan(0.4f),vecmath_atan(0.5f),vecmath_atan(0.6f))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_atan( mat24(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f)) ), mat24(vec4(vecmath_atan(0.1f),vecmath_atan(0.2f),vecmath_atan(0.3f),vecmath_atan(0.4f)),vec4(vecmath_atan(0.5f),vecmath_atan(0.6f),vecmath_atan(0.7f),vecmath_atan(0.8f))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_atan( mat32(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f)) ), mat32(vec2(vecmath_atan(0.1f),vecmath_atan(0.2f)),vec2(vecmath_atan(0.3f),vecmath_atan(0.4f)),vec2(vecmath_atan(0.5f),vecmath_atan(0.6f))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_atan( mat33(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f)) ), mat33(vec3(vecmath_atan(0.1f),vecmath_atan(0.2f),vecmath_atan(0.3f)),vec3(vecmath_atan(0.4f),vecmath_atan(0.5f),vecmath_atan(0.6f)),vec3(vecmath_atan(0.7f),vecmath_atan(0.8f),vecmath_atan(0.9f))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_atan( mat34(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,-0.1f,-0.2f,-0.3f)) ), mat34(vec4(vecmath_atan(0.1f),vecmath_atan(0.2f),vecmath_atan(0.3f),vecmath_atan(0.4f)),vec4(vecmath_atan(0.5f),vecmath_atan(0.6f),vecmath_atan(0.7f),vecmath_atan(0.8f)),vec4(vecmath_atan(0.9f),vecmath_atan(-0.1f),vecmath_atan(-0.2f),vecmath_atan(-0.3f))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_atan( mat42(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f),vec2(0.7f,0.8f)) ), mat42(vec2(vecmath_atan(0.1f),vecmath_atan(0.2f)),vec2(vecmath_atan(0.3f),vecmath_atan(0.4f)),vec2(vecmath_atan(0.5f),vecmath_atan(0.6f)),vec2(vecmath_atan(0.7f),vecmath_atan(0.8f))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_atan( mat43(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f),vec3(-0.1f,-0.2f,-0.3f)) ), mat43(vec3(vecmath_atan(0.1f),vecmath_atan(0.2f),vecmath_atan(0.3f)),vec3(vecmath_atan(0.4f),vecmath_atan(0.5f),vecmath_atan(0.6f)),vec3(vecmath_atan(0.7f),vecmath_atan(0.8f),vecmath_atan(0.9f)),vec3(vecmath_atan(-0.1f),vecmath_atan(-0.2f),vecmath_atan(-0.3f))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_atan( mat44(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,-0.1f,-0.2f,-0.3f),vec4(-0.4f,-0.5f,-0.6f,-0.7f)) ), mat44(vec4(vecmath_atan(0.1f),vecmath_atan(0.2f),vecmath_atan(0.3f),vecmath_atan(0.4f)),vec4(vecmath_atan(0.5f),vecmath_atan(0.6f),vecmath_atan(0.7f),vecmath_atan(0.8f)),vec4(vecmath_atan(0.9f),vecmath_atan(-0.1f),vecmath_atan(-0.2f),vecmath_atan(-0.3f)),vec4(vecmath_atan(-0.4f),vecmath_atan(-0.5f),vecmath_atan(-0.6f),vecmath_atan(-0.7f))) ) );
    TESTFW_TEST_END();

    // vm_atan2
    TESTFW_TEST_BEGIN( "vm_atan2 dispatches to correct *_atan2 implementation" )
        TESTFW_EXPECTED( vm_atan2( 1.0f, 2.0f ) == vecmath_atan2( 1.0f, 2.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_atan2( vec2(1,2), vec2(3,4) ), vec2(vecmath_atan2(1,3),vecmath_atan2(2,4)) ) );
        TESTFW_EXPECTED( vec3_eq( vm_atan2( vec3(1,2,3), vec3(4,5,6) ), vec3(vecmath_atan2(1,4),vecmath_atan2(2,5),vecmath_atan2(3,6)) ) );
        TESTFW_EXPECTED( vec4_eq( vm_atan2( vec4(1,2,3,4), vec4(5,6,7,8) ), vec4(vecmath_atan2(1,5),vecmath_atan2(2,6),vecmath_atan2(3,7),vecmath_atan2(4,8)) ) );
        TESTFW_EXPECTED( mat22_eq( vm_atan2( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)) ), mat22(vec2(vecmath_atan2(1,5),vecmath_atan2(2,6)),vec2(vecmath_atan2(3,7),vecmath_atan2(4,8))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_atan2( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(7,8,9),vec3(10,11,12)) ), mat23(vec3(vecmath_atan2(1,7),vecmath_atan2(2,8),vecmath_atan2(3,9)),vec3(vecmath_atan2(4,10),vecmath_atan2(5,11),vecmath_atan2(6,12))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_atan2( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ), mat24(vec4(vecmath_atan2(1,9),vecmath_atan2(2,10),vecmath_atan2(3,11),vecmath_atan2(4,12)),vec4(vecmath_atan2(5,13),vecmath_atan2(6,14),vecmath_atan2(7,15),vecmath_atan2(8,16))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_atan2( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ), mat32(vec2(vecmath_atan2(1,7),vecmath_atan2(2,8)),vec2(vecmath_atan2(3,9),vecmath_atan2(4,10)),vec2(vecmath_atan2(5,11),vecmath_atan2(6,12))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_atan2( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)) ), mat33(vec3(vecmath_atan2(1,10),vecmath_atan2(2,11),vecmath_atan2(3,12)),vec3(vecmath_atan2(4,13),vecmath_atan2(5,14),vecmath_atan2(6,15)),vec3(vecmath_atan2(7,16),vecmath_atan2(8,17),vecmath_atan2(9,18))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_atan2( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ), mat34(vec4(vecmath_atan2(1,13),vecmath_atan2(2,14),vecmath_atan2(3,15),vecmath_atan2(4,16)),vec4(vecmath_atan2(5,17),vecmath_atan2(6,18),vecmath_atan2(7,19),vecmath_atan2(8,20)),vec4(vecmath_atan2(9,21),vecmath_atan2(10,22),vecmath_atan2(11,23),vecmath_atan2(12,24))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_atan2( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ), mat42(vec2(vecmath_atan2(1,9),vecmath_atan2(2,10)),vec2(vecmath_atan2(3,11),vecmath_atan2(4,12)),vec2(vecmath_atan2(5,13),vecmath_atan2(6,14)),vec2(vecmath_atan2(7,15),vecmath_atan2(8,16))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_atan2( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ), mat43(vec3(vecmath_atan2(1,13),vecmath_atan2(2,14),vecmath_atan2(3,15)),vec3(vecmath_atan2(4,16),vecmath_atan2(5,17),vecmath_atan2(6,18)),vec3(vecmath_atan2(7,19),vecmath_atan2(8,20),vecmath_atan2(9,21)),vec3(vecmath_atan2(10,22),vecmath_atan2(11,23),vecmath_atan2(12,24))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_atan2( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ), mat44(vec4(vecmath_atan2(1,17),vecmath_atan2(2,18),vecmath_atan2(3,19),vecmath_atan2(4,20)),vec4(vecmath_atan2(5,21),vecmath_atan2(6,22),vecmath_atan2(7,23),vecmath_atan2(8,24)),vec4(vecmath_atan2(9,25),vecmath_atan2(10,26),vecmath_atan2(11,27),vecmath_atan2(12,28)),vec4(vecmath_atan2(13,29),vecmath_atan2(14,30),vecmath_atan2(15,31),vecmath_atan2(16,32))) ) );
    TESTFW_TEST_END();

    // vm_ceil
    TESTFW_TEST_BEGIN( "vm_ceil dispatches to correct *_ceil implementation" )
        TESTFW_EXPECTED( vm_ceil( 1.2f ) == vecmath_ceil( 1.2f ) );
        TESTFW_EXPECTED( vec2_eq( vm_ceil( vec2(1.2f,2.8f) ), vec2(vecmath_ceil(1.2f),vecmath_ceil(2.8f)) ) );
        TESTFW_EXPECTED( vec3_eq( vm_ceil( vec3(1.1f,2.5f,3.9f) ), vec3(vecmath_ceil(1.1f),vecmath_ceil(2.5f),vecmath_ceil(3.9f)) ) );
        TESTFW_EXPECTED( vec4_eq( vm_ceil( vec4(1.1f,2.2f,3.3f,4.4f) ), vec4(vecmath_ceil(1.1f),vecmath_ceil(2.2f),vecmath_ceil(3.3f),vecmath_ceil(4.4f)) ) );
        TESTFW_EXPECTED( mat22_eq( vm_ceil( mat22(vec2(1.1f,2.2f),vec2(3.3f,4.4f)) ), mat22(vec2(vecmath_ceil(1.1f),vecmath_ceil(2.2f)),vec2(vecmath_ceil(3.3f),vecmath_ceil(4.4f))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_ceil( mat23(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f)) ), mat23(vec3(vecmath_ceil(1.1f),vecmath_ceil(2.2f),vecmath_ceil(3.3f)),vec3(vecmath_ceil(4.4f),vecmath_ceil(5.5f),vecmath_ceil(6.6f))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_ceil( mat24(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f)) ), mat24(vec4(vecmath_ceil(1.1f),vecmath_ceil(2.2f),vecmath_ceil(3.3f),vecmath_ceil(4.4f)),vec4(vecmath_ceil(5.5f),vecmath_ceil(6.6f),vecmath_ceil(7.7f),vecmath_ceil(8.8f))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_ceil( mat32(vec2(1.1f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f)) ), mat32(vec2(vecmath_ceil(1.1f),vecmath_ceil(2.2f)),vec2(vecmath_ceil(3.3f),vecmath_ceil(4.4f)),vec2(vecmath_ceil(5.5f),vecmath_ceil(6.6f))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_ceil( mat33(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f)) ), mat33(vec3(vecmath_ceil(1.1f),vecmath_ceil(2.2f),vecmath_ceil(3.3f)),vec3(vecmath_ceil(4.4f),vecmath_ceil(5.5f),vecmath_ceil(6.6f)),vec3(vecmath_ceil(7.7f),vecmath_ceil(8.8f),vecmath_ceil(9.9f))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_ceil( mat34(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f),vec4(9.9f,10.1f,11.2f,12.3f)) ), mat34(vec4(vecmath_ceil(1.1f),vecmath_ceil(2.2f),vecmath_ceil(3.3f),vecmath_ceil(4.4f)),vec4(vecmath_ceil(5.5f),vecmath_ceil(6.6f),vecmath_ceil(7.7f),vecmath_ceil(8.8f)),vec4(vecmath_ceil(9.9f),vecmath_ceil(10.1f),vecmath_ceil(11.2f),vecmath_ceil(12.3f))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_ceil( mat42(vec2(1.1f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f),vec2(7.7f,8.8f)) ), mat42(vec2(vecmath_ceil(1.1f),vecmath_ceil(2.2f)),vec2(vecmath_ceil(3.3f),vecmath_ceil(4.4f)),vec2(vecmath_ceil(5.5f),vecmath_ceil(6.6f)),vec2(vecmath_ceil(7.7f),vecmath_ceil(8.8f))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_ceil( mat43(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f),vec3(10.1f,11.2f,12.3f)) ), mat43(vec3(vecmath_ceil(1.1f),vecmath_ceil(2.2f),vecmath_ceil(3.3f)),vec3(vecmath_ceil(4.4f),vecmath_ceil(5.5f),vecmath_ceil(6.6f)),vec3(vecmath_ceil(7.7f),vecmath_ceil(8.8f),vecmath_ceil(9.9f)),vec3(vecmath_ceil(10.1f),vecmath_ceil(11.2f),vecmath_ceil(12.3f))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_ceil( mat44(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f),vec4(9.9f,10.1f,11.2f,12.3f),vec4(13.4f,14.5f,15.6f,16.7f)) ), mat44(vec4(vecmath_ceil(1.1f),vecmath_ceil(2.2f),vecmath_ceil(3.3f),vecmath_ceil(4.4f)),vec4(vecmath_ceil(5.5f),vecmath_ceil(6.6f),vecmath_ceil(7.7f),vecmath_ceil(8.8f)),vec4(vecmath_ceil(9.9f),vecmath_ceil(10.1f),vecmath_ceil(11.2f),vecmath_ceil(12.3f)),vec4(vecmath_ceil(13.4f),vecmath_ceil(14.5f),vecmath_ceil(15.6f),vecmath_ceil(16.7f))) ) );
    TESTFW_TEST_END();

    // vm_clamp
    TESTFW_TEST_BEGIN( "vm_clamp dispatches to correct *_clamp implementation" )
        TESTFW_EXPECTED( vm_clamp( 5.0f, 1.0f, 3.0f ) == vecmath_clamp( 5.0f, 1.0f, 3.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_clamp( vec2(5,0), vec2(1,1), vec2(3,3) ), vec2(3,1) ) );
        TESTFW_EXPECTED( vec3_eq( vm_clamp( vec3(5,0,4), vec3(1,2,3), vec3(3,3,3) ), vec3(3,2,3) ) );
        TESTFW_EXPECTED( vec4_eq( vm_clamp( vec4(5,0,4,2), vec4(1,2,3,1), vec4(3,3,3,3) ), vec4(3,2,3,2) ) );
        TESTFW_EXPECTED( mat22_eq( vm_clamp( mat22(vec2(5,0),vec2(2,4)), mat22(vec2(1,1),vec2(1,1)), mat22(vec2(3,3),vec2(3,3)) ), mat22(vec2(3,1),vec2(2,3)) ) );
        TESTFW_EXPECTED( mat23_eq( vm_clamp( mat23(vec3(5,0,4),vec3(2,4,6)), mat23(vec3(1,2,3),vec3(1,1,1)), mat23(vec3(3,3,3),vec3(3,3,3)) ), mat23(vec3(3,2,3),vec3(2,3,3)) ) );
        TESTFW_EXPECTED( mat24_eq( vm_clamp( mat24(vec4(5,0,4,2),vec4(6,7,8,9)), mat24(vec4(1,2,3,1),vec4(1,1,1,1)), mat24(vec4(3,3,3,3),vec4(3,3,3,3)) ), mat24(vec4(3,2,3,2),vec4(3,3,3,3)) ) );
        TESTFW_EXPECTED( mat32_eq( vm_clamp( mat32(vec2(5,0),vec2(2,4),vec2(7,8)), mat32(vec2(1,1),vec2(1,1),vec2(1,1)), mat32(vec2(3,3),vec2(3,3),vec2(3,3)) ), mat32(vec2(3,1),vec2(2,3),vec2(3,3)) ) );
        TESTFW_EXPECTED( mat33_eq( vm_clamp( mat33(vec3(5,0,4),vec3(2,4,6),vec3(7,8,9)), mat33(vec3(1,2,3),vec3(1,1,1),vec3(1,1,1)), mat33(vec3(3,3,3),vec3(3,3,3),vec3(3,3,3)) ), mat33(vec3(3,2,3),vec3(2,3,3),vec3(3,3,3)) ) );
        TESTFW_EXPECTED( mat34_eq( vm_clamp( mat34(vec4(5,0,4,2),vec4(6,7,8,9),vec4(10,11,12,13)), mat34(vec4(1,2,3,1),vec4(1,1,1,1),vec4(1,1,1,1)), mat34(vec4(3,3,3,3),vec4(3,3,3,3),vec4(3,3,3,3)) ), mat34(vec4(3,2,3,2),vec4(3,3,3,3),vec4(3,3,3,3)) ) );
        TESTFW_EXPECTED( mat42_eq( vm_clamp( mat42(vec2(5,0),vec2(2,4),vec2(7,8),vec2(9,10)), mat42(vec2(1,1),vec2(1,1),vec2(1,1),vec2(1,1)), mat42(vec2(3,3),vec2(3,3),vec2(3,3),vec2(3,3)) ), mat42(vec2(3,1),vec2(2,3),vec2(3,3),vec2(3,3)) ) );
        TESTFW_EXPECTED( mat43_eq( vm_clamp( mat43(vec3(5,0,4),vec3(2,4,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(1,2,3),vec3(1,1,1),vec3(1,1,1),vec3(1,1,1)), mat43(vec3(3,3,3),vec3(3,3,3),vec3(3,3,3),vec3(3,3,3)) ), mat43(vec3(3,2,3),vec3(2,3,3),vec3(3,3,3),vec3(3,3,3)) ) );
        TESTFW_EXPECTED( mat44_eq( vm_clamp( mat44(vec4(5,0,4,2),vec4(6,7,8,9),vec4(10,11,12,13),vec4(14,15,16,17)), mat44(vec4(1,2,3,1),vec4(1,1,1,1),vec4(1,1,1,1),vec4(1,1,1,1)), mat44(vec4(3,3,3,3),vec4(3,3,3,3),vec4(3,3,3,3),vec4(3,3,3,3)) ), mat44(vec4(3,2,3,2),vec4(3,3,3,3),vec4(3,3,3,3),vec4(3,3,3,3)) ) );
    TESTFW_TEST_END();

    // vm_cos
    TESTFW_TEST_BEGIN( "vm_cos dispatches to correct *_cos implementation" )
        TESTFW_EXPECTED( vm_cos( 1.0f ) == vecmath_cos( 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_cos( vec2(1,2) ), vec2( vecmath_cos(1.0f), vecmath_cos(2.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_cos( vec3(1,2,3) ), vec3( vecmath_cos(1.0f), vecmath_cos(2.0f), vecmath_cos(3.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_cos( vec4(1,2,3,4) ), vec4( vecmath_cos(1.0f), vecmath_cos(2.0f), vecmath_cos(3.0f), vecmath_cos(4.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_cos( mat22(vec2(1,2),vec2(3,4)) ), mat22(vec2(vecmath_cos(1.0f),vecmath_cos(2.0f)),vec2(vecmath_cos(3.0f),vecmath_cos(4.0f))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_cos( mat23(vec3(1,2,3),vec3(4,5,6)) ), mat23(vec3(vecmath_cos(1.0f),vecmath_cos(2.0f),vecmath_cos(3.0f)),vec3(vecmath_cos(4.0f),vecmath_cos(5.0f),vecmath_cos(6.0f))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_cos( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), mat24(vec4(vecmath_cos(1.0f),vecmath_cos(2.0f),vecmath_cos(3.0f),vecmath_cos(4.0f)),vec4(vecmath_cos(5.0f),vecmath_cos(6.0f),vecmath_cos(7.0f),vecmath_cos(8.0f))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_cos( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), mat32(vec2(vecmath_cos(1.0f),vecmath_cos(2.0f)),vec2(vecmath_cos(3.0f),vecmath_cos(4.0f)),vec2(vecmath_cos(5.0f),vecmath_cos(6.0f))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_cos( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), mat33(vec3(vecmath_cos(1.0f),vecmath_cos(2.0f),vecmath_cos(3.0f)),vec3(vecmath_cos(4.0f),vecmath_cos(5.0f),vecmath_cos(6.0f)),vec3(vecmath_cos(7.0f),vecmath_cos(8.0f),vecmath_cos(9.0f))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_cos( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), mat34(vec4(vecmath_cos(1.0f),vecmath_cos(2.0f),vecmath_cos(3.0f),vecmath_cos(4.0f)),vec4(vecmath_cos(5.0f),vecmath_cos(6.0f),vecmath_cos(7.0f),vecmath_cos(8.0f)),vec4(vecmath_cos(9.0f),vecmath_cos(10.0f),vecmath_cos(11.0f),vecmath_cos(12.0f))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_cos( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), mat42(vec2(vecmath_cos(1.0f),vecmath_cos(2.0f)),vec2(vecmath_cos(3.0f),vecmath_cos(4.0f)),vec2(vecmath_cos(5.0f),vecmath_cos(6.0f)),vec2(vecmath_cos(7.0f),vecmath_cos(8.0f))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_cos( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), mat43(vec3(vecmath_cos(1.0f),vecmath_cos(2.0f),vecmath_cos(3.0f)),vec3(vecmath_cos(4.0f),vecmath_cos(5.0f),vecmath_cos(6.0f)),vec3(vecmath_cos(7.0f),vecmath_cos(8.0f),vecmath_cos(9.0f)),vec3(vecmath_cos(10.0f),vecmath_cos(11.0f),vecmath_cos(12.0f))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_cos( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), mat44(vec4(vecmath_cos(1.0f),vecmath_cos(2.0f),vecmath_cos(3.0f),vecmath_cos(4.0f)),vec4(vecmath_cos(5.0f),vecmath_cos(6.0f),vecmath_cos(7.0f),vecmath_cos(8.0f)),vec4(vecmath_cos(9.0f),vecmath_cos(10.0f),vecmath_cos(11.0f),vecmath_cos(12.0f)),vec4(vecmath_cos(13.0f),vecmath_cos(14.0f),vecmath_cos(15.0f),vecmath_cos(16.0f))) ) );
    TESTFW_TEST_END();

    // vm_cosh
    TESTFW_TEST_BEGIN( "vm_cosh dispatches to correct *_cosh implementation" )
        TESTFW_EXPECTED( vm_cosh( 1.0f ) == vecmath_cosh( 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_cosh( vec2(1,2) ), vec2( vecmath_cosh(1.0f), vecmath_cosh(2.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_cosh( vec3(1,2,3) ), vec3( vecmath_cosh(1.0f), vecmath_cosh(2.0f), vecmath_cosh(3.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_cosh( vec4(1,2,3,4) ), vec4( vecmath_cosh(1.0f), vecmath_cosh(2.0f), vecmath_cosh(3.0f), vecmath_cosh(4.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_cosh( mat22(vec2(1,2),vec2(3,4)) ), mat22(vec2(vecmath_cosh(1.0f),vecmath_cosh(2.0f)),vec2(vecmath_cosh(3.0f),vecmath_cosh(4.0f))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_cosh( mat23(vec3(1,2,3),vec3(4,5,6)) ), mat23(vec3(vecmath_cosh(1.0f),vecmath_cosh(2.0f),vecmath_cosh(3.0f)),vec3(vecmath_cosh(4.0f),vecmath_cosh(5.0f),vecmath_cosh(6.0f))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_cosh( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), mat24(vec4(vecmath_cosh(1.0f),vecmath_cosh(2.0f),vecmath_cosh(3.0f),vecmath_cosh(4.0f)),vec4(vecmath_cosh(5.0f),vecmath_cosh(6.0f),vecmath_cosh(7.0f),vecmath_cosh(8.0f))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_cosh( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), mat32(vec2(vecmath_cosh(1.0f),vecmath_cosh(2.0f)),vec2(vecmath_cosh(3.0f),vecmath_cosh(4.0f)),vec2(vecmath_cosh(5.0f),vecmath_cosh(6.0f))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_cosh( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), mat33(vec3(vecmath_cosh(1.0f),vecmath_cosh(2.0f),vecmath_cosh(3.0f)),vec3(vecmath_cosh(4.0f),vecmath_cosh(5.0f),vecmath_cosh(6.0f)),vec3(vecmath_cosh(7.0f),vecmath_cosh(8.0f),vecmath_cosh(9.0f))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_cosh( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), mat34(vec4(vecmath_cosh(1.0f),vecmath_cosh(2.0f),vecmath_cosh(3.0f),vecmath_cosh(4.0f)),vec4(vecmath_cosh(5.0f),vecmath_cosh(6.0f),vecmath_cosh(7.0f),vecmath_cosh(8.0f)),vec4(vecmath_cosh(9.0f),vecmath_cosh(10.0f),vecmath_cosh(11.0f),vecmath_cosh(12.0f))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_cosh( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), mat42(vec2(vecmath_cosh(1.0f),vecmath_cosh(2.0f)),vec2(vecmath_cosh(3.0f),vecmath_cosh(4.0f)),vec2(vecmath_cosh(5.0f),vecmath_cosh(6.0f)),vec2(vecmath_cosh(7.0f),vecmath_cosh(8.0f))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_cosh( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), mat43(vec3(vecmath_cosh(1.0f),vecmath_cosh(2.0f),vecmath_cosh(3.0f)),vec3(vecmath_cosh(4.0f),vecmath_cosh(5.0f),vecmath_cosh(6.0f)),vec3(vecmath_cosh(7.0f),vecmath_cosh(8.0f),vecmath_cosh(9.0f)),vec3(vecmath_cosh(10.0f),vecmath_cosh(11.0f),vecmath_cosh(12.0f))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_cosh( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), mat44(vec4(vecmath_cosh(1.0f),vecmath_cosh(2.0f),vecmath_cosh(3.0f),vecmath_cosh(4.0f)),vec4(vecmath_cosh(5.0f),vecmath_cosh(6.0f),vecmath_cosh(7.0f),vecmath_cosh(8.0f)),vec4(vecmath_cosh(9.0f),vecmath_cosh(10.0f),vecmath_cosh(11.0f),vecmath_cosh(12.0f)),vec4(vecmath_cosh(13.0f),vecmath_cosh(14.0f),vecmath_cosh(15.0f),vecmath_cosh(16.0f))) ) );
    TESTFW_TEST_END();

    // vm_cross
    TESTFW_TEST_BEGIN( "vm_cross dispatches to correct *_cross implementation" )
        TESTFW_EXPECTED( vm_cross( vec2(3,4), vec2(5,6) ) == vec2_cross( vec2(3,4), vec2(5,6) ) );
        TESTFW_EXPECTED( vec3_eq( vm_cross( vec3(1,0,0), vec3(0,1,0) ), vec3_cross( vec3(1,0,0), vec3(0,1,0) ) ) );
    TESTFW_TEST_END();

    // vm_degrees
    TESTFW_TEST_BEGIN( "vm_degrees dispatches to correct *_degrees implementation" )
        TESTFW_EXPECTED( vm_degrees( 1.0f ) == vecmath_degrees( 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_degrees( vec2(1,2) ), vec2( vecmath_degrees(1.0f), vecmath_degrees(2.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_degrees( vec3(1,2,3) ), vec3( vecmath_degrees(1.0f), vecmath_degrees(2.0f), vecmath_degrees(3.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_degrees( vec4(1,2,3,4) ), vec4( vecmath_degrees(1.0f), vecmath_degrees(2.0f), vecmath_degrees(3.0f), vecmath_degrees(4.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_degrees( mat22(vec2(1,2),vec2(3,4)) ), mat22(vec2(vecmath_degrees(1.0f),vecmath_degrees(2.0f)),vec2(vecmath_degrees(3.0f),vecmath_degrees(4.0f))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_degrees( mat23(vec3(1,2,3),vec3(4,5,6)) ), mat23(vec3(vecmath_degrees(1.0f),vecmath_degrees(2.0f),vecmath_degrees(3.0f)),vec3(vecmath_degrees(4.0f),vecmath_degrees(5.0f),vecmath_degrees(6.0f))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_degrees( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), mat24(vec4(vecmath_degrees(1.0f),vecmath_degrees(2.0f),vecmath_degrees(3.0f),vecmath_degrees(4.0f)),vec4(vecmath_degrees(5.0f),vecmath_degrees(6.0f),vecmath_degrees(7.0f),vecmath_degrees(8.0f))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_degrees( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), mat32(vec2(vecmath_degrees(1.0f),vecmath_degrees(2.0f)),vec2(vecmath_degrees(3.0f),vecmath_degrees(4.0f)),vec2(vecmath_degrees(5.0f),vecmath_degrees(6.0f))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_degrees( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), mat33(vec3(vecmath_degrees(1.0f),vecmath_degrees(2.0f),vecmath_degrees(3.0f)),vec3(vecmath_degrees(4.0f),vecmath_degrees(5.0f),vecmath_degrees(6.0f)),vec3(vecmath_degrees(7.0f),vecmath_degrees(8.0f),vecmath_degrees(9.0f))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_degrees( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), mat34(vec4(vecmath_degrees(1.0f),vecmath_degrees(2.0f),vecmath_degrees(3.0f),vecmath_degrees(4.0f)),vec4(vecmath_degrees(5.0f),vecmath_degrees(6.0f),vecmath_degrees(7.0f),vecmath_degrees(8.0f)),vec4(vecmath_degrees(9.0f),vecmath_degrees(10.0f),vecmath_degrees(11.0f),vecmath_degrees(12.0f))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_degrees( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), mat42(vec2(vecmath_degrees(1.0f),vecmath_degrees(2.0f)),vec2(vecmath_degrees(3.0f),vecmath_degrees(4.0f)),vec2(vecmath_degrees(5.0f),vecmath_degrees(6.0f)),vec2(vecmath_degrees(7.0f),vecmath_degrees(8.0f))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_degrees( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), mat43(vec3(vecmath_degrees(1.0f),vecmath_degrees(2.0f),vecmath_degrees(3.0f)),vec3(vecmath_degrees(4.0f),vecmath_degrees(5.0f),vecmath_degrees(6.0f)),vec3(vecmath_degrees(7.0f),vecmath_degrees(8.0f),vecmath_degrees(9.0f)),vec3(vecmath_degrees(10.0f),vecmath_degrees(11.0f),vecmath_degrees(12.0f))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_degrees( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), mat44(vec4(vecmath_degrees(1.0f),vecmath_degrees(2.0f),vecmath_degrees(3.0f),vecmath_degrees(4.0f)),vec4(vecmath_degrees(5.0f),vecmath_degrees(6.0f),vecmath_degrees(7.0f),vecmath_degrees(8.0f)),vec4(vecmath_degrees(9.0f),vecmath_degrees(10.0f),vecmath_degrees(11.0f),vecmath_degrees(12.0f)),vec4(vecmath_degrees(13.0f),vecmath_degrees(14.0f),vecmath_degrees(15.0f),vecmath_degrees(16.0f))) ) );
    TESTFW_TEST_END();

    // vm_distancesq
    TESTFW_TEST_BEGIN( "vm_distancesq dispatches to correct *_distancesq implementation" )
        TESTFW_EXPECTED( vm_distancesq( 1.0f, 4.0f ) == vecmath_distancesq( 1.0f, 4.0f ) );
        TESTFW_EXPECTED( vm_distancesq( vec2(1,2), vec2(4,6) ) == vec2_distancesq( vec2(1,2), vec2(4,6) ) );
        TESTFW_EXPECTED( vm_distancesq( vec3(1,2,3), vec3(4,5,6) ) == vec3_distancesq( vec3(1,2,3), vec3(4,5,6) ) );
        TESTFW_EXPECTED( vm_distancesq( vec4(1,2,3,4), vec4(5,6,7,8) ) == vec4_distancesq( vec4(1,2,3,4), vec4(5,6,7,8) ) );
    TESTFW_TEST_END();

    // vm_distance
    TESTFW_TEST_BEGIN( "vm_distance dispatches to correct *_distance implementation" )
        TESTFW_EXPECTED( vm_distance( 1.0f, 4.0f ) == vecmath_distance( 1.0f, 4.0f ) );
        TESTFW_EXPECTED( vm_distance( vec2(1,2), vec2(4,6) ) == vec2_distance( vec2(1,2), vec2(4,6) ) );
        TESTFW_EXPECTED( vm_distance( vec3(1,2,3), vec3(4,5,6) ) == vec3_distance( vec3(1,2,3), vec3(4,5,6) ) );
        TESTFW_EXPECTED( vm_distance( vec4(1,2,3,4), vec4(5,6,7,8) ) == vec4_distance( vec4(1,2,3,4), vec4(5,6,7,8) ) );
    TESTFW_TEST_END();

    // vm_dot
    TESTFW_TEST_BEGIN( "vm_dot dispatches to correct *_dot implementation" )
        TESTFW_EXPECTED( vm_dot( 2.0f, 3.0f ) == vecmath_dot( 2.0f, 3.0f ) );
        TESTFW_EXPECTED( vm_dot( vec2(1,2), vec2(3,4) ) == vec2_dot( vec2(1,2), vec2(3,4) ) );
        TESTFW_EXPECTED( vm_dot( vec3(1,2,3), vec3(4,5,6) ) == vec3_dot( vec3(1,2,3), vec3(4,5,6) ) );
        TESTFW_EXPECTED( vm_dot( vec4(1,2,3,4), vec4(5,6,7,8) ) == vec4_dot( vec4(1,2,3,4), vec4(5,6,7,8) ) );
    TESTFW_TEST_END();

    // vm_exp
    TESTFW_TEST_BEGIN( "vm_exp dispatches to correct *_exp implementation" )
        TESTFW_EXPECTED( vm_exp( 1.0f ) == vecmath_exp( 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_exp( vec2(1,2) ), vec2( vecmath_exp(1.0f), vecmath_exp(2.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_exp( vec3(1,2,3) ), vec3( vecmath_exp(1.0f), vecmath_exp(2.0f), vecmath_exp(3.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_exp( vec4(1,2,3,4) ), vec4( vecmath_exp(1.0f), vecmath_exp(2.0f), vecmath_exp(3.0f), vecmath_exp(4.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_exp( mat22(vec2(1,2),vec2(3,4)) ), mat22(vec2(vecmath_exp(1.0f),vecmath_exp(2.0f)),vec2(vecmath_exp(3.0f),vecmath_exp(4.0f))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_exp( mat23(vec3(1,2,3),vec3(4,5,6)) ), mat23(vec3(vecmath_exp(1.0f),vecmath_exp(2.0f),vecmath_exp(3.0f)),vec3(vecmath_exp(4.0f),vecmath_exp(5.0f),vecmath_exp(6.0f))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_exp( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), mat24(vec4(vecmath_exp(1.0f),vecmath_exp(2.0f),vecmath_exp(3.0f),vecmath_exp(4.0f)),vec4(vecmath_exp(5.0f),vecmath_exp(6.0f),vecmath_exp(7.0f),vecmath_exp(8.0f))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_exp( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), mat32(vec2(vecmath_exp(1.0f),vecmath_exp(2.0f)),vec2(vecmath_exp(3.0f),vecmath_exp(4.0f)),vec2(vecmath_exp(5.0f),vecmath_exp(6.0f))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_exp( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), mat33(vec3(vecmath_exp(1.0f),vecmath_exp(2.0f),vecmath_exp(3.0f)),vec3(vecmath_exp(4.0f),vecmath_exp(5.0f),vecmath_exp(6.0f)),vec3(vecmath_exp(7.0f),vecmath_exp(8.0f),vecmath_exp(9.0f))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_exp( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), mat34(vec4(vecmath_exp(1.0f),vecmath_exp(2.0f),vecmath_exp(3.0f),vecmath_exp(4.0f)),vec4(vecmath_exp(5.0f),vecmath_exp(6.0f),vecmath_exp(7.0f),vecmath_exp(8.0f)),vec4(vecmath_exp(9.0f),vecmath_exp(10.0f),vecmath_exp(11.0f),vecmath_exp(12.0f))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_exp( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), mat42(vec2(vecmath_exp(1.0f),vecmath_exp(2.0f)),vec2(vecmath_exp(3.0f),vecmath_exp(4.0f)),vec2(vecmath_exp(5.0f),vecmath_exp(6.0f)),vec2(vecmath_exp(7.0f),vecmath_exp(8.0f))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_exp( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), mat43(vec3(vecmath_exp(1.0f),vecmath_exp(2.0f),vecmath_exp(3.0f)),vec3(vecmath_exp(4.0f),vecmath_exp(5.0f),vecmath_exp(6.0f)),vec3(vecmath_exp(7.0f),vecmath_exp(8.0f),vecmath_exp(9.0f)),vec3(vecmath_exp(10.0f),vecmath_exp(11.0f),vecmath_exp(12.0f))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_exp( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), mat44(vec4(vecmath_exp(1.0f),vecmath_exp(2.0f),vecmath_exp(3.0f),vecmath_exp(4.0f)),vec4(vecmath_exp(5.0f),vecmath_exp(6.0f),vecmath_exp(7.0f),vecmath_exp(8.0f)),vec4(vecmath_exp(9.0f),vecmath_exp(10.0f),vecmath_exp(11.0f),vecmath_exp(12.0f)),vec4(vecmath_exp(13.0f),vecmath_exp(14.0f),vecmath_exp(15.0f),vecmath_exp(16.0f))) ) );
    TESTFW_TEST_END();

    // vm_exp2
    TESTFW_TEST_BEGIN( "vm_exp2 dispatches to correct *_exp2 implementation" )
        TESTFW_EXPECTED( vm_exp2( 1.0f ) == vecmath_exp2( 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_exp2( vec2(1,2) ), vec2( vecmath_exp2(1.0f), vecmath_exp2(2.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_exp2( vec3(1,2,3) ), vec3( vecmath_exp2(1.0f), vecmath_exp2(2.0f), vecmath_exp2(3.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_exp2( vec4(1,2,3,4) ), vec4( vecmath_exp2(1.0f), vecmath_exp2(2.0f), vecmath_exp2(3.0f), vecmath_exp2(4.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_exp2( mat22(vec2(1,2),vec2(3,4)) ), mat22(vec2(vecmath_exp2(1.0f),vecmath_exp2(2.0f)),vec2(vecmath_exp2(3.0f),vecmath_exp2(4.0f))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_exp2( mat23(vec3(1,2,3),vec3(4,5,6)) ), mat23(vec3(vecmath_exp2(1.0f),vecmath_exp2(2.0f),vecmath_exp2(3.0f)),vec3(vecmath_exp2(4.0f),vecmath_exp2(5.0f),vecmath_exp2(6.0f))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_exp2( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), mat24(vec4(vecmath_exp2(1.0f),vecmath_exp2(2.0f),vecmath_exp2(3.0f),vecmath_exp2(4.0f)),vec4(vecmath_exp2(5.0f),vecmath_exp2(6.0f),vecmath_exp2(7.0f),vecmath_exp2(8.0f))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_exp2( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), mat32(vec2(vecmath_exp2(1.0f),vecmath_exp2(2.0f)),vec2(vecmath_exp2(3.0f),vecmath_exp2(4.0f)),vec2(vecmath_exp2(5.0f),vecmath_exp2(6.0f))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_exp2( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), mat33(vec3(vecmath_exp2(1.0f),vecmath_exp2(2.0f),vecmath_exp2(3.0f)),vec3(vecmath_exp2(4.0f),vecmath_exp2(5.0f),vecmath_exp2(6.0f)),vec3(vecmath_exp2(7.0f),vecmath_exp2(8.0f),vecmath_exp2(9.0f))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_exp2( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), mat34(vec4(vecmath_exp2(1.0f),vecmath_exp2(2.0f),vecmath_exp2(3.0f),vecmath_exp2(4.0f)),vec4(vecmath_exp2(5.0f),vecmath_exp2(6.0f),vecmath_exp2(7.0f),vecmath_exp2(8.0f)),vec4(vecmath_exp2(9.0f),vecmath_exp2(10.0f),vecmath_exp2(11.0f),vecmath_exp2(12.0f))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_exp2( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), mat42(vec2(vecmath_exp2(1.0f),vecmath_exp2(2.0f)),vec2(vecmath_exp2(3.0f),vecmath_exp2(4.0f)),vec2(vecmath_exp2(5.0f),vecmath_exp2(6.0f)),vec2(vecmath_exp2(7.0f),vecmath_exp2(8.0f))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_exp2( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), mat43(vec3(vecmath_exp2(1.0f),vecmath_exp2(2.0f),vecmath_exp2(3.0f)),vec3(vecmath_exp2(4.0f),vecmath_exp2(5.0f),vecmath_exp2(6.0f)),vec3(vecmath_exp2(7.0f),vecmath_exp2(8.0f),vecmath_exp2(9.0f)),vec3(vecmath_exp2(10.0f),vecmath_exp2(11.0f),vecmath_exp2(12.0f))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_exp2( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), mat44(vec4(vecmath_exp2(1.0f),vecmath_exp2(2.0f),vecmath_exp2(3.0f),vecmath_exp2(4.0f)),vec4(vecmath_exp2(5.0f),vecmath_exp2(6.0f),vecmath_exp2(7.0f),vecmath_exp2(8.0f)),vec4(vecmath_exp2(9.0f),vecmath_exp2(10.0f),vecmath_exp2(11.0f),vecmath_exp2(12.0f)),vec4(vecmath_exp2(13.0f),vecmath_exp2(14.0f),vecmath_exp2(15.0f),vecmath_exp2(16.0f))) ) );
    TESTFW_TEST_END();

    // vm_floor
    TESTFW_TEST_BEGIN( "vm_floor dispatches to correct *_floor implementation" )
        TESTFW_EXPECTED( vm_floor( 1.9f ) == vecmath_floor( 1.9f ) );
        TESTFW_EXPECTED( vec2_eq( vm_floor( vec2(1.1f,2.9f) ), vec2( vecmath_floor(1.1f), vecmath_floor(2.9f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_floor( vec3(3.7f,4.3f,5.5f) ), vec3( vecmath_floor(3.7f), vecmath_floor(4.3f), vecmath_floor(5.5f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_floor( vec4(6.6f,7.2f,8.8f,9.1f) ), vec4( vecmath_floor(6.6f), vecmath_floor(7.2f), vecmath_floor(8.8f), vecmath_floor(9.1f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_floor( mat22(vec2(1.2f,2.5f),vec2(3.3f,4.8f)) ), mat22(vec2(vecmath_floor(1.2f),vecmath_floor(2.5f)),vec2(vecmath_floor(3.3f),vecmath_floor(4.8f))) ) );
        TESTFW_EXPECTED( mat23_eq( vm_floor( mat23(vec3(1.2f,2.3f,3.4f),vec3(4.5f,5.6f,6.7f)) ), mat23(vec3(vecmath_floor(1.2f),vecmath_floor(2.3f),vecmath_floor(3.4f)),vec3(vecmath_floor(4.5f),vecmath_floor(5.6f),vecmath_floor(6.7f))) ) );
        TESTFW_EXPECTED( mat24_eq( vm_floor( mat24(vec4(1.2f,2.3f,3.4f,4.5f),vec4(5.6f,6.7f,7.8f,8.9f)) ), mat24(vec4(vecmath_floor(1.2f),vecmath_floor(2.3f),vecmath_floor(3.4f),vecmath_floor(4.5f)),vec4(vecmath_floor(5.6f),vecmath_floor(6.7f),vecmath_floor(7.8f),vecmath_floor(8.9f))) ) );
        TESTFW_EXPECTED( mat32_eq( vm_floor( mat32(vec2(1.2f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f)) ), mat32(vec2(vecmath_floor(1.2f),vecmath_floor(2.2f)),vec2(vecmath_floor(3.3f),vecmath_floor(4.4f)),vec2(vecmath_floor(5.5f),vecmath_floor(6.6f))) ) );
        TESTFW_EXPECTED( mat33_eq( vm_floor( mat33(vec3(1.2f,2.2f,3.2f),vec3(4.2f,5.2f,6.2f),vec3(7.2f,8.2f,9.2f)) ), mat33(vec3(vecmath_floor(1.2f),vecmath_floor(2.2f),vecmath_floor(3.2f)),vec3(vecmath_floor(4.2f),vecmath_floor(5.2f),vecmath_floor(6.2f)),vec3(vecmath_floor(7.2f),vecmath_floor(8.2f),vecmath_floor(9.2f))) ) );
        TESTFW_EXPECTED( mat34_eq( vm_floor( mat34(vec4(1.2f,2.3f,3.4f,4.5f),vec4(5.6f,6.7f,7.8f,8.9f),vec4(9.1f,10.2f,11.3f,12.4f)) ), mat34(vec4(vecmath_floor(1.2f),vecmath_floor(2.3f),vecmath_floor(3.4f),vecmath_floor(4.5f)),vec4(vecmath_floor(5.6f),vecmath_floor(6.7f),vecmath_floor(7.8f),vecmath_floor(8.9f)),vec4(vecmath_floor(9.1f),vecmath_floor(10.2f),vecmath_floor(11.3f),vecmath_floor(12.4f))) ) );
        TESTFW_EXPECTED( mat42_eq( vm_floor( mat42(vec2(1.2f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f),vec2(7.7f,8.8f)) ), mat42(vec2(vecmath_floor(1.2f),vecmath_floor(2.2f)),vec2(vecmath_floor(3.3f),vecmath_floor(4.4f)),vec2(vecmath_floor(5.5f),vecmath_floor(6.6f)),vec2(vecmath_floor(7.7f),vecmath_floor(8.8f))) ) );
        TESTFW_EXPECTED( mat43_eq( vm_floor( mat43(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f),vec3(10.1f,11.2f,12.3f)) ), mat43(vec3(vecmath_floor(1.1f),vecmath_floor(2.2f),vecmath_floor(3.3f)),vec3(vecmath_floor(4.4f),vecmath_floor(5.5f),vecmath_floor(6.6f)),vec3(vecmath_floor(7.7f),vecmath_floor(8.8f),vecmath_floor(9.9f)),vec3(vecmath_floor(10.1f),vecmath_floor(11.2f),vecmath_floor(12.3f))) ) );
        TESTFW_EXPECTED( mat44_eq( vm_floor( mat44(vec4(1.2f,2.3f,3.4f,4.5f),vec4(5.6f,6.7f,7.8f,8.9f),vec4(9.1f,10.2f,11.3f,12.4f),vec4(13.5f,14.6f,15.7f,16.8f)) ), mat44(vec4(vecmath_floor(1.2f),vecmath_floor(2.3f),vecmath_floor(3.4f),vecmath_floor(4.5f)),vec4(vecmath_floor(5.6f),vecmath_floor(6.7f),vecmath_floor(7.8f),vecmath_floor(8.9f)),vec4(vecmath_floor(9.1f),vecmath_floor(10.2f),vecmath_floor(11.3f),vecmath_floor(12.4f)),vec4(vecmath_floor(13.5f),vecmath_floor(14.6f),vecmath_floor(15.7f),vecmath_floor(16.8f))) ) );
    TESTFW_TEST_END();

    // vm_fmod
    TESTFW_TEST_BEGIN( "vm_fmod dispatches to correct *_fmod implementation" )
        TESTFW_EXPECTED( vm_fmod( 5.5f, 2.0f ) == vecmath_fmod( 5.5f, 2.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_fmod( vec2(5.5f,7.3f), vec2(2.0f,3.0f) ), vec2_fmod( vec2(5.5f,7.3f), vec2(2.0f,3.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_fmod( vec3(9.9f,4.4f,6.6f), vec3(3.0f,2.0f,5.0f) ), vec3_fmod( vec3(9.9f,4.4f,6.6f), vec3(3.0f,2.0f,5.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_fmod( vec4(10.0f,11.0f,12.0f,13.0f), vec4(2.0f,3.0f,4.0f,5.0f) ), vec4_fmod( vec4(10.0f,11.0f,12.0f,13.0f), vec4(2.0f,3.0f,4.0f,5.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_fmod( mat22(vec2(5.5f,6.5f),vec2(7.5f,8.5f)), mat22(vec2(2.0f,2.0f),vec2(2.0f,2.0f)) ), mat22_fmod( mat22(vec2(5.5f,6.5f),vec2(7.5f,8.5f)), mat22(vec2(2.0f,2.0f),vec2(2.0f,2.0f)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_fmod( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(2,2,2),vec3(2,2,2)) ), mat23_fmod( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(2,2,2),vec3(2,2,2)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_fmod( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(2,2,2,2),vec4(2,2,2,2)) ), mat24_fmod( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(2,2,2,2),vec4(2,2,2,2)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_fmod( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(2,2),vec2(2,2),vec2(2,2)) ), mat32_fmod( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(2,2),vec2(2,2),vec2(2,2)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_fmod( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(2,2,2),vec3(2,2,2),vec3(2,2,2)) ), mat33_fmod( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(2,2,2),vec3(2,2,2),vec3(2,2,2)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_fmod( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(2,2,2,2),vec4(2,2,2,2),vec4(2,2,2,2)) ), mat34_fmod( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(2,2,2,2),vec4(2,2,2,2),vec4(2,2,2,2)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_fmod( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(2,2),vec2(2,2),vec2(2,2),vec2(2,2)) ), mat42_fmod( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(2,2),vec2(2,2),vec2(2,2),vec2(2,2)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_fmod( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(2,2,2),vec3(2,2,2),vec3(2,2,2),vec3(2,2,2)) ), mat43_fmod( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(2,2,2),vec3(2,2,2),vec3(2,2,2),vec3(2,2,2)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_fmod( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(2,2,2,2),vec4(2,2,2,2),vec4(2,2,2,2),vec4(2,2,2,2)) ), mat44_fmod( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(2,2,2,2),vec4(2,2,2,2),vec4(2,2,2,2),vec4(2,2,2,2)) ) ) );
    TESTFW_TEST_END();

    // vm_frac
    TESTFW_TEST_BEGIN( "vm_frac dispatches to correct *_frac implementation" )
        TESTFW_EXPECTED( vm_frac( 1.25f ) == vecmath_frac( 1.25f ) );
        TESTFW_EXPECTED( vec2_eq( vm_frac( vec2(1.25f,2.75f) ), vec2_frac( vec2(1.25f,2.75f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_frac( vec3(3.5f,4.1f,5.9f) ), vec3_frac( vec3(3.5f,4.1f,5.9f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_frac( vec4(6.1f,7.2f,8.3f,9.4f) ), vec4_frac( vec4(6.1f,7.2f,8.3f,9.4f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_frac( mat22(vec2(1.1f,2.2f),vec2(3.3f,4.4f)) ), mat22_frac( mat22(vec2(1.1f,2.2f),vec2(3.3f,4.4f)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_frac( mat23(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f)) ), mat23_frac( mat23(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_frac( mat24(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f)) ), mat24_frac( mat24(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_frac( mat32(vec2(1.1f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f)) ), mat32_frac( mat32(vec2(1.1f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_frac( mat33(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f)) ), mat33_frac( mat33(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_frac( mat34(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f),vec4(9.9f,10.1f,11.2f,12.3f)) ), mat34_frac( mat34(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f),vec4(9.9f,10.1f,11.2f,12.3f)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_frac( mat42(vec2(1.1f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f),vec2(7.7f,8.8f)) ), mat42_frac( mat42(vec2(1.1f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f),vec2(7.7f,8.8f)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_frac( mat43(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f),vec3(10.1f,11.2f,12.3f)) ), mat43_frac( mat43(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f),vec3(10.1f,11.2f,12.3f)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_frac( mat44(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f),vec4(9.9f,10.1f,11.2f,12.3f),vec4(13.4f,14.5f,15.6f,16.7f)) ), mat44_frac( mat44(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f),vec4(9.9f,10.1f,11.2f,12.3f),vec4(13.4f,14.5f,15.6f,16.7f)) ) ) );
    TESTFW_TEST_END();

    // vm_lengthsq
    TESTFW_TEST_BEGIN( "vm_lengthsq dispatches to correct *_lengthsq implementation" )
        TESTFW_EXPECTED( vm_lengthsq( 2.0f ) == vecmath_lengthsq( 2.0f ) );
        TESTFW_EXPECTED( vm_lengthsq( vec2(3.0f,4.0f) ) == vec2_lengthsq( vec2(3.0f,4.0f) ) );
        TESTFW_EXPECTED( vm_lengthsq( vec3(1.0f,2.0f,2.0f) ) == vec3_lengthsq( vec3(1.0f,2.0f,2.0f) ) );
        TESTFW_EXPECTED( vm_lengthsq( vec4(1.0f,2.0f,2.0f,3.0f) ) == vec4_lengthsq( vec4(1.0f,2.0f,2.0f,3.0f) ) );
    TESTFW_TEST_END();

    // vm_length
    TESTFW_TEST_BEGIN( "vm_length dispatches to correct *_length implementation" )
        TESTFW_EXPECTED( vm_length( 3.0f ) == vecmath_length( 3.0f ) );
        TESTFW_EXPECTED( vm_length( vec2(3.0f,4.0f) ) == vec2_length( vec2(3.0f,4.0f) ) );
        TESTFW_EXPECTED( vm_length( vec3(1.0f,2.0f,2.0f) ) == vec3_length( vec3(1.0f,2.0f,2.0f) ) );
        TESTFW_EXPECTED( vm_length( vec4(1.0f,2.0f,2.0f,3.0f) ) == vec4_length( vec4(1.0f,2.0f,2.0f,3.0f) ) );
    TESTFW_TEST_END();

    // vm_lerp
    TESTFW_TEST_BEGIN( "vm_lerp dispatches to correct *_lerp implementation" )
        TESTFW_EXPECTED( vm_lerp( 1.0f, 3.0f, 0.5f ) == vecmath_lerp( 1.0f, 3.0f, 0.5f ) );
        TESTFW_EXPECTED( vec2_eq( vm_lerp( vec2(1,2), vec2(3,4), 0.5f ), vec2_lerp( vec2(1,2), vec2(3,4), 0.5f ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_lerp( vec3(1,2,3), vec3(4,5,6), 0.25f ), vec3_lerp( vec3(1,2,3), vec3(4,5,6), 0.25f ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_lerp( vec4(1,2,3,4), vec4(5,6,7,8), 0.75f ), vec4_lerp( vec4(1,2,3,4), vec4(5,6,7,8), 0.75f ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_lerp( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)), 0.5f ), mat22_lerp( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)), 0.5f ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_lerp( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(7,8,9),vec3(10,11,12)), 0.25f ), mat23_lerp( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(7,8,9),vec3(10,11,12)), 0.25f ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_lerp( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)), 0.75f ), mat24_lerp( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)), 0.75f ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_lerp( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)), 0.5f ), mat32_lerp( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)), 0.5f ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_lerp( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)), 0.25f ), mat33_lerp( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)), 0.25f ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_lerp( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)), 0.75f ), mat34_lerp( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)), 0.75f ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_lerp( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)), 0.5f ), mat42_lerp( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)), 0.5f ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_lerp( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)), 0.25f ), mat43_lerp( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)), 0.25f ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_lerp( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)), 0.75f ), mat44_lerp( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)), 0.75f ) ) );
    TESTFW_TEST_END();

    // vm_log
    TESTFW_TEST_BEGIN( "vm_log dispatches to correct *_log implementation" )
        TESTFW_EXPECTED( vm_log( 2.71828f ) == vecmath_log( 2.71828f ) );
        TESTFW_EXPECTED( vec2_eq( vm_log( vec2(2.0f,3.0f) ), vec2_log( vec2(2.0f,3.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_log( vec3(4.0f,5.0f,6.0f) ), vec3_log( vec3(4.0f,5.0f,6.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_log( vec4(7.0f,8.0f,9.0f,10.0f) ), vec4_log( vec4(7.0f,8.0f,9.0f,10.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_log( mat22(vec2(1,2),vec2(3,4)) ), mat22_log( mat22(vec2(1,2),vec2(3,4)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_log( mat23(vec3(1,2,3),vec3(4,5,6)) ), mat23_log( mat23(vec3(1,2,3),vec3(4,5,6)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_log( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), mat24_log( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_log( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), mat32_log( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_log( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), mat33_log( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_log( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), mat34_log( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_log( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), mat42_log( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_log( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), mat43_log( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_log( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), mat44_log( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) ) );
    TESTFW_TEST_END();

    // vm_log2
    TESTFW_TEST_BEGIN( "vm_log2 dispatches to correct *_log2 implementation" )
        TESTFW_EXPECTED( vm_log2( 8.0f ) == vecmath_log2( 8.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_log2( vec2(2.0f,4.0f) ), vec2_log2( vec2(2.0f,4.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_log2( vec3(8.0f,16.0f,32.0f) ), vec3_log2( vec3(8.0f,16.0f,32.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_log2( vec4(64.0f,128.0f,256.0f,512.0f) ), vec4_log2( vec4(64.0f,128.0f,256.0f,512.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_log2( mat22(vec2(2,4),vec2(8,16)) ), mat22_log2( mat22(vec2(2,4),vec2(8,16)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_log2( mat23(vec3(2,4,8),vec3(16,32,64)) ), mat23_log2( mat23(vec3(2,4,8),vec3(16,32,64)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_log2( mat24(vec4(2,4,8,16),vec4(32,64,128,256)) ), mat24_log2( mat24(vec4(2,4,8,16),vec4(32,64,128,256)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_log2( mat32(vec2(2,4),vec2(8,16),vec2(32,64)) ), mat32_log2( mat32(vec2(2,4),vec2(8,16),vec2(32,64)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_log2( mat33(vec3(2,4,8),vec3(16,32,64),vec3(128,256,512)) ), mat33_log2( mat33(vec3(2,4,8),vec3(16,32,64),vec3(128,256,512)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_log2( mat34(vec4(2,4,8,16),vec4(32,64,128,256),vec4(512,1024,2048,4096)) ), mat34_log2( mat34(vec4(2,4,8,16),vec4(32,64,128,256),vec4(512,1024,2048,4096)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_log2( mat42(vec2(2,4),vec2(8,16),vec2(32,64),vec2(128,256)) ), mat42_log2( mat42(vec2(2,4),vec2(8,16),vec2(32,64),vec2(128,256)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_log2( mat43(vec3(2,4,8),vec3(16,32,64),vec3(128,256,512),vec3(1024,2048,4096)) ), mat43_log2( mat43(vec3(2,4,8),vec3(16,32,64),vec3(128,256,512),vec3(1024,2048,4096)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_log2( mat44(vec4(2,4,8,16),vec4(32,64,128,256),vec4(512,1024,2048,4096),vec4(8192,16384,32768,65536)) ), mat44_log2( mat44(vec4(2,4,8,16),vec4(32,64,128,256),vec4(512,1024,2048,4096),vec4(8192,16384,32768,65536)) ) ) );
    TESTFW_TEST_END();

    // vm_log10
    TESTFW_TEST_BEGIN( "vm_log10 dispatches to correct *_log10 implementation" )
        TESTFW_EXPECTED( vm_log10( 1000.0f ) == vecmath_log10( 1000.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_log10( vec2(10.0f,100.0f) ), vec2_log10( vec2(10.0f,100.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_log10( vec3(1.0f,10.0f,100.0f) ), vec3_log10( vec3(1.0f,10.0f,100.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_log10( vec4(1.0f,10.0f,100.0f,1000.0f) ), vec4_log10( vec4(1.0f,10.0f,100.0f,1000.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_log10( mat22(vec2(10,100),vec2(1000,10000)) ), mat22_log10( mat22(vec2(10,100),vec2(1000,10000)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_log10( mat23(vec3(1,10,100),vec3(1000,10000,100000)) ), mat23_log10( mat23(vec3(1,10,100),vec3(1000,10000,100000)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_log10( mat24(vec4(1,10,100,1000),vec4(10000,100000,1000000,10000000)) ), mat24_log10( mat24(vec4(1,10,100,1000),vec4(10000,100000,1000000,10000000)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_log10( mat32(vec2(10,100),vec2(1000,10000),vec2(100000,1000000)) ), mat32_log10( mat32(vec2(10,100),vec2(1000,10000),vec2(100000,1000000)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_log10( mat33(vec3(1,10,100),vec3(1000,10000,100000),vec3(1000000,10000000,100000000)) ), mat33_log10( mat33(vec3(1,10,100),vec3(1000,10000,100000),vec3(1000000,10000000,100000000)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_log10( mat34(vec4(1,10,100,1000),vec4(10000,100000,1000000,10000000),vec4(100000000,1000000000,1e10f,1e11f)) ), mat34_log10( mat34(vec4(1,10,100,1000),vec4(10000,100000,1000000,10000000),vec4(100000000,1000000000,1e10f,1e11f)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_log10( mat42(vec2(10,100),vec2(1000,10000),vec2(100000,1000000),vec2(10000000,100000000)) ), mat42_log10( mat42(vec2(10,100),vec2(1000,10000),vec2(100000,1000000),vec2(10000000,100000000)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_log10( mat43(vec3(1,10,100),vec3(1000,10000,100000),vec3(1000000,10000000,100000000),vec3(1000000000,1e10f,1e11f)) ), mat43_log10( mat43(vec3(1,10,100),vec3(1000,10000,100000),vec3(1000000,10000000,100000000),vec3(1000000000,1e10f,1e11f)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_log10( mat44(vec4(1,10,100,1000),vec4(10000,100000,1000000,10000000),vec4(100000000,1000000000,1e10f,1e11f),vec4(1e12f,1e13f,1e14f,1e15f)) ), mat44_log10( mat44(vec4(1,10,100,1000),vec4(10000,100000,1000000,10000000),vec4(100000000,1000000000,1e10f,1e11f),vec4(1e12f,1e13f,1e14f,1e15f)) ) ) );
    TESTFW_TEST_END();

    // vm_max
    TESTFW_TEST_BEGIN( "vm_max dispatches to correct *_max implementation" )
        TESTFW_EXPECTED( vm_max( 2.0f, 5.0f ) == vecmath_max( 2.0f, 5.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_max( vec2(1,5), vec2(3,2) ), vec2_max( vec2(1,5), vec2(3,2) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_max( vec3(1,4,2), vec3(3,2,5) ), vec3_max( vec3(1,4,2), vec3(3,2,5) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_max( vec4(1,4,2,8), vec4(3,2,5,6) ), vec4_max( vec4(1,4,2,8), vec4(3,2,5,6) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_max( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,0),vec2(2,6)) ), mat22_max( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,0),vec2(2,6)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_max( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(6,5,4),vec3(3,2,1)) ), mat23_max( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(6,5,4),vec3(3,2,1)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_max( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(8,7,6,5),vec4(4,3,2,1)) ), mat24_max( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(8,7,6,5),vec4(4,3,2,1)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_max( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(6,5),vec2(4,3),vec2(2,1)) ), mat32_max( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(6,5),vec2(4,3),vec2(2,1)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_max( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) ), mat33_max( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_max( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(12,11,10,9),vec4(8,7,6,5),vec4(4,3,2,1)) ), mat34_max( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(12,11,10,9),vec4(8,7,6,5),vec4(4,3,2,1)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_max( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(8,7),vec2(6,5),vec2(4,3),vec2(2,1)) ), mat42_max( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(8,7),vec2(6,5),vec2(4,3),vec2(2,1)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_max( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(12,11,10),vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) ), mat43_max( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(12,11,10),vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_max( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(16,15,14,13),vec4(12,11,10,9),vec4(8,7,6,5),vec4(4,3,2,1)) ), mat44_max( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(16,15,14,13),vec4(12,11,10,9),vec4(8,7,6,5),vec4(4,3,2,1)) ) ) );
    TESTFW_TEST_END();

    // vm_min
    TESTFW_TEST_BEGIN( "vm_min dispatches to correct *_min implementation" )
        TESTFW_EXPECTED( vm_min( 2.0f, 5.0f ) == vecmath_min( 2.0f, 5.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_min( vec2(1,5), vec2(3,2) ), vec2_min( vec2(1,5), vec2(3,2) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_min( vec3(1,4,2), vec3(3,2,5) ), vec3_min( vec3(1,4,2), vec3(3,2,5) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_min( vec4(1,4,2,8), vec4(3,2,5,6) ), vec4_min( vec4(1,4,2,8), vec4(3,2,5,6) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_min( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,0),vec2(2,6)) ), mat22_min( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,0),vec2(2,6)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_min( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(6,5,4),vec3(3,2,1)) ), mat23_min( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(6,5,4),vec3(3,2,1)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_min( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(8,7,6,5),vec4(4,3,2,1)) ), mat24_min( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(8,7,6,5),vec4(4,3,2,1)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_min( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(6,5),vec2(4,3),vec2(2,1)) ), mat32_min( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(6,5),vec2(4,3),vec2(2,1)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_min( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) ), mat33_min( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_min( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(12,11,10,9),vec4(8,7,6,5),vec4(4,3,2,1)) ), mat34_min( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(12,11,10,9),vec4(8,7,6,5),vec4(4,3,2,1)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_min( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(8,7),vec2(6,5),vec2(4,3),vec2(2,1)) ), mat42_min( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(8,7),vec2(6,5),vec2(4,3),vec2(2,1)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_min( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(12,11,10),vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) ), mat43_min( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(12,11,10),vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_min( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(16,15,14,13),vec4(12,11,10,9),vec4(8,7,6,5),vec4(4,3,2,1)) ), mat44_min( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(16,15,14,13),vec4(12,11,10,9),vec4(8,7,6,5),vec4(4,3,2,1)) ) ) );
    TESTFW_TEST_END();

    // vm_normalize
    TESTFW_TEST_BEGIN( "vm_normalize dispatches to correct *_normalize implementation" )
        TESTFW_EXPECTED( vm_normalize( 2.0f ) == vecmath_normalize( 2.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_normalize( vec2(3,4) ), vec2_normalize( vec2(3,4) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_normalize( vec3(1,2,3) ), vec3_normalize( vec3(1,2,3) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_normalize( vec4(1,2,3,4) ), vec4_normalize( vec4(1,2,3,4) ) ) );
    TESTFW_TEST_END();

    // vm_pow
    TESTFW_TEST_BEGIN( "vm_pow dispatches to correct *_pow implementation" )
        TESTFW_EXPECTED( vm_pow( 2.0f, 3.0f ) == vecmath_pow( 2.0f, 3.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_pow( vec2(2,3), vec2(4,5) ), vec2_pow( vec2(2,3), vec2(4,5) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_pow( vec3(1,2,3), vec3(4,5,6) ), vec3_pow( vec3(1,2,3), vec3(4,5,6) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_pow( vec4(1,2,3,4), vec4(5,6,7,8) ), vec4_pow( vec4(1,2,3,4), vec4(5,6,7,8) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_pow( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)) ), mat22_pow( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_pow( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(7,8,9),vec3(10,11,12)) ), mat23_pow( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_pow( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ), mat24_pow( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_pow( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ), mat32_pow( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_pow( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)) ), mat33_pow( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_pow( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ), mat34_pow( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_pow( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ), mat42_pow( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_pow( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ), mat43_pow( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_pow( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ), mat44_pow( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ) ) );
    TESTFW_TEST_END();

    // vm_radians
    TESTFW_TEST_BEGIN( "vm_radians dispatches to correct *_radians implementation" )
        TESTFW_EXPECTED( vm_radians( 180.0f ) == vecmath_radians( 180.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_radians( vec2(90.0f,180.0f) ), vec2_radians( vec2(90.0f,180.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_radians( vec3(45.0f,90.0f,135.0f) ), vec3_radians( vec3(45.0f,90.0f,135.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_radians( vec4(30.0f,60.0f,90.0f,120.0f) ), vec4_radians( vec4(30.0f,60.0f,90.0f,120.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_radians( mat22(vec2(10.0f,20.0f),vec2(30.0f,40.0f)) ), mat22_radians( mat22(vec2(10.0f,20.0f),vec2(30.0f,40.0f)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_radians( mat23(vec3(10.0f,20.0f,30.0f),vec3(40.0f,50.0f,60.0f)) ), mat23_radians( mat23(vec3(10.0f,20.0f,30.0f),vec3(40.0f,50.0f,60.0f)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_radians( mat24(vec4(10.0f,20.0f,30.0f,40.0f),vec4(50.0f,60.0f,70.0f,80.0f)) ), mat24_radians( mat24(vec4(10.0f,20.0f,30.0f,40.0f),vec4(50.0f,60.0f,70.0f,80.0f)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_radians( mat32(vec2(1.0f,2.0f),vec2(3.0f,4.0f),vec2(5.0f,6.0f)) ), mat32_radians( mat32(vec2(1.0f,2.0f),vec2(3.0f,4.0f),vec2(5.0f,6.0f)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_radians( mat33(vec3(1.0f,2.0f,3.0f),vec3(4.0f,5.0f,6.0f),vec3(7.0f,8.0f,9.0f)) ), mat33_radians( mat33(vec3(1.0f,2.0f,3.0f),vec3(4.0f,5.0f,6.0f),vec3(7.0f,8.0f,9.0f)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_radians( mat34(vec4(1.0f,2.0f,3.0f,4.0f),vec4(5.0f,6.0f,7.0f,8.0f),vec4(9.0f,10.0f,11.0f,12.0f)) ), mat34_radians( mat34(vec4(1.0f,2.0f,3.0f,4.0f),vec4(5.0f,6.0f,7.0f,8.0f),vec4(9.0f,10.0f,11.0f,12.0f)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_radians( mat42(vec2(1.0f,2.0f),vec2(3.0f,4.0f),vec2(5.0f,6.0f),vec2(7.0f,8.0f)) ), mat42_radians( mat42(vec2(1.0f,2.0f),vec2(3.0f,4.0f),vec2(5.0f,6.0f),vec2(7.0f,8.0f)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_radians( mat43(vec3(1.0f,2.0f,3.0f),vec3(4.0f,5.0f,6.0f),vec3(7.0f,8.0f,9.0f),vec3(10.0f,11.0f,12.0f)) ), mat43_radians( mat43(vec3(1.0f,2.0f,3.0f),vec3(4.0f,5.0f,6.0f),vec3(7.0f,8.0f,9.0f),vec3(10.0f,11.0f,12.0f)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_radians( mat44(vec4(1.0f,2.0f,3.0f,4.0f),vec4(5.0f,6.0f,7.0f,8.0f),vec4(9.0f,10.0f,11.0f,12.0f),vec4(13.0f,14.0f,15.0f,16.0f)) ), mat44_radians( mat44(vec4(1.0f,2.0f,3.0f,4.0f),vec4(5.0f,6.0f,7.0f,8.0f),vec4(9.0f,10.0f,11.0f,12.0f),vec4(13.0f,14.0f,15.0f,16.0f)) ) ) );
    TESTFW_TEST_END();

    // vm_rcp
    TESTFW_TEST_BEGIN( "vm_rcp dispatches to correct *_rcp implementation" )
        TESTFW_EXPECTED( vm_rcp( 2.0f ) == vecmath_rcp( 2.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_rcp( vec2(2.0f,4.0f) ), vec2_rcp( vec2(2.0f,4.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_rcp( vec3(1.0f,2.0f,4.0f) ), vec3_rcp( vec3(1.0f,2.0f,4.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_rcp( vec4(2.0f,4.0f,8.0f,16.0f) ), vec4_rcp( vec4(2.0f,4.0f,8.0f,16.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_rcp( mat22(vec2(1.0f,2.0f),vec2(4.0f,8.0f)) ), mat22_rcp( mat22(vec2(1.0f,2.0f),vec2(4.0f,8.0f)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_rcp( mat23(vec3(1.0f,2.0f,4.0f),vec3(8.0f,16.0f,32.0f)) ), mat23_rcp( mat23(vec3(1.0f,2.0f,4.0f),vec3(8.0f,16.0f,32.0f)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_rcp( mat24(vec4(1.0f,2.0f,4.0f,8.0f),vec4(16.0f,32.0f,64.0f,128.0f)) ), mat24_rcp( mat24(vec4(1.0f,2.0f,4.0f,8.0f),vec4(16.0f,32.0f,64.0f,128.0f)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_rcp( mat32(vec2(1.0f,2.0f),vec2(4.0f,8.0f),vec2(16.0f,32.0f)) ), mat32_rcp( mat32(vec2(1.0f,2.0f),vec2(4.0f,8.0f),vec2(16.0f,32.0f)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_rcp( mat33(vec3(1.0f,2.0f,4.0f),vec3(8.0f,16.0f,32.0f),vec3(64.0f,128.0f,256.0f)) ), mat33_rcp( mat33(vec3(1.0f,2.0f,4.0f),vec3(8.0f,16.0f,32.0f),vec3(64.0f,128.0f,256.0f)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_rcp( mat34(vec4(1.0f,2.0f,4.0f,8.0f),vec4(16.0f,32.0f,64.0f,128.0f),vec4(256.0f,512.0f,1024.0f,2048.0f)) ), mat34_rcp( mat34(vec4(1.0f,2.0f,4.0f,8.0f),vec4(16.0f,32.0f,64.0f,128.0f),vec4(256.0f,512.0f,1024.0f,2048.0f)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_rcp( mat42(vec2(1.0f,2.0f),vec2(4.0f,8.0f),vec2(16.0f,32.0f),vec2(64.0f,128.0f)) ), mat42_rcp( mat42(vec2(1.0f,2.0f),vec2(4.0f,8.0f),vec2(16.0f,32.0f),vec2(64.0f,128.0f)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_rcp( mat43(vec3(1.0f,2.0f,4.0f),vec3(8.0f,16.0f,32.0f),vec3(64.0f,128.0f,256.0f),vec3(512.0f,1024.0f,2048.0f)) ), mat43_rcp( mat43(vec3(1.0f,2.0f,4.0f),vec3(8.0f,16.0f,32.0f),vec3(64.0f,128.0f,256.0f),vec3(512.0f,1024.0f,2048.0f)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_rcp( mat44(vec4(1.0f,2.0f,4.0f,8.0f),vec4(16.0f,32.0f,64.0f,128.0f),vec4(256.0f,512.0f,1024.0f,2048.0f),vec4(4096.0f,8192.0f,16384.0f,32768.0f)) ), mat44_rcp( mat44(vec4(1.0f,2.0f,4.0f,8.0f),vec4(16.0f,32.0f,64.0f,128.0f),vec4(256.0f,512.0f,1024.0f,2048.0f),vec4(4096.0f,8192.0f,16384.0f,32768.0f)) ) ) );
    TESTFW_TEST_END();

    // vm_reflect
    TESTFW_TEST_BEGIN( "vm_reflect dispatches to correct *_reflect implementation" )
        TESTFW_EXPECTED( vm_reflect( 0.5f, -1.0f ) == vecmath_reflect( 0.5f, -1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_reflect( vec2(1,2), vec2(3,4) ), vec2_reflect( vec2(1,2), vec2(3,4) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_reflect( vec3(5,6,7), vec3(8,9,10) ), vec3_reflect( vec3(5,6,7), vec3(8,9,10) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_reflect( vec4(11,12,13,14), vec4(15,16,17,18) ), vec4_reflect( vec4(11,12,13,14), vec4(15,16,17,18) ) ) );
    TESTFW_TEST_END();

    // vm_refract
    TESTFW_TEST_BEGIN( "vm_refract dispatches to correct *_refract implementation" )
        TESTFW_EXPECTED( vm_refract( 0.5f, -1.0f, 1.2f ) == vecmath_refract( 0.5f, -1.0f, 1.2f ) );
        TESTFW_EXPECTED( vec2_eq( vm_refract( vec2(1,2), vec2(3,4), 1.1f ), vec2_refract( vec2(1,2), vec2(3,4), 1.1f ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_refract( vec3(5,6,7), vec3(8,9,10), 0.9f ), vec3_refract( vec3(5,6,7), vec3(8,9,10), 0.9f ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_refract( vec4(11,12,13,14), vec4(15,16,17,18), 0.8f ), vec4_refract( vec4(11,12,13,14), vec4(15,16,17,18), 0.8f ) ) );
    TESTFW_TEST_END();

    // vm_round
    TESTFW_TEST_BEGIN( "vm_round dispatches to correct *_round implementation" )
        TESTFW_EXPECTED( vm_round( 1.5f ) == vecmath_round( 1.5f ) );
        TESTFW_EXPECTED( vec2_eq( vm_round( vec2(1.2f,2.6f) ), vec2_round( vec2(1.2f,2.6f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_round( vec3(3.4f,4.5f,5.6f) ), vec3_round( vec3(3.4f,4.5f,5.6f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_round( vec4(6.7f,7.8f,8.9f,9.1f) ), vec4_round( vec4(6.7f,7.8f,8.9f,9.1f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_round( mat22(vec2(1.1f,2.2f),vec2(3.3f,4.4f)) ), mat22_round( mat22(vec2(1.1f,2.2f),vec2(3.3f,4.4f)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_round( mat23(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f)) ), mat23_round( mat23(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_round( mat24(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f)) ), mat24_round( mat24(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_round( mat32(vec2(1.1f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f)) ), mat32_round( mat32(vec2(1.1f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_round( mat33(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f)) ), mat33_round( mat33(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_round( mat34(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f),vec4(9.9f,10.1f,11.2f,12.3f)) ), mat34_round( mat34(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f),vec4(9.9f,10.1f,11.2f,12.3f)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_round( mat42(vec2(1.1f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f),vec2(7.7f,8.8f)) ), mat42_round( mat42(vec2(1.1f,2.2f),vec2(3.3f,4.4f),vec2(5.5f,6.6f),vec2(7.7f,8.8f)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_round( mat43(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f),vec3(10.1f,11.2f,12.3f)) ), mat43_round( mat43(vec3(1.1f,2.2f,3.3f),vec3(4.4f,5.5f,6.6f),vec3(7.7f,8.8f,9.9f),vec3(10.1f,11.2f,12.3f)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_round( mat44(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f),vec4(9.9f,10.1f,11.2f,12.3f),vec4(13.4f,14.5f,15.6f,16.7f)) ), mat44_round( mat44(vec4(1.1f,2.2f,3.3f,4.4f),vec4(5.5f,6.6f,7.7f,8.8f),vec4(9.9f,10.1f,11.2f,12.3f),vec4(13.4f,14.5f,15.6f,16.7f)) ) ) );
    TESTFW_TEST_END();

    // vm_rsqrt
    TESTFW_TEST_BEGIN( "vm_rsqrt dispatches to correct *_rsqrt implementation" )
        TESTFW_EXPECTED( vm_rsqrt( 4.0f ) == vecmath_rsqrt( 4.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_rsqrt( vec2(1.0f,4.0f) ), vec2_rsqrt( vec2(1.0f,4.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_rsqrt( vec3(9.0f,16.0f,25.0f) ), vec3_rsqrt( vec3(9.0f,16.0f,25.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_rsqrt( vec4(36.0f,49.0f,64.0f,81.0f) ), vec4_rsqrt( vec4(36.0f,49.0f,64.0f,81.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_rsqrt( mat22(vec2(1.0f,4.0f),vec2(9.0f,16.0f)) ), mat22_rsqrt( mat22(vec2(1.0f,4.0f),vec2(9.0f,16.0f)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_rsqrt( mat23(vec3(1.0f,4.0f,9.0f),vec3(16.0f,25.0f,36.0f)) ), mat23_rsqrt( mat23(vec3(1.0f,4.0f,9.0f),vec3(16.0f,25.0f,36.0f)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_rsqrt( mat24(vec4(1.0f,4.0f,9.0f,16.0f),vec4(25.0f,36.0f,49.0f,64.0f)) ), mat24_rsqrt( mat24(vec4(1.0f,4.0f,9.0f,16.0f),vec4(25.0f,36.0f,49.0f,64.0f)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_rsqrt( mat32(vec2(1.0f,4.0f),vec2(9.0f,16.0f),vec2(25.0f,36.0f)) ), mat32_rsqrt( mat32(vec2(1.0f,4.0f),vec2(9.0f,16.0f),vec2(25.0f,36.0f)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_rsqrt( mat33(vec3(1.0f,4.0f,9.0f),vec3(16.0f,25.0f,36.0f),vec3(49.0f,64.0f,81.0f)) ), mat33_rsqrt( mat33(vec3(1.0f,4.0f,9.0f),vec3(16.0f,25.0f,36.0f),vec3(49.0f,64.0f,81.0f)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_rsqrt( mat34(vec4(1.0f,4.0f,9.0f,16.0f),vec4(25.0f,36.0f,49.0f,64.0f),vec4(81.0f,100.0f,121.0f,144.0f)) ), mat34_rsqrt( mat34(vec4(1.0f,4.0f,9.0f,16.0f),vec4(25.0f,36.0f,49.0f,64.0f),vec4(81.0f,100.0f,121.0f,144.0f)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_rsqrt( mat42(vec2(1.0f,4.0f),vec2(9.0f,16.0f),vec2(25.0f,36.0f),vec2(49.0f,64.0f)) ), mat42_rsqrt( mat42(vec2(1.0f,4.0f),vec2(9.0f,16.0f),vec2(25.0f,36.0f),vec2(49.0f,64.0f)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_rsqrt( mat43(vec3(1.0f,4.0f,9.0f),vec3(16.0f,25.0f,36.0f),vec3(49.0f,64.0f,81.0f),vec3(100.0f,121.0f,144.0f)) ), mat43_rsqrt( mat43(vec3(1.0f,4.0f,9.0f),vec3(16.0f,25.0f,36.0f),vec3(49.0f,64.0f,81.0f),vec3(100.0f,121.0f,144.0f)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_rsqrt( mat44(vec4(1.0f,4.0f,9.0f,16.0f),vec4(25.0f,36.0f,49.0f,64.0f),vec4(81.0f,100.0f,121.0f,144.0f),vec4(169.0f,196.0f,225.0f,256.0f)) ), mat44_rsqrt( mat44(vec4(1.0f,4.0f,9.0f,16.0f),vec4(25.0f,36.0f,49.0f,64.0f),vec4(81.0f,100.0f,121.0f,144.0f),vec4(169.0f,196.0f,225.0f,256.0f)) ) ) );
    TESTFW_TEST_END();

    // vm_saturate
    TESTFW_TEST_BEGIN( "vm_saturate dispatches to correct *_saturate implementation" )
        TESTFW_EXPECTED( vm_saturate( -1.0f ) == vecmath_saturate( -1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_saturate( vec2(-0.5f, 1.5f) ), vec2_saturate( vec2(-0.5f, 1.5f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_saturate( vec3(-1.0f, 0.5f, 2.0f) ), vec3_saturate( vec3(-1.0f, 0.5f, 2.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_saturate( vec4(-0.1f, 0.4f, 1.1f, 0.6f) ), vec4_saturate( vec4(-0.1f, 0.4f, 1.1f, 0.6f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_saturate( mat22(vec2(-1.0f, 0.0f), vec2(1.0f, 2.0f)) ), mat22_saturate( mat22(vec2(-1.0f, 0.0f), vec2(1.0f, 2.0f)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_saturate( mat23(vec3(-1.0f, 0.0f, 0.5f), vec3(1.5f, 1.0f, -0.2f)) ), mat23_saturate( mat23(vec3(-1.0f, 0.0f, 0.5f), vec3(1.5f, 1.0f, -0.2f)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_saturate( mat24(vec4(0.0f, -0.5f, 0.5f, 1.5f), vec4(0.2f, 0.8f, -1.0f, 2.0f)) ), mat24_saturate( mat24(vec4(0.0f, -0.5f, 0.5f, 1.5f), vec4(0.2f, 0.8f, -1.0f, 2.0f)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_saturate( mat32(vec2(-1.0f, 0.5f), vec2(1.5f, -0.5f), vec2(0.7f, 1.2f)) ), mat32_saturate( mat32(vec2(-1.0f, 0.5f), vec2(1.5f, -0.5f), vec2(0.7f, 1.2f)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_saturate( mat33(vec3(-1.0f, 0.0f, 1.0f), vec3(1.5f, -0.2f, 0.3f), vec3(0.9f, 1.1f, -0.3f)) ), mat33_saturate( mat33(vec3(-1.0f, 0.0f, 1.0f), vec3(1.5f, -0.2f, 0.3f), vec3(0.9f, 1.1f, -0.3f)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_saturate( mat34(vec4(0.5f, -0.5f, 1.5f, 0.7f), vec4(0.8f, 1.2f, -0.4f, 0.3f), vec4(1.1f, 0.0f, 0.9f, -1.0f)) ), mat34_saturate( mat34(vec4(0.5f, -0.5f, 1.5f, 0.7f), vec4(0.8f, 1.2f, -0.4f, 0.3f), vec4(1.1f, 0.0f, 0.9f, -1.0f)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_saturate( mat42(vec2(-1.0f, 0.0f), vec2(1.0f, 2.0f), vec2(-0.5f, 0.5f), vec2(1.5f, -1.5f)) ), mat42_saturate( mat42(vec2(-1.0f, 0.0f), vec2(1.0f, 2.0f), vec2(-0.5f, 0.5f), vec2(1.5f, -1.5f)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_saturate( mat43(vec3(-0.5f, 1.0f, 1.5f), vec3(0.0f, -1.0f, 2.0f), vec3(0.7f, 0.8f, -0.9f), vec3(1.2f, -0.2f, 0.4f)) ), mat43_saturate( mat43(vec3(-0.5f, 1.0f, 1.5f), vec3(0.0f, -1.0f, 2.0f), vec3(0.7f, 0.8f, -0.9f), vec3(1.2f, -0.2f, 0.4f)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_saturate( mat44(vec4(1.1f, -0.1f, 0.9f, 0.3f), vec4(0.0f, 1.0f, 1.5f, -0.5f), vec4(0.6f, 0.7f, 1.3f, -0.3f), vec4(0.8f, 0.2f, -1.0f, 2.0f)) ), mat44_saturate( mat44(vec4(1.1f, -0.1f, 0.9f, 0.3f), vec4(0.0f, 1.0f, 1.5f, -0.5f), vec4(0.6f, 0.7f, 1.3f, -0.3f), vec4(0.8f, 0.2f, -1.0f, 2.0f)) ) ) );
    TESTFW_TEST_END();

    // vm_sign
    TESTFW_TEST_BEGIN( "vm_sign dispatches to correct *_sign implementation" )
        TESTFW_EXPECTED( vm_sign( -2.0f ) == vecmath_sign( -2.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_sign( vec2(-1.0f, 2.0f) ), vec2_sign( vec2(-1.0f, 2.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_sign( vec3(0.0f, -3.5f, 3.5f) ), vec3_sign( vec3(0.0f, -3.5f, 3.5f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_sign( vec4(-4.0f, 0.0f, 4.0f, -0.0f) ), vec4_sign( vec4(-4.0f, 0.0f, 4.0f, -0.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_sign( mat22(vec2(-1.0f, 0.0f), vec2(1.0f, 2.0f)) ), mat22_sign( mat22(vec2(-1.0f, 0.0f), vec2(1.0f, 2.0f)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_sign( mat23(vec3(-1.0f, 0.0f, 1.0f), vec3(-2.0f, 2.0f, 0.0f)) ), mat23_sign( mat23(vec3(-1.0f, 0.0f, 1.0f), vec3(-2.0f, 2.0f, 0.0f)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_sign( mat24(vec4(0.0f, -1.0f, 1.0f, 2.0f), vec4(-2.0f, 0.0f, 3.0f, -3.0f)) ), mat24_sign( mat24(vec4(0.0f, -1.0f, 1.0f, 2.0f), vec4(-2.0f, 0.0f, 3.0f, -3.0f)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_sign( mat32(vec2(-1.0f, 1.0f), vec2(0.0f, 2.0f), vec2(-2.0f, 0.0f)) ), mat32_sign( mat32(vec2(-1.0f, 1.0f), vec2(0.0f, 2.0f), vec2(-2.0f, 0.0f)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_sign( mat33(vec3(0.0f, 1.0f, -1.0f), vec3(2.0f, -2.0f, 0.0f), vec3(-3.0f, 3.0f, 0.0f)) ), mat33_sign( mat33(vec3(0.0f, 1.0f, -1.0f), vec3(2.0f, -2.0f, 0.0f), vec3(-3.0f, 3.0f, 0.0f)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_sign( mat34(vec4(1.0f, -1.0f, 0.0f, 2.0f), vec4(-2.0f, 0.0f, 3.0f, -3.0f), vec4(4.0f, -4.0f, 0.0f, 5.0f)) ), mat34_sign( mat34(vec4(1.0f, -1.0f, 0.0f, 2.0f), vec4(-2.0f, 0.0f, 3.0f, -3.0f), vec4(4.0f, -4.0f, 0.0f, 5.0f)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_sign( mat42(vec2(-1.0f, 0.0f), vec2(1.0f, -2.0f), vec2(2.0f, 0.0f), vec2(-3.0f, 3.0f)) ), mat42_sign( mat42(vec2(-1.0f, 0.0f), vec2(1.0f, -2.0f), vec2(2.0f, 0.0f), vec2(-3.0f, 3.0f)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_sign( mat43(vec3(-1.0f, 0.0f, 1.0f), vec3(-2.0f, 2.0f, 0.0f), vec3(3.0f, -3.0f, 0.0f), vec3(4.0f, 0.0f, -4.0f)) ), mat43_sign( mat43(vec3(-1.0f, 0.0f, 1.0f), vec3(-2.0f, 2.0f, 0.0f), vec3(3.0f, -3.0f, 0.0f), vec3(4.0f, 0.0f, -4.0f)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_sign( mat44(vec4(0.0f, -1.0f, 1.0f, -2.0f), vec4(2.0f, 0.0f, -3.0f, 3.0f), vec4(-4.0f, 4.0f, 0.0f, -5.0f), vec4(5.0f, 0.0f, -6.0f, 6.0f)) ), mat44_sign( mat44(vec4(0.0f, -1.0f, 1.0f, -2.0f), vec4(2.0f, 0.0f, -3.0f, 3.0f), vec4(-4.0f, 4.0f, 0.0f, -5.0f), vec4(5.0f, 0.0f, -6.0f, 6.0f)) ) ) );
    TESTFW_TEST_END();

    // vm_sin
    TESTFW_TEST_BEGIN( "vm_sin dispatches to correct *_sin implementation" )
        TESTFW_EXPECTED( vm_sin( 0.5f ) == vecmath_sin( 0.5f ) );
        TESTFW_EXPECTED( vec2_eq( vm_sin( vec2(0.1f, 0.2f) ), vec2_sin( vec2(0.1f, 0.2f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_sin( vec3(0.3f, 0.4f, 0.5f) ), vec3_sin( vec3(0.3f, 0.4f, 0.5f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_sin( vec4(0.6f, 0.7f, 0.8f, 0.9f) ), vec4_sin( vec4(0.6f, 0.7f, 0.8f, 0.9f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_sin( mat22(vec2(0.1f,0.2f),vec2(0.3f,0.4f)) ), mat22_sin( mat22(vec2(0.1f,0.2f),vec2(0.3f,0.4f)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_sin( mat23(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f)) ), mat23_sin( mat23(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_sin( mat24(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f)) ), mat24_sin( mat24(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_sin( mat32(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f)) ), mat32_sin( mat32(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_sin( mat33(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f)) ), mat33_sin( mat33(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_sin( mat34(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,1.0f,1.1f,1.2f)) ), mat34_sin( mat34(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,1.0f,1.1f,1.2f)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_sin( mat42(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f),vec2(0.7f,0.8f)) ), mat42_sin( mat42(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f),vec2(0.7f,0.8f)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_sin( mat43(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f),vec3(1.0f,1.1f,1.2f)) ), mat43_sin( mat43(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f),vec3(1.0f,1.1f,1.2f)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_sin( mat44(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,1.0f,1.1f,1.2f),vec4(1.3f,1.4f,1.5f,1.6f)) ), mat44_sin( mat44(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,1.0f,1.1f,1.2f),vec4(1.3f,1.4f,1.5f,1.6f)) ) ) );
    TESTFW_TEST_END();

    // vm_sinh
    TESTFW_TEST_BEGIN( "vm_sinh dispatches to correct *_sinh implementation" )
        TESTFW_EXPECTED( vm_sinh( 0.5f ) == vecmath_sinh( 0.5f ) );
        TESTFW_EXPECTED( vec2_eq( vm_sinh( vec2(0.1f, 0.2f) ), vec2_sinh( vec2(0.1f, 0.2f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_sinh( vec3(0.3f, 0.4f, 0.5f) ), vec3_sinh( vec3(0.3f, 0.4f, 0.5f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_sinh( vec4(0.6f, 0.7f, 0.8f, 0.9f) ), vec4_sinh( vec4(0.6f, 0.7f, 0.8f, 0.9f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_sinh( mat22(vec2(0.1f,0.2f),vec2(0.3f,0.4f)) ), mat22_sinh( mat22(vec2(0.1f,0.2f),vec2(0.3f,0.4f)) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_sinh( mat23(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f)) ), mat23_sinh( mat23(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f)) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_sinh( mat24(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f)) ), mat24_sinh( mat24(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f)) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_sinh( mat32(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f)) ), mat32_sinh( mat32(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f)) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_sinh( mat33(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f)) ), mat33_sinh( mat33(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f)) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_sinh( mat34(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,1.0f,1.1f,1.2f)) ), mat34_sinh( mat34(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,1.0f,1.1f,1.2f)) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_sinh( mat42(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f),vec2(0.7f,0.8f)) ), mat42_sinh( mat42(vec2(0.1f,0.2f),vec2(0.3f,0.4f),vec2(0.5f,0.6f),vec2(0.7f,0.8f)) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_sinh( mat43(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f),vec3(1.0f,1.1f,1.2f)) ), mat43_sinh( mat43(vec3(0.1f,0.2f,0.3f),vec3(0.4f,0.5f,0.6f),vec3(0.7f,0.8f,0.9f),vec3(1.0f,1.1f,1.2f)) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_sinh( mat44(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,1.0f,1.1f,1.2f),vec4(1.3f,1.4f,1.5f,1.6f)) ), mat44_sinh( mat44(vec4(0.1f,0.2f,0.3f,0.4f),vec4(0.5f,0.6f,0.7f,0.8f),vec4(0.9f,1.0f,1.1f,1.2f),vec4(1.3f,1.4f,1.5f,1.6f)) ) ) );
    TESTFW_TEST_END();

    // vm_smoothstep
    TESTFW_TEST_BEGIN( "vm_smoothstep dispatches to correct *_smoothstep implementation" )
        TESTFW_EXPECTED( vm_smoothstep( 0.0f, 1.0f, 0.5f ) == vecmath_smoothstep( 0.0f, 1.0f, 0.5f ) );
        TESTFW_EXPECTED( vec2_eq( vm_smoothstep( vec2(0,0), vec2(1,1), vec2(0.5f,0.5f) ), vec2_smoothstep( vec2(0,0), vec2(1,1), vec2(0.5f,0.5f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_smoothstep( vec3(0,0,0), vec3(1,1,1), vec3(0.5f,0.5f,0.5f) ), vec3_smoothstep( vec3(0,0,0), vec3(1,1,1), vec3(0.5f,0.5f,0.5f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_smoothstep( vec4(0,0,0,0), vec4(1,1,1,1), vec4(0.5f,0.5f,0.5f,0.5f) ), vec4_smoothstep( vec4(0,0,0,0), vec4(1,1,1,1), vec4(0.5f,0.5f,0.5f,0.5f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_smoothstep( mat22f(0), mat22f(1), mat22f(0.5f) ), mat22_smoothstep( mat22f(0), mat22f(1), mat22f(0.5f) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_smoothstep( mat23f(0), mat23f(1), mat23f(0.5f) ), mat23_smoothstep( mat23f(0), mat23f(1), mat23f(0.5f) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_smoothstep( mat24f(0), mat24f(1), mat24f(0.5f) ), mat24_smoothstep( mat24f(0), mat24f(1), mat24f(0.5f) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_smoothstep( mat32f(0), mat32f(1), mat32f(0.5f) ), mat32_smoothstep( mat32f(0), mat32f(1), mat32f(0.5f) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_smoothstep( mat33f(0), mat33f(1), mat33f(0.5f) ), mat33_smoothstep( mat33f(0), mat33f(1), mat33f(0.5f) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_smoothstep( mat34f(0), mat34f(1), mat34f(0.5f) ), mat34_smoothstep( mat34f(0), mat34f(1), mat34f(0.5f) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_smoothstep( mat42f(0), mat42f(1), mat42f(0.5f) ), mat42_smoothstep( mat42f(0), mat42f(1), mat42f(0.5f) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_smoothstep( mat43f(0), mat43f(1), mat43f(0.5f) ), mat43_smoothstep( mat43f(0), mat43f(1), mat43f(0.5f) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_smoothstep( mat44f(0), mat44f(1), mat44f(0.5f) ), mat44_smoothstep( mat44f(0), mat44f(1), mat44f(0.5f) ) ) );
    TESTFW_TEST_END();

    // vm_smootherstep
    TESTFW_TEST_BEGIN( "vm_smootherstep dispatches to correct *_smootherstep implementation" )
        TESTFW_EXPECTED( vm_smootherstep( 0.0f, 1.0f, 0.5f ) == vecmath_smootherstep( 0.0f, 1.0f, 0.5f ) );
        TESTFW_EXPECTED( vec2_eq( vm_smootherstep( vec2(0,0), vec2(1,1), vec2(0.5f,0.5f) ), vec2_smootherstep( vec2(0,0), vec2(1,1), vec2(0.5f,0.5f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_smootherstep( vec3(0,0,0), vec3(1,1,1), vec3(0.5f,0.5f,0.5f) ), vec3_smootherstep( vec3(0,0,0), vec3(1,1,1), vec3(0.5f,0.5f,0.5f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_smootherstep( vec4(0,0,0,0), vec4(1,1,1,1), vec4(0.5f,0.5f,0.5f,0.5f) ), vec4_smootherstep( vec4(0,0,0,0), vec4(1,1,1,1), vec4(0.5f,0.5f,0.5f,0.5f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_smootherstep( mat22f(0), mat22f(1), mat22f(0.5f) ), mat22_smootherstep( mat22f(0), mat22f(1), mat22f(0.5f) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_smootherstep( mat23f(0), mat23f(1), mat23f(0.5f) ), mat23_smootherstep( mat23f(0), mat23f(1), mat23f(0.5f) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_smootherstep( mat24f(0), mat24f(1), mat24f(0.5f) ), mat24_smootherstep( mat24f(0), mat24f(1), mat24f(0.5f) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_smootherstep( mat32f(0), mat32f(1), mat32f(0.5f) ), mat32_smootherstep( mat32f(0), mat32f(1), mat32f(0.5f) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_smootherstep( mat33f(0), mat33f(1), mat33f(0.5f) ), mat33_smootherstep( mat33f(0), mat33f(1), mat33f(0.5f) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_smootherstep( mat34f(0), mat34f(1), mat34f(0.5f) ), mat34_smootherstep( mat34f(0), mat34f(1), mat34f(0.5f) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_smootherstep( mat42f(0), mat42f(1), mat42f(0.5f) ), mat42_smootherstep( mat42f(0), mat42f(1), mat42f(0.5f) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_smootherstep( mat43f(0), mat43f(1), mat43f(0.5f) ), mat43_smootherstep( mat43f(0), mat43f(1), mat43f(0.5f) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_smootherstep( mat44f(0), mat44f(1), mat44f(0.5f) ), mat44_smootherstep( mat44f(0), mat44f(1), mat44f(0.5f) ) ) );
    TESTFW_TEST_END();

    // vm_sqrt
    TESTFW_TEST_BEGIN( "vm_sqrt dispatches to correct *_sqrt implementation" )
        TESTFW_EXPECTED( vm_sqrt( 4.0f ) == vecmath_sqrt( 4.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_sqrt( vec2(4.0f,9.0f) ), vec2_sqrt( vec2(4.0f,9.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_sqrt( vec3(1.0f,16.0f,25.0f) ), vec3_sqrt( vec3(1.0f,16.0f,25.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_sqrt( vec4(36.0f,49.0f,64.0f,81.0f) ), vec4_sqrt( vec4(36.0f,49.0f,64.0f,81.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_sqrt( mat22f(4.0f) ), mat22_sqrt( mat22f(4.0f) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_sqrt( mat23f(9.0f) ), mat23_sqrt( mat23f(9.0f) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_sqrt( mat24f(16.0f) ), mat24_sqrt( mat24f(16.0f) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_sqrt( mat32f(25.0f) ), mat32_sqrt( mat32f(25.0f) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_sqrt( mat33f(36.0f) ), mat33_sqrt( mat33f(36.0f) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_sqrt( mat34f(49.0f) ), mat34_sqrt( mat34f(49.0f) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_sqrt( mat42f(64.0f) ), mat42_sqrt( mat42f(64.0f) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_sqrt( mat43f(81.0f) ), mat43_sqrt( mat43f(81.0f) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_sqrt( mat44f(100.0f) ), mat44_sqrt( mat44f(100.0f) ) ) );
    TESTFW_TEST_END();

    // vm_step
    TESTFW_TEST_BEGIN( "vm_step dispatches to correct *_step implementation" )
        TESTFW_EXPECTED( vm_step( 0.5f, 0.25f ) == vecmath_step( 0.5f, 0.25f ) );
        TESTFW_EXPECTED( vec2_eq( vm_step( vec2(0.5f,0.5f), vec2(0.25f,0.75f) ), vec2_step( vec2(0.5f,0.5f), vec2(0.25f,0.75f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_step( vec3(0.1f,0.5f,0.9f), vec3(0.2f,0.4f,1.0f) ), vec3_step( vec3(0.1f,0.5f,0.9f), vec3(0.2f,0.4f,1.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_step( vec4(0.2f,0.4f,0.6f,0.8f), vec4(0.1f,0.5f,0.7f,0.9f) ), vec4_step( vec4(0.2f,0.4f,0.6f,0.8f), vec4(0.1f,0.5f,0.7f,0.9f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_step( mat22f(0.5f), mat22f(0.25f) ), mat22_step( mat22f(0.5f), mat22f(0.25f) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_step( mat23f(0.5f), mat23f(0.25f) ), mat23_step( mat23f(0.5f), mat23f(0.25f) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_step( mat24f(0.5f), mat24f(0.25f) ), mat24_step( mat24f(0.5f), mat24f(0.25f) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_step( mat32f(0.5f), mat32f(0.25f) ), mat32_step( mat32f(0.5f), mat32f(0.25f) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_step( mat33f(0.5f), mat33f(0.25f) ), mat33_step( mat33f(0.5f), mat33f(0.25f) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_step( mat34f(0.5f), mat34f(0.25f) ), mat34_step( mat34f(0.5f), mat34f(0.25f) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_step( mat42f(0.5f), mat42f(0.25f) ), mat42_step( mat42f(0.5f), mat42f(0.25f) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_step( mat43f(0.5f), mat43f(0.25f) ), mat43_step( mat43f(0.5f), mat43f(0.25f) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_step( mat44f(0.5f), mat44f(0.25f) ), mat44_step( mat44f(0.5f), mat44f(0.25f) ) ) );
    TESTFW_TEST_END();

    // vm_tan
    TESTFW_TEST_BEGIN( "vm_tan dispatches to correct *_tan implementation" )
        TESTFW_EXPECTED( vm_tan( 1.0f ) == vecmath_tan( 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_tan( vec2(1.0f,2.0f) ), vec2_tan( vec2(1.0f,2.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_tan( vec3(3.0f,4.0f,5.0f) ), vec3_tan( vec3(3.0f,4.0f,5.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_tan( vec4(6.0f,7.0f,8.0f,9.0f) ), vec4_tan( vec4(6.0f,7.0f,8.0f,9.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_tan( mat22f(1.0f) ), mat22_tan( mat22f(1.0f) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_tan( mat23f(2.0f) ), mat23_tan( mat23f(2.0f) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_tan( mat24f(3.0f) ), mat24_tan( mat24f(3.0f) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_tan( mat32f(4.0f) ), mat32_tan( mat32f(4.0f) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_tan( mat33f(5.0f) ), mat33_tan( mat33f(5.0f) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_tan( mat34f(6.0f) ), mat34_tan( mat34f(6.0f) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_tan( mat42f(7.0f) ), mat42_tan( mat42f(7.0f) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_tan( mat43f(8.0f) ), mat43_tan( mat43f(8.0f) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_tan( mat44f(9.0f) ), mat44_tan( mat44f(9.0f) ) ) );
    TESTFW_TEST_END();

    // vm_tanh
    TESTFW_TEST_BEGIN( "vm_tanh dispatches to correct *_tanh implementation" )
        TESTFW_EXPECTED( vm_tanh( 1.0f ) == vecmath_tanh( 1.0f ) );
        TESTFW_EXPECTED( vec2_eq( vm_tanh( vec2(1.0f,2.0f) ), vec2_tanh( vec2(1.0f,2.0f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_tanh( vec3(3.0f,4.0f,5.0f) ), vec3_tanh( vec3(3.0f,4.0f,5.0f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_tanh( vec4(6.0f,7.0f,8.0f,9.0f) ), vec4_tanh( vec4(6.0f,7.0f,8.0f,9.0f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_tanh( mat22f(1.0f) ), mat22_tanh( mat22f(1.0f) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_tanh( mat23f(2.0f) ), mat23_tanh( mat23f(2.0f) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_tanh( mat24f(3.0f) ), mat24_tanh( mat24f(3.0f) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_tanh( mat32f(4.0f) ), mat32_tanh( mat32f(4.0f) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_tanh( mat33f(5.0f) ), mat33_tanh( mat33f(5.0f) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_tanh( mat34f(6.0f) ), mat34_tanh( mat34f(6.0f) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_tanh( mat42f(7.0f) ), mat42_tanh( mat42f(7.0f) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_tanh( mat43f(8.0f) ), mat43_tanh( mat43f(8.0f) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_tanh( mat44f(9.0f) ), mat44_tanh( mat44f(9.0f) ) ) );
    TESTFW_TEST_END();

    // vm_trunc
    TESTFW_TEST_BEGIN( "vm_trunc dispatches to correct *_trunc implementation" )
        TESTFW_EXPECTED( vm_trunc( 1.9f ) == vecmath_trunc( 1.9f ) );
        TESTFW_EXPECTED( vec2_eq( vm_trunc( vec2(1.9f,2.1f) ), vec2_trunc( vec2(1.9f,2.1f) ) ) );
        TESTFW_EXPECTED( vec3_eq( vm_trunc( vec3(3.6f,4.4f,5.2f) ), vec3_trunc( vec3(3.6f,4.4f,5.2f) ) ) );
        TESTFW_EXPECTED( vec4_eq( vm_trunc( vec4(6.9f,7.8f,8.7f,9.6f) ), vec4_trunc( vec4(6.9f,7.8f,8.7f,9.6f) ) ) );
        TESTFW_EXPECTED( mat22_eq( vm_trunc( mat22f(1.9f) ), mat22_trunc( mat22f(1.9f) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_trunc( mat23f(2.1f) ), mat23_trunc( mat23f(2.1f) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_trunc( mat24f(3.3f) ), mat24_trunc( mat24f(3.3f) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_trunc( mat32f(4.6f) ), mat32_trunc( mat32f(4.6f) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_trunc( mat33f(5.5f) ), mat33_trunc( mat33f(5.5f) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_trunc( mat34f(6.2f) ), mat34_trunc( mat34f(6.2f) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_trunc( mat42f(7.7f) ), mat42_trunc( mat42f(7.7f) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_trunc( mat43f(8.4f) ), mat43_trunc( mat43f(8.4f) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_trunc( mat44f(9.1f) ), mat44_trunc( mat44f(9.1f) ) ) );
    TESTFW_TEST_END();

    // vm_transpose
    TESTFW_TEST_BEGIN( "vm_transpose dispatches to correct *_transpose implementation" )
        TESTFW_EXPECTED( mat22_eq( vm_transpose( mat22f(1.0f) ), mat22_transpose( mat22f(1.0f) ) ) );
        TESTFW_EXPECTED( mat32_eq( vm_transpose( mat23f(2.0f) ), mat23_transpose( mat23f(2.0f) ) ) );
        TESTFW_EXPECTED( mat42_eq( vm_transpose( mat24f(3.0f) ), mat24_transpose( mat24f(3.0f) ) ) );
        TESTFW_EXPECTED( mat23_eq( vm_transpose( mat32f(4.0f) ), mat32_transpose( mat32f(4.0f) ) ) );
        TESTFW_EXPECTED( mat33_eq( vm_transpose( mat33f(5.0f) ), mat33_transpose( mat33f(5.0f) ) ) );
        TESTFW_EXPECTED( mat43_eq( vm_transpose( mat34f(6.0f) ), mat34_transpose( mat34f(6.0f) ) ) );
        TESTFW_EXPECTED( mat24_eq( vm_transpose( mat42f(7.0f) ), mat42_transpose( mat42f(7.0f) ) ) );
        TESTFW_EXPECTED( mat34_eq( vm_transpose( mat43f(8.0f) ), mat43_transpose( mat43f(8.0f) ) ) );
        TESTFW_EXPECTED( mat44_eq( vm_transpose( mat44f(9.0f) ), mat44_transpose( mat44f(9.0f) ) ) );
    TESTFW_TEST_END();

    // vm_determinant
    TESTFW_TEST_BEGIN( "vm_determinant dispatches to correct *_determinant implementation" )
        TESTFW_EXPECTED( vm_determinant( mat22f(1.0f) ) == mat22_determinant( mat22f(1.0f) ) );
        TESTFW_EXPECTED( vm_determinant( mat33f(2.0f) ) == mat33_determinant( mat33f(2.0f) ) );
        TESTFW_EXPECTED( vm_determinant( mat44f(3.0f) ) == mat44_determinant( mat44f(3.0f) ) );
    TESTFW_TEST_END();
}

#endif /* VECMATH_GENERICS */


#ifdef __cplusplus

void test_cpp_operators( void ) {
    // operator-
    TESTFW_TEST_BEGIN( "operator- dispatches to correct *_neg implementation" )
        TESTFW_EXPECTED( vec2_eq( -vec2(1,-2), vec2_neg( vec2(1,-2) ) ) );
        TESTFW_EXPECTED( vec3_eq( -vec3(1,-2,3), vec3_neg( vec3(1,-2,3) ) ) );
        TESTFW_EXPECTED( vec4_eq( -vec4(1,-2,3,-4), vec4_neg( vec4(1,-2,3,-4) ) ) );
        TESTFW_EXPECTED( mat22_eq( -mat22(vec2(1,2),vec2(3,4)), mat22_neg( mat22(vec2(1,2),vec2(3,4)) ) ) );
        TESTFW_EXPECTED( mat23_eq( -mat23(vec3(1,2,3),vec3(4,5,6)), mat23_neg( mat23(vec3(1,2,3),vec3(4,5,6)) ) ) );
        TESTFW_EXPECTED( mat24_eq( -mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24_neg( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) ) );
        TESTFW_EXPECTED( mat32_eq( -mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32_neg( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) ) );
        TESTFW_EXPECTED( mat33_eq( -mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33_neg( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) ) );
        TESTFW_EXPECTED( mat34_eq( -mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34_neg( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) ) );
        TESTFW_EXPECTED( mat42_eq( -mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42_neg( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat43_eq( -mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43_neg( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( mat44_eq( -mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44_neg( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) ) );
    TESTFW_TEST_END();

    // operator==
    TESTFW_TEST_BEGIN( "operator== dispatches to correct *_eq implementation" )
        TESTFW_EXPECTED( ( vec2(1,2) == vec2(1,2) ) == (bool)vec2_eq( vec2(1,2), vec2(1,2) ) );
        TESTFW_EXPECTED( ( vec2(1,2) == vec2(3,4) ) == (bool)vec2_eq( vec2(1,2), vec2(3,4) ) );
        TESTFW_EXPECTED( ( vec3(1,2,3) == vec3(1,2,3) ) == (bool)vec3_eq( vec3(1,2,3), vec3(1,2,3) ) );
        TESTFW_EXPECTED( ( vec3(1,2,3) == vec3(4,5,6) ) == (bool)vec3_eq( vec3(1,2,3), vec3(4,5,6) ) );
        TESTFW_EXPECTED( ( vec4(1,2,3,4) == vec4(1,2,3,4) ) == (bool)vec4_eq( vec4(1,2,3,4), vec4(1,2,3,4) ) );
        TESTFW_EXPECTED( ( vec4(1,2,3,4) == vec4(5,6,7,8) ) == (bool)vec4_eq( vec4(1,2,3,4), vec4(5,6,7,8) ) );
        TESTFW_EXPECTED( ( mat22(vec2(1,2),vec2(3,4)) == mat22(vec2(1,2),vec2(3,4)) ) == (bool)mat22_eq( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(1,2),vec2(3,4)) ) );
        TESTFW_EXPECTED( ( mat22(vec2(1,2),vec2(3,4)) == mat22(vec2(5,6),vec2(7,8)) ) == (bool)mat22_eq( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)) ) );
        TESTFW_EXPECTED( ( mat23(vec3(1,2,3),vec3(4,5,6)) == mat23(vec3(1,2,3),vec3(4,5,6)) ) == (bool)mat23_eq( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(1,2,3),vec3(4,5,6)) ) );
        TESTFW_EXPECTED( ( mat23(vec3(1,2,3),vec3(4,5,6)) == mat23(vec3(7,8,9),vec3(10,11,12)) ) == (bool)mat23_eq( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(7,8,9),vec3(10,11,12)) ) );
        TESTFW_EXPECTED( ( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) == mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) == (bool)mat24_eq( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) );
        TESTFW_EXPECTED( ( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) == mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ) == (bool)mat24_eq( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ) );
        TESTFW_EXPECTED( ( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) == mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) == (bool)mat32_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) );
        TESTFW_EXPECTED( ( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) == mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ) == (bool)mat32_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ) );
        TESTFW_EXPECTED( ( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) == mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) == (bool)mat33_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) );
        TESTFW_EXPECTED( ( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) == mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)) ) == (bool)mat33_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)) ) );
        TESTFW_EXPECTED( ( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) == mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) == (bool)mat34_eq( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) );
        TESTFW_EXPECTED( ( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) == mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ) == (bool)mat34_eq( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ) );
        TESTFW_EXPECTED( ( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) == mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) == (bool)mat42_eq( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) );
        TESTFW_EXPECTED( ( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) == mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ) == (bool)mat42_eq( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ) );
        TESTFW_EXPECTED( ( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) == mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) == (bool)mat43_eq( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) );
        TESTFW_EXPECTED( ( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) == mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ) == (bool)mat43_eq( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ) );
        TESTFW_EXPECTED( ( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) == mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) == (bool)mat44_eq( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) );
        TESTFW_EXPECTED( ( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) == mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ) == (bool)mat44_eq( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ) );
    TESTFW_TEST_END();

    // operator!=
    TESTFW_TEST_BEGIN( "operator!= dispatches to correct *_eq implementation" )
        TESTFW_EXPECTED( ( vec2(1,2) != vec2(1,2) ) == !(bool)vec2_eq( vec2(1,2), vec2(1,2) ) );
        TESTFW_EXPECTED( ( vec2(1,2) != vec2(3,4) ) == !(bool)vec2_eq( vec2(1,2), vec2(3,4) ) );
        TESTFW_EXPECTED( ( vec3(1,2,3) != vec3(1,2,3) ) == !(bool)vec3_eq( vec3(1,2,3), vec3(1,2,3) ) );
        TESTFW_EXPECTED( ( vec3(1,2,3) != vec3(4,5,6) ) == !(bool)vec3_eq( vec3(1,2,3), vec3(4,5,6) ) );
        TESTFW_EXPECTED( ( vec4(1,2,3,4) != vec4(1,2,3,4) ) == !(bool)vec4_eq( vec4(1,2,3,4), vec4(1,2,3,4) ) );
        TESTFW_EXPECTED( ( vec4(1,2,3,4) != vec4(5,6,7,8) ) == !(bool)vec4_eq( vec4(1,2,3,4), vec4(5,6,7,8) ) );
        TESTFW_EXPECTED( ( mat22(vec2(1,2),vec2(3,4)) != mat22(vec2(1,2),vec2(3,4)) ) == !(bool)mat22_eq( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(1,2),vec2(3,4)) ) );
        TESTFW_EXPECTED( ( mat22(vec2(1,2),vec2(3,4)) != mat22(vec2(5,6),vec2(7,8)) ) == !(bool)mat22_eq( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)) ) );
        TESTFW_EXPECTED( ( mat23(vec3(1,2,3),vec3(4,5,6)) != mat23(vec3(1,2,3),vec3(4,5,6)) ) == !(bool)mat23_eq( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(1,2,3),vec3(4,5,6)) ) );
        TESTFW_EXPECTED( ( mat23(vec3(1,2,3),vec3(4,5,6)) != mat23(vec3(7,8,9),vec3(10,11,12)) ) == !(bool)mat23_eq( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(7,8,9),vec3(10,11,12)) ) );
        TESTFW_EXPECTED( ( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) != mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) == !(bool)mat24_eq( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) );
        TESTFW_EXPECTED( ( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) != mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ) == !(bool)mat24_eq( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ) );
        TESTFW_EXPECTED( ( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) != mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) == !(bool)mat32_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) );
        TESTFW_EXPECTED( ( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) != mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ) == !(bool)mat32_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ) );
        TESTFW_EXPECTED( ( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) != mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) == !(bool)mat33_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) );
        TESTFW_EXPECTED( ( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) != mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)) ) == !(bool)mat33_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)) ) );
        TESTFW_EXPECTED( ( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) != mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) == !(bool)mat34_eq( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) );
        TESTFW_EXPECTED( ( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) != mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ) == !(bool)mat34_eq( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ) );
        TESTFW_EXPECTED( ( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) != mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) == !(bool)mat42_eq( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) );
        TESTFW_EXPECTED( ( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) != mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ) == !(bool)mat42_eq( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ) );
        TESTFW_EXPECTED( ( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) != mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) == !(bool)mat43_eq( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) );
        TESTFW_EXPECTED( ( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) != mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ) == !(bool)mat43_eq( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ) );
        TESTFW_EXPECTED( ( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) != mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) == !(bool)mat44_eq( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) );
        TESTFW_EXPECTED( ( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) != mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ) == !(bool)mat44_eq( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ) );
    TESTFW_TEST_END();

    // operator+
    TESTFW_TEST_BEGIN( "operator+ dispatches to correct *_add implementation" )
        TESTFW_EXPECTED( vec2_eq( vec2(1,2) + vec2(3,4), vec2_add( vec2(1,2), vec2(3,4) ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3(1,2,3) + vec3(4,5,6), vec3_add( vec3(1,2,3), vec3(4,5,6) ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4(1,2,3,4) + vec4(5,6,7,8), vec4_add( vec4(1,2,3,4), vec4(5,6,7,8) ) ) );
        TESTFW_EXPECTED( mat22_eq( mat22(vec2(1,2),vec2(3,4)) + mat22(vec2(5,6),vec2(7,8)), mat22_add( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat23_eq( mat23(vec3(1,2,3),vec3(4,5,6)) + mat23(vec3(7,8,9),vec3(10,11,12)), mat23_add( mat23(vec3(1,2,3),vec3(4,5,6)), mat23(vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( mat24_eq( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) + mat24(vec4(9,10,11,12),vec4(13,14,15,16)), mat24_add( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24(vec4(9,10,11,12),vec4(13,14,15,16)) ) ) );
        TESTFW_EXPECTED( mat32_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) + mat32(vec2(7,8),vec2(9,10),vec2(11,12)), mat32_add( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ) ) );
        TESTFW_EXPECTED( mat33_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) + mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)), mat33_add( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) ) ) );
        TESTFW_EXPECTED( mat34_eq( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) + mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)), mat34_add( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) ) ) );
        TESTFW_EXPECTED( mat42_eq( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) + mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)), mat42_add( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) ) ) );
        TESTFW_EXPECTED( mat43_eq( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) + mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)), mat43_add( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) ) ) );
        TESTFW_EXPECTED( mat44_eq( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) + mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)), mat44_add( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) ) ) );
    TESTFW_TEST_END();

    // operator-
    TESTFW_TEST_BEGIN( "operator- dispatches to correct *_sub implementation" )
        TESTFW_EXPECTED( vec2_eq( vec2(3,4) - vec2(1,2), vec2_sub( vec2(3,4), vec2(1,2) ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3(4,5,6) - vec3(1,2,3), vec3_sub( vec3(4,5,6), vec3(1,2,3) ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4(5,6,7,8) - vec4(1,2,3,4), vec4_sub( vec4(5,6,7,8), vec4(1,2,3,4) ) ) );
        TESTFW_EXPECTED( mat22_eq( mat22(vec2(5,6),vec2(7,8)) - mat22(vec2(1,2),vec2(3,4)), mat22_sub( mat22(vec2(5,6),vec2(7,8)), mat22(vec2(1,2),vec2(3,4)) ) ) );
        TESTFW_EXPECTED( mat23_eq( mat23(vec3(7,8,9),vec3(10,11,12)) - mat23(vec3(1,2,3),vec3(4,5,6)), mat23_sub( mat23(vec3(7,8,9),vec3(10,11,12)), mat23(vec3(1,2,3),vec3(4,5,6)) ) ) );
        TESTFW_EXPECTED( mat24_eq( mat24(vec4(9,10,11,12),vec4(13,14,15,16)) - mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24_sub( mat24(vec4(9,10,11,12),vec4(13,14,15,16)), mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) ) );
        TESTFW_EXPECTED( mat32_eq( mat32(vec2(7,8),vec2(9,10),vec2(11,12)) - mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32_sub( mat32(vec2(7,8),vec2(9,10),vec2(11,12)), mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) ) );
        TESTFW_EXPECTED( mat33_eq( mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)) - mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33_sub( mat33(vec3(9,8,7),vec3(6,5,4),vec3(3,2,1)), mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) ) );
        TESTFW_EXPECTED( mat34_eq( mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)) - mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34_sub( mat34(vec4(13,14,15,16),vec4(17,18,19,20),vec4(21,22,23,24)), mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) ) );
        TESTFW_EXPECTED( mat42_eq( mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)) - mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42_sub( mat42(vec2(9,10),vec2(11,12),vec2(13,14),vec2(15,16)), mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat43_eq( mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)) - mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43_sub( mat43(vec3(13,14,15),vec3(16,17,18),vec3(19,20,21),vec3(22,23,24)), mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( mat44_eq( mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)) - mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44_sub( mat44(vec4(17,18,19,20),vec4(21,22,23,24),vec4(25,26,27,28),vec4(29,30,31,32)), mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) ) );
    TESTFW_TEST_END();

    // operator/
    TESTFW_TEST_BEGIN( "operator/ dispatches to correct *_div implementation" )
        TESTFW_EXPECTED( vec2_eq( vec2(6,8) / vec2(2,4), vec2_div( vec2(6,8), vec2(2,4) ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3(9,10,12) / vec3(3,2,4), vec3_div( vec3(9,10,12), vec3(3,2,4) ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4(20,18,16,14) / vec4(2,3,4,7), vec4_div( vec4(20,18,16,14), vec4(2,3,4,7) ) ) );
        TESTFW_EXPECTED( mat22_eq( mat22(vec2(6,8),vec2(10,12)) / mat22(vec2(2,2),vec2(5,4)), mat22_div( mat22(vec2(6,8),vec2(10,12)), mat22(vec2(2,2),vec2(5,4)) ) ) );
        TESTFW_EXPECTED( mat23_eq( mat23(vec3(9,10,11),vec3(12,13,14)) / mat23(vec3(1,2,1),vec3(3,1,2)), mat23_div( mat23(vec3(9,10,11),vec3(12,13,14)), mat23(vec3(1,2,1),vec3(3,1,2)) ) ) );
        TESTFW_EXPECTED( mat24_eq( mat24(vec4(10,12,14,16),vec4(18,20,22,24)) / mat24(vec4(2,2,2,2),vec4(3,2,2,2)), mat24_div( mat24(vec4(10,12,14,16),vec4(18,20,22,24)), mat24(vec4(2,2,2,2),vec4(3,2,2,2)) ) ) );
        TESTFW_EXPECTED( mat32_eq( mat32(vec2(6,8),vec2(10,12),vec2(14,16)) / mat32(vec2(2,2),vec2(5,4),vec2(7,8)), mat32_div( mat32(vec2(6,8),vec2(10,12),vec2(14,16)), mat32(vec2(2,2),vec2(5,4),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat33_eq( mat33(vec3(9,10,11),vec3(12,13,14),vec3(15,16,17)) / mat33(vec3(1,2,1),vec3(3,1,2),vec3(5,2,3)), mat33_div( mat33(vec3(9,10,11),vec3(12,13,14),vec3(15,16,17)), mat33(vec3(1,2,1),vec3(3,1,2),vec3(5,2,3)) ) ) );
        TESTFW_EXPECTED( mat34_eq( mat34(vec4(10,12,14,16),vec4(18,20,22,24),vec4(26,28,30,32)) / mat34(vec4(2,2,2,2),vec4(3,2,2,2),vec4(2,4,2,4)), mat34_div( mat34(vec4(10,12,14,16),vec4(18,20,22,24),vec4(26,28,30,32)), mat34(vec4(2,2,2,2),vec4(3,2,2,2),vec4(2,4,2,4)) ) ) );
        TESTFW_EXPECTED( mat42_eq( mat42(vec2(6,8),vec2(10,12),vec2(14,16),vec2(18,20)) / mat42(vec2(2,2),vec2(5,4),vec2(7,8),vec2(9,10)), mat42_div( mat42(vec2(6,8),vec2(10,12),vec2(14,16),vec2(18,20)), mat42(vec2(2,2),vec2(5,4),vec2(7,8),vec2(9,10)) ) ) );
        TESTFW_EXPECTED( mat43_eq( mat43(vec3(9,10,11),vec3(12,13,14),vec3(15,16,17),vec3(18,19,20)) / mat43(vec3(1,2,1),vec3(3,1,2),vec3(5,2,3),vec3(7,3,4)), mat43_div( mat43(vec3(9,10,11),vec3(12,13,14),vec3(15,16,17),vec3(18,19,20)), mat43(vec3(1,2,1),vec3(3,1,2),vec3(5,2,3),vec3(7,3,4)) ) ) );
        TESTFW_EXPECTED( mat44_eq( mat44(vec4(10,12,14,16),vec4(18,20,22,24),vec4(26,28,30,32),vec4(34,36,38,40)) / mat44(vec4(2,2,2,2),vec4(3,2,2,2),vec4(2,4,2,4),vec4(2,2,4,2)), mat44_div( mat44(vec4(10,12,14,16),vec4(18,20,22,24),vec4(26,28,30,32),vec4(34,36,38,40)), mat44(vec4(2,2,2,2),vec4(3,2,2,2),vec4(2,4,2,4),vec4(2,2,4,2)) ) ) );
    TESTFW_TEST_END();

    // operator+
    TESTFW_TEST_BEGIN( "operator+ dispatches to correct *_addf implementation" )
        TESTFW_EXPECTED( vec2_eq( vec2(1,2) + 3.0f, vec2_addf( vec2(1,2), 3.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3(1,2,3) + 4.0f, vec3_addf( vec3(1,2,3), 4.0f ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4(1,2,3,4) + 5.0f, vec4_addf( vec4(1,2,3,4), 5.0f ) ) );
        TESTFW_EXPECTED( mat22_eq( mat22(vec2(1,2),vec2(3,4)) + 2.0f, mat22_addf( mat22(vec2(1,2),vec2(3,4)), 2.0f ) ) );
        TESTFW_EXPECTED( mat23_eq( mat23(vec3(1,2,3),vec3(4,5,6)) + 3.0f, mat23_addf( mat23(vec3(1,2,3),vec3(4,5,6)), 3.0f ) ) );
        TESTFW_EXPECTED( mat24_eq( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) + 4.0f, mat24_addf( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), 4.0f ) ) );
        TESTFW_EXPECTED( mat32_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) + 1.0f, mat32_addf( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), 1.0f ) ) );
        TESTFW_EXPECTED( mat33_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) + 2.0f, mat33_addf( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), 2.0f ) ) );
        TESTFW_EXPECTED( mat34_eq( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) + 3.0f, mat34_addf( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), 3.0f ) ) );
        TESTFW_EXPECTED( mat42_eq( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) + 2.0f, mat42_addf( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), 2.0f ) ) );
        TESTFW_EXPECTED( mat43_eq( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) + 1.0f, mat43_addf( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), 1.0f ) ) );
        TESTFW_EXPECTED( mat44_eq( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) + 4.0f, mat44_addf( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), 4.0f ) ) );
    TESTFW_TEST_END();

    // operator+
    TESTFW_TEST_BEGIN( "operator+ dispatches to correct *_addf implementation with scalar on left" )
        TESTFW_EXPECTED( vec2_eq( 3.0f + vec2(1,2), vec2_addf( vec2(1,2), 3.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( 4.0f + vec3(1,2,3), vec3_addf( vec3(1,2,3), 4.0f ) ) );
        TESTFW_EXPECTED( vec4_eq( 5.0f + vec4(1,2,3,4), vec4_addf( vec4(1,2,3,4), 5.0f ) ) );
        TESTFW_EXPECTED( mat22_eq( 2.0f + mat22(vec2(1,2),vec2(3,4)), mat22_addf( mat22(vec2(1,2),vec2(3,4)), 2.0f ) ) );
        TESTFW_EXPECTED( mat23_eq( 3.0f + mat23(vec3(1,2,3),vec3(4,5,6)), mat23_addf( mat23(vec3(1,2,3),vec3(4,5,6)), 3.0f ) ) );
        TESTFW_EXPECTED( mat24_eq( 4.0f + mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24_addf( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), 4.0f ) ) );
        TESTFW_EXPECTED( mat32_eq( 1.0f + mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32_addf( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), 1.0f ) ) );
        TESTFW_EXPECTED( mat33_eq( 2.0f + mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33_addf( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), 2.0f ) ) );
        TESTFW_EXPECTED( mat34_eq( 3.0f + mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34_addf( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), 3.0f ) ) );
        TESTFW_EXPECTED( mat42_eq( 2.0f + mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42_addf( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), 2.0f ) ) );
        TESTFW_EXPECTED( mat43_eq( 1.0f + mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43_addf( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), 1.0f ) ) );
        TESTFW_EXPECTED( mat44_eq( 4.0f + mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44_addf( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), 4.0f ) ) );
    TESTFW_TEST_END();

    // operator-
    TESTFW_TEST_BEGIN( "operator- dispatches to correct *_subf implementation with scalar on right" )
        TESTFW_EXPECTED( vec2_eq( vec2(4,5) - 2.0f, vec2_subf( vec2(4,5), 2.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3(5,6,7) - 3.0f, vec3_subf( vec3(5,6,7), 3.0f ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4(6,7,8,9) - 4.0f, vec4_subf( vec4(6,7,8,9), 4.0f ) ) );
        TESTFW_EXPECTED( mat22_eq( mat22(vec2(4,5),vec2(6,7)) - 1.0f, mat22_subf( mat22(vec2(4,5),vec2(6,7)), 1.0f ) ) );
        TESTFW_EXPECTED( mat23_eq( mat23(vec3(4,5,6),vec3(7,8,9)) - 2.0f, mat23_subf( mat23(vec3(4,5,6),vec3(7,8,9)), 2.0f ) ) );
        TESTFW_EXPECTED( mat24_eq( mat24(vec4(5,6,7,8),vec4(9,10,11,12)) - 3.0f, mat24_subf( mat24(vec4(5,6,7,8),vec4(9,10,11,12)), 3.0f ) ) );
        TESTFW_EXPECTED( mat32_eq( mat32(vec2(3,4),vec2(5,6),vec2(7,8)) - 1.0f, mat32_subf( mat32(vec2(3,4),vec2(5,6),vec2(7,8)), 1.0f ) ) );
        TESTFW_EXPECTED( mat33_eq( mat33(vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) - 2.0f, mat33_subf( mat33(vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), 2.0f ) ) );
        TESTFW_EXPECTED( mat34_eq( mat34(vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) - 3.0f, mat34_subf( mat34(vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), 3.0f ) ) );
        TESTFW_EXPECTED( mat42_eq( mat42(vec2(2,3),vec2(4,5),vec2(6,7),vec2(8,9)) - 1.0f, mat42_subf( mat42(vec2(2,3),vec2(4,5),vec2(6,7),vec2(8,9)), 1.0f ) ) );
        TESTFW_EXPECTED( mat43_eq( mat43(vec3(3,4,5),vec3(6,7,8),vec3(9,10,11),vec3(12,13,14)) - 2.0f, mat43_subf( mat43(vec3(3,4,5),vec3(6,7,8),vec3(9,10,11),vec3(12,13,14)), 2.0f ) ) );
        TESTFW_EXPECTED( mat44_eq( mat44(vec4(4,5,6,7),vec4(8,9,10,11),vec4(12,13,14,15),vec4(16,17,18,19)) - 3.0f, mat44_subf( mat44(vec4(4,5,6,7),vec4(8,9,10,11),vec4(12,13,14,15),vec4(16,17,18,19)), 3.0f ) ) );
    TESTFW_TEST_END();

    // operator-
    TESTFW_TEST_BEGIN( "operator- dispatches to correct *neg+addf implementation with scalar on left" )
        TESTFW_EXPECTED( vec2_eq( 5.0f - vec2(1,2), vec2_addf( vec2_neg( vec2(1,2) ), 5.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( 6.0f - vec3(1,2,3), vec3_addf( vec3_neg( vec3(1,2,3) ), 6.0f ) ) );
        TESTFW_EXPECTED( vec4_eq( 7.0f - vec4(1,2,3,4), vec4_addf( vec4_neg( vec4(1,2,3,4) ), 7.0f ) ) );
        TESTFW_EXPECTED( mat22_eq( 3.0f - mat22(vec2(1,2),vec2(3,4)), mat22_addf( mat22_neg( mat22(vec2(1,2),vec2(3,4)) ), 3.0f ) ) );
        TESTFW_EXPECTED( mat23_eq( 4.0f - mat23(vec3(1,2,3),vec3(4,5,6)), mat23_addf( mat23_neg( mat23(vec3(1,2,3),vec3(4,5,6)) ), 4.0f ) ) );
        TESTFW_EXPECTED( mat24_eq( 5.0f - mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24_addf( mat24_neg( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ), 5.0f ) ) );
        TESTFW_EXPECTED( mat32_eq( 2.0f - mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32_addf( mat32_neg( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ), 2.0f ) ) );
        TESTFW_EXPECTED( mat33_eq( 3.0f - mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33_addf( mat33_neg( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ), 3.0f ) ) );
        TESTFW_EXPECTED( mat34_eq( 4.0f - mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34_addf( mat34_neg( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ), 4.0f ) ) );
        TESTFW_EXPECTED( mat42_eq( 3.0f - mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42_addf( mat42_neg( mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ), 3.0f ) ) );
        TESTFW_EXPECTED( mat43_eq( 2.0f - mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43_addf( mat43_neg( mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ), 2.0f ) ) );
        TESTFW_EXPECTED( mat44_eq( 1.0f - mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44_addf( mat44_neg( mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ), 1.0f ) ) );
    TESTFW_TEST_END();

    // operator/
    TESTFW_TEST_BEGIN( "operator/ dispatches to correct *_divf implementation with scalar on right" )
        TESTFW_EXPECTED( vec2_eq( vec2(4,6) / 2.0f, vec2_divf( vec2(4,6), 2.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3(6,9,12) / 3.0f, vec3_divf( vec3(6,9,12), 3.0f ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4(8,12,16,20) / 4.0f, vec4_divf( vec4(8,12,16,20), 4.0f ) ) );
        TESTFW_EXPECTED( mat22_eq( mat22(vec2(6,8),vec2(10,12)) / 2.0f, mat22_divf( mat22(vec2(6,8),vec2(10,12)), 2.0f ) ) );
        TESTFW_EXPECTED( mat23_eq( mat23(vec3(6,9,12),vec3(15,18,21)) / 3.0f, mat23_divf( mat23(vec3(6,9,12),vec3(15,18,21)), 3.0f ) ) );
        TESTFW_EXPECTED( mat24_eq( mat24(vec4(8,12,16,20),vec4(24,28,32,36)) / 4.0f, mat24_divf( mat24(vec4(8,12,16,20),vec4(24,28,32,36)), 4.0f ) ) );
        TESTFW_EXPECTED( mat32_eq( mat32(vec2(6,8),vec2(10,12),vec2(14,16)) / 2.0f, mat32_divf( mat32(vec2(6,8),vec2(10,12),vec2(14,16)), 2.0f ) ) );
        TESTFW_EXPECTED( mat33_eq( mat33(vec3(6,9,12),vec3(15,18,21),vec3(24,27,30)) / 3.0f, mat33_divf( mat33(vec3(6,9,12),vec3(15,18,21),vec3(24,27,30)), 3.0f ) ) );
        TESTFW_EXPECTED( mat34_eq( mat34(vec4(8,12,16,20),vec4(24,28,32,36),vec4(40,44,48,52)) / 4.0f, mat34_divf( mat34(vec4(8,12,16,20),vec4(24,28,32,36),vec4(40,44,48,52)), 4.0f ) ) );
        TESTFW_EXPECTED( mat42_eq( mat42(vec2(6,8),vec2(10,12),vec2(14,16),vec2(18,20)) / 2.0f, mat42_divf( mat42(vec2(6,8),vec2(10,12),vec2(14,16),vec2(18,20)), 2.0f ) ) );
        TESTFW_EXPECTED( mat43_eq( mat43(vec3(6,9,12),vec3(15,18,21),vec3(24,27,30),vec3(33,36,39)) / 3.0f, mat43_divf( mat43(vec3(6,9,12),vec3(15,18,21),vec3(24,27,30),vec3(33,36,39)), 3.0f ) ) );
        TESTFW_EXPECTED( mat44_eq( mat44(vec4(8,12,16,20),vec4(24,28,32,36),vec4(40,44,48,52),vec4(56,60,64,68)) / 4.0f, mat44_divf( mat44(vec4(8,12,16,20),vec4(24,28,32,36),vec4(40,44,48,52),vec4(56,60,64,68)), 4.0f ) ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "operator/ dispatches to correct *_div implementation with scalar on left" )
        TESTFW_EXPECTED( vec2_eq( 8.0f / vec2(2,4), vec2_div( vec2(8,8), vec2(2,4) ) ) );
        TESTFW_EXPECTED( vec3_eq( 9.0f / vec3(3,1,9), vec3_div( vec3(9,9,9), vec3(3,1,9) ) ) );
        TESTFW_EXPECTED( vec4_eq( 12.0f / vec4(4,2,3,6), vec4_div( vec4(12,12,12,12), vec4(4,2,3,6) ) ) );
        TESTFW_EXPECTED( mat22_eq( 6.0f / mat22(vec2(1,2),vec2(3,4)), mat22_div( mat22f(6.0f), mat22(vec2(1,2),vec2(3,4)) ) ) );
        TESTFW_EXPECTED( mat23_eq( 9.0f / mat23(vec3(1,2,3),vec3(4,5,6)), mat23_div( mat23f(9.0f), mat23(vec3(1,2,3),vec3(4,5,6)) ) ) );
        TESTFW_EXPECTED( mat24_eq( 12.0f / mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24_div( mat24f(12.0f), mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) ) );
        TESTFW_EXPECTED( mat32_eq( 6.0f / mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32_div( mat32f(6.0f), mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) ) );
        TESTFW_EXPECTED( mat33_eq( 9.0f / mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33_div( mat33f(9.0f), mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) ) );
        TESTFW_EXPECTED( mat34_eq( 12.0f / mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34_div( mat34f(12.0f), mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) ) );
        TESTFW_EXPECTED( mat42_eq( 8.0f / mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42_div( mat42f(8.0f), mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat43_eq( 9.0f / mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43_div( mat43f(9.0f), mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( mat44_eq( 12.0f / mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44_div( mat44f(12.0f), mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) ) );
    TESTFW_TEST_END();

    // operator*
    TESTFW_TEST_BEGIN( "operator* dispatches to correct *_mul implementation" )
        TESTFW_EXPECTED( vec2_eq( 2.0f * vec2(1,2), vec2_fmul( 2.0f, vec2(1,2) ) ) );
        TESTFW_EXPECTED( vec3_eq( 2.0f * vec3(1,2,3), vec3_fmul( 2.0f, vec3(1,2,3) ) ) );
        TESTFW_EXPECTED( vec4_eq( 2.0f * vec4(1,2,3,4), vec4_fmul( 2.0f, vec4(1,2,3,4) ) ) );
        TESTFW_EXPECTED( mat22_eq( 2.0f * mat22(vec2(1,2),vec2(3,4)), mat22_fmul( 2.0f, mat22(vec2(1,2),vec2(3,4)) ) ) );
        TESTFW_EXPECTED( mat23_eq( 2.0f * mat23(vec3(1,2,3),vec3(4,5,6)), mat23_fmul( 2.0f, mat23(vec3(1,2,3),vec3(4,5,6)) ) ) );
        TESTFW_EXPECTED( mat24_eq( 2.0f * mat24(vec4(1,2,3,4),vec4(5,6,7,8)), mat24_fmul( 2.0f, mat24(vec4(1,2,3,4),vec4(5,6,7,8)) ) ) );
        TESTFW_EXPECTED( mat32_eq( 2.0f * mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat32_fmul( 2.0f, mat32(vec2(1,2),vec2(3,4),vec2(5,6)) ) ) );
        TESTFW_EXPECTED( mat33_eq( 2.0f * mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33_fmul( 2.0f, mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) ) ) );
        TESTFW_EXPECTED( mat34_eq( 2.0f * mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), mat34_fmul( 2.0f, mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) ) ) );
        TESTFW_EXPECTED( mat42_eq( 2.0f * mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)), mat42_fmul( 2.0f, mat42(vec2(1,2),vec2(3,4),vec2(5,6),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat43_eq( 2.0f * mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), mat43_fmul( 2.0f, mat43(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( mat44_eq( 2.0f * mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)), mat44_fmul( 2.0f, mat44(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16)) ) ) );
        TESTFW_EXPECTED( vec2_eq( vec2(1,2) * vec2(3,4), vec2_mul( vec2(1,2), vec2(3,4) ) ) );
        TESTFW_EXPECTED( vec2_eq( vec2(1,2) * 2.0f, vec2_mulf( vec2(1,2), 2.0f ) ) );
        TESTFW_EXPECTED( vec2_eq( vec2(1,2) * mat22(vec2(3,4),vec2(5,6)), vec2_mul_mat22( vec2(1,2), mat22(vec2(3,4),vec2(5,6)) ) ) );
        TESTFW_EXPECTED( vec3_eq( vec2(1,2) * mat23(vec3(3,4,5),vec3(6,7,8)), vec2_mul_mat23( vec2(1,2), mat23(vec3(3,4,5),vec3(6,7,8)) ) ) );
        TESTFW_EXPECTED( vec4_eq( vec2(1,2) * mat24(vec4(3,4,5,6),vec4(7,8,9,10)), vec2_mul_mat24( vec2(1,2), mat24(vec4(3,4,5,6),vec4(7,8,9,10)) ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3(1,2,3) * vec3(4,5,6), vec3_mul( vec3(1,2,3), vec3(4,5,6) ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3(1,2,3) * 2.0f, vec3_mulf( vec3(1,2,3), 2.0f ) ) );
        TESTFW_EXPECTED( vec2_eq( vec3(1,2,3) * mat32(vec2(4,5),vec2(6,7),vec2(8,9)), vec3_mul_mat32( vec3(1,2,3), mat32(vec2(4,5),vec2(6,7),vec2(8,9)) ) ) );
        TESTFW_EXPECTED( vec3_eq( vec3(1,2,3) * mat33(vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)), vec3_mul_mat33( vec3(1,2,3), mat33(vec3(4,5,6),vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( vec4_eq( vec3(1,2,3) * mat34(vec4(4,5,6,7),vec4(8,9,10,11),vec4(12,13,14,15)), vec3_mul_mat34( vec3(1,2,3), mat34(vec4(4,5,6,7),vec4(8,9,10,11),vec4(12,13,14,15)) ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4(1,2,3,4) * vec4(5,6,7,8), vec4_mul( vec4(1,2,3,4), vec4(5,6,7,8) ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4(1,2,3,4) * 2.0f, vec4_mulf( vec4(1,2,3,4), 2.0f ) ) );
        TESTFW_EXPECTED( vec2_eq( vec4(1,2,3,4) * mat42(vec2(5,6),vec2(7,8),vec2(9,10),vec2(11,12)), vec4_mul_mat42( vec4(1,2,3,4), mat42(vec2(5,6),vec2(7,8),vec2(9,10),vec2(11,12)) ) ) );
        TESTFW_EXPECTED( vec3_eq( vec4(1,2,3,4) * mat43(vec3(5,6,7),vec3(8,9,10),vec3(11,12,13),vec3(14,15,16)), vec4_mul_mat43( vec4(1,2,3,4), mat43(vec3(5,6,7),vec3(8,9,10),vec3(11,12,13),vec3(14,15,16)) ) ) );
        TESTFW_EXPECTED( vec4_eq( vec4(1,2,3,4) * mat44(vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16),vec4(17,18,19,20)), vec4_mul_mat44( vec4(1,2,3,4), mat44(vec4(5,6,7,8),vec4(9,10,11,12),vec4(13,14,15,16),vec4(17,18,19,20)) ) ) );
        TESTFW_EXPECTED( mat22_eq( mat22(vec2(1,2),vec2(3,4)) * 2.0f, mat22_mulf( mat22(vec2(1,2),vec2(3,4)), 2.0f ) ) );
        TESTFW_EXPECTED( vec2_eq( mat22(vec2(1,2),vec2(3,4)) * vec2(5,6), mat22_mul_vec2( mat22(vec2(1,2),vec2(3,4)), vec2(5,6) ) ) );
        TESTFW_EXPECTED( mat22_eq( mat22(vec2(1,2),vec2(3,4)) * mat22(vec2(5,6),vec2(7,8)), mat22_mul_mat22( mat22(vec2(1,2),vec2(3,4)), mat22(vec2(5,6),vec2(7,8)) ) ) );
        TESTFW_EXPECTED( mat23_eq( mat22(vec2(1,2),vec2(3,4)) * mat23(vec3(5,6,7),vec3(8,9,10)), mat22_mul_mat23( mat22(vec2(1,2),vec2(3,4)), mat23(vec3(5,6,7),vec3(8,9,10)) ) ) );
        TESTFW_EXPECTED( mat24_eq( mat22(vec2(1,2),vec2(3,4)) * mat24(vec4(5,6,7,8),vec4(9,10,11,12)), mat22_mul_mat24( mat22(vec2(1,2),vec2(3,4)), mat24(vec4(5,6,7,8),vec4(9,10,11,12)) ) ) );
        TESTFW_EXPECTED( mat23_eq( mat23(vec3(1,2,3),vec3(4,5,6)) * 2.0f, mat23_mulf( mat23(vec3(1,2,3),vec3(4,5,6)), 2.0f ) ) );
        TESTFW_EXPECTED( mat22_eq( mat23(vec3(1,2,3),vec3(4,5,6)) * mat32(vec2(7,8),vec2(9,10),vec2(11,12)), mat23_mul_mat32( mat23(vec3(1,2,3),vec3(4,5,6)), mat32(vec2(7,8),vec2(9,10),vec2(11,12)) ) ) );
        TESTFW_EXPECTED( mat23_eq( mat23(vec3(1,2,3),vec3(4,5,6)) * mat33(vec3(7,8,9),vec3(10,11,12),vec3(13,14,15)), mat23_mul_mat33( mat23(vec3(1,2,3),vec3(4,5,6)), mat33(vec3(7,8,9),vec3(10,11,12),vec3(13,14,15)) ) ) );
        TESTFW_EXPECTED( mat24_eq( mat23(vec3(1,2,3),vec3(4,5,6)) * mat34(vec4(7,8,9,10),vec4(11,12,13,14),vec4(15,16,17,18)), mat23_mul_mat34( mat23(vec3(1,2,3),vec3(4,5,6)), mat34(vec4(7,8,9,10),vec4(11,12,13,14),vec4(15,16,17,18)) ) ) );
        TESTFW_EXPECTED( mat24_eq( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) * 2.0f, mat24_mulf( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), 2.0f ) ) );
        TESTFW_EXPECTED( vec2_eq( mat24(vec4(1,2,3,4),vec4(5,6,7,8)) * vec4(9,10,11,12), mat24_mul_vec4( mat24(vec4(1,2,3,4),vec4(5,6,7,8)), vec4(9,10,11,12) ) ) );
        TESTFW_EXPECTED( mat32_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) * 2.0f, mat32_mulf( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), 2.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) * vec2(7,8), mat32_mul_vec2( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), vec2(7,8) ) ) );
        TESTFW_EXPECTED( mat32_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) * mat22(vec2(7,8),vec2(9,10)), mat32_mul_mat22( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat22(vec2(7,8),vec2(9,10)) ) ) );
        TESTFW_EXPECTED( mat33_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) * mat23(vec3(7,8,9),vec3(10,11,12)), mat32_mul_mat23( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat23(vec3(7,8,9),vec3(10,11,12)) ) ) );
        TESTFW_EXPECTED( mat34_eq( mat32(vec2(1,2),vec2(3,4),vec2(5,6)) * mat24(vec4(7,8,9,10),vec4(11,12,13,14)), mat32_mul_mat24( mat32(vec2(1,2),vec2(3,4),vec2(5,6)), mat24(vec4(7,8,9,10),vec4(11,12,13,14)) ) ) );
        TESTFW_EXPECTED( mat33_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) * 2.0f, mat33_mulf( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), 2.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) * vec3(10,11,12), mat33_mul_vec3( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), vec3(10,11,12) ) ) );
        TESTFW_EXPECTED( mat32_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) * mat32(vec2(10,11),vec2(12,13),vec2(14,15)), mat33_mul_mat32( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat32(vec2(10,11),vec2(12,13),vec2(14,15)) ) ) );
        TESTFW_EXPECTED( mat33_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) * mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)), mat33_mul_mat33( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat33(vec3(10,11,12),vec3(13,14,15),vec3(16,17,18)) ) ) );
        TESTFW_EXPECTED( mat34_eq( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)) * mat34(vec4(10,11,12,13),vec4(14,15,16,17),vec4(18,19,20,21)), mat33_mul_mat34( mat33(vec3(1,2,3),vec3(4,5,6),vec3(7,8,9)), mat34(vec4(10,11,12,13),vec4(14,15,16,17),vec4(18,19,20,21)) ) ) );
        TESTFW_EXPECTED( mat34_eq( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) * 2.0f, mat34_mulf( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), 2.0f ) ) );
        TESTFW_EXPECTED( vec3_eq( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)) * vec4(13,14,15,16), mat34_mul_vec4( mat34(vec4(1,2,3,4),vec4(5,6,7,8),vec4(9,10,11,12)), vec4(13,14,15,16) ) ) );

    TESTFW_TEST_END();
}

#endif /* __cplusplus */


#ifdef VECMATH_RUN_D3DX_TESTS

#pragma warning( push )  
    #pragma warning( disable: 4201 ) // nonstandard extension used: nameless struct/union
    #pragma warning( disable: 4255 ) // no function prototype given: converting '()' to '(void)'
    #pragma warning( disable: 4668 ) // not defined as a preprocessor macro, replacing with '0' for '#if/#elif'
    #pragma warning( disable: 4820 ) // '4' bytes padding added after data member
    #pragma warning( disable: 5105 ) // macro expansion producing 'defined' has undefined behavior
    #pragma warning( disable: 5029 ) // nonstandard extension used: alignment attributes in C++ apply to variables, data members and tag types only
    #pragma warning( disable: 5267 ) // definition of implicit assignment operator for 'D3DXFLOAT16' is deprecated because it has a user-provided copy constructor
    #include <d3dx9.h>
    #pragma comment( lib, "d3dx9.lib" )
#pragma warning( pop ) 

void test_d3d_compliance( void ) {

    #define MAT44_APPROX( A, B ) ( \
        vecmath_abs( (A).x.x - (B)._11 ) <= 0.00001f && vecmath_abs( (A).x.y - (B)._12 ) <= 0.00001f && vecmath_abs( (A).x.z - (B)._13 ) <= 0.00001f && vecmath_abs( (A).x.w - (B)._14 ) <= 0.00001f && \
        vecmath_abs( (A).y.x - (B)._21 ) <= 0.00001f && vecmath_abs( (A).y.y - (B)._22 ) <= 0.00001f && vecmath_abs( (A).y.z - (B)._23 ) <= 0.00001f && vecmath_abs( (A).y.w - (B)._24 ) <= 0.00001f && \
        vecmath_abs( (A).z.x - (B)._31 ) <= 0.00001f && vecmath_abs( (A).z.y - (B)._32 ) <= 0.00001f && vecmath_abs( (A).z.z - (B)._33 ) <= 0.00001f && vecmath_abs( (A).z.w - (B)._34 ) <= 0.00001f && \
        vecmath_abs( (A).w.x - (B)._41 ) <= 0.00001f && vecmath_abs( (A).w.y - (B)._42 ) <= 0.00001f && vecmath_abs( (A).w.z - (B)._43 ) <= 0.00001f && vecmath_abs( (A).w.w - (B)._44 ) <= 0.00001f )

    #define VEC2_APPROX( A, B ) ( vecmath_abs( (A).x - (B).x ) < 0.00001f && vecmath_abs( (A).y - (B).y ) < 0.00001f )

    #define VEC3_APPROX( A, B ) ( vecmath_abs( (A).x - (B).x ) < 0.00001f && vecmath_abs( (A).y - (B).y ) < 0.00001f && vecmath_abs( (A).z - (B).z ) < 0.00001f )

    #define VEC4_APPROX( A, B ) ( vecmath_abs( (A).x - (B).x ) < 0.00001f && vecmath_abs( (A).y - (B).y ) < 0.00001f && vecmath_abs( (A).z - (B).z ) < 0.00001f && vecmath_abs( (A).w - (B).w ) < 0.00001f )

    #define QUAT_APPROX( A, B ) ( \
        ( vecmath_abs( (A).x - (B).x ) < 0.00001f && vecmath_abs( (A).y - (B).y ) < 0.00001f && vecmath_abs( (A).z - (B).z ) < 0.00001f && vecmath_abs( (A).w - (B).w ) < 0.00001f ) || \
        ( vecmath_abs( (A).x + (B).x ) < 0.00001f && vecmath_abs( (A).y + (B).y ) < 0.00001f && vecmath_abs( (A).z + (B).z ) < 0.00001f && vecmath_abs( (A).w + (B).w ) < 0.00001f ) )

    //mat44_look_at_lh
    TESTFW_TEST_BEGIN( "mat44_look_at_lh matches D3DXMatrixLookAtLH" )
        vec3_t eye = vec3( 1, 2, -5 );
        vec3_t at = vec3( 0, 0, 0 );
        vec3_t up = vec3( 0, 1, 0 );
        mat44_t m = mat44_look_at_lh( eye, at, up );
        D3DXMATRIX d3d; D3DXMatrixLookAtLH( &d3d, (D3DXVECTOR3*)&eye, (D3DXVECTOR3*)&at, (D3DXVECTOR3*)&up );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_lh matches D3DXMatrixLookAtLH for downward view" )
        vec3_t eye = vec3( 0, 10, 0 );
        vec3_t at = vec3( 0, 0, 0 );
        vec3_t up = vec3( 0, 0, -1 );
        mat44_t m = mat44_look_at_lh( eye, at, up );
        D3DXMATRIX d3d; D3DXMatrixLookAtLH( &d3d, (D3DXVECTOR3*)&eye, (D3DXVECTOR3*)&at, (D3DXVECTOR3*)&up );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_lh matches D3DXMatrixLookAtLH for diagonal view" )
        vec3_t eye = vec3( -2, 3, 1 );
        vec3_t at = vec3( 5, -1, 2 );
        vec3_t up = vec3( 0, 1, 0 );
        mat44_t m = mat44_look_at_lh( eye, at, up );
        D3DXMATRIX d3d; D3DXMatrixLookAtLH( &d3d, (D3DXVECTOR3*)&eye, (D3DXVECTOR3*)&at, (D3DXVECTOR3*)&up );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    // mat44_look_at_rh
    TESTFW_TEST_BEGIN( "mat44_look_at_rh matches D3DXMatrixLookAtRH" )
        vec3_t eye = vec3( 1, 2, -5 );
        vec3_t at = vec3( 0, 0, 0 );
        vec3_t up = vec3( 0, 1, 0 );
        mat44_t m = mat44_look_at_rh( eye, at, up );
        D3DXMATRIX d3d; D3DXMatrixLookAtRH( &d3d, (D3DXVECTOR3*)&eye, (D3DXVECTOR3*)&at, (D3DXVECTOR3*)&up );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_rh matches D3DXMatrixLookAtRH for downward view" )
        vec3_t eye = vec3( 0, 10, 0 );
        vec3_t at = vec3( 0, 0, 0 );
        vec3_t up = vec3( 0, 0, -1 );
        mat44_t m = mat44_look_at_rh( eye, at, up );
        D3DXMATRIX d3d; D3DXMatrixLookAtRH( &d3d, (D3DXVECTOR3*)&eye, (D3DXVECTOR3*)&at, (D3DXVECTOR3*)&up );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_look_at_rh matches D3DXMatrixLookAtRH for diagonal view" )
        vec3_t eye = vec3( -2, 3, 1 );
        vec3_t at = vec3( 5, -1, 2 );
        vec3_t up = vec3( 0, 1, 0 );
        mat44_t m = mat44_look_at_rh( eye, at, up );
        D3DXMATRIX d3d; D3DXMatrixLookAtRH( &d3d, (D3DXVECTOR3*)&eye, (D3DXVECTOR3*)&at, (D3DXVECTOR3*)&up );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    // mat44_ortho_lh
    TESTFW_TEST_BEGIN( "mat44_ortho_lh matches D3DXMatrixOrthoLH" )
        mat44_t m = mat44_ortho_lh( 4.0f, 3.0f, 0.1f, 100.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoLH( &d3d, 4.0f, 3.0f, 0.1f, 100.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_lh matches D3DXMatrixOrthoLH for wide view" )
        mat44_t m = mat44_ortho_lh( 16.0f, 9.0f, 1.0f, 1000.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoLH( &d3d, 16.0f, 9.0f, 1.0f, 1000.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_lh matches D3DXMatrixOrthoLH for near-zero zn" )
        mat44_t m = mat44_ortho_lh( 2.0f, 2.0f, 0.001f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoLH( &d3d, 2.0f, 2.0f, 0.001f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    // mat44_ortho_rh
    TESTFW_TEST_BEGIN( "mat44_ortho_rh matches D3DXMatrixOrthoRH" )
        mat44_t m = mat44_ortho_rh( 4.0f, 3.0f, 0.1f, 100.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoRH( &d3d, 4.0f, 3.0f, 0.1f, 100.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_rh matches D3DXMatrixOrthoRH for wide view" )
        mat44_t m = mat44_ortho_rh( 16.0f, 9.0f, 1.0f, 1000.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoRH( &d3d, 16.0f, 9.0f, 1.0f, 1000.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_rh matches D3DXMatrixOrthoRH for near-zero zn" )
        mat44_t m = mat44_ortho_rh( 2.0f, 2.0f, 0.001f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoRH( &d3d, 2.0f, 2.0f, 0.001f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    // mat44_ortho_off_center_lh
    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_lh matches D3DXMatrixOrthoOffCenterLH" )
        mat44_t m = mat44_ortho_off_center_lh( -2.0f, 2.0f, -1.5f, 1.5f, 0.1f, 100.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoOffCenterLH( &d3d, -2.0f, 2.0f, -1.5f, 1.5f, 0.1f, 100.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_lh matches D3DXMatrixOrthoOffCenterLH for asymmetric bounds" )
        mat44_t m = mat44_ortho_off_center_lh( 0.0f, 4.0f, -3.0f, 1.0f, 1.0f, 1000.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoOffCenterLH( &d3d, 0.0f, 4.0f, -3.0f, 1.0f, 1.0f, 1000.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_lh matches D3DXMatrixOrthoOffCenterLH for small near range" )
        mat44_t m = mat44_ortho_off_center_lh( -1.0f, 1.0f, -1.0f, 1.0f, 0.001f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoOffCenterLH( &d3d, -1.0f, 1.0f, -1.0f, 1.0f, 0.001f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_ortho_off_center_rh
    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_rh matches D3DXMatrixOrthoOffCenterRH" )
        mat44_t m = mat44_ortho_off_center_rh( -2.0f, 2.0f, -1.5f, 1.5f, 0.1f, 100.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoOffCenterRH( &d3d, -2.0f, 2.0f, -1.5f, 1.5f, 0.1f, 100.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_rh matches D3DXMatrixOrthoOffCenterRH for asymmetric bounds" )
        mat44_t m = mat44_ortho_off_center_rh( 0.0f, 4.0f, -3.0f, 1.0f, 1.0f, 1000.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoOffCenterRH( &d3d, 0.0f, 4.0f, -3.0f, 1.0f, 1.0f, 1000.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_ortho_off_center_rh matches D3DXMatrixOrthoOffCenterRH for small near range" )
        mat44_t m = mat44_ortho_off_center_rh( -1.0f, 1.0f, -1.0f, 1.0f, 0.001f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixOrthoOffCenterRH( &d3d, -1.0f, 1.0f, -1.0f, 1.0f, 0.001f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_perspective_lh
    TESTFW_TEST_BEGIN( "mat44_perspective_lh matches D3DXMatrixPerspectiveLH" )
        mat44_t m = mat44_perspective_lh( 4.0f, 3.0f, 0.1f, 100.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveLH( &d3d, 4.0f, 3.0f, 0.1f, 100.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_lh matches D3DXMatrixPerspectiveLH for wide view" )
        mat44_t m = mat44_perspective_lh( 16.0f, 9.0f, 1.0f, 1000.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveLH( &d3d, 16.0f, 9.0f, 1.0f, 1000.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_lh matches D3DXMatrixPerspectiveLH for small near plane" )
        mat44_t m = mat44_perspective_lh( 2.0f, 2.0f, 0.001f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveLH( &d3d, 2.0f, 2.0f, 0.001f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_perspective_rh
    TESTFW_TEST_BEGIN( "mat44_perspective_rh matches D3DXMatrixPerspectiveRH" )
        mat44_t m = mat44_perspective_rh( 4.0f, 3.0f, 0.1f, 100.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveRH( &d3d, 4.0f, 3.0f, 0.1f, 100.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_rh matches D3DXMatrixPerspectiveRH for wide view" )
        mat44_t m = mat44_perspective_rh( 16.0f, 9.0f, 1.0f, 1000.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveRH( &d3d, 16.0f, 9.0f, 1.0f, 1000.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_rh matches D3DXMatrixPerspectiveRH for small near plane" )
        mat44_t m = mat44_perspective_rh( 2.0f, 2.0f, 0.001f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveRH( &d3d, 2.0f, 2.0f, 0.001f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_perspective_off_center_lh
    TESTFW_TEST_BEGIN( "mat44_perspective_off_center_lh matches D3DXMatrixPerspectiveOffCenterLH" )
        mat44_t m = mat44_perspective_off_center_lh( -2.0f, 2.0f, -1.5f, 1.5f, 0.1f, 100.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveOffCenterLH( &d3d, -2.0f, 2.0f, -1.5f, 1.5f, 0.1f, 100.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_off_center_lh matches D3DXMatrixPerspectiveOffCenterLH for asymmetric bounds" )
        mat44_t m = mat44_perspective_off_center_lh( 0.0f, 4.0f, -3.0f, 1.0f, 1.0f, 1000.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveOffCenterLH( &d3d, 0.0f, 4.0f, -3.0f, 1.0f, 1.0f, 1000.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_off_center_lh matches D3DXMatrixPerspectiveOffCenterLH for small near plane" )
        mat44_t m = mat44_perspective_off_center_lh( -1.0f, 1.0f, -1.0f, 1.0f, 0.001f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveOffCenterLH( &d3d, -1.0f, 1.0f, -1.0f, 1.0f, 0.001f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
        
    // mat44_perspective_off_center_rh
    TESTFW_TEST_BEGIN( "mat44_perspective_off_center_rh matches D3DXMatrixPerspectiveOffCenterRH" )
        mat44_t m = mat44_perspective_off_center_rh( -2.0f, 2.0f, -1.5f, 1.5f, 0.1f, 100.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveOffCenterRH( &d3d, -2.0f, 2.0f, -1.5f, 1.5f, 0.1f, 100.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_off_center_rh matches D3DXMatrixPerspectiveOffCenterRH for asymmetric bounds" )
        mat44_t m = mat44_perspective_off_center_rh( 0.0f, 4.0f, -3.0f, 1.0f, 1.0f, 1000.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveOffCenterRH( &d3d, 0.0f, 4.0f, -3.0f, 1.0f, 1.0f, 1000.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_off_center_rh matches D3DXMatrixPerspectiveOffCenterRH for small near plane" )
        mat44_t m = mat44_perspective_off_center_rh( -1.0f, 1.0f, -1.0f, 1.0f, 0.001f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveOffCenterRH( &d3d, -1.0f, 1.0f, -1.0f, 1.0f, 0.001f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_perspective_fov_lh
    TESTFW_TEST_BEGIN( "mat44_perspective_fov_lh matches D3DXMatrixPerspectiveFovLH" )
        mat44_t m = mat44_perspective_fov_lh( 1.0472f, 4.0f / 3.0f, 0.1f, 100.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveFovLH( &d3d, 1.0472f, 4.0f / 3.0f, 0.1f, 100.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_fov_lh matches D3DXMatrixPerspectiveFovLH for wide aspect" )
        mat44_t m = mat44_perspective_fov_lh( 0.7854f, 16.0f / 9.0f, 1.0f, 1000.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveFovLH( &d3d, 0.7854f, 16.0f / 9.0f, 1.0f, 1000.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_fov_lh matches D3DXMatrixPerspectiveFovLH for narrow fov" )
        mat44_t m = mat44_perspective_fov_lh( 0.3491f, 1.0f, 0.001f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveFovLH( &d3d, 0.3491f, 1.0f, 0.001f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_perspective_fov_rh
    TESTFW_TEST_BEGIN( "mat44_perspective_fov_rh matches D3DXMatrixPerspectiveFovRH" )
        mat44_t m = mat44_perspective_fov_rh( 1.0472f, 4.0f / 3.0f, 0.1f, 100.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveFovRH( &d3d, 1.0472f, 4.0f / 3.0f, 0.1f, 100.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_fov_rh matches D3DXMatrixPerspectiveFovRH for wide aspect" )
        mat44_t m = mat44_perspective_fov_rh( 0.7854f, 16.0f / 9.0f, 1.0f, 1000.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveFovRH( &d3d, 0.7854f, 16.0f / 9.0f, 1.0f, 1000.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_perspective_fov_rh matches D3DXMatrixPerspectiveFovRH for narrow fov" )
        mat44_t m = mat44_perspective_fov_rh( 0.3491f, 1.0f, 0.001f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixPerspectiveFovRH( &d3d, 0.3491f, 1.0f, 0.001f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_rotation_axis
    TESTFW_TEST_BEGIN( "mat44_rotation_axis matches D3DXMatrixRotationAxis for x-axis" )
        vec3_t axis = vec3( 1, 0, 0 );
        mat44_t m = mat44_rotation_axis( axis, 1.5708f );
        D3DXMATRIX d3d; D3DXMatrixRotationAxis( &d3d, (D3DXVECTOR3*)&axis, 1.5708f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_axis matches D3DXMatrixRotationAxis for y-axis" )
        vec3_t axis = vec3( 0, 1, 0 );
        mat44_t m = mat44_rotation_axis( axis, 3.1416f );
        D3DXMATRIX d3d; D3DXMatrixRotationAxis( &d3d, (D3DXVECTOR3*)&axis, 3.1416f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_axis matches D3DXMatrixRotationAxis for diagonal axis" )
        vec3_t axis = vec3( 1, 1, 1 );
        mat44_t m = mat44_rotation_axis( axis, 0.7854f );
        D3DXMATRIX d3d; D3DXMatrixRotationAxis( &d3d, (D3DXVECTOR3*)&axis, 0.7854f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    TESTFW_TEST_BEGIN( "mat44_rotation_axis matches D3DXMatrixRotationAxis for arbitrary axis" )
        vec3_t axis = vec3( -2.0f, 5.5f, 1.25f );
        mat44_t m = mat44_rotation_axis( axis, 0.7854f );
        D3DXMATRIX d3d; D3DXMatrixRotationAxis( &d3d, (D3DXVECTOR3*)&axis, 0.7854f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    // mat44_rotation_x
    TESTFW_TEST_BEGIN( "mat44_rotation_x matches D3DXMatrixRotationX for 90 degrees" )
        mat44_t m = mat44_rotation_x( 1.5708f );
        D3DXMATRIX d3d; D3DXMatrixRotationX( &d3d, 1.5708f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_x matches D3DXMatrixRotationX for 180 degrees" )
        mat44_t m = mat44_rotation_x( 3.1416f );
        D3DXMATRIX d3d; D3DXMatrixRotationX( &d3d, 3.1416f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_x matches D3DXMatrixRotationX for small angle" )
        mat44_t m = mat44_rotation_x( 0.1f );
        D3DXMATRIX d3d; D3DXMatrixRotationX( &d3d, 0.1f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_rotation_y
    TESTFW_TEST_BEGIN( "mat44_rotation_y matches D3DXMatrixRotationY for 90 degrees" )
        mat44_t m = mat44_rotation_y( 1.5708f );
        D3DXMATRIX d3d; D3DXMatrixRotationY( &d3d, 1.5708f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_y matches D3DXMatrixRotationY for 180 degrees" )
        mat44_t m = mat44_rotation_y( 3.1416f );
        D3DXMATRIX d3d; D3DXMatrixRotationY( &d3d, 3.1416f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_y matches D3DXMatrixRotationY for small angle" )
        mat44_t m = mat44_rotation_y( 0.1f );
        D3DXMATRIX d3d; D3DXMatrixRotationY( &d3d, 0.1f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_rotation_z
    TESTFW_TEST_BEGIN( "mat44_rotation_z matches D3DXMatrixRotationZ for 90 degrees" )
        mat44_t m = mat44_rotation_z( 1.5708f );
        D3DXMATRIX d3d; D3DXMatrixRotationZ( &d3d, 1.5708f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_z matches D3DXMatrixRotationZ for 180 degrees" )
        mat44_t m = mat44_rotation_z( 3.1416f );
        D3DXMATRIX d3d; D3DXMatrixRotationZ( &d3d, 3.1416f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_z matches D3DXMatrixRotationZ for small angle" )
        mat44_t m = mat44_rotation_z( 0.1f );
        D3DXMATRIX d3d; D3DXMatrixRotationZ( &d3d, 0.1f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_rotation_yaw_pitch_roll
    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll matches D3DXMatrixRotationYawPitchRoll for yaw only" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 1.5708f, 0.0f, 0.0f );
        D3DXMATRIX d3d; D3DXMatrixRotationYawPitchRoll( &d3d, 1.5708f, 0.0f, 0.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll matches D3DXMatrixRotationYawPitchRoll for pitch only" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 0.0f, 1.5708f, 0.0f );
        D3DXMATRIX d3d; D3DXMatrixRotationYawPitchRoll( &d3d, 0.0f, 1.5708f, 0.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll matches D3DXMatrixRotationYawPitchRoll for roll only" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 0.0f, 0.0f, 1.5708f );
        D3DXMATRIX d3d; D3DXMatrixRotationYawPitchRoll( &d3d, 0.0f, 0.0f, 1.5708f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll matches D3DXMatrixRotationYawPitchRoll for yaw + pitch" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 1.0f, 0.5f, 0.0f );
        D3DXMATRIX d3d; D3DXMatrixRotationYawPitchRoll( &d3d, 1.0f, 0.5f, 0.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll matches D3DXMatrixRotationYawPitchRoll for yaw + roll" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 0.5f, 0.0f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixRotationYawPitchRoll( &d3d, 0.5f, 0.0f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll matches D3DXMatrixRotationYawPitchRoll for pitch + roll" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 0.0f, -1.0f, 1.0f );
        D3DXMATRIX d3d; D3DXMatrixRotationYawPitchRoll( &d3d, 0.0f, -1.0f, 1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll matches D3DXMatrixRotationYawPitchRoll for all angles" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 0.5f, 1.0f, -0.75f );
        D3DXMATRIX d3d; D3DXMatrixRotationYawPitchRoll( &d3d, 0.5f, 1.0f, -0.75f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll matches D3DXMatrixRotationYawPitchRoll for large angles" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 6.2832f, 3.1416f, -3.1416f );
        D3DXMATRIX d3d; D3DXMatrixRotationYawPitchRoll( &d3d, 6.2832f, 3.1416f, -3.1416f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_rotation_yaw_pitch_roll matches D3DXMatrixRotationYawPitchRoll for small angles" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 0.001f, -0.002f, 0.0005f );
        D3DXMATRIX d3d; D3DXMatrixRotationYawPitchRoll( &d3d, 0.001f, -0.002f, 0.0005f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_scaling
    TESTFW_TEST_BEGIN( "mat44_scaling matches D3DXMatrixScaling for uniform scale" )
        mat44_t m = mat44_scaling( 2.0f, 2.0f, 2.0f );
        D3DXMATRIX d3d; D3DXMatrixScaling( &d3d, 2.0f, 2.0f, 2.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_scaling matches D3DXMatrixScaling for non-uniform scale" )
        mat44_t m = mat44_scaling( 1.0f, 2.0f, 3.0f );
        D3DXMATRIX d3d; D3DXMatrixScaling( &d3d, 1.0f, 2.0f, 3.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_scaling matches D3DXMatrixScaling for negative scale" )
        mat44_t m = mat44_scaling( -1.0f, 1.0f, -1.0f );
        D3DXMATRIX d3d; D3DXMatrixScaling( &d3d, -1.0f, 1.0f, -1.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_translation
    TESTFW_TEST_BEGIN( "mat44_translation matches D3DXMatrixTranslation for positive offset" )
        mat44_t m = mat44_translation( 1.0f, 2.0f, 3.0f );
        D3DXMATRIX d3d; D3DXMatrixTranslation( &d3d, 1.0f, 2.0f, 3.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_translation matches D3DXMatrixTranslation for negative offset" )
        mat44_t m = mat44_translation( -4.0f, 0.0f, 7.5f );
        D3DXMATRIX d3d; D3DXMatrixTranslation( &d3d, -4.0f, 0.0f, 7.5f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_translation matches D3DXMatrixTranslation for zero offset" )
        mat44_t m = mat44_translation( 0.0f, 0.0f, 0.0f );
        D3DXMATRIX d3d; D3DXMatrixTranslation( &d3d, 0.0f, 0.0f, 0.0f );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // mat44_decompose
    TESTFW_TEST_BEGIN( "mat44_decompose matches D3DXMatrixDecompose for identity matrix" )
        vec3_t s; vec4_t q; vec3_t t;
        mat44_t m = mat44_identity();
        D3DXVECTOR3 ds, dt; D3DXQUATERNION dq;
        int d3dok = D3DXMatrixDecompose( &ds, &dq, &dt, (D3DXMATRIX*)&m );
        int ok = mat44_decompose( &s, &q, &t, m );
        TESTFW_EXPECTED( ok == ( d3dok == S_OK ) );
        if( ok ) { TESTFW_EXPECTED( VEC3_APPROX( s, ds ) ); TESTFW_EXPECTED( QUAT_APPROX( q, dq ) ); TESTFW_EXPECTED( VEC3_APPROX( t, dt ) ); }
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_decompose matches D3DXMatrixDecompose for translation only" )
        vec3_t s; vec4_t q; vec3_t t;
        mat44_t m = mat44_translation( 3.0f, -2.0f, 7.0f );
        D3DXVECTOR3 ds, dt; D3DXQUATERNION dq;
        int d3dok = D3DXMatrixDecompose( &ds, &dq, &dt, (D3DXMATRIX*)&m );
        int ok = mat44_decompose( &s, &q, &t, m );
        TESTFW_EXPECTED( ok == ( d3dok == S_OK ) );
        if( ok ) { TESTFW_EXPECTED( VEC3_APPROX( s, ds ) ); TESTFW_EXPECTED( QUAT_APPROX( q, dq ) ); TESTFW_EXPECTED( VEC3_APPROX( t, dt ) ); }
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_decompose matches D3DXMatrixDecompose for uniform scale" )
        vec3_t s; vec4_t q; vec3_t t;
        mat44_t m = mat44_scaling( 2.0f, 2.0f, 2.0f );
        D3DXVECTOR3 ds, dt; D3DXQUATERNION dq;
        int d3dok = D3DXMatrixDecompose( &ds, &dq, &dt, (D3DXMATRIX*)&m );
        int ok = mat44_decompose( &s, &q, &t, m );
        TESTFW_EXPECTED( ok == ( d3dok == S_OK ) );
        if( ok ) { TESTFW_EXPECTED( VEC3_APPROX( s, ds ) ); TESTFW_EXPECTED( QUAT_APPROX( q, dq ) ); TESTFW_EXPECTED( VEC3_APPROX( t, dt ) ); }
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_decompose matches D3DXMatrixDecompose for non-uniform scale" )
        vec3_t s; vec4_t q; vec3_t t;
        mat44_t m = mat44_scaling( 1.0f, 2.0f, -3.0f );
        D3DXVECTOR3 ds, dt; D3DXQUATERNION dq;
        int d3dok = D3DXMatrixDecompose( &ds, &dq, &dt, (D3DXMATRIX*)&m );
        int ok = mat44_decompose( &s, &q, &t, m );
        TESTFW_EXPECTED( ok == ( d3dok == S_OK ) );
        if( ok ) { TESTFW_EXPECTED( VEC3_APPROX( s, ds ) ); TESTFW_EXPECTED( QUAT_APPROX( q, dq ) ); TESTFW_EXPECTED( VEC3_APPROX( t, dt ) ); }
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_decompose matches D3DXMatrixDecompose for rotation only" )
        vec3_t s; vec4_t q; vec3_t t;
        mat44_t m = mat44_rotation_axis( vec3( 1, 2, 3 ), 0.75f );
        D3DXVECTOR3 ds, dt; D3DXQUATERNION dq;
        int d3dok = D3DXMatrixDecompose( &ds, &dq, &dt, (D3DXMATRIX*)&m );
        int ok = mat44_decompose( &s, &q, &t, m );
        TESTFW_EXPECTED( ok == ( d3dok == S_OK ) );
        if( ok ) { TESTFW_EXPECTED( VEC3_APPROX( s, ds ) ); TESTFW_EXPECTED( QUAT_APPROX( q, dq ) ); TESTFW_EXPECTED( VEC3_APPROX( t, dt ) ); }
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_decompose matches D3DXMatrixDecompose for full TRS matrix" )
        vec3_t s; vec4_t q; vec3_t t;
        mat44_t r = mat44_rotation_yaw_pitch_roll( 0.3f, 1.0f, -0.8f );
        mat44_t sc = mat44_scaling( 2.0f, 3.0f, 4.0f );
        mat44_t tr = mat44_translation( 10.0f, -2.0f, 0.5f );
        mat44_t m = mat44_mul_mat44( tr, mat44_mul_mat44( r, sc ) );
        D3DXVECTOR3 ds, dt; D3DXQUATERNION dq;
        int d3dok = D3DXMatrixDecompose( &ds, &dq, &dt, (D3DXMATRIX*)&m );
        int ok = mat44_decompose( &s, &q, &t, m );
        TESTFW_EXPECTED( ok == ( d3dok == S_OK ) );
        if( ok ) { TESTFW_EXPECTED( VEC3_APPROX( s, ds ) ); TESTFW_EXPECTED( QUAT_APPROX( q, dq ) ); TESTFW_EXPECTED( VEC3_APPROX( t, dt ) ); }
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_decompose matches D3DXMatrixDecompose for matrix with shear" )
        vec3_t s; vec4_t q; vec3_t t;
        mat44_t m = mat44_identity(); m.x.y = 1.0f;
        D3DXVECTOR3 ds, dt; D3DXQUATERNION dq;
        int d3dok = D3DXMatrixDecompose( &ds, &dq, &dt, (D3DXMATRIX*)&m );
        int ok = mat44_decompose( &s, &q, &t, m );
        TESTFW_EXPECTED( ok == ( d3dok == S_OK ) );
        if( ok ) { TESTFW_EXPECTED( VEC3_APPROX( s, ds ) ); TESTFW_EXPECTED( QUAT_APPROX( q, dq ) ); TESTFW_EXPECTED( VEC3_APPROX( t, dt ) ); }
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_decompose matches D3DXMatrixDecompose for projection matrix" )
        vec3_t s; vec4_t q; vec3_t t;
        mat44_t m = mat44_perspective_fov_lh( 1.0f, 1.0f, 0.1f, 100.0f );
        D3DXVECTOR3 ds, dt; D3DXQUATERNION dq;
        int d3dok = D3DXMatrixDecompose( &ds, &dq, &dt, (D3DXMATRIX*)&m );
        int ok = mat44_decompose( &s, &q, &t, m );
        TESTFW_EXPECTED( ok == ( d3dok == S_OK ) );
        if( ok ) { TESTFW_EXPECTED( VEC3_APPROX( s, ds ) ); TESTFW_EXPECTED( QUAT_APPROX( q, dq ) ); TESTFW_EXPECTED( VEC3_APPROX( t, dt ) ); }
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_decompose matches D3DXMatrixDecompose for zero matrix" )
        vec3_t s; vec4_t q; vec3_t t;
        mat44_t m = mat44_scaling( 0.0f, 0.0f, 0.0f );
        D3DXVECTOR3 ds, dt; D3DXQUATERNION dq;
        int d3dok = D3DXMatrixDecompose( &ds, &dq, &dt, (D3DXMATRIX*)&m );
        int ok = mat44_decompose( &s, &q, &t, m );
        TESTFW_EXPECTED( ok == ( d3dok == S_OK ) );
        if( ok ) { TESTFW_EXPECTED( VEC3_APPROX( s, ds ) ); TESTFW_EXPECTED( QUAT_APPROX( q, dq ) ); TESTFW_EXPECTED( VEC3_APPROX( t, dt ) ); }
    TESTFW_TEST_END();

    // quat_slerp
    TESTFW_TEST_BEGIN( "quat_slerp matches D3DXQuaternionSlerp at t = 0.5" )
        vec4_t a = vec4( 0.0f, 0.0f, 0.0f, 1.0f );
        vec4_t b = vec4( 0.7071f, 0.0f, 0.0f, 0.7071f );
        vec4_t r = quat_slerp( a, b, 0.5f );
        D3DXQUATERNION d3dr; D3DXQuaternionSlerp( &d3dr, (D3DXQUATERNION*)&a, (D3DXQUATERNION*)&b, 0.5f );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_slerp matches D3DXQuaternionSlerp for opposite sign" )
        vec4_t a = vec4( 0.0f, 0.0f, 0.0f, 1.0f );
        vec4_t b = vec4( -0.7071f, 0.0f, 0.0f, -0.7071f );
        vec4_t r = quat_slerp( a, b, 0.5f );
        D3DXQUATERNION d3dr; D3DXQuaternionSlerp( &d3dr, (D3DXQUATERNION*)&a, (D3DXQUATERNION*)&b, 0.5f );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_slerp matches D3DXQuaternionSlerp for near-equal input" )
        vec4_t a = vec4( 0.001f, 0.0f, 0.0f, 1.0f );
        vec4_t b = vec4( 0.002f, 0.0f, 0.0f, 1.0f );
        vec4_t r = quat_slerp( a, b, 0.5f );
        D3DXQUATERNION d3dr; D3DXQuaternionSlerp( &d3dr, (D3DXQUATERNION*)&a, (D3DXQUATERNION*)&b, 0.5f );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();
    
    // quat_barycentric
    TESTFW_TEST_BEGIN( "quat_barycentric matches D3DXQuaternionBaryCentric at midpoint (f = 0.5, g = 0.0)" )
        vec4_t q1 = vec4( 0.0f, 0.0f, 0.0f, 1.0f );
        vec4_t q2 = vec4( 0.7071f, 0.0f, 0.0f, 0.7071f );
        vec4_t q3 = vec4( 0.0f, 0.7071f, 0.0f, 0.7071f );
        vec4_t r = quat_barycentric( q1, q2, q3, 0.5f, 0.0f );
        D3DXQUATERNION d3dr; D3DXQuaternionBaryCentric( &d3dr, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&q2, (D3DXQUATERNION*)&q3, 0.5f, 0.0f );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_barycentric matches D3DXQuaternionBaryCentric at triangle center (f = g = 1/3)" )
        vec4_t q1 = vec4( 0.0f, 0.0f, 0.0f, 1.0f );
        vec4_t q2 = vec4( 0.7071f, 0.0f, 0.0f, 0.7071f );
        vec4_t q3 = vec4( 0.0f, 0.7071f, 0.0f, 0.7071f );
        vec4_t r = quat_barycentric( q1, q2, q3, 1.0f / 3.0f, 1.0f / 3.0f );
        D3DXQUATERNION d3dr; D3DXQuaternionBaryCentric( &d3dr, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&q2, (D3DXQUATERNION*)&q3, 1.0f / 3.0f, 1.0f / 3.0f );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_barycentric matches D3DXQuaternionBaryCentric at extreme weight (f = 1.0, g = 0.0)" )
        vec4_t q1 = vec4( 0.0f, 0.0f, 0.0f, 1.0f );
        vec4_t q2 = vec4( 0.7071f, 0.0f, 0.0f, 0.7071f );
        vec4_t q3 = vec4( 0.0f, 0.7071f, 0.0f, 0.7071f );
        vec4_t r = quat_barycentric( q1, q2, q3, 1.0f, 0.0f );
        D3DXQUATERNION d3dr; D3DXQuaternionBaryCentric( &d3dr, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&q2, (D3DXQUATERNION*)&q3, 1.0f, 0.0f );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();
    
    // quat_conjugate
    TESTFW_TEST_BEGIN( "quat_conjugate matches D3DXQuaternionConjugate for positive quaternion" )
        vec4_t q = vec4( 0.3f, 0.4f, 0.5f, 0.6f );
        vec4_t r = quat_conjugate( q );
        D3DXQUATERNION d3dr; D3DXQuaternionConjugate( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_conjugate matches D3DXQuaternionConjugate for negative quaternion" )
        vec4_t q = vec4( -0.1f, -0.2f, -0.3f, -0.4f );
        vec4_t r = quat_conjugate( q );
        D3DXQUATERNION d3dr; D3DXQuaternionConjugate( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_conjugate matches D3DXQuaternionConjugate for zero vector quaternion" )
        vec4_t q = vec4( 0.0f, 0.0f, 0.0f, 1.0f );
        vec4_t r = quat_conjugate( q );
        D3DXQUATERNION d3dr; D3DXQuaternionConjugate( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();
    
    // quat_exp
    TESTFW_TEST_BEGIN( "quat_exp matches D3DXQuaternionExp for unit imaginary quaternion" )
        vec4_t q = vec4( 1.0f, 0.0f, 0.0f, 0.0f );
        vec4_t r = quat_exp( q );
        D3DXQUATERNION d3dr; D3DXQuaternionExp( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_exp matches D3DXQuaternionExp for general quaternion" )
        vec4_t q = vec4( 0.5f, -0.3f, 0.8f, 1.0f );
        vec4_t r = quat_exp( q );
        D3DXQUATERNION d3dr; D3DXQuaternionExp( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_exp matches D3DXQuaternionExp for zero quaternion" )
        vec4_t q = vec4( 0.0f, 0.0f, 0.0f, 0.0f );
        vec4_t r = quat_exp( q );
        D3DXQUATERNION d3dr; D3DXQuaternionExp( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();
    
    // quat_identity
    TESTFW_TEST_BEGIN( "quat_identity matches D3DXQuaternionIdentity" )
        vec4_t q = quat_identity();
        D3DXQUATERNION d3dq; D3DXQuaternionIdentity( &d3dq );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();
    
    // quat_inverse
    TESTFW_TEST_BEGIN( "quat_inverse matches D3DXQuaternionInverse for unit quaternion" )
        vec4_t q = vec4( 0.0f, 0.0f, 0.7071f, 0.7071f );
        vec4_t r = quat_inverse( q );
        D3DXQUATERNION d3dr; D3DXQuaternionInverse( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_inverse matches D3DXQuaternionInverse for normalized nontrivial quaternion" )
        vec4_t q = vec4( 0.3f, -0.4f, 0.1f, 0.85f );
        q = vec4_normalize( q );
        vec4_t r = quat_inverse( q );
        D3DXQUATERNION d3dr; D3DXQuaternionInverse( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_inverse matches D3DXQuaternionInverse for unnormalized quaternion" )
        vec4_t q = vec4( 1.0f, 2.0f, 3.0f, 4.0f );
        vec4_t r = quat_inverse( q );
        D3DXQUATERNION d3dr; D3DXQuaternionInverse( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();
    
    // quat_ln
    TESTFW_TEST_BEGIN( "quat_ln matches D3DXQuaternionLn for 90-degree x-rotation" )
        vec4_t q = vec4( 0.7071f, 0.0f, 0.0f, 0.7071f );
        vec4_t r = quat_ln( q );
        D3DXQUATERNION d3dr; D3DXQuaternionLn( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_ln matches D3DXQuaternionLn for 180-degree y-rotation" )
        vec4_t q = vec4( 0.0f, 1.0f, 0.0f, 0.0f );
        vec4_t r = quat_ln( q );
        D3DXQUATERNION d3dr; D3DXQuaternionLn( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_ln matches D3DXQuaternionLn for identity quaternion" )
        vec4_t q = vec4( 0.0f, 0.0f, 0.0f, 1.0f );
        vec4_t r = quat_ln( q );
        D3DXQUATERNION d3dr; D3DXQuaternionLn( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();
    
    // quat_mul
    TESTFW_TEST_BEGIN( "quat_mul matches D3DXQuaternionMultiply for identity * identity" )
        vec4_t a = vec4( 0, 0, 0, 1 );
        vec4_t b = vec4( 0, 0, 0, 1 );
        vec4_t r = quat_mul( a, b );
        D3DXQUATERNION d3dr; D3DXQuaternionMultiply( &d3dr, (D3DXQUATERNION*)&a, (D3DXQUATERNION*)&b );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_mul matches D3DXQuaternionMultiply for simple x * y rotation" )
        vec4_t a = vec4( 0.7071f, 0, 0, 0.7071f );
        vec4_t b = vec4( 0, 0.7071f, 0, 0.7071f );
        vec4_t r = quat_mul( a, b );
        D3DXQUATERNION d3dr; D3DXQuaternionMultiply( &d3dr, (D3DXQUATERNION*)&a, (D3DXQUATERNION*)&b );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_mul matches D3DXQuaternionMultiply for two negative quaternions" )
        vec4_t a = vec4( -0.5f, -0.5f, -0.5f, -0.5f );
        vec4_t b = vec4( -0.5f, 0.5f, -0.5f, 0.5f );
        vec4_t r = quat_mul( a, b );
        D3DXQUATERNION d3dr; D3DXQuaternionMultiply( &d3dr, (D3DXQUATERNION*)&a, (D3DXQUATERNION*)&b );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_mul matches D3DXQuaternionMultiply for arbitrary input" )
        vec4_t a = vec4( 0.1f, -0.6f, 0.3f, 0.7f );
        vec4_t b = vec4( -0.2f, 0.5f, 0.4f, -0.6f );
        vec4_t r = quat_mul( a, b );
        D3DXQUATERNION d3dr; D3DXQuaternionMultiply( &d3dr, (D3DXQUATERNION*)&a, (D3DXQUATERNION*)&b );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();
    
    // quat_rotation_axis
    TESTFW_TEST_BEGIN( "quat_rotation_axis matches D3DXQuaternionRotationAxis for 90-degree x-rotation" )
        vec3_t axis = vec3( 1, 0, 0 );
        float angle = 1.5708f;
        vec4_t q = quat_rotation_axis( axis, angle );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationAxis( &d3dq, (D3DXVECTOR3*)&axis, angle );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_axis matches D3DXQuaternionRotationAxis for 180-degree y-rotation" )
        vec3_t axis = vec3( 0, 1, 0 );
        float angle = 3.1416f;
        vec4_t q = quat_rotation_axis( axis, angle );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationAxis( &d3dq, (D3DXVECTOR3*)&axis, angle );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_axis matches D3DXQuaternionRotationAxis for diagonal axis" )
        vec3_t axis = vec3( 1, 1, 1 );
        float angle = 0.7854f;
        vec4_t q = quat_rotation_axis( axis, angle );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationAxis( &d3dq, (D3DXVECTOR3*)&axis, angle );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_axis matches D3DXQuaternionRotationAxis for arbitrary axis" )
        vec3_t axis = vec3( -2.0f, 5.5f, 1.25f );
        float angle = 0.75f;
        vec4_t q = quat_rotation_axis( axis, angle );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationAxis( &d3dq, (D3DXVECTOR3*)&axis, angle );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();
    
    // quat_rotation_matrix
    TESTFW_TEST_BEGIN( "quat_rotation_matrix matches D3DXQuaternionRotationMatrix for identity matrix" )
        mat44_t m = mat44_identity();
        vec4_t q = quat_rotation_matrix( m );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationMatrix( &d3dq, (D3DXMATRIX*)&m );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_matrix matches D3DXQuaternionRotationMatrix for 90-degree x-rotation" )
        mat44_t m = mat44_rotation_x( 1.5708f );
        vec4_t q = quat_rotation_matrix( m );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationMatrix( &d3dq, (D3DXMATRIX*)&m );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_matrix matches D3DXQuaternionRotationMatrix for 180-degree y-rotation" )
        mat44_t m = mat44_rotation_y( 3.1416f );
        vec4_t q = quat_rotation_matrix( m );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationMatrix( &d3dq, (D3DXMATRIX*)&m );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_matrix matches D3DXQuaternionRotationMatrix for roll-pitch-yaw rotation" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 0.5f, 1.0f, -0.75f );
        vec4_t q = quat_rotation_matrix( m );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationMatrix( &d3dq, (D3DXMATRIX*)&m );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_matrix matches D3DXQuaternionRotationMatrix for small rotation matrix" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 0.001f, -0.002f, 0.0005f );
        vec4_t q = quat_rotation_matrix( m );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationMatrix( &d3dq, (D3DXMATRIX*)&m );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_matrix matches D3DXQuaternionRotationMatrix for non-orthogonal matrix" )
        mat44_t m = mat44_identity(); m.x.y = 0.2f;
        vec4_t q = quat_rotation_matrix( m );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationMatrix( &d3dq, (D3DXMATRIX*)&m );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();
    
    // quat_rotation_yaw_pitch_roll
    TESTFW_TEST_BEGIN( "quat_rotation_yaw_pitch_roll matches D3DXQuaternionRotationYawPitchRoll for yaw only" )
        vec4_t q = quat_rotation_yaw_pitch_roll( 1.5708f, 0.0f, 0.0f );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationYawPitchRoll( &d3dq, 1.5708f, 0.0f, 0.0f );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_yaw_pitch_roll matches D3DXQuaternionRotationYawPitchRoll for pitch only" )
        vec4_t q = quat_rotation_yaw_pitch_roll( 0.0f, 1.5708f, 0.0f );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationYawPitchRoll( &d3dq, 0.0f, 1.5708f, 0.0f );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_yaw_pitch_roll matches D3DXQuaternionRotationYawPitchRoll for roll only" )
        vec4_t q = quat_rotation_yaw_pitch_roll( 0.0f, 0.0f, 1.5708f );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationYawPitchRoll( &d3dq, 0.0f, 0.0f, 1.5708f );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_yaw_pitch_roll matches D3DXQuaternionRotationYawPitchRoll for yaw + pitch" )
        vec4_t q = quat_rotation_yaw_pitch_roll( 1.0f, 0.5f, 0.0f );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationYawPitchRoll( &d3dq, 1.0f, 0.5f, 0.0f );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_yaw_pitch_roll matches D3DXQuaternionRotationYawPitchRoll for pitch + roll" )
        vec4_t q = quat_rotation_yaw_pitch_roll( 0.0f, -1.0f, 1.0f );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationYawPitchRoll( &d3dq, 0.0f, -1.0f, 1.0f );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_yaw_pitch_roll matches D3DXQuaternionRotationYawPitchRoll for yaw + roll" )
        vec4_t q = quat_rotation_yaw_pitch_roll( 0.5f, 0.0f, -0.75f );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationYawPitchRoll( &d3dq, 0.5f, 0.0f, -0.75f );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_yaw_pitch_roll matches D3DXQuaternionRotationYawPitchRoll for full rotation" )
        vec4_t q = quat_rotation_yaw_pitch_roll( 0.3f, 1.0f, -0.8f );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationYawPitchRoll( &d3dq, 0.3f, 1.0f, -0.8f );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_yaw_pitch_roll matches D3DXQuaternionRotationYawPitchRoll for large angles" )
        vec4_t q = quat_rotation_yaw_pitch_roll( 6.2832f, -3.1416f, 3.1416f );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationYawPitchRoll( &d3dq, 6.2832f, -3.1416f, 3.1416f );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotation_yaw_pitch_roll matches D3DXQuaternionRotationYawPitchRoll for small angles" )
        vec4_t q = quat_rotation_yaw_pitch_roll( 0.001f, -0.002f, 0.0005f );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationYawPitchRoll( &d3dq, 0.001f, -0.002f, 0.0005f );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();
    
    // quat_squad_setup
    TESTFW_TEST_BEGIN( "quat_squad_setup matches D3DXQuaternionSquadSetup for identity path" )
        vec4_t q0 = vec4( 0, 0, 0, 1 );
        vec4_t q1 = vec4( 0, 0, 0, 1 );
        vec4_t q2 = vec4( 0, 0, 0, 1 );
        vec4_t q3 = vec4( 0, 0, 0, 1 );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        D3DXQUATERNION da, db, dc;
        D3DXQuaternionSquadSetup( &da, &db, &dc, (D3DXQUATERNION*)&q0, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&q2, (D3DXQUATERNION*)&q3 );
        TESTFW_EXPECTED( QUAT_APPROX( a, da ) ); TESTFW_EXPECTED( QUAT_APPROX( b, db ) ); TESTFW_EXPECTED( QUAT_APPROX( c, dc ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_squad_setup matches D3DXQuaternionSquadSetup for short arc rotation path" )
        vec4_t q0 = quat_rotation_axis( vec3( 1, 0, 0 ), 0.0f );
        vec4_t q1 = quat_rotation_axis( vec3( 1, 0, 0 ), 0.3f );
        vec4_t q2 = quat_rotation_axis( vec3( 1, 0, 0 ), 0.6f );
        vec4_t q3 = quat_rotation_axis( vec3( 1, 0, 0 ), 1.0f );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        D3DXQUATERNION da, db, dc;
        D3DXQuaternionSquadSetup( &da, &db, &dc, (D3DXQUATERNION*)&q0, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&q2, (D3DXQUATERNION*)&q3 );
        TESTFW_EXPECTED( QUAT_APPROX( a, da ) ); TESTFW_EXPECTED( QUAT_APPROX( b, db ) ); TESTFW_EXPECTED( QUAT_APPROX( c, dc ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_squad_setup matches D3DXQuaternionSquadSetup for varying orientations" )
        vec4_t q0 = quat_rotation_axis( vec3( 1, 2, 0 ), 0.1f );
        vec4_t q1 = quat_rotation_axis( vec3( 0, 1, 0 ), 1.0f );
        vec4_t q2 = quat_rotation_axis( vec3( 0, 0, 1 ), 1.5f );
        vec4_t q3 = quat_rotation_axis( vec3( -1, 2, 0.5f ), 2.0f );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        D3DXQUATERNION da, db, dc;
        D3DXQuaternionSquadSetup( &da, &db, &dc, (D3DXQUATERNION*)&q0, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&q2, (D3DXQUATERNION*)&q3 );
        TESTFW_EXPECTED( QUAT_APPROX( a, da ) ); TESTFW_EXPECTED( QUAT_APPROX( b, db ) ); TESTFW_EXPECTED( QUAT_APPROX( c, dc ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_squad_setup matches D3DXQuaternionSquadSetup for arbitrary unnormalized inputs" )
        vec4_t q0 = vec4( 1.2f, -0.8f, 0.6f, 0.4f );
        vec4_t q1 = vec4( -1.1f, 2.3f, -0.9f, 0.7f );
        vec4_t q2 = vec4( 0.5f, -2.0f, 1.0f, -1.5f );
        vec4_t q3 = vec4( 3.0f, 0.0f, -0.5f, 2.2f );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        D3DXQUATERNION da, db, dc;
        D3DXQuaternionSquadSetup( &da, &db, &dc, (D3DXQUATERNION*)&q0, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&q2, (D3DXQUATERNION*)&q3 );
        TESTFW_EXPECTED( QUAT_APPROX( a, da ) ); TESTFW_EXPECTED( QUAT_APPROX( b, db ) ); TESTFW_EXPECTED( QUAT_APPROX( c, dc ) );
    TESTFW_TEST_END();

    // quat_squad
    TESTFW_TEST_BEGIN( "quat_squad matches D3DXQuaternionSquad for identity interpolation" )
        vec4_t q = vec4( 0, 0, 0, 1 );
        vec4_t r = quat_squad( q, q, q, q, 0.5f );
        D3DXQUATERNION d3dr; D3DXQuaternionSquad( &d3dr, (D3DXQUATERNION*)&q, (D3DXQUATERNION*)&q, (D3DXQUATERNION*)&q, (D3DXQUATERNION*)&q, 0.5f );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_squad matches D3DXQuaternionSquad for middle interpolation of short arc" )
        vec4_t q0 = quat_rotation_axis( vec3( 0, 1, 0 ), 0.0f );
        vec4_t q1 = quat_rotation_axis( vec3( 0, 1, 0 ), 0.5f );
        vec4_t q2 = quat_rotation_axis( vec3( 0, 1, 0 ), 1.0f );
        vec4_t q3 = quat_rotation_axis( vec3( 0, 1, 0 ), 1.5f );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        vec4_t r = quat_squad( q1, a, b, c, 0.5f );
        D3DXQUATERNION da, db, dc, d3dr;
        D3DXQuaternionSquadSetup( &da, &db, &dc, (D3DXQUATERNION*)&q0, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&q2, (D3DXQUATERNION*)&q3 );
        D3DXQuaternionSquad( &d3dr, (D3DXQUATERNION*)&q1, &da, &db, &dc, 0.5f );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_squad matches D3DXQuaternionSquad at t = 0 and t = 1" )
        vec4_t q0 = quat_rotation_axis( vec3( 1, 2, 0 ), 0.1f );
        vec4_t q1 = quat_rotation_axis( vec3( 0, 1, 0 ), 1.0f );
        vec4_t q2 = quat_rotation_axis( vec3( 0, 0, 1 ), 1.5f );
        vec4_t q3 = quat_rotation_axis( vec3( -1, 2, 0.5f ), 2.0f );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        vec4_t r0 = quat_squad( q1, a, b, c, 0.0f );
        vec4_t r1 = quat_squad( q1, a, b, c, 1.0f );
        D3DXQUATERNION da, db, dc, d3dr0, d3dr1;
        D3DXQuaternionSquadSetup( &da, &db, &dc, (D3DXQUATERNION*)&q0, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&q2, (D3DXQUATERNION*)&q3 );
        D3DXQuaternionSquad( &d3dr0, (D3DXQUATERNION*)&q1, &da, &db, &dc, 0.0f );
        D3DXQuaternionSquad( &d3dr1, (D3DXQUATERNION*)&q1, &da, &db, &dc, 1.0f );
        TESTFW_EXPECTED( QUAT_APPROX( r0, d3dr0 ) ); TESTFW_EXPECTED( QUAT_APPROX( r1, d3dr1 ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_squad matches D3DXQuaternionSquad for arbitrary orientation set at t = 0.3" )
        vec4_t q0 = vec4( -0.3f, 0.6f, 0.1f, 0.7f );
        vec4_t q1 = vec4( 0.5f, -0.2f, 0.3f, 0.8f );
        vec4_t q2 = vec4( 0.1f, 0.4f, -0.7f, 0.5f );
        vec4_t q3 = vec4( -0.6f, 0.2f, 0.3f, -0.4f );
        q0 = vec4_normalize( q0 ); q1 = vec4_normalize( q1 ); q2 = vec4_normalize( q2 ); q3 = vec4_normalize( q3 );
        vec4_t a, b, c;
        quat_squad_setup( &a, &b, &c, q0, q1, q2, q3 );
        vec4_t r = quat_squad( q1, a, b, c, 0.3f );
        D3DXQUATERNION da, db, dc, d3dr;
        D3DXQuaternionSquadSetup( &da, &db, &dc, (D3DXQUATERNION*)&q0, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&q2, (D3DXQUATERNION*)&q3 );
        D3DXQuaternionSquad( &d3dr, (D3DXQUATERNION*)&q1, &da, &db, &dc, 0.3f );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();
    
    TESTFW_TEST_BEGIN( "quat_squad matches D3DXQuaternionSquad for arbitrary quaternions" )
        vec4_t q1 = vec4( -0.4f, 0.3f, 0.1f, 0.85f );
        vec4_t a = vec4( 0.5f, -0.6f, 0.2f, 0.3f );
        vec4_t b = vec4( 0.1f, 0.2f, -0.9f, 0.25f );
        vec4_t c = vec4( -0.3f, 0.7f, 0.1f, -0.6f );
        vec4_t r = quat_squad( q1, a, b, c, 0.65f );
        D3DXQUATERNION d3dr;
        D3DXQuaternionSquad( &d3dr, (D3DXQUATERNION*)&q1, (D3DXQUATERNION*)&a, (D3DXQUATERNION*)&b, (D3DXQUATERNION*)&c, 0.65f );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    // quat_to_axis_angle
    TESTFW_TEST_BEGIN( "quat_to_axis_angle matches D3DXQuaternionToAxisAngle for 90-degree x-rotation" )
        vec4_t q = quat_rotation_axis( vec3( 1, 0, 0 ), 1.5708f );
        vec3_t axis; float angle;
        quat_to_axis_angle( q, &axis, &angle );
        D3DXVECTOR3 d3daxis; float d3dangle;
        D3DXQuaternionToAxisAngle( (D3DXQUATERNION*)&q, &d3daxis, &d3dangle );
        TESTFW_EXPECTED( VEC3_APPROX( axis, d3daxis ) ); TESTFW_EXPECTED( vecmath_abs( angle - d3dangle ) < 0.00001f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_to_axis_angle matches D3DXQuaternionToAxisAngle for 180-degree y-rotation" )
        vec4_t q = quat_rotation_axis( vec3( 0, 1, 0 ), 3.1416f );
        vec3_t axis; float angle;
        quat_to_axis_angle( q, &axis, &angle );
        D3DXVECTOR3 d3daxis; float d3dangle;
        D3DXQuaternionToAxisAngle( (D3DXQUATERNION*)&q, &d3daxis, &d3dangle );
        TESTFW_EXPECTED( VEC3_APPROX( axis, d3daxis ) ); TESTFW_EXPECTED( vecmath_abs( angle - d3dangle ) < 0.00001f );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_to_axis_angle matches D3DXQuaternionToAxisAngle for arbitrary quaternion" )
        vec4_t q = vec4_normalize( vec4( 0.4f, -0.3f, 0.6f, 0.5f ) );
        vec3_t axis; float angle;
        quat_to_axis_angle( q, &axis, &angle );
        D3DXVECTOR3 d3daxis; float d3dangle;
        D3DXQuaternionToAxisAngle( (D3DXQUATERNION*)&q, &d3daxis, &d3dangle );
        TESTFW_EXPECTED( VEC3_APPROX( axis, d3daxis ) ); TESTFW_EXPECTED( vecmath_abs( angle - d3dangle ) < 0.00001f );
    TESTFW_TEST_END();
    
    // quat_rotate_vector
    TESTFW_TEST_BEGIN( "quat_rotate_vector matches D3DXVec3TransformCoord for identity rotation" )
        vec3_t v = vec3( 1.0f, 2.0f, 3.0f );
        vec4_t q = quat_identity();
        vec3_t r = quat_rotate_vector( v, q );
        D3DXVECTOR3 d3dv = *(D3DXVECTOR3*)&v;
        D3DXMATRIX m; D3DXMatrixRotationQuaternion( &m, (D3DXQUATERNION*)&q );
        D3DXVECTOR3 d3dr; D3DXVec3TransformCoord( &d3dr, &d3dv, &m );
        TESTFW_EXPECTED( VEC3_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotate_vector matches D3DXVec3TransformCoord for 90-degree y-rotation" )
        vec3_t v = vec3( 1.0f, 0.0f, 0.0f );
        vec4_t q = quat_rotation_axis( vec3( 0, 1, 0 ), 1.5708f );
        vec3_t r = quat_rotate_vector( v, q );
        D3DXVECTOR3 d3dv = *(D3DXVECTOR3*)&v;
        D3DXMATRIX m; D3DXMatrixRotationQuaternion( &m, (D3DXQUATERNION*)&q );
        D3DXVECTOR3 d3dr; D3DXVec3TransformCoord( &d3dr, &d3dv, &m );
        TESTFW_EXPECTED( VEC3_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_rotate_vector matches D3DXVec3TransformCoord for arbitrary vector and quaternion" )
        vec3_t v = vec3( 2.0f, -1.5f, 0.75f );
        vec4_t q = vec4_normalize( vec4( 0.3f, 0.5f, -0.2f, 0.7f ) );
        vec3_t r = quat_rotate_vector( v, q );
        D3DXVECTOR3 d3dv = *(D3DXVECTOR3*)&v;
        D3DXMATRIX m; D3DXMatrixRotationQuaternion( &m, (D3DXQUATERNION*)&q );
        D3DXVECTOR3 d3dr; D3DXVec3TransformCoord( &d3dr, &d3dv, &m );
        TESTFW_EXPECTED( VEC3_APPROX( r, d3dr ) );
    TESTFW_TEST_END();
    
    // quat_from_mat44
    TESTFW_TEST_BEGIN( "quat_from_mat44 matches D3DXQuaternionRotationMatrix for identity matrix" )
        mat44_t m = mat44_identity();
        vec4_t q = quat_from_mat44( m );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationMatrix( &d3dq, (D3DXMATRIX*)&m );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_from_mat44 matches D3DXQuaternionRotationMatrix for 90-degree x-rotation" )
        mat44_t m = mat44_rotation_x( 1.5708f );
        vec4_t q = quat_from_mat44( m );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationMatrix( &d3dq, (D3DXMATRIX*)&m );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_from_mat44 matches D3DXQuaternionRotationMatrix for yaw-pitch-roll rotation" )
        mat44_t m = mat44_rotation_yaw_pitch_roll( 1.0f, -0.5f, 0.25f );
        vec4_t q = quat_from_mat44( m );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationMatrix( &d3dq, (D3DXMATRIX*)&m );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_from_mat44 matches D3DXQuaternionRotationMatrix for rotation with scale" )
        mat44_t r = mat44_rotation_axis( vec3( 1, 1, 0 ), 1.0f );
        mat44_t s = mat44_scaling( 2.0f, 2.0f, 2.0f );
        mat44_t m = mat44_mul_mat44( r, s );
        vec4_t q = quat_from_mat44( m );
        D3DXQUATERNION d3dq; D3DXQuaternionRotationMatrix( &d3dq, (D3DXMATRIX*)&m );
        TESTFW_EXPECTED( QUAT_APPROX( q, d3dq ) );
    TESTFW_TEST_END();
    
    // mat44_from_quat
    TESTFW_TEST_BEGIN( "mat44_from_quat matches D3DXMatrixRotationQuaternion for identity quaternion" )
        vec4_t q = quat_identity();
        mat44_t m = mat44_from_quat( q );
        D3DXMATRIX d3d; D3DXMatrixRotationQuaternion( &d3d, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_from_quat matches D3DXMatrixRotationQuaternion for 90-degree x-rotation" )
        vec4_t q = quat_rotation_axis( vec3( 1, 0, 0 ), 1.5708f );
        mat44_t m = mat44_from_quat( q );
        D3DXMATRIX d3d; D3DXMatrixRotationQuaternion( &d3d, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_from_quat matches D3DXMatrixRotationQuaternion for 180-degree y-rotation" )
        vec4_t q = quat_rotation_axis( vec3( 0, 1, 0 ), 3.1416f );
        mat44_t m = mat44_from_quat( q );
        D3DXMATRIX d3d; D3DXMatrixRotationQuaternion( &d3d, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "mat44_from_quat matches D3DXMatrixRotationQuaternion for arbitrary quaternion" )
        vec4_t q = vec4_normalize( vec4( 0.25f, -0.5f, 0.75f, 1.0f ) );
        mat44_t m = mat44_from_quat( q );
        D3DXMATRIX d3d; D3DXMatrixRotationQuaternion( &d3d, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( MAT44_APPROX( m, d3d ) );
    TESTFW_TEST_END();
    
    // quat_normalize
    TESTFW_TEST_BEGIN( "quat_normalize matches D3DXQuaternionNormalize for identity quaternion" )
        vec4_t q = vec4( 0, 0, 0, 1 );
        vec4_t r = quat_normalize( q );
        D3DXQUATERNION d3dr; D3DXQuaternionNormalize( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_normalize matches D3DXQuaternionNormalize for scaled quaternion" )
        vec4_t q = vec4( 0.3f, -0.6f, 0.1f, 0.5f );
        vec4_t r = quat_normalize( q );
        D3DXQUATERNION d3dr; D3DXQuaternionNormalize( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_normalize matches D3DXQuaternionNormalize for negative components" )
        vec4_t q = vec4( -2.0f, 4.0f, -1.0f, 3.0f );
        vec4_t r = quat_normalize( q );
        D3DXQUATERNION d3dr; D3DXQuaternionNormalize( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "quat_normalize matches D3DXQuaternionNormalize for zero quaternion" )
        vec4_t q = vec4( 0, 0, 0, 0 );
        vec4_t r = quat_normalize( q );
        D3DXQUATERNION d3dr; D3DXQuaternionNormalize( &d3dr, (D3DXQUATERNION*)&q );
        TESTFW_EXPECTED( QUAT_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_transform matches D3DXVec2Transform" )
        vec2_t v = vec2( 1.0f, 2.0f );
        mat44_t m = mat44_mul_mat44( mat44_scaling( 2.0f, 3.0f, 1.0f ), mat44_translation( 4.0f, 5.0f, 6.0f ) );
        vec4_t r = vec2_transform( v, m );
        D3DXVECTOR2 d3dv = *(D3DXVECTOR2*)&v;
        D3DXMATRIX d3dm = *(D3DXMATRIX*)&m;
        D3DXVECTOR4 d3dr; D3DXVec2Transform( &d3dr, &d3dv, &d3dm );
        TESTFW_EXPECTED( VEC4_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_transform_coord matches D3DXVec2TransformCoord" )
        vec2_t v = vec2( 1.0f, 2.0f );
        mat44_t m = mat44_mul_mat44( mat44_mul_mat44( mat44_scaling( 2.0f, 3.0f, 1.0f ), mat44_translation( 4.0f, 5.0f, 6.0f ) ), mat44_perspective_lh( 100.0f, 100.0f, 1.0f, 1000.0f ) );
        vec2_t r = vec2_transform_coord( v, m );
        D3DXVECTOR2 d3dv = *(D3DXVECTOR2*)&v;
        D3DXMATRIX d3dm = *(D3DXMATRIX*)&m;
        D3DXVECTOR2 d3dr; D3DXVec2TransformCoord( &d3dr, &d3dv, &d3dm );
        TESTFW_EXPECTED( VEC2_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec2_transform_normal matches D3DXVec2TransformNormal" )
        vec2_t v = vec2( 1.0f, 2.0f );
        mat44_t m = mat44_mul_mat44(
            mat44_scaling( 2.0f, 3.0f, 1.0f ),
            mat44_translation( 4.0f, 5.0f, 6.0f )
        );
        vec2_t r = vec2_transform_normal( v, m );
        D3DXVECTOR2 d3dv = *(D3DXVECTOR2*)&v;
        D3DXMATRIX d3dm = *(D3DXMATRIX*)&m;
        D3DXVECTOR2 d3dr; D3DXVec2TransformNormal( &d3dr, &d3dv, &d3dm );
        TESTFW_EXPECTED( VEC2_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_transform matches D3DXVec3Transform" )
        vec3_t v = vec3( 1.0f, 2.0f, 3.0f );
        mat44_t m = mat44_mul_mat44(
            mat44_scaling( 2.0f, 3.0f, 4.0f ),
            mat44_translation( 5.0f, 6.0f, 7.0f )
        );
        vec4_t r = vec3_transform( v, m );
        D3DXVECTOR3 d3dv = *(D3DXVECTOR3*)&v;
        D3DXMATRIX d3dm = *(D3DXMATRIX*)&m;
        D3DXVECTOR4 d3dr; D3DXVec3Transform( &d3dr, &d3dv, &d3dm );
        TESTFW_EXPECTED( VEC4_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_transform_coord matches D3DXVec3TransformCoord" )
        vec3_t v = vec3( 1.0f, 2.0f, 3.0f );
        mat44_t m = mat44_mul_mat44( mat44_mul_mat44( mat44_scaling( 2.0f, 3.0f, 4.0f ), mat44_translation( 5.0f, 6.0f, 7.0f ) ), mat44_perspective_lh( 100.0f, 100.0f, 1.0f, 1000.0f ) );
        vec3_t r = vec3_transform_coord( v, m );
        D3DXVECTOR3 d3dv = *(D3DXVECTOR3*)&v;
        D3DXMATRIX d3dm = *(D3DXMATRIX*)&m;
        D3DXVECTOR3 d3dr; D3DXVec3TransformCoord( &d3dr, &d3dv, &d3dm );
        TESTFW_EXPECTED( VEC3_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec3_transform_normal matches D3DXVec3TransformNormal" )
        vec3_t v = vec3( 1.0f, 2.0f, 3.0f );
        mat44_t m = mat44_mul_mat44( mat44_scaling( 2.0f, 3.0f, 4.0f ), mat44_rotation_y( 1.0f ) );
        vec3_t r = vec3_transform_normal( v, m );
        D3DXVECTOR3 d3dv = *(D3DXVECTOR3*)&v;
        D3DXMATRIX d3dm = *(D3DXMATRIX*)&m;
        D3DXVECTOR3 d3dr; D3DXVec3TransformNormal( &d3dr, &d3dv, &d3dm );
        TESTFW_EXPECTED( VEC3_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    TESTFW_TEST_BEGIN( "vec4_transform matches D3DXVec4Transform" )
        vec4_t v = vec4( 1.0f, 2.0f, 3.0f, 4.0f );
        mat44_t m = mat44_mul_mat44( mat44_scaling( 2.0f, 3.0f, 4.0f ), mat44_translation( 5.0f, 6.0f, 7.0f ) );
        vec4_t r = vec4_transform( v, m );
        D3DXVECTOR4 d3dv = *(D3DXVECTOR4*)&v;
        D3DXMATRIX d3dm = *(D3DXMATRIX*)&m;
        D3DXVECTOR4 d3dr; D3DXVec4Transform( &d3dr, &d3dv, &d3dm );
        TESTFW_EXPECTED( VEC4_APPROX( r, d3dr ) );
    TESTFW_TEST_END();

    #undef MAT44_APPROX
    #undef VEC2_APPROX
    #undef VEC3_APPROX
    #undef VEC4_APPROX
    #undef QUAT_APPROX
}

#endif /* VECMATH_RUN_D3DX_TESTS */


int main( int argc, char** argv ) {
    (void) argc, (void) argv;
    TESTFW_INIT();

    test_scalar_math();

    test_vec2();
    test_vec3();
    test_vec4();

    test_mat22();
    test_mat23();
    test_mat32();
    test_mat33();
    test_mat24();
    test_mat34();
    test_mat42();
    test_mat43();
    test_mat44();

    test_matrix_math();
    test_matrix_multiplications();
    test_quaternions();
    test_matrix_utils();

    test_swizzling_vec2();
    test_swizzling_vec3();
    test_swizzling_vec4();

    #if defined( VECMATH_GENERICS ) && ( defined( __cplusplus ) || ( ( defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L ) || defined(__TINYC__) ) )
        test_generics();
    #endif /* VECMATH_GENERICS */

    #ifdef __cplusplus
        test_cpp_operators();
    #endif /* __cplusplus */

    #ifdef VECMATH_RUN_D3DX_TESTS
        test_d3d_compliance();
    #endif /* VECMATH_RUN_D3DX_TESTS */

    return TESTFW_SUMMARY();
}



#ifdef VECMATH_USE_EXTERNAL_TESTFW
    #define TESTFW_IMPLEMENTATION
    #ifdef _MSC_VER
        #pragma warning( push )
        #pragma warning( disable: 4710 ) // function not inlined
        #pragma warning( disable: 4820 ) // '4' bytes padding added after data member
    #endif
    #include "testfw.h"
    #ifdef _MSC_VER
        #pragma warning( pop )
    #endif
#endif /* VECMATH_USE_EXTERNAL_TESTFW */


#endif /* VECMATH_RUN_TESTS */


/*
------------------------------------------------------------------------------

This software is available under 2 licenses - you may choose the one you like.

------------------------------------------------------------------------------

ALTERNATIVE A - MIT License

Copyright (c) 2025 Mattias Gustavsson

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.

------------------------------------------------------------------------------

ALTERNATIVE B - Public Domain (www.unlicense.org)

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.

In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

------------------------------------------------------------------------------
*/
